(() => {
  var __webpack_modules__ = {63: t => {
    "use strict";
    var e = {};
    !function (t, e) {
      function i() {}
      t.inherit = function (t, e) {
        var n = t;
        i.prototype = e.prototype, t.prototype = new i, t.prototype.constructor = n;
      }, t.generateCallback = function (t, e) {
        return function () {
          e.apply(t, arguments);
        };
      }, t.NVector = function (t) {
        t === e && (t = 0);
        for (var i = new Array(t || 0), n = 0; n < t; ++n) i[n] = 0;
        return i;
      }, t.is = function (t, i) {
        return null !== t && (i instanceof Function && t instanceof i || !(t.constructor.__implements == e || !t.constructor.__implements[i]));
      }, t.parseUInt = function (t) {
        return Math.abs(parseInt(t));
      };
    }(e);
    var i, n, r, o, s, a, l, c, h, u, p, m, d, _, y, g, x, v, b, w, S, M, A, C, T, E, L, D, R, B, P, I, V, F, k, N, G, U, z, O, H = Array, W = e.NVector;
    for (void 0 === e && (e = {}), void 0 === e.Collision && (e.Collision = {}), void 0 === e.Collision.Shapes && (e.Collision.Shapes = {}), void 0 === e.Common && (e.Common = {}), void 0 === e.Common.Math && (e.Common.Math = {}), void 0 === e.Dynamics && (e.Dynamics = {}), void 0 === e.Dynamics.Contacts && (e.Dynamics.Contacts = {}), void 0 === e.Dynamics.Controllers && (e.Dynamics.Controllers = {}), void 0 === e.Dynamics.Joints && (e.Dynamics.Joints = {}), e.Collision.IBroadPhase = "Box2D.Collision.IBroadPhase", e.Collision.b2AABB = function t() {
      t.b2AABB.apply(this, arguments);
    }, e.Collision.b2Bound = function t() {
      t.b2Bound.apply(this, arguments);
    }, e.Collision.b2BoundValues = function t() {
      t.b2BoundValues.apply(this, arguments), this.constructor === t && this.b2BoundValues.apply(this, arguments);
    }, e.Collision.b2Collision = function t() {
      t.b2Collision.apply(this, arguments);
    }, e.Collision.b2ContactID = function t() {
      t.b2ContactID.apply(this, arguments), this.constructor === t && this.b2ContactID.apply(this, arguments);
    }, e.Collision.b2ContactPoint = function t() {
      t.b2ContactPoint.apply(this, arguments);
    }, e.Collision.b2Distance = function t() {
      t.b2Distance.apply(this, arguments);
    }, e.Collision.b2DistanceInput = function t() {
      t.b2DistanceInput.apply(this, arguments);
    }, e.Collision.b2DistanceOutput = function t() {
      t.b2DistanceOutput.apply(this, arguments);
    }, e.Collision.b2DistanceProxy = function t() {
      t.b2DistanceProxy.apply(this, arguments);
    }, e.Collision.b2DynamicTree = function t() {
      t.b2DynamicTree.apply(this, arguments), this.constructor === t && this.b2DynamicTree.apply(this, arguments);
    }, e.Collision.b2DynamicTreeBroadPhase = function t() {
      t.b2DynamicTreeBroadPhase.apply(this, arguments);
    }, e.Collision.b2DynamicTreeNode = function t() {
      t.b2DynamicTreeNode.apply(this, arguments);
    }, e.Collision.b2DynamicTreePair = function t() {
      t.b2DynamicTreePair.apply(this, arguments);
    }, e.Collision.b2Manifold = function t() {
      t.b2Manifold.apply(this, arguments), this.constructor === t && this.b2Manifold.apply(this, arguments);
    }, e.Collision.b2ManifoldPoint = function t() {
      t.b2ManifoldPoint.apply(this, arguments), this.constructor === t && this.b2ManifoldPoint.apply(this, arguments);
    }, e.Collision.b2Point = function t() {
      t.b2Point.apply(this, arguments);
    }, e.Collision.b2RayCastInput = function t() {
      t.b2RayCastInput.apply(this, arguments), this.constructor === t && this.b2RayCastInput.apply(this, arguments);
    }, e.Collision.b2RayCastOutput = function t() {
      t.b2RayCastOutput.apply(this, arguments);
    }, e.Collision.b2Segment = function t() {
      t.b2Segment.apply(this, arguments);
    }, e.Collision.b2SeparationFunction = function t() {
      t.b2SeparationFunction.apply(this, arguments);
    }, e.Collision.b2Simplex = function t() {
      t.b2Simplex.apply(this, arguments), this.constructor === t && this.b2Simplex.apply(this, arguments);
    }, e.Collision.b2SimplexCache = function t() {
      t.b2SimplexCache.apply(this, arguments);
    }, e.Collision.b2SimplexVertex = function t() {
      t.b2SimplexVertex.apply(this, arguments);
    }, e.Collision.b2TimeOfImpact = function t() {
      t.b2TimeOfImpact.apply(this, arguments);
    }, e.Collision.b2TOIInput = function t() {
      t.b2TOIInput.apply(this, arguments);
    }, e.Collision.b2WorldManifold = function t() {
      t.b2WorldManifold.apply(this, arguments), this.constructor === t && this.b2WorldManifold.apply(this, arguments);
    }, e.Collision.ClipVertex = function t() {
      t.ClipVertex.apply(this, arguments);
    }, e.Collision.Features = function t() {
      t.Features.apply(this, arguments);
    }, e.Collision.Shapes.b2CircleShape = function t() {
      t.b2CircleShape.apply(this, arguments), this.constructor === t && this.b2CircleShape.apply(this, arguments);
    }, e.Collision.Shapes.b2EdgeChainDef = function t() {
      t.b2EdgeChainDef.apply(this, arguments), this.constructor === t && this.b2EdgeChainDef.apply(this, arguments);
    }, e.Collision.Shapes.b2EdgeShape = function t() {
      t.b2EdgeShape.apply(this, arguments), this.constructor === t && this.b2EdgeShape.apply(this, arguments);
    }, e.Collision.Shapes.b2MassData = function t() {
      t.b2MassData.apply(this, arguments);
    }, e.Collision.Shapes.b2PolygonShape = function t() {
      t.b2PolygonShape.apply(this, arguments), this.constructor === t && this.b2PolygonShape.apply(this, arguments);
    }, e.Collision.Shapes.b2Shape = function t() {
      t.b2Shape.apply(this, arguments), this.constructor === t && this.b2Shape.apply(this, arguments);
    }, e.Common.b2internal = "Box2D.Common.b2internal", e.Common.b2Color = function t() {
      t.b2Color.apply(this, arguments), this.constructor === t && this.b2Color.apply(this, arguments);
    }, e.Common.b2Settings = function t() {
      t.b2Settings.apply(this, arguments);
    }, e.Common.Math.b2Mat22 = function t() {
      t.b2Mat22.apply(this, arguments), this.constructor === t && this.b2Mat22.apply(this, arguments);
    }, e.Common.Math.b2Mat33 = function t() {
      t.b2Mat33.apply(this, arguments), this.constructor === t && this.b2Mat33.apply(this, arguments);
    }, e.Common.Math.b2Math = function t() {
      t.b2Math.apply(this, arguments);
    }, e.Common.Math.b2Sweep = function t() {
      t.b2Sweep.apply(this, arguments);
    }, e.Common.Math.b2Transform = function t() {
      t.b2Transform.apply(this, arguments), this.constructor === t && this.b2Transform.apply(this, arguments);
    }, e.Common.Math.b2Vec2 = function t() {
      t.b2Vec2.apply(this, arguments), this.constructor === t && this.b2Vec2.apply(this, arguments);
    }, e.Common.Math.b2Vec3 = function t() {
      t.b2Vec3.apply(this, arguments), this.constructor === t && this.b2Vec3.apply(this, arguments);
    }, e.Dynamics.b2Body = function t() {
      t.b2Body.apply(this, arguments), this.constructor === t && this.b2Body.apply(this, arguments);
    }, e.Dynamics.b2BodyDef = function t() {
      t.b2BodyDef.apply(this, arguments), this.constructor === t && this.b2BodyDef.apply(this, arguments);
    }, e.Dynamics.b2ContactFilter = function t() {
      t.b2ContactFilter.apply(this, arguments);
    }, e.Dynamics.b2ContactImpulse = function t() {
      t.b2ContactImpulse.apply(this, arguments);
    }, e.Dynamics.b2ContactListener = function t() {
      t.b2ContactListener.apply(this, arguments);
    }, e.Dynamics.b2ContactManager = function t() {
      t.b2ContactManager.apply(this, arguments), this.constructor === t && this.b2ContactManager.apply(this, arguments);
    }, e.Dynamics.b2DebugDraw = function t() {
      t.b2DebugDraw.apply(this, arguments), this.constructor === t && this.b2DebugDraw.apply(this, arguments);
    }, e.Dynamics.b2DestructionListener = function t() {
      t.b2DestructionListener.apply(this, arguments);
    }, e.Dynamics.b2FilterData = function t() {
      t.b2FilterData.apply(this, arguments);
    }, e.Dynamics.b2Fixture = function t() {
      t.b2Fixture.apply(this, arguments), this.constructor === t && this.b2Fixture.apply(this, arguments);
    }, e.Dynamics.b2FixtureDef = function t() {
      t.b2FixtureDef.apply(this, arguments), this.constructor === t && this.b2FixtureDef.apply(this, arguments);
    }, e.Dynamics.b2Island = function t() {
      t.b2Island.apply(this, arguments), this.constructor === t && this.b2Island.apply(this, arguments);
    }, e.Dynamics.b2TimeStep = function t() {
      t.b2TimeStep.apply(this, arguments);
    }, e.Dynamics.b2World = function t() {
      t.b2World.apply(this, arguments), this.constructor === t && this.b2World.apply(this, arguments);
    }, e.Dynamics.Contacts.b2CircleContact = function t() {
      t.b2CircleContact.apply(this, arguments);
    }, e.Dynamics.Contacts.b2Contact = function t() {
      t.b2Contact.apply(this, arguments), this.constructor === t && this.b2Contact.apply(this, arguments);
    }, e.Dynamics.Contacts.b2ContactConstraint = function t() {
      t.b2ContactConstraint.apply(this, arguments), this.constructor === t && this.b2ContactConstraint.apply(this, arguments);
    }, e.Dynamics.Contacts.b2ContactConstraintPoint = function t() {
      t.b2ContactConstraintPoint.apply(this, arguments);
    }, e.Dynamics.Contacts.b2ContactEdge = function t() {
      t.b2ContactEdge.apply(this, arguments);
    }, e.Dynamics.Contacts.b2ContactFactory = function t() {
      t.b2ContactFactory.apply(this, arguments), this.constructor === t && this.b2ContactFactory.apply(this, arguments);
    }, e.Dynamics.Contacts.b2ContactRegister = function t() {
      t.b2ContactRegister.apply(this, arguments);
    }, e.Dynamics.Contacts.b2ContactResult = function t() {
      t.b2ContactResult.apply(this, arguments);
    }, e.Dynamics.Contacts.b2ContactSolver = function t() {
      t.b2ContactSolver.apply(this, arguments), this.constructor === t && this.b2ContactSolver.apply(this, arguments);
    }, e.Dynamics.Contacts.b2EdgeAndCircleContact = function t() {
      t.b2EdgeAndCircleContact.apply(this, arguments);
    }, e.Dynamics.Contacts.b2NullContact = function t() {
      t.b2NullContact.apply(this, arguments), this.constructor === t && this.b2NullContact.apply(this, arguments);
    }, e.Dynamics.Contacts.b2PolyAndCircleContact = function t() {
      t.b2PolyAndCircleContact.apply(this, arguments);
    }, e.Dynamics.Contacts.b2PolyAndEdgeContact = function t() {
      t.b2PolyAndEdgeContact.apply(this, arguments);
    }, e.Dynamics.Contacts.b2PolygonContact = function t() {
      t.b2PolygonContact.apply(this, arguments);
    }, e.Dynamics.Contacts.b2PositionSolverManifold = function t() {
      t.b2PositionSolverManifold.apply(this, arguments), this.constructor === t && this.b2PositionSolverManifold.apply(this, arguments);
    }, e.Dynamics.Controllers.b2BuoyancyController = function t() {
      t.b2BuoyancyController.apply(this, arguments);
    }, e.Dynamics.Controllers.b2ConstantAccelController = function t() {
      t.b2ConstantAccelController.apply(this, arguments);
    }, e.Dynamics.Controllers.b2ConstantForceController = function t() {
      t.b2ConstantForceController.apply(this, arguments);
    }, e.Dynamics.Controllers.b2Controller = function t() {
      t.b2Controller.apply(this, arguments);
    }, e.Dynamics.Controllers.b2ControllerEdge = function t() {
      t.b2ControllerEdge.apply(this, arguments);
    }, e.Dynamics.Controllers.b2GravityController = function t() {
      t.b2GravityController.apply(this, arguments);
    }, e.Dynamics.Controllers.b2TensorDampingController = function t() {
      t.b2TensorDampingController.apply(this, arguments);
    }, e.Dynamics.Joints.b2DistanceJoint = function t() {
      t.b2DistanceJoint.apply(this, arguments), this.constructor === t && this.b2DistanceJoint.apply(this, arguments);
    }, e.Dynamics.Joints.b2DistanceJointDef = function t() {
      t.b2DistanceJointDef.apply(this, arguments), this.constructor === t && this.b2DistanceJointDef.apply(this, arguments);
    }, e.Dynamics.Joints.b2FrictionJoint = function t() {
      t.b2FrictionJoint.apply(this, arguments), this.constructor === t && this.b2FrictionJoint.apply(this, arguments);
    }, e.Dynamics.Joints.b2FrictionJointDef = function t() {
      t.b2FrictionJointDef.apply(this, arguments), this.constructor === t && this.b2FrictionJointDef.apply(this, arguments);
    }, e.Dynamics.Joints.b2GearJoint = function t() {
      t.b2GearJoint.apply(this, arguments), this.constructor === t && this.b2GearJoint.apply(this, arguments);
    }, e.Dynamics.Joints.b2GearJointDef = function t() {
      t.b2GearJointDef.apply(this, arguments), this.constructor === t && this.b2GearJointDef.apply(this, arguments);
    }, e.Dynamics.Joints.b2Jacobian = function t() {
      t.b2Jacobian.apply(this, arguments);
    }, e.Dynamics.Joints.b2Joint = function t() {
      t.b2Joint.apply(this, arguments), this.constructor === t && this.b2Joint.apply(this, arguments);
    }, e.Dynamics.Joints.b2JointDef = function t() {
      t.b2JointDef.apply(this, arguments), this.constructor === t && this.b2JointDef.apply(this, arguments);
    }, e.Dynamics.Joints.b2JointEdge = function t() {
      t.b2JointEdge.apply(this, arguments);
    }, e.Dynamics.Joints.b2LineJoint = function t() {
      t.b2LineJoint.apply(this, arguments), this.constructor === t && this.b2LineJoint.apply(this, arguments);
    }, e.Dynamics.Joints.b2LineJointDef = function t() {
      t.b2LineJointDef.apply(this, arguments), this.constructor === t && this.b2LineJointDef.apply(this, arguments);
    }, e.Dynamics.Joints.b2MouseJoint = function t() {
      t.b2MouseJoint.apply(this, arguments), this.constructor === t && this.b2MouseJoint.apply(this, arguments);
    }, e.Dynamics.Joints.b2MouseJointDef = function t() {
      t.b2MouseJointDef.apply(this, arguments), this.constructor === t && this.b2MouseJointDef.apply(this, arguments);
    }, e.Dynamics.Joints.b2PrismaticJoint = function t() {
      t.b2PrismaticJoint.apply(this, arguments), this.constructor === t && this.b2PrismaticJoint.apply(this, arguments);
    }, e.Dynamics.Joints.b2PrismaticJointDef = function t() {
      t.b2PrismaticJointDef.apply(this, arguments), this.constructor === t && this.b2PrismaticJointDef.apply(this, arguments);
    }, e.Dynamics.Joints.b2PulleyJoint = function t() {
      t.b2PulleyJoint.apply(this, arguments), this.constructor === t && this.b2PulleyJoint.apply(this, arguments);
    }, e.Dynamics.Joints.b2PulleyJointDef = function t() {
      t.b2PulleyJointDef.apply(this, arguments), this.constructor === t && this.b2PulleyJointDef.apply(this, arguments);
    }, e.Dynamics.Joints.b2RevoluteJoint = function t() {
      t.b2RevoluteJoint.apply(this, arguments), this.constructor === t && this.b2RevoluteJoint.apply(this, arguments);
    }, e.Dynamics.Joints.b2RevoluteJointDef = function t() {
      t.b2RevoluteJointDef.apply(this, arguments), this.constructor === t && this.b2RevoluteJointDef.apply(this, arguments);
    }, e.Dynamics.Joints.b2WeldJoint = function t() {
      t.b2WeldJoint.apply(this, arguments), this.constructor === t && this.b2WeldJoint.apply(this, arguments);
    }, e.Dynamics.Joints.b2WeldJointDef = function t() {
      t.b2WeldJointDef.apply(this, arguments), this.constructor === t && this.b2WeldJointDef.apply(this, arguments);
    }, e.postDefs = [], i = e.Collision.Shapes.b2CircleShape, e.Collision.Shapes.b2EdgeChainDef, e.Collision.Shapes.b2EdgeShape, e.Collision.Shapes.b2MassData, n = e.Collision.Shapes.b2PolygonShape, r = e.Collision.Shapes.b2Shape, e.Common.b2Color, e.Common.b2internal, o = e.Common.b2Settings, e.Common.Math.b2Mat22, e.Common.Math.b2Mat33, s = e.Common.Math.b2Math, a = e.Common.Math.b2Sweep, l = e.Common.Math.b2Transform, c = e.Common.Math.b2Vec2, e.Common.Math.b2Vec3, h = e.Collision.b2AABB, u = e.Collision.b2Bound, p = e.Collision.b2BoundValues, m = e.Collision.b2Collision, d = e.Collision.b2ContactID, _ = e.Collision.b2ContactPoint, y = e.Collision.b2Distance, g = e.Collision.b2DistanceInput, x = e.Collision.b2DistanceOutput, v = e.Collision.b2DistanceProxy, b = e.Collision.b2DynamicTree, w = e.Collision.b2DynamicTreeBroadPhase, S = e.Collision.b2DynamicTreeNode, M = e.Collision.b2DynamicTreePair, A = e.Collision.b2Manifold, C = e.Collision.b2ManifoldPoint, T = e.Collision.b2Point, E = e.Collision.b2RayCastInput, L = e.Collision.b2RayCastOutput, D = e.Collision.b2Segment, R = e.Collision.b2SeparationFunction, B = e.Collision.b2Simplex, P = e.Collision.b2SimplexCache, I = e.Collision.b2SimplexVertex, V = e.Collision.b2TimeOfImpact, F = e.Collision.b2TOIInput, k = e.Collision.b2WorldManifold, N = e.Collision.ClipVertex, G = e.Collision.Features, U = e.Collision.IBroadPhase, h.b2AABB = function () {
      this.lowerBound = new c, this.upperBound = new c;
    }, h.prototype.IsValid = function () {
      var t = this.upperBound.x - this.lowerBound.x, e = this.upperBound.y - this.lowerBound.y, i = t >= 0 && e >= 0;
      return i = i && this.lowerBound.IsValid() && this.upperBound.IsValid();
    }, h.prototype.GetCenter = function () {
      return new c((this.lowerBound.x + this.upperBound.x) / 2, (this.lowerBound.y + this.upperBound.y) / 2);
    }, h.prototype.GetExtents = function () {
      return new c((this.upperBound.x - this.lowerBound.x) / 2, (this.upperBound.y - this.lowerBound.y) / 2);
    }, h.prototype.Contains = function (t) {
      var e = true;
      return e = (e = (e = (e = e && this.lowerBound.x <= t.lowerBound.x) && this.lowerBound.y <= t.lowerBound.y) && t.upperBound.x <= this.upperBound.x) && t.upperBound.y <= this.upperBound.y;
    }, h.prototype.RayCast = function (t, e) {
      var i = -Number.MAX_VALUE, n = Number.MAX_VALUE, r = e.p1.x, o = e.p1.y, s = e.p2.x - e.p1.x, a = e.p2.y - e.p1.y, l = Math.abs(s), c = Math.abs(a), h = t.normal, u = 0, p = 0, m = 0, d = 0, _ = 0;
      if (l < Number.MIN_VALUE) {
        if (r < this.lowerBound.x || this.upperBound.x < r) return false;
      } else if (u = 1 / s, _ = -1, (p = (this.lowerBound.x - r) * u) > (m = (this.upperBound.x - r) * u) && (d = p, p = m, m = d, _ = 1), p > i && (h.x = _, h.y = 0, i = p), i > (n = Math.min(n, m))) return false;
      if (c < Number.MIN_VALUE) {
        if (o < this.lowerBound.y || this.upperBound.y < o) return false;
      } else if (u = 1 / a, _ = -1, (p = (this.lowerBound.y - o) * u) > (m = (this.upperBound.y - o) * u) && (d = p, p = m, m = d, _ = 1), p > i && (h.y = _, h.x = 0, i = p), i > (n = Math.min(n, m))) return false;
      return t.fraction = i, true;
    }, h.prototype.TestOverlap = function (t) {
      var e = t.lowerBound.x - this.upperBound.x, i = t.lowerBound.y - this.upperBound.y, n = this.lowerBound.x - t.upperBound.x, r = this.lowerBound.y - t.upperBound.y;
      return !(e > 0 || i > 0 || n > 0 || r > 0);
    }, h.Combine = function (t, e) {
      var i = new h;
      return i.Combine(t, e), i;
    }, h.prototype.Combine = function (t, e) {
      this.lowerBound.x = Math.min(t.lowerBound.x, e.lowerBound.x), this.lowerBound.y = Math.min(t.lowerBound.y, e.lowerBound.y), this.upperBound.x = Math.max(t.upperBound.x, e.upperBound.x), this.upperBound.y = Math.max(t.upperBound.y, e.upperBound.y);
    }, u.b2Bound = function () {}, u.prototype.IsLower = function () {
      return 0 == (1 & this.value);
    }, u.prototype.IsUpper = function () {
      return 1 == (1 & this.value);
    }, u.prototype.Swap = function (t) {
      var e = this.value, i = this.proxy, n = this.stabbingCount;
      this.value = t.value, this.proxy = t.proxy, this.stabbingCount = t.stabbingCount, t.value = e, t.proxy = i, t.stabbingCount = n;
    }, p.b2BoundValues = function () {}, p.prototype.b2BoundValues = function () {
      this.lowerValues = new W, this.lowerValues[0] = 0, this.lowerValues[1] = 0, this.upperValues = new W, this.upperValues[0] = 0, this.upperValues[1] = 0;
    }, m.b2Collision = function () {}, m.ClipSegmentToLine = function (t, e, i, n) {
      var r;
      void 0 === n && (n = 0);
      var o = 0, s = (r = e[0]).v, a = (r = e[1]).v, l = i.x * s.x + i.y * s.y - n, c = i.x * a.x + i.y * a.y - n;
      if (l <= 0 && t[o++].Set(e[0]), c <= 0 && t[o++].Set(e[1]), l * c < 0) {
        var h, u = l / (l - c), p = (r = t[o]).v;
        p.x = s.x + u * (a.x - s.x), p.y = s.y + u * (a.y - s.y), r = t[o], l > 0 ? (h = e[0], r.id = h.id) : (h = e[1], r.id = h.id), ++o;
      }
      return o;
    }, m.EdgeSeparation = function (t, e, i, n, r) {
      void 0 === i && (i = 0), parseInt(t.m_vertexCount);
      var o, s, a = t.m_vertices, l = t.m_normals, c = parseInt(n.m_vertexCount), h = n.m_vertices;
      o = e.R, s = l[i];
      for (var u = o.col1.x * s.x + o.col2.x * s.y, p = o.col1.y * s.x + o.col2.y * s.y, m = (o = r.R).col1.x * u + o.col1.y * p, d = o.col2.x * u + o.col2.y * p, _ = 0, y = Number.MAX_VALUE, g = 0; g < c; ++g) {
        var x = (s = h[g]).x * m + s.y * d;
        x < y && (y = x, _ = g);
      }
      s = a[i], o = e.R;
      var v = e.position.x + (o.col1.x * s.x + o.col2.x * s.y), b = e.position.y + (o.col1.y * s.x + o.col2.y * s.y);
      s = h[_], o = r.R;
      var w = r.position.x + (o.col1.x * s.x + o.col2.x * s.y), S = r.position.y + (o.col1.y * s.x + o.col2.y * s.y);
      return (w -= v) * u + (S -= b) * p;
    }, m.FindMaxSeparation = function (t, e, i, n, r) {
      var o, s, a = parseInt(e.m_vertexCount), l = e.m_normals;
      s = r.R, o = n.m_centroid;
      var c = r.position.x + (s.col1.x * o.x + s.col2.x * o.y), h = r.position.y + (s.col1.y * o.x + s.col2.y * o.y);
      s = i.R, o = e.m_centroid, c -= i.position.x + (s.col1.x * o.x + s.col2.x * o.y), h -= i.position.y + (s.col1.y * o.x + s.col2.y * o.y);
      for (var u = c * i.R.col1.x + h * i.R.col1.y, p = c * i.R.col2.x + h * i.R.col2.y, d = 0, _ = -Number.MAX_VALUE, y = 0; y < a; ++y) {
        var g = (o = l[y]).x * u + o.y * p;
        g > _ && (_ = g, d = y);
      }
      var x = m.EdgeSeparation(e, i, d, n, r), v = parseInt(d - 1 >= 0 ? d - 1 : a - 1), b = m.EdgeSeparation(e, i, v, n, r), w = parseInt(d + 1 < a ? d + 1 : 0), S = m.EdgeSeparation(e, i, w, n, r), M = 0, A = 0, C = 0;
      if (b > x && b > S) C = -1, M = v, A = b; else {
        if (!(S > x)) return t[0] = d, x;
        C = 1, M = w, A = S;
      }
      for (; d = -1 == C ? M - 1 >= 0 ? M - 1 : a - 1 : M + 1 < a ? M + 1 : 0, (x = m.EdgeSeparation(e, i, d, n, r)) > A;) M = d, A = x;
      return t[0] = M, A;
    }, m.FindIncidentEdge = function (t, e, i, n, r, o) {
      void 0 === n && (n = 0), parseInt(e.m_vertexCount);
      var s, a, l = e.m_normals, c = parseInt(r.m_vertexCount), h = r.m_vertices, u = r.m_normals;
      s = i.R, a = l[n];
      var p = s.col1.x * a.x + s.col2.x * a.y, m = s.col1.y * a.x + s.col2.y * a.y, d = (s = o.R).col1.x * p + s.col1.y * m;
      m = s.col2.x * p + s.col2.y * m, p = d;
      for (var _, y = 0, g = Number.MAX_VALUE, x = 0; x < c; ++x) {
        var v = p * (a = u[x]).x + m * a.y;
        v < g && (g = v, y = x);
      }
      var b = parseInt(y), w = parseInt(b + 1 < c ? b + 1 : 0);
      _ = t[0], a = h[b], s = o.R, _.v.x = o.position.x + (s.col1.x * a.x + s.col2.x * a.y), _.v.y = o.position.y + (s.col1.y * a.x + s.col2.y * a.y), _.id.features.referenceEdge = n, _.id.features.incidentEdge = b, _.id.features.incidentVertex = 0, _ = t[1], a = h[w], s = o.R, _.v.x = o.position.x + (s.col1.x * a.x + s.col2.x * a.y), _.v.y = o.position.y + (s.col1.y * a.x + s.col2.y * a.y), _.id.features.referenceEdge = n, _.id.features.incidentEdge = w, _.id.features.incidentVertex = 1;
    }, m.MakeClipPointVector = function () {
      var t = new H(2);
      return t[0] = new N, t[1] = new N, t;
    }, m.CollidePolygons = function (t, e, i, n, r) {
      var s;
      t.m_pointCount = 0;
      var a = e.m_radius + n.m_radius, l = 0;
      m.s_edgeAO[0] = l;
      var c = m.FindMaxSeparation(m.s_edgeAO, e, i, n, r);
      if (l = m.s_edgeAO[0], !(c > a)) {
        var h = 0;
        m.s_edgeBO[0] = h;
        var u = m.FindMaxSeparation(m.s_edgeBO, n, r, e, i);
        if (h = m.s_edgeBO[0], !(u > a)) {
          var p, d, _, y, g, x = 0, v = 0;
          u > 0.98 * c + 0.001 ? (p = n, d = e, _ = r, y = i, x = h, t.m_type = A.e_faceB, v = 1) : (p = e, d = n, _ = i, y = r, x = l, t.m_type = A.e_faceA, v = 0);
          var b = m.s_incidentEdge;
          m.FindIncidentEdge(b, p, _, x, d, y);
          var w, S = parseInt(p.m_vertexCount), M = p.m_vertices, C = M[x];
          w = x + 1 < S ? M[parseInt(x + 1)] : M[0];
          var T = m.s_localTangent;
          T.Set(w.x - C.x, w.y - C.y), T.Normalize();
          var E = m.s_localNormal;
          E.x = T.y, E.y = -T.x;
          var L = m.s_planePoint;
          L.Set(0.5 * (C.x + w.x), 0.5 * (C.y + w.y));
          var D = m.s_tangent;
          g = _.R, D.x = g.col1.x * T.x + g.col2.x * T.y, D.y = g.col1.y * T.x + g.col2.y * T.y;
          var R = m.s_tangent2;
          R.x = -D.x, R.y = -D.y;
          var B = m.s_normal;
          B.x = D.y, B.y = -D.x;
          var P = m.s_v11, I = m.s_v12;
          P.x = _.position.x + (g.col1.x * C.x + g.col2.x * C.y), P.y = _.position.y + (g.col1.y * C.x + g.col2.y * C.y), I.x = _.position.x + (g.col1.x * w.x + g.col2.x * w.y), I.y = _.position.y + (g.col1.y * w.x + g.col2.y * w.y);
          var V = B.x * P.x + B.y * P.y, F = -D.x * P.x - D.y * P.y + a, k = D.x * I.x + D.y * I.y + a, N = m.s_clipPoints1, G = m.s_clipPoints2;
          if (!(m.ClipSegmentToLine(N, b, R, F) < 2 || m.ClipSegmentToLine(G, N, D, k) < 2)) {
            t.m_localPlaneNormal.SetV(E), t.m_localPoint.SetV(L);
            for (var U = 0, z = 0; z < o.b2_maxManifoldPoints; ++z) if (s = G[z], B.x * s.v.x + B.y * s.v.y - V <= a) {
              var O = t.m_points[U];
              g = y.R;
              var H = s.v.x - y.position.x, W = s.v.y - y.position.y;
              O.m_localPoint.x = H * g.col1.x + W * g.col1.y, O.m_localPoint.y = H * g.col2.x + W * g.col2.y, O.m_id.Set(s.id), O.m_id.features.flip = v, ++U;
            }
            t.m_pointCount = U;
          }
        }
      }
    }, m.CollideCircles = function (t, e, i, n, r) {
      var o, s;
      t.m_pointCount = 0, o = i.R, s = e.m_p;
      var a = i.position.x + (o.col1.x * s.x + o.col2.x * s.y), l = i.position.y + (o.col1.y * s.x + o.col2.y * s.y);
      o = r.R, s = n.m_p;
      var c = r.position.x + (o.col1.x * s.x + o.col2.x * s.y) - a, h = r.position.y + (o.col1.y * s.x + o.col2.y * s.y) - l, u = c * c + h * h, p = e.m_radius + n.m_radius;
      u > p * p || (t.m_type = A.e_circles, t.m_localPoint.SetV(e.m_p), t.m_localPlaneNormal.SetZero(), t.m_pointCount = 1, t.m_points[0].m_localPoint.SetV(n.m_p), t.m_points[0].m_id.key = 0);
    }, m.CollidePolygonAndCircle = function (t, e, i, n, r) {
      t.m_pointCount = 0;
      var o, s, a = 0, l = 0;
      s = r.R, o = n.m_p;
      var c = r.position.x + (s.col1.x * o.x + s.col2.x * o.y), h = r.position.y + (s.col1.y * o.x + s.col2.y * o.y);
      a = c - i.position.x, l = h - i.position.y;
      for (var u = a * (s = i.R).col1.x + l * s.col1.y, p = a * s.col2.x + l * s.col2.y, m = 0, d = -Number.MAX_VALUE, _ = e.m_radius + n.m_radius, y = parseInt(e.m_vertexCount), g = e.m_vertices, x = e.m_normals, v = 0; v < y; ++v) {
        a = u - (o = g[v]).x, l = p - o.y;
        var b = (o = x[v]).x * a + o.y * l;
        if (b > _) return;
        b > d && (d = b, m = v);
      }
      var w = parseInt(m), S = parseInt(w + 1 < y ? w + 1 : 0), M = g[w], C = g[S];
      if (d < Number.MIN_VALUE) return t.m_pointCount = 1, t.m_type = A.e_faceA, t.m_localPlaneNormal.SetV(x[m]), t.m_localPoint.x = 0.5 * (M.x + C.x), t.m_localPoint.y = 0.5 * (M.y + C.y), t.m_points[0].m_localPoint.SetV(n.m_p), void (t.m_points[0].m_id.key = 0);
      var T = (u - M.x) * (C.x - M.x) + (p - M.y) * (C.y - M.y), E = (u - C.x) * (M.x - C.x) + (p - C.y) * (M.y - C.y);
      if (T <= 0) {
        if ((u - M.x) * (u - M.x) + (p - M.y) * (p - M.y) > _ * _) return;
        t.m_pointCount = 1, t.m_type = A.e_faceA, t.m_localPlaneNormal.x = u - M.x, t.m_localPlaneNormal.y = p - M.y, t.m_localPlaneNormal.Normalize(), t.m_localPoint.SetV(M), t.m_points[0].m_localPoint.SetV(n.m_p), t.m_points[0].m_id.key = 0;
      } else if (E <= 0) {
        if ((u - C.x) * (u - C.x) + (p - C.y) * (p - C.y) > _ * _) return;
        t.m_pointCount = 1, t.m_type = A.e_faceA, t.m_localPlaneNormal.x = u - C.x, t.m_localPlaneNormal.y = p - C.y, t.m_localPlaneNormal.Normalize(), t.m_localPoint.SetV(C), t.m_points[0].m_localPoint.SetV(n.m_p), t.m_points[0].m_id.key = 0;
      } else {
        var L = 0.5 * (M.x + C.x), D = 0.5 * (M.y + C.y);
        if ((d = (u - L) * x[w].x + (p - D) * x[w].y) > _) return;
        t.m_pointCount = 1, t.m_type = A.e_faceA, t.m_localPlaneNormal.x = x[w].x, t.m_localPlaneNormal.y = x[w].y, t.m_localPlaneNormal.Normalize(), t.m_localPoint.Set(L, D), t.m_points[0].m_localPoint.SetV(n.m_p), t.m_points[0].m_id.key = 0;
      }
    }, m.TestOverlap = function (t, e) {
      var i = e.lowerBound, n = t.upperBound, r = i.x - n.x, o = i.y - n.y;
      i = t.lowerBound, n = e.upperBound;
      var s = i.x - n.x, a = i.y - n.y;
      return !(r > 0 || o > 0 || s > 0 || a > 0);
    }, e.postDefs.push(function () {
      e.Collision.b2Collision.s_incidentEdge = m.MakeClipPointVector(), e.Collision.b2Collision.s_clipPoints1 = m.MakeClipPointVector(), e.Collision.b2Collision.s_clipPoints2 = m.MakeClipPointVector(), e.Collision.b2Collision.s_edgeAO = new W(1), e.Collision.b2Collision.s_edgeBO = new W(1), e.Collision.b2Collision.s_localTangent = new c, e.Collision.b2Collision.s_localNormal = new c, e.Collision.b2Collision.s_planePoint = new c, e.Collision.b2Collision.s_normal = new c, e.Collision.b2Collision.s_tangent = new c, e.Collision.b2Collision.s_tangent2 = new c, e.Collision.b2Collision.s_v11 = new c, e.Collision.b2Collision.s_v12 = new c, e.Collision.b2Collision.b2CollidePolyTempVec = new c, e.Collision.b2Collision.b2_nullFeature = 255;
    }), d.b2ContactID = function () {
      this.features = new G;
    }, d.prototype.b2ContactID = function () {
      this.features._m_id = this;
    }, d.prototype.Set = function (t) {
      this.key = t._key;
    }, d.prototype.Copy = function () {
      var t = new d;
      return t.key = this.key, t;
    }, Object.defineProperty(d.prototype, "key", {enumerable: false, configurable: true, get: function () {
      return this._key;
    }}), Object.defineProperty(d.prototype, "key", {enumerable: false, configurable: true, set: function (t) {
      void 0 === t && (t = 0), this._key = t, this.features._referenceEdge = 255 & this._key, this.features._incidentEdge = (65280 & this._key) >> 8 & 255, this.features._incidentVertex = (16711680 & this._key) >> 16 & 255, this.features._flip = (4278190080 & this._key) >> 24 & 255;
    }}), _.b2ContactPoint = function () {
      this.position = new c, this.velocity = new c, this.normal = new c, this.id = new d;
    }, y.b2Distance = function () {}, y.Distance = function (t, e, i) {
      ++y.b2_gjkCalls;
      var n = i.proxyA, r = i.proxyB, a = i.transformA, l = i.transformB, h = y.s_simplex;
      h.ReadCache(e, n, a, r, l);
      for (var u, p = h.m_vertices, m = y.s_saveA, d = y.s_saveB, _ = 0, g = (h.GetClosestPoint().LengthSquared(), 0), x = 0; x < 20;) {
        for (_ = h.m_count, g = 0; g < _; g++) m[g] = p[g].indexA, d[g] = p[g].indexB;
        switch (h.m_count) {
          case 1:
            break;
          case 2:
            h.Solve2();
            break;
          case 3:
            h.Solve3();
            break;
          default:
            o.b2Assert(false);
        }
        if (3 == h.m_count) break;
        (u = h.GetClosestPoint()).LengthSquared();
        var v = h.GetSearchDirection();
        if (v.LengthSquared() < Number.MIN_VALUE * Number.MIN_VALUE) break;
        var b = p[h.m_count];
        b.indexA = n.GetSupport(s.MulTMV(a.R, v.GetNegative())), b.wA = s.MulX(a, n.GetVertex(b.indexA)), b.indexB = r.GetSupport(s.MulTMV(l.R, v)), b.wB = s.MulX(l, r.GetVertex(b.indexB)), b.w = s.SubtractVV(b.wB, b.wA), ++x, ++y.b2_gjkIters;
        var w = false;
        for (g = 0; g < _; g++) if (b.indexA == m[g] && b.indexB == d[g]) {
          w = true;
          break;
        }
        if (w) break;
        ++h.m_count;
      }
      if (y.b2_gjkMaxIters = s.Max(y.b2_gjkMaxIters, x), h.GetWitnessPoints(t.pointA, t.pointB), t.distance = s.SubtractVV(t.pointA, t.pointB).Length(), t.iterations = x, h.WriteCache(e), i.useRadii) {
        var S = n.m_radius, M = r.m_radius;
        if (t.distance > S + M && t.distance > Number.MIN_VALUE) {
          t.distance -= S + M;
          var A = s.SubtractVV(t.pointB, t.pointA);
          A.Normalize(), t.pointA.x += S * A.x, t.pointA.y += S * A.y, t.pointB.x -= M * A.x, t.pointB.y -= M * A.y;
        } else (u = new c).x = 0.5 * (t.pointA.x + t.pointB.x), u.y = 0.5 * (t.pointA.y + t.pointB.y), t.pointA.x = t.pointB.x = u.x, t.pointA.y = t.pointB.y = u.y, t.distance = 0;
      }
    }, e.postDefs.push(function () {
      e.Collision.b2Distance.s_simplex = new B, e.Collision.b2Distance.s_saveA = new W(3), e.Collision.b2Distance.s_saveB = new W(3);
    }), g.b2DistanceInput = function () {}, x.b2DistanceOutput = function () {
      this.pointA = new c, this.pointB = new c;
    }, v.b2DistanceProxy = function () {}, v.prototype.Set = function (t) {
      switch (t.GetType()) {
        case r.e_circleShape:
          var e = t instanceof i ? t : null;
          this.m_vertices = new H(1, true), this.m_vertices[0] = e.m_p, this.m_count = 1, this.m_radius = e.m_radius;
          break;
        case r.e_polygonShape:
          var s = t instanceof n ? t : null;
          this.m_vertices = s.m_vertices, this.m_count = s.m_vertexCount, this.m_radius = s.m_radius;
          break;
        default:
          o.b2Assert(false);
      }
    }, v.prototype.GetSupport = function (t) {
      for (var e = 0, i = this.m_vertices[0].x * t.x + this.m_vertices[0].y * t.y, n = 1; n < this.m_count; ++n) {
        var r = this.m_vertices[n].x * t.x + this.m_vertices[n].y * t.y;
        r > i && (e = n, i = r);
      }
      return e;
    }, v.prototype.GetSupportVertex = function (t) {
      for (var e = 0, i = this.m_vertices[0].x * t.x + this.m_vertices[0].y * t.y, n = 1; n < this.m_count; ++n) {
        var r = this.m_vertices[n].x * t.x + this.m_vertices[n].y * t.y;
        r > i && (e = n, i = r);
      }
      return this.m_vertices[e];
    }, v.prototype.GetVertexCount = function () {
      return this.m_count;
    }, v.prototype.GetVertex = function (t) {
      return void 0 === t && (t = 0), o.b2Assert(0 <= t && t < this.m_count), this.m_vertices[t];
    }, b.b2DynamicTree = function () {}, b.prototype.b2DynamicTree = function () {
      this.m_root = null, this.m_freeList = null, this.m_path = 0, this.m_insertionCount = 0;
    }, b.prototype.CreateProxy = function (t, e) {
      var i = this.AllocateNode(), n = o.b2_aabbExtension, r = o.b2_aabbExtension;
      return i.aabb.lowerBound.x = t.lowerBound.x - n, i.aabb.lowerBound.y = t.lowerBound.y - r, i.aabb.upperBound.x = t.upperBound.x + n, i.aabb.upperBound.y = t.upperBound.y + r, i.userData = e, this.InsertLeaf(i), i;
    }, b.prototype.DestroyProxy = function (t) {
      this.RemoveLeaf(t), this.FreeNode(t);
    }, b.prototype.MoveProxy = function (t, e, i) {
      if (o.b2Assert(t.IsLeaf()), t.aabb.Contains(e)) return false;
      this.RemoveLeaf(t);
      var n = o.b2_aabbExtension + o.b2_aabbMultiplier * (i.x > 0 ? i.x : -i.x), r = o.b2_aabbExtension + o.b2_aabbMultiplier * (i.y > 0 ? i.y : -i.y);
      return t.aabb.lowerBound.x = e.lowerBound.x - n, t.aabb.lowerBound.y = e.lowerBound.y - r, t.aabb.upperBound.x = e.upperBound.x + n, t.aabb.upperBound.y = e.upperBound.y + r, this.InsertLeaf(t), true;
    }, b.prototype.Rebalance = function (t) {
      if (void 0 === t && (t = 0), null != this.m_root) for (var e = 0; e < t; e++) {
        for (var i = this.m_root, n = 0; 0 == i.IsLeaf();) i = this.m_path >> n & 1 ? i.child2 : i.child1, n = n + 1 & 31;
        ++this.m_path, this.RemoveLeaf(i), this.InsertLeaf(i);
      }
    }, b.prototype.GetFatAABB = function (t) {
      return t.aabb;
    }, b.prototype.GetUserData = function (t) {
      return t.userData;
    }, b.prototype.Query = function (t, e) {
      if (null != this.m_root) {
        var i = new H, n = 0;
        for (i[n++] = this.m_root; n > 0;) {
          var r = i[--n];
          if (r.aabb.TestOverlap(e)) if (r.IsLeaf()) {
            if (!t(r)) return;
          } else i[n++] = r.child1, i[n++] = r.child2;
        }
      }
    }, b.prototype.RayCast = function (t, e) {
      if (null != this.m_root) {
        var i = e.p1, n = e.p2, r = s.SubtractVV(i, n);
        r.Normalize();
        var o = s.CrossFV(1, r), a = s.AbsV(o), l = e.maxFraction, c = new h, u = 0, p = 0;
        u = i.x + l * (n.x - i.x), p = i.y + l * (n.y - i.y), c.lowerBound.x = Math.min(i.x, u), c.lowerBound.y = Math.min(i.y, p), c.upperBound.x = Math.max(i.x, u), c.upperBound.y = Math.max(i.y, p);
        var m = new H, d = 0;
        for (m[d++] = this.m_root; d > 0;) {
          var _ = m[--d];
          if (0 != _.aabb.TestOverlap(c)) {
            var y = _.aabb.GetCenter(), g = _.aabb.GetExtents();
            if (!(Math.abs(o.x * (i.x - y.x) + o.y * (i.y - y.y)) - a.x * g.x - a.y * g.y > 0)) if (_.IsLeaf()) {
              var x = new E;
              if (x.p1 = e.p1, x.p2 = e.p2, x.maxFraction = e.maxFraction, 0 == (l = t(x, _))) return;
              l > 0 && (u = i.x + l * (n.x - i.x), p = i.y + l * (n.y - i.y), c.lowerBound.x = Math.min(i.x, u), c.lowerBound.y = Math.min(i.y, p), c.upperBound.x = Math.max(i.x, u), c.upperBound.y = Math.max(i.y, p));
            } else m[d++] = _.child1, m[d++] = _.child2;
          }
        }
      }
    }, b.prototype.AllocateNode = function () {
      if (this.m_freeList) {
        var t = this.m_freeList;
        return this.m_freeList = t.parent, t.parent = null, t.child1 = null, t.child2 = null, t;
      }
      return new S;
    }, b.prototype.FreeNode = function (t) {
      t.parent = this.m_freeList, this.m_freeList = t;
    }, b.prototype.InsertLeaf = function (t) {
      if (++this.m_insertionCount, null == this.m_root) return this.m_root = t, void (this.m_root.parent = null);
      var e = t.aabb.GetCenter(), i = this.m_root;
      if (0 == i.IsLeaf()) do {
        var n = i.child1, r = i.child2;
        i = Math.abs((n.aabb.lowerBound.x + n.aabb.upperBound.x) / 2 - e.x) + Math.abs((n.aabb.lowerBound.y + n.aabb.upperBound.y) / 2 - e.y) < Math.abs((r.aabb.lowerBound.x + r.aabb.upperBound.x) / 2 - e.x) + Math.abs((r.aabb.lowerBound.y + r.aabb.upperBound.y) / 2 - e.y) ? n : r;
      } while (0 == i.IsLeaf());
      var o = i.parent, s = this.AllocateNode();
      if (s.parent = o, s.userData = null, s.aabb.Combine(t.aabb, i.aabb), o) {
        i.parent.child1 == i ? o.child1 = s : o.child2 = s, s.child1 = i, s.child2 = t, i.parent = s, t.parent = s;
        do {
          if (o.aabb.Contains(s.aabb)) break;
          o.aabb.Combine(o.child1.aabb, o.child2.aabb), s = o, o = o.parent;
        } while (o);
      } else s.child1 = i, s.child2 = t, i.parent = s, t.parent = s, this.m_root = s;
    }, b.prototype.RemoveLeaf = function (t) {
      if (t != this.m_root) {
        var e, i = t.parent, n = i.parent;
        if (e = i.child1 == t ? i.child2 : i.child1, n) for (n.child1 == i ? n.child1 = e : n.child2 = e, e.parent = n, this.FreeNode(i); n;) {
          var r = n.aabb;
          if (n.aabb = h.Combine(n.child1.aabb, n.child2.aabb), r.Contains(n.aabb)) break;
          n = n.parent;
        } else this.m_root = e, e.parent = null, this.FreeNode(i);
      } else this.m_root = null;
    }, w.b2DynamicTreeBroadPhase = function () {
      this.m_tree = new b, this.m_moveBuffer = new H, this.m_pairBuffer = new H, this.m_pairCount = 0;
    }, w.prototype.CreateProxy = function (t, e) {
      var i = this.m_tree.CreateProxy(t, e);
      return ++this.m_proxyCount, this.BufferMove(i), i;
    }, w.prototype.DestroyProxy = function (t) {
      this.UnBufferMove(t), --this.m_proxyCount, this.m_tree.DestroyProxy(t);
    }, w.prototype.MoveProxy = function (t, e, i) {
      this.m_tree.MoveProxy(t, e, i) && this.BufferMove(t);
    }, w.prototype.TestOverlap = function (t, e) {
      var i = this.m_tree.GetFatAABB(t), n = this.m_tree.GetFatAABB(e);
      return i.TestOverlap(n);
    }, w.prototype.GetUserData = function (t) {
      return this.m_tree.GetUserData(t);
    }, w.prototype.GetFatAABB = function (t) {
      return this.m_tree.GetFatAABB(t);
    }, w.prototype.GetProxyCount = function () {
      return this.m_proxyCount;
    }, w.prototype.UpdatePairs = function (t) {
      var e = this;
      e.m_pairCount = 0;
      var i, n = 0;
      function r(t) {
        if (t == i) return true;
        e.m_pairCount == e.m_pairBuffer.length && (e.m_pairBuffer[e.m_pairCount] = new M);
        var n = e.m_pairBuffer[e.m_pairCount];
        return n.proxyA = t < i ? t : i, n.proxyB = t >= i ? t : i, ++e.m_pairCount, true;
      }
      for (n = 0; n < e.m_moveBuffer.length; ++n) {
        i = e.m_moveBuffer[n];
        var o = e.m_tree.GetFatAABB(i);
        e.m_tree.Query(r, o);
      }
      for (e.m_moveBuffer.length = 0, n = 0; n < e.m_pairCount;) {
        var s = e.m_pairBuffer[n];
        for (t(e.m_tree.GetUserData(s.proxyA), e.m_tree.GetUserData(s.proxyB)), ++n; n < e.m_pairCount;) {
          var a = e.m_pairBuffer[n];
          if (a.proxyA != s.proxyA || a.proxyB != s.proxyB) break;
          ++n;
        }
      }
    }, w.prototype.Query = function (t, e) {
      this.m_tree.Query(t, e);
    }, w.prototype.RayCast = function (t, e) {
      this.m_tree.RayCast(t, e);
    }, w.prototype.Validate = function () {}, w.prototype.Rebalance = function (t) {
      void 0 === t && (t = 0), this.m_tree.Rebalance(t);
    }, w.prototype.BufferMove = function (t) {
      this.m_moveBuffer[this.m_moveBuffer.length] = t;
    }, w.prototype.UnBufferMove = function (t) {
      var e = parseInt(this.m_moveBuffer.indexOf(t));
      this.m_moveBuffer.splice(e, 1);
    }, w.prototype.ComparePairs = function (t, e) {
      return 0;
    }, w.__implements = {}, w.__implements[U] = true, S.b2DynamicTreeNode = function () {
      this.aabb = new h;
    }, S.prototype.IsLeaf = function () {
      return null == this.child1;
    }, M.b2DynamicTreePair = function () {}, A.b2Manifold = function () {
      this.m_pointCount = 0;
    }, A.prototype.b2Manifold = function () {
      this.m_points = new H(o.b2_maxManifoldPoints);
      for (var t = 0; t < o.b2_maxManifoldPoints; t++) this.m_points[t] = new C;
      this.m_localPlaneNormal = new c, this.m_localPoint = new c;
    }, A.prototype.Reset = function () {
      for (var t = 0; t < o.b2_maxManifoldPoints; t++) (this.m_points[t] instanceof C ? this.m_points[t] : null).Reset();
      this.m_localPlaneNormal.SetZero(), this.m_localPoint.SetZero(), this.m_type = 0, this.m_pointCount = 0;
    }, A.prototype.Set = function (t) {
      this.m_pointCount = t.m_pointCount;
      for (var e = 0; e < o.b2_maxManifoldPoints; e++) (this.m_points[e] instanceof C ? this.m_points[e] : null).Set(t.m_points[e]);
      this.m_localPlaneNormal.SetV(t.m_localPlaneNormal), this.m_localPoint.SetV(t.m_localPoint), this.m_type = t.m_type;
    }, A.prototype.Copy = function () {
      var t = new A;
      return t.Set(this), t;
    }, e.postDefs.push(function () {
      e.Collision.b2Manifold.e_circles = 1, e.Collision.b2Manifold.e_faceA = 2, e.Collision.b2Manifold.e_faceB = 4;
    }), C.b2ManifoldPoint = function () {
      this.m_localPoint = new c, this.m_id = new d;
    }, C.prototype.b2ManifoldPoint = function () {
      this.Reset();
    }, C.prototype.Reset = function () {
      this.m_localPoint.SetZero(), this.m_normalImpulse = 0, this.m_tangentImpulse = 0, this.m_id.key = 0;
    }, C.prototype.Set = function (t) {
      this.m_localPoint.SetV(t.m_localPoint), this.m_normalImpulse = t.m_normalImpulse, this.m_tangentImpulse = t.m_tangentImpulse, this.m_id.Set(t.m_id);
    }, T.b2Point = function () {
      this.p = new c;
    }, T.prototype.Support = function (t, e, i) {
      return void 0 === e && (e = 0), void 0 === i && (i = 0), this.p;
    }, T.prototype.GetFirstVertex = function (t) {
      return this.p;
    }, E.b2RayCastInput = function () {
      this.p1 = new c, this.p2 = new c;
    }, E.prototype.b2RayCastInput = function (t, e, i) {
      void 0 === t && (t = null), void 0 === e && (e = null), void 0 === i && (i = 1), t && this.p1.SetV(t), e && this.p2.SetV(e), this.maxFraction = i;
    }, L.b2RayCastOutput = function () {
      this.normal = new c;
    }, D.b2Segment = function () {
      this.p1 = new c, this.p2 = new c;
    }, D.prototype.TestSegment = function (t, e, i, n) {
      void 0 === n && (n = 0);
      var r = i.p1, o = i.p2.x - r.x, s = i.p2.y - r.y, a = this.p2.x - this.p1.x, l = this.p2.y - this.p1.y, c = -a, h = 100 * Number.MIN_VALUE, u = -(o * l + s * c);
      if (u > h) {
        var p = r.x - this.p1.x, m = r.y - this.p1.y, d = p * l + m * c;
        if (0 <= d && d <= n * u) {
          var _ = -o * m + s * p;
          if (-h * u <= _ && _ <= u * (1 + h)) {
            d /= u;
            var y = Math.sqrt(l * l + c * c);
            return l /= y, c /= y, t[0] = d, e.Set(l, c), true;
          }
        }
      }
      return false;
    }, D.prototype.Extend = function (t) {
      this.ExtendForward(t), this.ExtendBackward(t);
    }, D.prototype.ExtendForward = function (t) {
      var e = this.p2.x - this.p1.x, i = this.p2.y - this.p1.y, n = Math.min(e > 0 ? (t.upperBound.x - this.p1.x) / e : e < 0 ? (t.lowerBound.x - this.p1.x) / e : Number.POSITIVE_INFINITY, i > 0 ? (t.upperBound.y - this.p1.y) / i : i < 0 ? (t.lowerBound.y - this.p1.y) / i : Number.POSITIVE_INFINITY);
      this.p2.x = this.p1.x + e * n, this.p2.y = this.p1.y + i * n;
    }, D.prototype.ExtendBackward = function (t) {
      var e = -this.p2.x + this.p1.x, i = -this.p2.y + this.p1.y, n = Math.min(e > 0 ? (t.upperBound.x - this.p2.x) / e : e < 0 ? (t.lowerBound.x - this.p2.x) / e : Number.POSITIVE_INFINITY, i > 0 ? (t.upperBound.y - this.p2.y) / i : i < 0 ? (t.lowerBound.y - this.p2.y) / i : Number.POSITIVE_INFINITY);
      this.p1.x = this.p2.x + e * n, this.p1.y = this.p2.y + i * n;
    }, R.b2SeparationFunction = function () {
      this.m_localPoint = new c, this.m_axis = new c;
    }, R.prototype.Initialize = function (t, e, i, n, r) {
      this.m_proxyA = e, this.m_proxyB = n;
      var a, l, h, u, p, m, d = parseInt(t.count);
      o.b2Assert(0 < d && d < 3);
      var _, y, g = 0, x = 0, v = 0, b = 0, w = 0, S = 0, M = 0;
      if (1 == d) this.m_type = R.e_points, a = this.m_proxyA.GetVertex(t.indexA[0]), u = this.m_proxyB.GetVertex(t.indexB[0]), y = a, _ = i.R, g = i.position.x + (_.col1.x * y.x + _.col2.x * y.y), x = i.position.y + (_.col1.y * y.x + _.col2.y * y.y), y = u, _ = r.R, v = r.position.x + (_.col1.x * y.x + _.col2.x * y.y), b = r.position.y + (_.col1.y * y.x + _.col2.y * y.y), this.m_axis.x = v - g, this.m_axis.y = b - x, this.m_axis.Normalize(); else if (t.indexB[0] == t.indexB[1]) this.m_type = R.e_faceA, l = this.m_proxyA.GetVertex(t.indexA[0]), h = this.m_proxyA.GetVertex(t.indexA[1]), u = this.m_proxyB.GetVertex(t.indexB[0]), this.m_localPoint.x = 0.5 * (l.x + h.x), this.m_localPoint.y = 0.5 * (l.y + h.y), this.m_axis = s.CrossVF(s.SubtractVV(h, l), 1), this.m_axis.Normalize(), y = this.m_axis, w = (_ = i.R).col1.x * y.x + _.col2.x * y.y, S = _.col1.y * y.x + _.col2.y * y.y, y = this.m_localPoint, _ = i.R, g = i.position.x + (_.col1.x * y.x + _.col2.x * y.y), x = i.position.y + (_.col1.y * y.x + _.col2.y * y.y), y = u, _ = r.R, (M = ((v = r.position.x + (_.col1.x * y.x + _.col2.x * y.y)) - g) * w + ((b = r.position.y + (_.col1.y * y.x + _.col2.y * y.y)) - x) * S) < 0 && this.m_axis.NegativeSelf(); else if (t.indexA[0] == t.indexA[0]) this.m_type = R.e_faceB, p = this.m_proxyB.GetVertex(t.indexB[0]), m = this.m_proxyB.GetVertex(t.indexB[1]), a = this.m_proxyA.GetVertex(t.indexA[0]), this.m_localPoint.x = 0.5 * (p.x + m.x), this.m_localPoint.y = 0.5 * (p.y + m.y), this.m_axis = s.CrossVF(s.SubtractVV(m, p), 1), this.m_axis.Normalize(), y = this.m_axis, w = (_ = r.R).col1.x * y.x + _.col2.x * y.y, S = _.col1.y * y.x + _.col2.y * y.y, y = this.m_localPoint, _ = r.R, v = r.position.x + (_.col1.x * y.x + _.col2.x * y.y), b = r.position.y + (_.col1.y * y.x + _.col2.y * y.y), y = a, _ = i.R, (M = ((g = i.position.x + (_.col1.x * y.x + _.col2.x * y.y)) - v) * w + ((x = i.position.y + (_.col1.y * y.x + _.col2.y * y.y)) - b) * S) < 0 && this.m_axis.NegativeSelf(); else {
        l = this.m_proxyA.GetVertex(t.indexA[0]), h = this.m_proxyA.GetVertex(t.indexA[1]), p = this.m_proxyB.GetVertex(t.indexB[0]), m = this.m_proxyB.GetVertex(t.indexB[1]), s.MulX(i, a);
        var A = s.MulMV(i.R, s.SubtractVV(h, l)), C = (s.MulX(r, u), s.MulMV(r.R, s.SubtractVV(m, p))), T = A.x * A.x + A.y * A.y, E = C.x * C.x + C.y * C.y, L = s.SubtractVV(C, A), D = A.x * L.x + A.y * L.y, B = C.x * L.x + C.y * L.y, P = A.x * C.x + A.y * C.y, I = T * E - P * P;
        M = 0, 0 != I && (M = s.Clamp((P * B - D * E) / I, 0, 1));
        var V = (P * M + B) / E;
        V < 0 && (V = 0, M = s.Clamp((P - D) / T, 0, 1)), (a = new c).x = l.x + M * (h.x - l.x), a.y = l.y + M * (h.y - l.y), (u = new c).x = p.x + M * (m.x - p.x), u.y = p.y + M * (m.y - p.y), 0 == M || 1 == M ? (this.m_type = R.e_faceB, this.m_axis = s.CrossVF(s.SubtractVV(m, p), 1), this.m_axis.Normalize(), this.m_localPoint = u, y = this.m_axis, w = (_ = r.R).col1.x * y.x + _.col2.x * y.y, S = _.col1.y * y.x + _.col2.y * y.y, y = this.m_localPoint, _ = r.R, v = r.position.x + (_.col1.x * y.x + _.col2.x * y.y), b = r.position.y + (_.col1.y * y.x + _.col2.y * y.y), y = a, _ = i.R, g = i.position.x + (_.col1.x * y.x + _.col2.x * y.y), x = i.position.y + (_.col1.y * y.x + _.col2.y * y.y), M < 0 && this.m_axis.NegativeSelf()) : (this.m_type = R.e_faceA, this.m_axis = s.CrossVF(s.SubtractVV(h, l), 1), this.m_localPoint = a, y = this.m_axis, w = (_ = i.R).col1.x * y.x + _.col2.x * y.y, S = _.col1.y * y.x + _.col2.y * y.y, y = this.m_localPoint, _ = i.R, g = i.position.x + (_.col1.x * y.x + _.col2.x * y.y), x = i.position.y + (_.col1.y * y.x + _.col2.y * y.y), y = u, _ = r.R, v = r.position.x + (_.col1.x * y.x + _.col2.x * y.y), b = r.position.y + (_.col1.y * y.x + _.col2.y * y.y), M < 0 && this.m_axis.NegativeSelf());
      }
    }, R.prototype.Evaluate = function (t, e) {
      var i, n, r, a, l, c, h;
      switch (this.m_type) {
        case R.e_points:
          return i = s.MulTMV(t.R, this.m_axis), n = s.MulTMV(e.R, this.m_axis.GetNegative()), r = this.m_proxyA.GetSupportVertex(i), a = this.m_proxyB.GetSupportVertex(n), l = s.MulX(t, r), ((c = s.MulX(e, a)).x - l.x) * this.m_axis.x + (c.y - l.y) * this.m_axis.y;
        case R.e_faceA:
          return h = s.MulMV(t.R, this.m_axis), l = s.MulX(t, this.m_localPoint), n = s.MulTMV(e.R, h.GetNegative()), a = this.m_proxyB.GetSupportVertex(n), ((c = s.MulX(e, a)).x - l.x) * h.x + (c.y - l.y) * h.y;
        case R.e_faceB:
          return h = s.MulMV(e.R, this.m_axis), c = s.MulX(e, this.m_localPoint), i = s.MulTMV(t.R, h.GetNegative()), r = this.m_proxyA.GetSupportVertex(i), ((l = s.MulX(t, r)).x - c.x) * h.x + (l.y - c.y) * h.y;
        default:
          return o.b2Assert(false), 0;
      }
    }, e.postDefs.push(function () {
      e.Collision.b2SeparationFunction.e_points = 1, e.Collision.b2SeparationFunction.e_faceA = 2, e.Collision.b2SeparationFunction.e_faceB = 4;
    }), B.b2Simplex = function () {
      this.m_v1 = new I, this.m_v2 = new I, this.m_v3 = new I, this.m_vertices = new H(3);
    }, B.prototype.b2Simplex = function () {
      this.m_vertices[0] = this.m_v1, this.m_vertices[1] = this.m_v2, this.m_vertices[2] = this.m_v3;
    }, B.prototype.ReadCache = function (t, e, i, n, r) {
      var a, l;
      o.b2Assert(0 <= t.count && t.count <= 3), this.m_count = t.count;
      for (var c = this.m_vertices, h = 0; h < this.m_count; h++) {
        var u = c[h];
        u.indexA = t.indexA[h], u.indexB = t.indexB[h], a = e.GetVertex(u.indexA), l = n.GetVertex(u.indexB), u.wA = s.MulX(i, a), u.wB = s.MulX(r, l), u.w = s.SubtractVV(u.wB, u.wA), u.a = 0;
      }
      if (this.m_count > 1) {
        var p = t.metric, m = this.GetMetric();
        (m < 0.5 * p || 2 * p < m || m < Number.MIN_VALUE) && (this.m_count = 0);
      }
      0 == this.m_count && ((u = c[0]).indexA = 0, u.indexB = 0, a = e.GetVertex(0), l = n.GetVertex(0), u.wA = s.MulX(i, a), u.wB = s.MulX(r, l), u.w = s.SubtractVV(u.wB, u.wA), this.m_count = 1);
    }, B.prototype.WriteCache = function (t) {
      t.metric = this.GetMetric(), t.count = e.parseUInt(this.m_count);
      for (var i = this.m_vertices, n = 0; n < this.m_count; n++) t.indexA[n] = e.parseUInt(i[n].indexA), t.indexB[n] = e.parseUInt(i[n].indexB);
    }, B.prototype.GetSearchDirection = function () {
      switch (this.m_count) {
        case 1:
          return this.m_v1.w.GetNegative();
        case 2:
          var t = s.SubtractVV(this.m_v2.w, this.m_v1.w);
          return s.CrossVV(t, this.m_v1.w.GetNegative()) > 0 ? s.CrossFV(1, t) : s.CrossVF(t, 1);
        default:
          return o.b2Assert(false), new c;
      }
    }, B.prototype.GetClosestPoint = function () {
      switch (this.m_count) {
        case 0:
          return o.b2Assert(false), new c;
        case 1:
          return this.m_v1.w;
        case 2:
          return new c(this.m_v1.a * this.m_v1.w.x + this.m_v2.a * this.m_v2.w.x, this.m_v1.a * this.m_v1.w.y + this.m_v2.a * this.m_v2.w.y);
        default:
          return o.b2Assert(false), new c;
      }
    }, B.prototype.GetWitnessPoints = function (t, e) {
      switch (this.m_count) {
        case 0:
          o.b2Assert(false);
          break;
        case 1:
          t.SetV(this.m_v1.wA), e.SetV(this.m_v1.wB);
          break;
        case 2:
          t.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x, t.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y, e.x = this.m_v1.a * this.m_v1.wB.x + this.m_v2.a * this.m_v2.wB.x, e.y = this.m_v1.a * this.m_v1.wB.y + this.m_v2.a * this.m_v2.wB.y;
          break;
        case 3:
          e.x = t.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x + this.m_v3.a * this.m_v3.wA.x, e.y = t.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y + this.m_v3.a * this.m_v3.wA.y;
          break;
        default:
          o.b2Assert(false);
      }
    }, B.prototype.GetMetric = function () {
      switch (this.m_count) {
        case 0:
          return o.b2Assert(false), 0;
        case 1:
          return 0;
        case 2:
          return s.SubtractVV(this.m_v1.w, this.m_v2.w).Length();
        case 3:
          return s.CrossVV(s.SubtractVV(this.m_v2.w, this.m_v1.w), s.SubtractVV(this.m_v3.w, this.m_v1.w));
        default:
          return o.b2Assert(false), 0;
      }
    }, B.prototype.Solve2 = function () {
      var t = this.m_v1.w, e = this.m_v2.w, i = s.SubtractVV(e, t), n = -(t.x * i.x + t.y * i.y);
      if (n <= 0) return this.m_v1.a = 1, void (this.m_count = 1);
      var r = e.x * i.x + e.y * i.y;
      if (r <= 0) return this.m_v2.a = 1, this.m_count = 1, void this.m_v1.Set(this.m_v2);
      var o = 1 / (r + n);
      this.m_v1.a = r * o, this.m_v2.a = n * o, this.m_count = 2;
    }, B.prototype.Solve3 = function () {
      var t = this.m_v1.w, e = this.m_v2.w, i = this.m_v3.w, n = s.SubtractVV(e, t), r = s.Dot(t, n), o = s.Dot(e, n), a = -r, l = s.SubtractVV(i, t), c = s.Dot(t, l), h = s.Dot(i, l), u = -c, p = s.SubtractVV(i, e), m = s.Dot(e, p), d = s.Dot(i, p), _ = -m, y = s.CrossVV(n, l), g = y * s.CrossVV(e, i), x = y * s.CrossVV(i, t), v = y * s.CrossVV(t, e);
      if (a <= 0 && u <= 0) return this.m_v1.a = 1, void (this.m_count = 1);
      if (o > 0 && a > 0 && v <= 0) {
        var b = 1 / (o + a);
        return this.m_v1.a = o * b, this.m_v2.a = a * b, void (this.m_count = 2);
      }
      if (h > 0 && u > 0 && x <= 0) {
        var w = 1 / (h + u);
        return this.m_v1.a = h * w, this.m_v3.a = u * w, this.m_count = 2, void this.m_v2.Set(this.m_v3);
      }
      if (o <= 0 && _ <= 0) return this.m_v2.a = 1, this.m_count = 1, void this.m_v1.Set(this.m_v2);
      if (h <= 0 && d <= 0) return this.m_v3.a = 1, this.m_count = 1, void this.m_v1.Set(this.m_v3);
      if (d > 0 && _ > 0 && g <= 0) {
        var S = 1 / (d + _);
        return this.m_v2.a = d * S, this.m_v3.a = _ * S, this.m_count = 2, void this.m_v1.Set(this.m_v3);
      }
      var M = 1 / (g + x + v);
      this.m_v1.a = g * M, this.m_v2.a = x * M, this.m_v3.a = v * M, this.m_count = 3;
    }, P.b2SimplexCache = function () {
      this.indexA = new W(3), this.indexB = new W(3);
    }, I.b2SimplexVertex = function () {}, I.prototype.Set = function (t) {
      this.wA.SetV(t.wA), this.wB.SetV(t.wB), this.w.SetV(t.w), this.a = t.a, this.indexA = t.indexA, this.indexB = t.indexB;
    }, V.b2TimeOfImpact = function () {}, V.TimeOfImpact = function (t) {
      ++V.b2_toiCalls;
      var e = t.proxyA, i = t.proxyB, n = t.sweepA, r = t.sweepB;
      o.b2Assert(n.t0 == r.t0), o.b2Assert(1 - n.t0 > Number.MIN_VALUE);
      var a = e.m_radius + i.m_radius, l = t.tolerance, c = 0, h = 0, u = 0;
      for (V.s_cache.count = 0, V.s_distanceInput.useRadii = false;;) {
        if (n.GetTransform(V.s_xfA, c), r.GetTransform(V.s_xfB, c), V.s_distanceInput.proxyA = e, V.s_distanceInput.proxyB = i, V.s_distanceInput.transformA = V.s_xfA, V.s_distanceInput.transformB = V.s_xfB, y.Distance(V.s_distanceOutput, V.s_cache, V.s_distanceInput), V.s_distanceOutput.distance <= 0) {
          c = 1;
          break;
        }
        V.s_fcn.Initialize(V.s_cache, e, V.s_xfA, i, V.s_xfB);
        var p = V.s_fcn.Evaluate(V.s_xfA, V.s_xfB);
        if (p <= 0) {
          c = 1;
          break;
        }
        if (0 == h && (u = p > a ? s.Max(a - l, 0.75 * a) : s.Max(p - l, 0.02 * a)), p - u < 0.5 * l) {
          if (0 == h) {
            c = 1;
            break;
          }
          break;
        }
        var m = c, d = c, _ = 1, g = p;
        n.GetTransform(V.s_xfA, _), r.GetTransform(V.s_xfB, _);
        var x = V.s_fcn.Evaluate(V.s_xfA, V.s_xfB);
        if (x >= u) {
          c = 1;
          break;
        }
        for (var v = 0;;) {
          var b = 0;
          b = 1 & v ? d + (u - g) * (_ - d) / (x - g) : 0.5 * (d + _), n.GetTransform(V.s_xfA, b), r.GetTransform(V.s_xfB, b);
          var w = V.s_fcn.Evaluate(V.s_xfA, V.s_xfB);
          if (s.Abs(w - u) < 0.025 * l) {
            m = b;
            break;
          }
          if (w > u ? (d = b, g = w) : (_ = b, x = w), ++v, ++V.b2_toiRootIters, 50 == v) break;
        }
        if (V.b2_toiMaxRootIters = s.Max(V.b2_toiMaxRootIters, v), m < (1 + 100 * Number.MIN_VALUE) * c) break;
        if (c = m, h++, ++V.b2_toiIters, 1e3 == h) break;
      }
      return V.b2_toiMaxIters = s.Max(V.b2_toiMaxIters, h), c;
    }, e.postDefs.push(function () {
      e.Collision.b2TimeOfImpact.b2_toiCalls = 0, e.Collision.b2TimeOfImpact.b2_toiIters = 0, e.Collision.b2TimeOfImpact.b2_toiMaxIters = 0, e.Collision.b2TimeOfImpact.b2_toiRootIters = 0, e.Collision.b2TimeOfImpact.b2_toiMaxRootIters = 0, e.Collision.b2TimeOfImpact.s_cache = new P, e.Collision.b2TimeOfImpact.s_distanceInput = new g, e.Collision.b2TimeOfImpact.s_xfA = new l, e.Collision.b2TimeOfImpact.s_xfB = new l, e.Collision.b2TimeOfImpact.s_fcn = new R, e.Collision.b2TimeOfImpact.s_distanceOutput = new x;
    }), F.b2TOIInput = function () {
      this.proxyA = new v, this.proxyB = new v, this.sweepA = new a, this.sweepB = new a;
    }, k.b2WorldManifold = function () {
      this.m_normal = new c;
    }, k.prototype.b2WorldManifold = function () {
      this.m_points = new H(o.b2_maxManifoldPoints);
      for (var t = 0; t < o.b2_maxManifoldPoints; t++) this.m_points[t] = new c;
    }, k.prototype.Initialize = function (t, e, i, n, r) {
      if (void 0 === i && (i = 0), void 0 === r && (r = 0), 0 != t.m_pointCount) {
        var o, s, a = 0, l = 0, c = 0, h = 0, u = 0, p = 0, m = 0;
        switch (t.m_type) {
          case A.e_circles:
            s = e.R, o = t.m_localPoint;
            var d = e.position.x + s.col1.x * o.x + s.col2.x * o.y, _ = e.position.y + s.col1.y * o.x + s.col2.y * o.y;
            s = n.R, o = t.m_points[0].m_localPoint;
            var y = n.position.x + s.col1.x * o.x + s.col2.x * o.y, g = n.position.y + s.col1.y * o.x + s.col2.y * o.y, x = y - d, v = g - _, b = x * x + v * v;
            if (b > Number.MIN_VALUE * Number.MIN_VALUE) {
              var w = Math.sqrt(b);
              this.m_normal.x = x / w, this.m_normal.y = v / w;
            } else this.m_normal.x = 1, this.m_normal.y = 0;
            var S = d + i * this.m_normal.x, M = _ + i * this.m_normal.y, C = y - r * this.m_normal.x, T = g - r * this.m_normal.y;
            this.m_points[0].x = 0.5 * (S + C), this.m_points[0].y = 0.5 * (M + T);
            break;
          case A.e_faceA:
            for (s = e.R, o = t.m_localPlaneNormal, l = s.col1.x * o.x + s.col2.x * o.y, c = s.col1.y * o.x + s.col2.y * o.y, s = e.R, o = t.m_localPoint, h = e.position.x + s.col1.x * o.x + s.col2.x * o.y, u = e.position.y + s.col1.y * o.x + s.col2.y * o.y, this.m_normal.x = l, this.m_normal.y = c, a = 0; a < t.m_pointCount; a++) s = n.R, o = t.m_points[a].m_localPoint, p = n.position.x + s.col1.x * o.x + s.col2.x * o.y, m = n.position.y + s.col1.y * o.x + s.col2.y * o.y, this.m_points[a].x = p + 0.5 * (i - (p - h) * l - (m - u) * c - r) * l, this.m_points[a].y = m + 0.5 * (i - (p - h) * l - (m - u) * c - r) * c;
            break;
          case A.e_faceB:
            for (s = n.R, o = t.m_localPlaneNormal, l = s.col1.x * o.x + s.col2.x * o.y, c = s.col1.y * o.x + s.col2.y * o.y, s = n.R, o = t.m_localPoint, h = n.position.x + s.col1.x * o.x + s.col2.x * o.y, u = n.position.y + s.col1.y * o.x + s.col2.y * o.y, this.m_normal.x = -l, this.m_normal.y = -c, a = 0; a < t.m_pointCount; a++) s = e.R, o = t.m_points[a].m_localPoint, p = e.position.x + s.col1.x * o.x + s.col2.x * o.y, m = e.position.y + s.col1.y * o.x + s.col2.y * o.y, this.m_points[a].x = p + 0.5 * (r - (p - h) * l - (m - u) * c - i) * l, this.m_points[a].y = m + 0.5 * (r - (p - h) * l - (m - u) * c - i) * c;
        }
      }
    }, N.ClipVertex = function () {
      this.v = new c, this.id = new d;
    }, N.prototype.Set = function (t) {
      this.v.SetV(t.v), this.id.Set(t.id);
    }, G.Features = function () {}, Object.defineProperty(G.prototype, "referenceEdge", {enumerable: false, configurable: true, get: function () {
      return this._referenceEdge;
    }}), Object.defineProperty(G.prototype, "referenceEdge", {enumerable: false, configurable: true, set: function (t) {
      void 0 === t && (t = 0), this._referenceEdge = t, this._m_id._key = 4294967040 & this._m_id._key | 255 & this._referenceEdge;
    }}), Object.defineProperty(G.prototype, "incidentEdge", {enumerable: false, configurable: true, get: function () {
      return this._incidentEdge;
    }}), Object.defineProperty(G.prototype, "incidentEdge", {enumerable: false, configurable: true, set: function (t) {
      void 0 === t && (t = 0), this._incidentEdge = t, this._m_id._key = 4294902015 & this._m_id._key | this._incidentEdge << 8 & 65280;
    }}), Object.defineProperty(G.prototype, "incidentVertex", {enumerable: false, configurable: true, get: function () {
      return this._incidentVertex;
    }}), Object.defineProperty(G.prototype, "incidentVertex", {enumerable: false, configurable: true, set: function (t) {
      void 0 === t && (t = 0), this._incidentVertex = t, this._m_id._key = 4278255615 & this._m_id._key | this._incidentVertex << 16 & 16711680;
    }}), Object.defineProperty(G.prototype, "flip", {enumerable: false, configurable: true, get: function () {
      return this._flip;
    }}), Object.defineProperty(G.prototype, "flip", {enumerable: false, configurable: true, set: function (t) {
      void 0 === t && (t = 0), this._flip = t, this._m_id._key = 16777215 & this._m_id._key | this._flip << 24 & 4278190080;
    }}), function () {
      e.Common.b2Color, e.Common.b2internal;
      var t = e.Common.b2Settings, i = e.Collision.Shapes.b2CircleShape, n = e.Collision.Shapes.b2EdgeChainDef, r = e.Collision.Shapes.b2EdgeShape, o = e.Collision.Shapes.b2MassData, s = e.Collision.Shapes.b2PolygonShape, a = e.Collision.Shapes.b2Shape, l = e.Common.Math.b2Mat22, c = (e.Common.Math.b2Mat33, e.Common.Math.b2Math), h = (e.Common.Math.b2Sweep, e.Common.Math.b2Transform), u = e.Common.Math.b2Vec2, p = (e.Common.Math.b2Vec3, e.Dynamics.b2Body, e.Dynamics.b2BodyDef, e.Dynamics.b2ContactFilter, e.Dynamics.b2ContactImpulse, e.Dynamics.b2ContactListener, e.Dynamics.b2ContactManager, e.Dynamics.b2DebugDraw, e.Dynamics.b2DestructionListener, e.Dynamics.b2FilterData, e.Dynamics.b2Fixture, e.Dynamics.b2FixtureDef, e.Dynamics.b2Island, e.Dynamics.b2TimeStep, e.Dynamics.b2World, e.Collision.b2AABB, e.Collision.b2Bound, e.Collision.b2BoundValues, e.Collision.b2Collision, e.Collision.b2ContactID, e.Collision.b2ContactPoint, e.Collision.b2Distance), m = e.Collision.b2DistanceInput, d = e.Collision.b2DistanceOutput, _ = e.Collision.b2DistanceProxy, y = (e.Collision.b2DynamicTree, e.Collision.b2DynamicTreeBroadPhase, e.Collision.b2DynamicTreeNode, e.Collision.b2DynamicTreePair, e.Collision.b2Manifold, e.Collision.b2ManifoldPoint, e.Collision.b2Point, e.Collision.b2RayCastInput, e.Collision.b2RayCastOutput, e.Collision.b2Segment, e.Collision.b2SeparationFunction, e.Collision.b2Simplex, e.Collision.b2SimplexCache);
      e.Collision.b2SimplexVertex, e.Collision.b2TimeOfImpact, e.Collision.b2TOIInput, e.Collision.b2WorldManifold, e.Collision.ClipVertex, e.Collision.Features, e.Collision.IBroadPhase;
      e.inherit(i, e.Collision.Shapes.b2Shape), i.prototype.__super = e.Collision.Shapes.b2Shape.prototype, i.b2CircleShape = function () {
        e.Collision.Shapes.b2Shape.b2Shape.apply(this, arguments), this.m_p = new u;
      }, i.prototype.Copy = function () {
        var t = new i;
        return t.Set(this), t;
      }, i.prototype.Set = function (t) {
        if (this.__super.Set.call(this, t), e.is(t, i)) {
          var n = t instanceof i ? t : null;
          this.m_p.SetV(n.m_p);
        }
      }, i.prototype.TestPoint = function (t, e) {
        var i = t.R, n = t.position.x + (i.col1.x * this.m_p.x + i.col2.x * this.m_p.y), r = t.position.y + (i.col1.y * this.m_p.x + i.col2.y * this.m_p.y);
        return (n = e.x - n) * n + (r = e.y - r) * r <= this.m_radius * this.m_radius;
      }, i.prototype.RayCast = function (t, e, i) {
        var n = i.R, r = i.position.x + (n.col1.x * this.m_p.x + n.col2.x * this.m_p.y), o = i.position.y + (n.col1.y * this.m_p.x + n.col2.y * this.m_p.y), s = e.p1.x - r, a = e.p1.y - o, l = s * s + a * a - this.m_radius * this.m_radius, c = e.p2.x - e.p1.x, h = e.p2.y - e.p1.y, u = s * c + a * h, p = c * c + h * h, m = u * u - p * l;
        if (m < 0 || p < Number.MIN_VALUE) return false;
        var d = -(u + Math.sqrt(m));
        return 0 <= d && d <= e.maxFraction * p && (d /= p, t.fraction = d, t.normal.x = s + d * c, t.normal.y = a + d * h, t.normal.Normalize(), true);
      }, i.prototype.ComputeAABB = function (t, e) {
        var i = e.R, n = e.position.x + (i.col1.x * this.m_p.x + i.col2.x * this.m_p.y), r = e.position.y + (i.col1.y * this.m_p.x + i.col2.y * this.m_p.y);
        t.lowerBound.Set(n - this.m_radius, r - this.m_radius), t.upperBound.Set(n + this.m_radius, r + this.m_radius);
      }, i.prototype.ComputeMass = function (e, i) {
        void 0 === i && (i = 0), e.mass = i * t.b2_pi * this.m_radius * this.m_radius, e.center.SetV(this.m_p), e.I = e.mass * (0.5 * this.m_radius * this.m_radius + (this.m_p.x * this.m_p.x + this.m_p.y * this.m_p.y));
      }, i.prototype.ComputeSubmergedArea = function (t, e, i, n) {
        void 0 === e && (e = 0);
        var r = c.MulX(i, this.m_p), o = -(c.Dot(t, r) - e);
        if (o < -this.m_radius + Number.MIN_VALUE) return 0;
        if (o > this.m_radius) return n.SetV(r), Math.PI * this.m_radius * this.m_radius;
        var s = this.m_radius * this.m_radius, a = o * o, l = s * (Math.asin(o / this.m_radius) + Math.PI / 2) + o * Math.sqrt(s - a), h = -0.6666666666666666 * Math.pow(s - a, 1.5) / l;
        return n.x = r.x + t.x * h, n.y = r.y + t.y * h, l;
      }, i.prototype.GetLocalPosition = function () {
        return this.m_p;
      }, i.prototype.SetLocalPosition = function (t) {
        this.m_p.SetV(t);
      }, i.prototype.GetRadius = function () {
        return this.m_radius;
      }, i.prototype.SetRadius = function (t) {
        void 0 === t && (t = 0), this.m_radius = t;
      }, i.prototype.b2CircleShape = function (t) {
        void 0 === t && (t = 0), this.__super.b2Shape.call(this), this.m_type = a.e_circleShape, this.m_radius = t;
      }, n.b2EdgeChainDef = function () {}, n.prototype.b2EdgeChainDef = function () {
        this.vertexCount = 0, this.isALoop = true, this.vertices = [];
      }, e.inherit(r, e.Collision.Shapes.b2Shape), r.prototype.__super = e.Collision.Shapes.b2Shape.prototype, r.b2EdgeShape = function () {
        e.Collision.Shapes.b2Shape.b2Shape.apply(this, arguments), this.s_supportVec = new u, this.m_v1 = new u, this.m_v2 = new u, this.m_coreV1 = new u, this.m_coreV2 = new u, this.m_normal = new u, this.m_direction = new u, this.m_cornerDir1 = new u, this.m_cornerDir2 = new u;
      }, r.prototype.TestPoint = function (t, e) {
        return false;
      }, r.prototype.RayCast = function (t, e, i) {
        var n, r = e.p2.x - e.p1.x, o = e.p2.y - e.p1.y;
        n = i.R;
        var s = i.position.x + (n.col1.x * this.m_v1.x + n.col2.x * this.m_v1.y), a = i.position.y + (n.col1.y * this.m_v1.x + n.col2.y * this.m_v1.y), l = i.position.y + (n.col1.y * this.m_v2.x + n.col2.y * this.m_v2.y) - a, c = -(i.position.x + (n.col1.x * this.m_v2.x + n.col2.x * this.m_v2.y) - s), h = 100 * Number.MIN_VALUE, u = -(r * l + o * c);
        if (u > h) {
          var p = e.p1.x - s, m = e.p1.y - a, d = p * l + m * c;
          if (0 <= d && d <= e.maxFraction * u) {
            var _ = -r * m + o * p;
            if (-h * u <= _ && _ <= u * (1 + h)) {
              d /= u, t.fraction = d;
              var y = Math.sqrt(l * l + c * c);
              return t.normal.x = l / y, t.normal.y = c / y, true;
            }
          }
        }
        return false;
      }, r.prototype.ComputeAABB = function (t, e) {
        var i = e.R, n = e.position.x + (i.col1.x * this.m_v1.x + i.col2.x * this.m_v1.y), r = e.position.y + (i.col1.y * this.m_v1.x + i.col2.y * this.m_v1.y), o = e.position.x + (i.col1.x * this.m_v2.x + i.col2.x * this.m_v2.y), s = e.position.y + (i.col1.y * this.m_v2.x + i.col2.y * this.m_v2.y);
        n < o ? (t.lowerBound.x = n, t.upperBound.x = o) : (t.lowerBound.x = o, t.upperBound.x = n), r < s ? (t.lowerBound.y = r, t.upperBound.y = s) : (t.lowerBound.y = s, t.upperBound.y = r);
      }, r.prototype.ComputeMass = function (t, e) {
        void 0 === e && (e = 0), t.mass = 0, t.center.SetV(this.m_v1), t.I = 0;
      }, r.prototype.ComputeSubmergedArea = function (t, e, i, n) {
        void 0 === e && (e = 0);
        var r = new u(t.x * e, t.y * e), o = c.MulX(i, this.m_v1), s = c.MulX(i, this.m_v2), a = c.Dot(t, o) - e, l = c.Dot(t, s) - e;
        if (a > 0) {
          if (l > 0) return 0;
          o.x = -l / (a - l) * o.x + a / (a - l) * s.x, o.y = -l / (a - l) * o.y + a / (a - l) * s.y;
        } else l > 0 && (s.x = -l / (a - l) * o.x + a / (a - l) * s.x, s.y = -l / (a - l) * o.y + a / (a - l) * s.y);
        return n.x = (r.x + o.x + s.x) / 3, n.y = (r.y + o.y + s.y) / 3, 0.5 * ((o.x - r.x) * (s.y - r.y) - (o.y - r.y) * (s.x - r.x));
      }, r.prototype.GetLength = function () {
        return this.m_length;
      }, r.prototype.GetVertex1 = function () {
        return this.m_v1;
      }, r.prototype.GetVertex2 = function () {
        return this.m_v2;
      }, r.prototype.GetCoreVertex1 = function () {
        return this.m_coreV1;
      }, r.prototype.GetCoreVertex2 = function () {
        return this.m_coreV2;
      }, r.prototype.GetNormalVector = function () {
        return this.m_normal;
      }, r.prototype.GetDirectionVector = function () {
        return this.m_direction;
      }, r.prototype.GetCorner1Vector = function () {
        return this.m_cornerDir1;
      }, r.prototype.GetCorner2Vector = function () {
        return this.m_cornerDir2;
      }, r.prototype.Corner1IsConvex = function () {
        return this.m_cornerConvex1;
      }, r.prototype.Corner2IsConvex = function () {
        return this.m_cornerConvex2;
      }, r.prototype.GetFirstVertex = function (t) {
        var e = t.R;
        return new u(t.position.x + (e.col1.x * this.m_coreV1.x + e.col2.x * this.m_coreV1.y), t.position.y + (e.col1.y * this.m_coreV1.x + e.col2.y * this.m_coreV1.y));
      }, r.prototype.GetNextEdge = function () {
        return this.m_nextEdge;
      }, r.prototype.GetPrevEdge = function () {
        return this.m_prevEdge;
      }, r.prototype.Support = function (t, e, i) {
        void 0 === e && (e = 0), void 0 === i && (i = 0);
        var n = t.R, r = t.position.x + (n.col1.x * this.m_coreV1.x + n.col2.x * this.m_coreV1.y), o = t.position.y + (n.col1.y * this.m_coreV1.x + n.col2.y * this.m_coreV1.y), s = t.position.x + (n.col1.x * this.m_coreV2.x + n.col2.x * this.m_coreV2.y), a = t.position.y + (n.col1.y * this.m_coreV2.x + n.col2.y * this.m_coreV2.y);
        return r * e + o * i > s * e + a * i ? (this.s_supportVec.x = r, this.s_supportVec.y = o) : (this.s_supportVec.x = s, this.s_supportVec.y = a), this.s_supportVec;
      }, r.prototype.b2EdgeShape = function (e, i) {
        this.__super.b2Shape.call(this), this.m_type = a.e_edgeShape, this.m_prevEdge = null, this.m_nextEdge = null, this.m_v1 = e, this.m_v2 = i, this.m_direction.Set(this.m_v2.x - this.m_v1.x, this.m_v2.y - this.m_v1.y), this.m_length = this.m_direction.Normalize(), this.m_normal.Set(this.m_direction.y, -this.m_direction.x), this.m_coreV1.Set(-t.b2_toiSlop * (this.m_normal.x - this.m_direction.x) + this.m_v1.x, -t.b2_toiSlop * (this.m_normal.y - this.m_direction.y) + this.m_v1.y), this.m_coreV2.Set(-t.b2_toiSlop * (this.m_normal.x + this.m_direction.x) + this.m_v2.x, -t.b2_toiSlop * (this.m_normal.y + this.m_direction.y) + this.m_v2.y), this.m_cornerDir1 = this.m_normal, this.m_cornerDir2.Set(-this.m_normal.x, -this.m_normal.y);
      }, r.prototype.SetPrevEdge = function (t, e, i, n) {
        this.m_prevEdge = t, this.m_coreV1 = e, this.m_cornerDir1 = i, this.m_cornerConvex1 = n;
      }, r.prototype.SetNextEdge = function (t, e, i, n) {
        this.m_nextEdge = t, this.m_coreV2 = e, this.m_cornerDir2 = i, this.m_cornerConvex2 = n;
      }, o.b2MassData = function () {
        this.mass = 0, this.center = new u(0, 0), this.I = 0;
      }, e.inherit(s, e.Collision.Shapes.b2Shape), s.prototype.__super = e.Collision.Shapes.b2Shape.prototype, s.b2PolygonShape = function () {
        e.Collision.Shapes.b2Shape.b2Shape.apply(this, arguments);
      }, s.prototype.Copy = function () {
        var t = new s;
        return t.Set(this), t;
      }, s.prototype.Set = function (t) {
        if (this.__super.Set.call(this, t), e.is(t, s)) {
          var i = t instanceof s ? t : null;
          this.m_centroid.SetV(i.m_centroid), this.m_vertexCount = i.m_vertexCount, this.Reserve(this.m_vertexCount);
          for (var n = 0; n < this.m_vertexCount; n++) this.m_vertices[n].SetV(i.m_vertices[n]), this.m_normals[n].SetV(i.m_normals[n]);
        }
      }, s.prototype.SetAsArray = function (t, e) {
        void 0 === e && (e = 0);
        var i, n = new H, r = 0;
        for (r = 0; r < t.length; ++r) i = t[r], n.push(i);
        this.SetAsVector(n, e);
      }, s.AsArray = function (t, e) {
        void 0 === e && (e = 0);
        var i = new s;
        return i.SetAsArray(t, e), i;
      }, s.prototype.SetAsVector = function (e, i) {
        void 0 === i && (i = 0), 0 == i && (i = e.length), t.b2Assert(2 <= i), this.m_vertexCount = i, this.Reserve(i);
        var n = 0;
        for (n = 0; n < this.m_vertexCount; n++) this.m_vertices[n].SetV(e[n]);
        for (n = 0; n < this.m_vertexCount; ++n) {
          var r = parseInt(n), o = parseInt(n + 1 < this.m_vertexCount ? n + 1 : 0), a = c.SubtractVV(this.m_vertices[o], this.m_vertices[r]);
          t.b2Assert(a.LengthSquared() > Number.MIN_VALUE), this.m_normals[n].SetV(c.CrossVF(a, 1)), this.m_normals[n].Normalize();
        }
        this.m_centroid = s.ComputeCentroid(this.m_vertices, this.m_vertexCount);
      }, s.AsVector = function (t, e) {
        void 0 === e && (e = 0);
        var i = new s;
        return i.SetAsVector(t, e), i;
      }, s.prototype.SetAsBox = function (t, e) {
        void 0 === t && (t = 0), void 0 === e && (e = 0), this.m_vertexCount = 4, this.Reserve(4), this.m_vertices[0].Set(-t, -e), this.m_vertices[1].Set(t, -e), this.m_vertices[2].Set(t, e), this.m_vertices[3].Set(-t, e), this.m_normals[0].Set(0, -1), this.m_normals[1].Set(1, 0), this.m_normals[2].Set(0, 1), this.m_normals[3].Set(-1, 0), this.m_centroid.SetZero();
      }, s.AsBox = function (t, e) {
        void 0 === t && (t = 0), void 0 === e && (e = 0);
        var i = new s;
        return i.SetAsBox(t, e), i;
      }, s.prototype.SetAsOrientedBox = function (t, e, i, n) {
        void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = null), void 0 === n && (n = 0), this.m_vertexCount = 4, this.Reserve(4), this.m_vertices[0].Set(-t, -e), this.m_vertices[1].Set(t, -e), this.m_vertices[2].Set(t, e), this.m_vertices[3].Set(-t, e), this.m_normals[0].Set(0, -1), this.m_normals[1].Set(1, 0), this.m_normals[2].Set(0, 1), this.m_normals[3].Set(-1, 0), this.m_centroid = i;
        var r = new h;
        r.position = i, r.R.Set(n);
        for (var o = 0; o < this.m_vertexCount; ++o) this.m_vertices[o] = c.MulX(r, this.m_vertices[o]), this.m_normals[o] = c.MulMV(r.R, this.m_normals[o]);
      }, s.AsOrientedBox = function (t, e, i, n) {
        void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = null), void 0 === n && (n = 0);
        var r = new s;
        return r.SetAsOrientedBox(t, e, i, n), r;
      }, s.prototype.SetAsEdge = function (t, e) {
        this.m_vertexCount = 2, this.Reserve(2), this.m_vertices[0].SetV(t), this.m_vertices[1].SetV(e), this.m_centroid.x = 0.5 * (t.x + e.x), this.m_centroid.y = 0.5 * (t.y + e.y), this.m_normals[0] = c.CrossVF(c.SubtractVV(e, t), 1), this.m_normals[0].Normalize(), this.m_normals[1].x = -this.m_normals[0].x, this.m_normals[1].y = -this.m_normals[0].y;
      }, s.AsEdge = function (t, e) {
        var i = new s;
        return i.SetAsEdge(t, e), i;
      }, s.prototype.TestPoint = function (t, e) {
        for (var i, n = t.R, r = e.x - t.position.x, o = e.y - t.position.y, s = r * n.col1.x + o * n.col1.y, a = r * n.col2.x + o * n.col2.y, l = 0; l < this.m_vertexCount; ++l) {
          if (r = s - (i = this.m_vertices[l]).x, o = a - i.y, (i = this.m_normals[l]).x * r + i.y * o > 0) return false;
        }
        return true;
      }, s.prototype.RayCast = function (t, e, i) {
        var n, r, o = 0, s = e.maxFraction, a = 0, l = 0;
        a = e.p1.x - i.position.x, l = e.p1.y - i.position.y;
        var c = a * (n = i.R).col1.x + l * n.col1.y, h = a * n.col2.x + l * n.col2.y;
        a = e.p2.x - i.position.x, l = e.p2.y - i.position.y;
        for (var u = a * (n = i.R).col1.x + l * n.col1.y - c, p = a * n.col2.x + l * n.col2.y - h, m = parseInt(-1), d = 0; d < this.m_vertexCount; ++d) {
          a = (r = this.m_vertices[d]).x - c, l = r.y - h;
          var _ = (r = this.m_normals[d]).x * a + r.y * l, y = r.x * u + r.y * p;
          if (0 == y) {
            if (_ < 0) return false;
          } else y < 0 && _ < o * y ? (o = _ / y, m = d) : y > 0 && _ < s * y && (s = _ / y);
          if (s < o - Number.MIN_VALUE) return false;
        }
        return m >= 0 && (t.fraction = o, n = i.R, r = this.m_normals[m], t.normal.x = n.col1.x * r.x + n.col2.x * r.y, t.normal.y = n.col1.y * r.x + n.col2.y * r.y, true);
      }, s.prototype.ComputeAABB = function (t, e) {
        for (var i = e.R, n = this.m_vertices[0], r = e.position.x + (i.col1.x * n.x + i.col2.x * n.y), o = e.position.y + (i.col1.y * n.x + i.col2.y * n.y), s = r, a = o, l = 1; l < this.m_vertexCount; ++l) {
          n = this.m_vertices[l];
          var c = e.position.x + (i.col1.x * n.x + i.col2.x * n.y), h = e.position.y + (i.col1.y * n.x + i.col2.y * n.y);
          r = r < c ? r : c, o = o < h ? o : h, s = s > c ? s : c, a = a > h ? a : h;
        }
        t.lowerBound.x = r - this.m_radius, t.lowerBound.y = o - this.m_radius, t.upperBound.x = s + this.m_radius, t.upperBound.y = a + this.m_radius;
      }, s.prototype.ComputeMass = function (t, e) {
        if (void 0 === e && (e = 0), 2 == this.m_vertexCount) return t.center.x = 0.5 * (this.m_vertices[0].x + this.m_vertices[1].x), t.center.y = 0.5 * (this.m_vertices[0].y + this.m_vertices[1].y), t.mass = 0, void (t.I = 0);
        for (var i = 0, n = 0, r = 0, o = 0, s = 0.3333333333333333, a = 0; a < this.m_vertexCount; ++a) {
          var l = this.m_vertices[a], c = a + 1 < this.m_vertexCount ? this.m_vertices[parseInt(a + 1)] : this.m_vertices[0], h = l.x - 0, u = l.y - 0, p = c.x - 0, m = c.y - 0, d = h * m - u * p, _ = 0.5 * d;
          r += _, i += _ * s * (0 + l.x + c.x), n += _ * s * (0 + l.y + c.y);
          o += d * (s * (0.25 * (h * h + p * h + p * p) + (0 * h + 0 * p)) + 0 + (s * (0.25 * (u * u + m * u + m * m) + (0 * u + 0 * m)) + 0));
        }
        t.mass = e * r, i *= 1 / r, n *= 1 / r, t.center.Set(i, n), t.I = e * o;
      }, s.prototype.ComputeSubmergedArea = function (t, e, i, n) {
        void 0 === e && (e = 0);
        var r = c.MulTMV(i.R, t), s = e - c.Dot(t, i.position), a = new W, l = 0, h = parseInt(-1), p = parseInt(-1), m = false, d = 0;
        for (d = 0; d < this.m_vertexCount; ++d) {
          a[d] = c.Dot(r, this.m_vertices[d]) - s;
          var _ = a[d] < -Number.MIN_VALUE;
          d > 0 && (_ ? m || (h = d - 1, l++) : m && (p = d - 1, l++)), m = _;
        }
        switch (l) {
          case 0:
            if (m) {
              var y = new o;
              return this.ComputeMass(y, 1), n.SetV(c.MulX(i, y.center)), y.mass;
            }
            return 0;
          case 1:
            -1 == h ? h = this.m_vertexCount - 1 : p = this.m_vertexCount - 1;
        }
        var g, x = parseInt((h + 1) % this.m_vertexCount), v = parseInt((p + 1) % this.m_vertexCount), b = (0 - a[h]) / (a[x] - a[h]), w = (0 - a[p]) / (a[v] - a[p]), S = new u(this.m_vertices[h].x * (1 - b) + this.m_vertices[x].x * b, this.m_vertices[h].y * (1 - b) + this.m_vertices[x].y * b), M = new u(this.m_vertices[p].x * (1 - w) + this.m_vertices[v].x * w, this.m_vertices[p].y * (1 - w) + this.m_vertices[v].y * w), A = 0, C = new u, T = this.m_vertices[x];
        for (d = x; d != v;) {
          g = (d = (d + 1) % this.m_vertexCount) == v ? M : this.m_vertices[d];
          var E = 0.5 * ((T.x - S.x) * (g.y - S.y) - (T.y - S.y) * (g.x - S.x));
          A += E, C.x += E * (S.x + T.x + g.x) / 3, C.y += E * (S.y + T.y + g.y) / 3, T = g;
        }
        return C.Multiply(1 / A), n.SetV(c.MulX(i, C)), A;
      }, s.prototype.GetVertexCount = function () {
        return this.m_vertexCount;
      }, s.prototype.GetVertices = function () {
        return this.m_vertices;
      }, s.prototype.GetNormals = function () {
        return this.m_normals;
      }, s.prototype.GetSupport = function (t) {
        for (var e = 0, i = this.m_vertices[0].x * t.x + this.m_vertices[0].y * t.y, n = 1; n < this.m_vertexCount; ++n) {
          var r = this.m_vertices[n].x * t.x + this.m_vertices[n].y * t.y;
          r > i && (e = n, i = r);
        }
        return e;
      }, s.prototype.GetSupportVertex = function (t) {
        for (var e = 0, i = this.m_vertices[0].x * t.x + this.m_vertices[0].y * t.y, n = 1; n < this.m_vertexCount; ++n) {
          var r = this.m_vertices[n].x * t.x + this.m_vertices[n].y * t.y;
          r > i && (e = n, i = r);
        }
        return this.m_vertices[e];
      }, s.prototype.Validate = function () {
        return false;
      }, s.prototype.b2PolygonShape = function () {
        this.__super.b2Shape.call(this), this.m_type = a.e_polygonShape, this.m_centroid = new u, this.m_vertices = new H, this.m_normals = new H;
      }, s.prototype.Reserve = function (t) {
        void 0 === t && (t = 0);
        for (var e = parseInt(this.m_vertices.length); e < t; e++) this.m_vertices[e] = new u, this.m_normals[e] = new u;
      }, s.ComputeCentroid = function (t, e) {
        void 0 === e && (e = 0);
        for (var i = new u, n = 0, r = 0.3333333333333333, o = 0; o < e; ++o) {
          var s = t[o], a = o + 1 < e ? t[parseInt(o + 1)] : t[0], l = s.x - 0, c = s.y - 0, h = a.x - 0, p = 0.5 * (l * (a.y - 0) - c * h);
          n += p, i.x += p * r * (0 + s.x + a.x), i.y += p * r * (0 + s.y + a.y);
        }
        return i.x *= 1 / n, i.y *= 1 / n, i;
      }, s.ComputeOBB = function (t, e, i) {
        void 0 === i && (i = 0);
        var n = 0, r = new H(i + 1);
        for (n = 0; n < i; ++n) r[n] = e[n];
        r[i] = r[0];
        var o = Number.MAX_VALUE;
        for (n = 1; n <= i; ++n) {
          for (var s = r[parseInt(n - 1)], a = r[n].x - s.x, l = r[n].y - s.y, c = Math.sqrt(a * a + l * l), h = -(l /= c), u = a /= c, p = Number.MAX_VALUE, m = Number.MAX_VALUE, d = -Number.MAX_VALUE, _ = -Number.MAX_VALUE, y = 0; y < i; ++y) {
            var g = r[y].x - s.x, x = r[y].y - s.y, v = a * g + l * x, b = h * g + u * x;
            v < p && (p = v), b < m && (m = b), v > d && (d = v), b > _ && (_ = b);
          }
          var w = (d - p) * (_ - m);
          if (w < 0.95 * o) {
            o = w, t.R.col1.x = a, t.R.col1.y = l, t.R.col2.x = h, t.R.col2.y = u;
            var S = 0.5 * (p + d), M = 0.5 * (m + _), A = t.R;
            t.center.x = s.x + (A.col1.x * S + A.col2.x * M), t.center.y = s.y + (A.col1.y * S + A.col2.y * M), t.extents.x = 0.5 * (d - p), t.extents.y = 0.5 * (_ - m);
          }
        }
      }, e.postDefs.push(function () {
        e.Collision.Shapes.b2PolygonShape.s_mat = new l;
      }), a.b2Shape = function () {}, a.prototype.Copy = function () {
        return null;
      }, a.prototype.Set = function (t) {
        this.m_radius = t.m_radius;
      }, a.prototype.GetType = function () {
        return this.m_type;
      }, a.prototype.TestPoint = function (t, e) {
        return false;
      }, a.prototype.RayCast = function (t, e, i) {
        return false;
      }, a.prototype.ComputeAABB = function (t, e) {}, a.prototype.ComputeMass = function (t, e) {
        void 0 === e && (e = 0);
      }, a.prototype.ComputeSubmergedArea = function (t, e, i, n) {
        return void 0 === e && (e = 0), 0;
      }, a.TestOverlap = function (t, e, i, n) {
        var r = new m;
        r.proxyA = new _, r.proxyA.Set(t), r.proxyB = new _, r.proxyB.Set(i), r.transformA = e, r.transformB = n, r.useRadii = true;
        var o = new y;
        o.count = 0;
        var s = new d;
        return p.Distance(s, o, r), s.distance < 10 * Number.MIN_VALUE;
      }, a.prototype.b2Shape = function () {
        this.m_type = a.e_unknownShape, this.m_radius = t.b2_linearSlop;
      }, e.postDefs.push(function () {
        e.Collision.Shapes.b2Shape.e_unknownShape = parseInt(-1), e.Collision.Shapes.b2Shape.e_circleShape = 0, e.Collision.Shapes.b2Shape.e_polygonShape = 1, e.Collision.Shapes.b2Shape.e_edgeShape = 2, e.Collision.Shapes.b2Shape.e_shapeTypeCount = 3, e.Collision.Shapes.b2Shape.e_hitCollide = 1, e.Collision.Shapes.b2Shape.e_missCollide = 0, e.Collision.Shapes.b2Shape.e_startsInsideCollide = parseInt(-1);
      });
    }(), function () {
      var t = e.Common.b2Color, i = (e.Common.b2internal, e.Common.b2Settings), n = (e.Common.Math.b2Mat22, e.Common.Math.b2Mat33, e.Common.Math.b2Math);
      e.Common.Math.b2Sweep, e.Common.Math.b2Transform, e.Common.Math.b2Vec2, e.Common.Math.b2Vec3;
      t.b2Color = function () {
        this._r = 0, this._g = 0, this._b = 0;
      }, t.prototype.b2Color = function (t, i, r) {
        void 0 === t && (t = 0), void 0 === i && (i = 0), void 0 === r && (r = 0), this._r = e.parseUInt(255 * n.Clamp(t, 0, 1)), this._g = e.parseUInt(255 * n.Clamp(i, 0, 1)), this._b = e.parseUInt(255 * n.Clamp(r, 0, 1));
      }, t.prototype.Set = function (t, i, r) {
        void 0 === t && (t = 0), void 0 === i && (i = 0), void 0 === r && (r = 0), this._r = e.parseUInt(255 * n.Clamp(t, 0, 1)), this._g = e.parseUInt(255 * n.Clamp(i, 0, 1)), this._b = e.parseUInt(255 * n.Clamp(r, 0, 1));
      }, Object.defineProperty(t.prototype, "r", {enumerable: false, configurable: true, set: function (t) {
        void 0 === t && (t = 0), this._r = e.parseUInt(255 * n.Clamp(t, 0, 1));
      }}), Object.defineProperty(t.prototype, "g", {enumerable: false, configurable: true, set: function (t) {
        void 0 === t && (t = 0), this._g = e.parseUInt(255 * n.Clamp(t, 0, 1));
      }}), Object.defineProperty(t.prototype, "b", {enumerable: false, configurable: true, set: function (t) {
        void 0 === t && (t = 0), this._b = e.parseUInt(255 * n.Clamp(t, 0, 1));
      }}), Object.defineProperty(t.prototype, "color", {enumerable: false, configurable: true, get: function () {
        return this._r << 16 | this._g << 8 | this._b;
      }}), i.b2Settings = function () {}, i.b2MixFriction = function (t, e) {
        return void 0 === t && (t = 0), void 0 === e && (e = 0), Math.sqrt(t * e);
      }, i.b2MixRestitution = function (t, e) {
        return void 0 === t && (t = 0), void 0 === e && (e = 0), t > e ? t : e;
      }, i.b2Assert = function (t) {
        if (!t) throw "Assertion Failed";
      }, e.postDefs.push(function () {
        e.Common.b2Settings.VERSION = "2.1alpha", e.Common.b2Settings.USHRT_MAX = 65535, e.Common.b2Settings.b2_pi = Math.PI, e.Common.b2Settings.b2_maxManifoldPoints = 2, e.Common.b2Settings.b2_aabbExtension = 0.1, e.Common.b2Settings.b2_aabbMultiplier = 2, e.Common.b2Settings.b2_polygonRadius = 2 * i.b2_linearSlop, e.Common.b2Settings.b2_linearSlop = 0.005, e.Common.b2Settings.b2_angularSlop = 0.011111111111111112 * i.b2_pi, e.Common.b2Settings.b2_toiSlop = 8 * i.b2_linearSlop, e.Common.b2Settings.b2_maxTOIContactsPerIsland = 32, e.Common.b2Settings.b2_maxTOIJointsPerIsland = 32, e.Common.b2Settings.b2_velocityThreshold = 1, e.Common.b2Settings.b2_maxLinearCorrection = 0.2, e.Common.b2Settings.b2_maxAngularCorrection = 0.044444444444444446 * i.b2_pi, e.Common.b2Settings.b2_maxTranslation = 2, e.Common.b2Settings.b2_maxTranslationSquared = i.b2_maxTranslation * i.b2_maxTranslation, e.Common.b2Settings.b2_maxRotation = 0.5 * i.b2_pi, e.Common.b2Settings.b2_maxRotationSquared = i.b2_maxRotation * i.b2_maxRotation, e.Common.b2Settings.b2_contactBaumgarte = 0.2, e.Common.b2Settings.b2_timeToSleep = 0.5, e.Common.b2Settings.b2_linearSleepTolerance = 0.01, e.Common.b2Settings.b2_angularSleepTolerance = 0.011111111111111112 * i.b2_pi;
      });
    }(), function () {
      e.Collision.b2AABB, e.Common.b2Color, e.Common.b2internal, e.Common.b2Settings;
      var t = e.Common.Math.b2Mat22, i = e.Common.Math.b2Mat33, n = e.Common.Math.b2Math, r = e.Common.Math.b2Sweep, o = e.Common.Math.b2Transform, s = e.Common.Math.b2Vec2, a = e.Common.Math.b2Vec3;
      t.b2Mat22 = function () {
        this.col1 = new s, this.col2 = new s;
      }, t.prototype.b2Mat22 = function () {
        this.SetIdentity();
      }, t.FromAngle = function (e) {
        void 0 === e && (e = 0);
        var i = new t;
        return i.Set(e), i;
      }, t.FromVV = function (e, i) {
        var n = new t;
        return n.SetVV(e, i), n;
      }, t.prototype.Set = function (t) {
        void 0 === t && (t = 0);
        var e = Math.cos(t), i = Math.sin(t);
        this.col1.x = e, this.col2.x = -i, this.col1.y = i, this.col2.y = e;
      }, t.prototype.SetVV = function (t, e) {
        this.col1.SetV(t), this.col2.SetV(e);
      }, t.prototype.Copy = function () {
        var e = new t;
        return e.SetM(this), e;
      }, t.prototype.SetM = function (t) {
        this.col1.SetV(t.col1), this.col2.SetV(t.col2);
      }, t.prototype.AddM = function (t) {
        this.col1.x += t.col1.x, this.col1.y += t.col1.y, this.col2.x += t.col2.x, this.col2.y += t.col2.y;
      }, t.prototype.SetIdentity = function () {
        this.col1.x = 1, this.col2.x = 0, this.col1.y = 0, this.col2.y = 1;
      }, t.prototype.SetZero = function () {
        this.col1.x = 0, this.col2.x = 0, this.col1.y = 0, this.col2.y = 0;
      }, t.prototype.GetAngle = function () {
        return Math.atan2(this.col1.y, this.col1.x);
      }, t.prototype.GetInverse = function (t) {
        var e = this.col1.x, i = this.col2.x, n = this.col1.y, r = this.col2.y, o = e * r - i * n;
        return 0 != o && (o = 1 / o), t.col1.x = o * r, t.col2.x = -o * i, t.col1.y = -o * n, t.col2.y = o * e, t;
      }, t.prototype.Solve = function (t, e, i) {
        void 0 === e && (e = 0), void 0 === i && (i = 0);
        var n = this.col1.x, r = this.col2.x, o = this.col1.y, s = this.col2.y, a = n * s - r * o;
        return 0 != a && (a = 1 / a), t.x = a * (s * e - r * i), t.y = a * (n * i - o * e), t;
      }, t.prototype.Abs = function () {
        this.col1.Abs(), this.col2.Abs();
      }, i.b2Mat33 = function () {
        this.col1 = new a, this.col2 = new a, this.col3 = new a;
      }, i.prototype.b2Mat33 = function (t, e, i) {
        void 0 === t && (t = null), void 0 === e && (e = null), void 0 === i && (i = null), t || e || i ? (this.col1.SetV(t), this.col2.SetV(e), this.col3.SetV(i)) : (this.col1.SetZero(), this.col2.SetZero(), this.col3.SetZero());
      }, i.prototype.SetVVV = function (t, e, i) {
        this.col1.SetV(t), this.col2.SetV(e), this.col3.SetV(i);
      }, i.prototype.Copy = function () {
        return new i(this.col1, this.col2, this.col3);
      }, i.prototype.SetM = function (t) {
        this.col1.SetV(t.col1), this.col2.SetV(t.col2), this.col3.SetV(t.col3);
      }, i.prototype.AddM = function (t) {
        this.col1.x += t.col1.x, this.col1.y += t.col1.y, this.col1.z += t.col1.z, this.col2.x += t.col2.x, this.col2.y += t.col2.y, this.col2.z += t.col2.z, this.col3.x += t.col3.x, this.col3.y += t.col3.y, this.col3.z += t.col3.z;
      }, i.prototype.SetIdentity = function () {
        this.col1.x = 1, this.col2.x = 0, this.col3.x = 0, this.col1.y = 0, this.col2.y = 1, this.col3.y = 0, this.col1.z = 0, this.col2.z = 0, this.col3.z = 1;
      }, i.prototype.SetZero = function () {
        this.col1.x = 0, this.col2.x = 0, this.col3.x = 0, this.col1.y = 0, this.col2.y = 0, this.col3.y = 0, this.col1.z = 0, this.col2.z = 0, this.col3.z = 0;
      }, i.prototype.Solve22 = function (t, e, i) {
        void 0 === e && (e = 0), void 0 === i && (i = 0);
        var n = this.col1.x, r = this.col2.x, o = this.col1.y, s = this.col2.y, a = n * s - r * o;
        return 0 != a && (a = 1 / a), t.x = a * (s * e - r * i), t.y = a * (n * i - o * e), t;
      }, i.prototype.Solve33 = function (t, e, i, n) {
        void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 0);
        var r = this.col1.x, o = this.col1.y, s = this.col1.z, a = this.col2.x, l = this.col2.y, c = this.col2.z, h = this.col3.x, u = this.col3.y, p = this.col3.z, m = r * (l * p - c * u) + o * (c * h - a * p) + s * (a * u - l * h);
        return 0 != m && (m = 1 / m), t.x = m * (e * (l * p - c * u) + i * (c * h - a * p) + n * (a * u - l * h)), t.y = m * (r * (i * p - n * u) + o * (n * h - e * p) + s * (e * u - i * h)), t.z = m * (r * (l * n - c * i) + o * (c * e - a * n) + s * (a * i - l * e)), t;
      }, n.b2Math = function () {}, n.IsValid = function (t) {
        return void 0 === t && (t = 0), isFinite(t);
      }, n.Dot = function (t, e) {
        return t.x * e.x + t.y * e.y;
      }, n.CrossVV = function (t, e) {
        return t.x * e.y - t.y * e.x;
      }, n.CrossVF = function (t, e) {
        return void 0 === e && (e = 0), new s(e * t.y, -e * t.x);
      }, n.CrossFV = function (t, e) {
        return void 0 === t && (t = 0), new s(-t * e.y, t * e.x);
      }, n.MulMV = function (t, e) {
        return new s(t.col1.x * e.x + t.col2.x * e.y, t.col1.y * e.x + t.col2.y * e.y);
      }, n.MulTMV = function (t, e) {
        return new s(n.Dot(e, t.col1), n.Dot(e, t.col2));
      }, n.MulX = function (t, e) {
        var i = n.MulMV(t.R, e);
        return i.x += t.position.x, i.y += t.position.y, i;
      }, n.MulXT = function (t, e) {
        var i = n.SubtractVV(e, t.position), r = i.x * t.R.col1.x + i.y * t.R.col1.y;
        return i.y = i.x * t.R.col2.x + i.y * t.R.col2.y, i.x = r, i;
      }, n.AddVV = function (t, e) {
        return new s(t.x + e.x, t.y + e.y);
      }, n.SubtractVV = function (t, e) {
        return new s(t.x - e.x, t.y - e.y);
      }, n.Distance = function (t, e) {
        var i = t.x - e.x, n = t.y - e.y;
        return Math.sqrt(i * i + n * n);
      }, n.DistanceSquared = function (t, e) {
        var i = t.x - e.x, n = t.y - e.y;
        return i * i + n * n;
      }, n.MulFV = function (t, e) {
        return void 0 === t && (t = 0), new s(t * e.x, t * e.y);
      }, n.AddMM = function (e, i) {
        return t.FromVV(n.AddVV(e.col1, i.col1), n.AddVV(e.col2, i.col2));
      }, n.MulMM = function (e, i) {
        return t.FromVV(n.MulMV(e, i.col1), n.MulMV(e, i.col2));
      }, n.MulTMM = function (e, i) {
        var r = new s(n.Dot(e.col1, i.col1), n.Dot(e.col2, i.col1)), o = new s(n.Dot(e.col1, i.col2), n.Dot(e.col2, i.col2));
        return t.FromVV(r, o);
      }, n.Abs = function (t) {
        return void 0 === t && (t = 0), t > 0 ? t : -t;
      }, n.AbsV = function (t) {
        return new s(n.Abs(t.x), n.Abs(t.y));
      }, n.AbsM = function (e) {
        return t.FromVV(n.AbsV(e.col1), n.AbsV(e.col2));
      }, n.Min = function (t, e) {
        return void 0 === t && (t = 0), void 0 === e && (e = 0), t < e ? t : e;
      }, n.MinV = function (t, e) {
        return new s(n.Min(t.x, e.x), n.Min(t.y, e.y));
      }, n.Max = function (t, e) {
        return void 0 === t && (t = 0), void 0 === e && (e = 0), t > e ? t : e;
      }, n.MaxV = function (t, e) {
        return new s(n.Max(t.x, e.x), n.Max(t.y, e.y));
      }, n.Clamp = function (t, e, i) {
        return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), t < e ? e : t > i ? i : t;
      }, n.ClampV = function (t, e, i) {
        return n.MaxV(e, n.MinV(t, i));
      }, n.Swap = function (t, e) {
        var i = t[0];
        t[0] = e[0], e[0] = i;
      }, n.Random = function () {
        return 2 * Math.random() - 1;
      }, n.RandomRange = function (t, e) {
        void 0 === t && (t = 0), void 0 === e && (e = 0);
        var i = Math.random();
        return i = (e - t) * i + t;
      }, n.NextPowerOfTwo = function (t) {
        return void 0 === t && (t = 0), t |= t >> 1 & 2147483647, t |= t >> 2 & 1073741823, t |= t >> 4 & 268435455, t |= t >> 8 & 16777215, (t |= t >> 16 & 65535) + 1;
      }, n.IsPowerOfTwo = function (t) {
        return void 0 === t && (t = 0), t > 0 && 0 == (t & t - 1);
      }, e.postDefs.push(function () {
        e.Common.Math.b2Math.b2Vec2_zero = new s(0, 0), e.Common.Math.b2Math.b2Mat22_identity = t.FromVV(new s(1, 0), new s(0, 1)), e.Common.Math.b2Math.b2Transform_identity = new o(n.b2Vec2_zero, n.b2Mat22_identity);
      }), r.b2Sweep = function () {
        this.localCenter = new s, this.c0 = new s, this.c = new s;
      }, r.prototype.Set = function (t) {
        this.localCenter.SetV(t.localCenter), this.c0.SetV(t.c0), this.c.SetV(t.c), this.a0 = t.a0, this.a = t.a, this.t0 = t.t0;
      }, r.prototype.Copy = function () {
        var t = new r;
        return t.localCenter.SetV(this.localCenter), t.c0.SetV(this.c0), t.c.SetV(this.c), t.a0 = this.a0, t.a = this.a, t.t0 = this.t0, t;
      }, r.prototype.GetTransform = function (t, e) {
        void 0 === e && (e = 0), t.position.x = (1 - e) * this.c0.x + e * this.c.x, t.position.y = (1 - e) * this.c0.y + e * this.c.y;
        var i = (1 - e) * this.a0 + e * this.a;
        t.R.Set(i);
        var n = t.R;
        t.position.x -= n.col1.x * this.localCenter.x + n.col2.x * this.localCenter.y, t.position.y -= n.col1.y * this.localCenter.x + n.col2.y * this.localCenter.y;
      }, r.prototype.Advance = function (t) {
        if (void 0 === t && (t = 0), this.t0 < t && 1 - this.t0 > Number.MIN_VALUE) {
          var e = (t - this.t0) / (1 - this.t0);
          this.c0.x = (1 - e) * this.c0.x + e * this.c.x, this.c0.y = (1 - e) * this.c0.y + e * this.c.y, this.a0 = (1 - e) * this.a0 + e * this.a, this.t0 = t;
        }
      }, o.b2Transform = function () {
        this.position = new s, this.R = new t;
      }, o.prototype.b2Transform = function (t, e) {
        void 0 === t && (t = null), void 0 === e && (e = null), t && (this.position.SetV(t), this.R.SetM(e));
      }, o.prototype.Initialize = function (t, e) {
        this.position.SetV(t), this.R.SetM(e);
      }, o.prototype.SetIdentity = function () {
        this.position.SetZero(), this.R.SetIdentity();
      }, o.prototype.Set = function (t) {
        this.position.SetV(t.position), this.R.SetM(t.R);
      }, o.prototype.GetAngle = function () {
        return Math.atan2(this.R.col1.y, this.R.col1.x);
      }, s.b2Vec2 = function () {}, s.prototype.b2Vec2 = function (t, e) {
        void 0 === t && (t = 0), void 0 === e && (e = 0), this.x = t, this.y = e;
      }, s.prototype.SetZero = function () {
        this.x = 0, this.y = 0;
      }, s.prototype.Set = function (t, e) {
        void 0 === t && (t = 0), void 0 === e && (e = 0), this.x = t, this.y = e;
      }, s.prototype.SetV = function (t) {
        this.x = t.x, this.y = t.y;
      }, s.prototype.GetNegative = function () {
        return new s(-this.x, -this.y);
      }, s.prototype.NegativeSelf = function () {
        this.x = -this.x, this.y = -this.y;
      }, s.Make = function (t, e) {
        return void 0 === t && (t = 0), void 0 === e && (e = 0), new s(t, e);
      }, s.prototype.Copy = function () {
        return new s(this.x, this.y);
      }, s.prototype.Add = function (t) {
        this.x += t.x, this.y += t.y;
      }, s.prototype.Subtract = function (t) {
        this.x -= t.x, this.y -= t.y;
      }, s.prototype.Multiply = function (t) {
        void 0 === t && (t = 0), this.x *= t, this.y *= t;
      }, s.prototype.MulM = function (t) {
        var e = this.x;
        this.x = t.col1.x * e + t.col2.x * this.y, this.y = t.col1.y * e + t.col2.y * this.y;
      }, s.prototype.MulTM = function (t) {
        var e = n.Dot(this, t.col1);
        this.y = n.Dot(this, t.col2), this.x = e;
      }, s.prototype.CrossVF = function (t) {
        void 0 === t && (t = 0);
        var e = this.x;
        this.x = t * this.y, this.y = -t * e;
      }, s.prototype.CrossFV = function (t) {
        void 0 === t && (t = 0);
        var e = this.x;
        this.x = -t * this.y, this.y = t * e;
      }, s.prototype.MinV = function (t) {
        this.x = this.x < t.x ? this.x : t.x, this.y = this.y < t.y ? this.y : t.y;
      }, s.prototype.MaxV = function (t) {
        this.x = this.x > t.x ? this.x : t.x, this.y = this.y > t.y ? this.y : t.y;
      }, s.prototype.Abs = function () {
        this.x < 0 && (this.x = -this.x), this.y < 0 && (this.y = -this.y);
      }, s.prototype.Length = function () {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      }, s.prototype.LengthSquared = function () {
        return this.x * this.x + this.y * this.y;
      }, s.prototype.Normalize = function () {
        var t = Math.sqrt(this.x * this.x + this.y * this.y);
        if (t < Number.MIN_VALUE) return 0;
        var e = 1 / t;
        return this.x *= e, this.y *= e, t;
      }, s.prototype.IsValid = function () {
        return n.IsValid(this.x) && n.IsValid(this.y);
      }, a.b2Vec3 = function () {}, a.prototype.b2Vec3 = function (t, e, i) {
        void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), this.x = t, this.y = e, this.z = i;
      }, a.prototype.SetZero = function () {
        this.x = this.y = this.z = 0;
      }, a.prototype.Set = function (t, e, i) {
        void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), this.x = t, this.y = e, this.z = i;
      }, a.prototype.SetV = function (t) {
        this.x = t.x, this.y = t.y, this.z = t.z;
      }, a.prototype.GetNegative = function () {
        return new a(-this.x, -this.y, -this.z);
      }, a.prototype.NegativeSelf = function () {
        this.x = -this.x, this.y = -this.y, this.z = -this.z;
      }, a.prototype.Copy = function () {
        return new a(this.x, this.y, this.z);
      }, a.prototype.Add = function (t) {
        this.x += t.x, this.y += t.y, this.z += t.z;
      }, a.prototype.Subtract = function (t) {
        this.x -= t.x, this.y -= t.y, this.z -= t.z;
      }, a.prototype.Multiply = function (t) {
        void 0 === t && (t = 0), this.x *= t, this.y *= t, this.z *= t;
      };
    }(), function () {
      e.Dynamics.Controllers.b2ControllerEdge, e.Common.Math.b2Mat22, e.Common.Math.b2Mat33;
      var t = e.Common.Math.b2Math, i = e.Common.Math.b2Sweep, n = e.Common.Math.b2Transform, r = e.Common.Math.b2Vec2, o = (e.Common.Math.b2Vec3, e.Common.b2Color), s = (e.Common.b2internal, e.Common.b2Settings), a = e.Collision.b2AABB, l = (e.Collision.b2Bound, e.Collision.b2BoundValues, e.Collision.b2Collision, e.Collision.b2ContactID, e.Collision.b2ContactPoint), c = (e.Collision.b2Distance, e.Collision.b2DistanceInput, e.Collision.b2DistanceOutput, e.Collision.b2DistanceProxy, e.Collision.b2DynamicTree, e.Collision.b2DynamicTreeBroadPhase), h = (e.Collision.b2DynamicTreeNode, e.Collision.b2DynamicTreePair, e.Collision.b2Manifold, e.Collision.b2ManifoldPoint, e.Collision.b2Point, e.Collision.b2RayCastInput), u = e.Collision.b2RayCastOutput, p = (e.Collision.b2Segment, e.Collision.b2SeparationFunction, e.Collision.b2Simplex, e.Collision.b2SimplexCache, e.Collision.b2SimplexVertex, e.Collision.b2TimeOfImpact, e.Collision.b2TOIInput, e.Collision.b2WorldManifold, e.Collision.ClipVertex, e.Collision.Features, e.Collision.IBroadPhase, e.Collision.Shapes.b2CircleShape), m = (e.Collision.Shapes.b2EdgeChainDef, e.Collision.Shapes.b2EdgeShape), d = e.Collision.Shapes.b2MassData, _ = e.Collision.Shapes.b2PolygonShape, y = e.Collision.Shapes.b2Shape, g = e.Dynamics.b2Body, x = e.Dynamics.b2BodyDef, v = e.Dynamics.b2ContactFilter, b = e.Dynamics.b2ContactImpulse, w = e.Dynamics.b2ContactListener, S = e.Dynamics.b2ContactManager, M = e.Dynamics.b2DebugDraw, A = e.Dynamics.b2DestructionListener, C = e.Dynamics.b2FilterData, T = e.Dynamics.b2Fixture, E = e.Dynamics.b2FixtureDef, L = e.Dynamics.b2Island, D = e.Dynamics.b2TimeStep, R = e.Dynamics.b2World, B = (e.Dynamics.Contacts.b2CircleContact, e.Dynamics.Contacts.b2Contact), P = (e.Dynamics.Contacts.b2ContactConstraint, e.Dynamics.Contacts.b2ContactConstraintPoint, e.Dynamics.Contacts.b2ContactEdge, e.Dynamics.Contacts.b2ContactFactory), I = (e.Dynamics.Contacts.b2ContactRegister, e.Dynamics.Contacts.b2ContactResult, e.Dynamics.Contacts.b2ContactSolver), V = (e.Dynamics.Contacts.b2EdgeAndCircleContact, e.Dynamics.Contacts.b2NullContact, e.Dynamics.Contacts.b2PolyAndCircleContact, e.Dynamics.Contacts.b2PolyAndEdgeContact, e.Dynamics.Contacts.b2PolygonContact, e.Dynamics.Contacts.b2PositionSolverManifold, e.Dynamics.Controllers.b2Controller, e.Dynamics.Joints.b2DistanceJoint, e.Dynamics.Joints.b2DistanceJointDef, e.Dynamics.Joints.b2FrictionJoint, e.Dynamics.Joints.b2FrictionJointDef, e.Dynamics.Joints.b2GearJoint, e.Dynamics.Joints.b2GearJointDef, e.Dynamics.Joints.b2Jacobian, e.Dynamics.Joints.b2Joint), F = (e.Dynamics.Joints.b2JointDef, e.Dynamics.Joints.b2JointEdge, e.Dynamics.Joints.b2LineJoint, e.Dynamics.Joints.b2LineJointDef, e.Dynamics.Joints.b2MouseJoint, e.Dynamics.Joints.b2MouseJointDef, e.Dynamics.Joints.b2PrismaticJoint, e.Dynamics.Joints.b2PrismaticJointDef, e.Dynamics.Joints.b2PulleyJoint);
      e.Dynamics.Joints.b2PulleyJointDef, e.Dynamics.Joints.b2RevoluteJoint, e.Dynamics.Joints.b2RevoluteJointDef, e.Dynamics.Joints.b2WeldJoint, e.Dynamics.Joints.b2WeldJointDef;
      g.b2Body = function () {
        this.m_xf = new n, this.m_sweep = new i, this.m_linearVelocity = new r, this.m_force = new r;
      }, g.prototype.connectEdges = function (e, i, n) {
        void 0 === n && (n = 0);
        var r = Math.atan2(i.GetDirectionVector().y, i.GetDirectionVector().x), o = Math.tan(0.5 * (r - n)), a = t.MulFV(o, i.GetDirectionVector());
        a = t.SubtractVV(a, i.GetNormalVector()), a = t.MulFV(s.b2_toiSlop, a), a = t.AddVV(a, i.GetVertex1());
        var l = t.AddVV(e.GetDirectionVector(), i.GetDirectionVector());
        l.Normalize();
        var c = t.Dot(e.GetDirectionVector(), i.GetNormalVector()) > 0;
        return e.SetNextEdge(i, a, l, c), i.SetPrevEdge(e, a, l, c), r;
      }, g.prototype.CreateFixture = function (t) {
        if (1 == this.m_world.IsLocked()) return null;
        var e = new T;
        if (e.Create(this, this.m_xf, t), this.m_flags & g.e_activeFlag) {
          var i = this.m_world.m_contactManager.m_broadPhase;
          e.CreateProxy(i, this.m_xf);
        }
        return e.m_next = this.m_fixtureList, this.m_fixtureList = e, ++this.m_fixtureCount, e.m_body = this, e.m_density > 0 && this.ResetMassData(), this.m_world.m_flags |= R.e_newFixture, e;
      }, g.prototype.CreateFixture2 = function (t, e) {
        void 0 === e && (e = 0);
        var i = new E;
        return i.shape = t, i.density = e, this.CreateFixture(i);
      }, g.prototype.DestroyFixture = function (t) {
        if (1 != this.m_world.IsLocked()) {
          for (var e = this.m_fixtureList, i = null; null != e;) {
            if (e == t) {
              i ? i.m_next = t.m_next : this.m_fixtureList = t.m_next, true;
              break;
            }
            i = e, e = e.m_next;
          }
          for (var n = this.m_contactList; n;) {
            var r = n.contact;
            n = n.next;
            var o = r.GetFixtureA(), s = r.GetFixtureB();
            t != o && t != s || this.m_world.m_contactManager.Destroy(r);
          }
          if (this.m_flags & g.e_activeFlag) {
            var a = this.m_world.m_contactManager.m_broadPhase;
            t.DestroyProxy(a);
          }
          t.Destroy(), t.m_body = null, t.m_next = null, --this.m_fixtureCount, this.ResetMassData();
        }
      }, g.prototype.SetPositionAndAngle = function (t, e) {
        var i;
        if (void 0 === e && (e = 0), 1 != this.m_world.IsLocked()) {
          this.m_xf.R.Set(e), this.m_xf.position.SetV(t);
          var n = this.m_xf.R, r = this.m_sweep.localCenter;
          this.m_sweep.c.x = n.col1.x * r.x + n.col2.x * r.y, this.m_sweep.c.y = n.col1.y * r.x + n.col2.y * r.y, this.m_sweep.c.x += this.m_xf.position.x, this.m_sweep.c.y += this.m_xf.position.y, this.m_sweep.c0.SetV(this.m_sweep.c), this.m_sweep.a0 = this.m_sweep.a = e;
          var o = this.m_world.m_contactManager.m_broadPhase;
          for (i = this.m_fixtureList; i; i = i.m_next) i.Synchronize(o, this.m_xf, this.m_xf);
          this.m_world.m_contactManager.FindNewContacts();
        }
      }, g.prototype.SetTransform = function (t) {
        this.SetPositionAndAngle(t.position, t.GetAngle());
      }, g.prototype.GetTransform = function () {
        return this.m_xf;
      }, g.prototype.GetPosition = function () {
        return this.m_xf.position;
      }, g.prototype.SetPosition = function (t) {
        this.SetPositionAndAngle(t, this.GetAngle());
      }, g.prototype.GetAngle = function () {
        return this.m_sweep.a;
      }, g.prototype.SetAngle = function (t) {
        void 0 === t && (t = 0), this.SetPositionAndAngle(this.GetPosition(), t);
      }, g.prototype.GetWorldCenter = function () {
        return this.m_sweep.c;
      }, g.prototype.GetLocalCenter = function () {
        return this.m_sweep.localCenter;
      }, g.prototype.SetLinearVelocity = function (t) {
        this.m_type != g.b2_staticBody && this.m_linearVelocity.SetV(t);
      }, g.prototype.GetLinearVelocity = function () {
        return this.m_linearVelocity;
      }, g.prototype.SetAngularVelocity = function (t) {
        void 0 === t && (t = 0), this.m_type != g.b2_staticBody && (this.m_angularVelocity = t);
      }, g.prototype.GetAngularVelocity = function () {
        return this.m_angularVelocity;
      }, g.prototype.GetDefinition = function () {
        var t = new x;
        return t.type = this.GetType(), t.allowSleep = (this.m_flags & g.e_allowSleepFlag) == g.e_allowSleepFlag, t.angle = this.GetAngle(), t.angularDamping = this.m_angularDamping, t.angularVelocity = this.m_angularVelocity, t.fixedRotation = (this.m_flags & g.e_fixedRotationFlag) == g.e_fixedRotationFlag, t.bullet = (this.m_flags & g.e_bulletFlag) == g.e_bulletFlag, t.awake = (this.m_flags & g.e_awakeFlag) == g.e_awakeFlag, t.linearDamping = this.m_linearDamping, t.linearVelocity.SetV(this.GetLinearVelocity()), t.position = this.GetPosition(), t.userData = this.GetUserData(), t;
      }, g.prototype.ApplyForce = function (t, e) {
        this.m_type == g.b2_dynamicBody && (0 == this.IsAwake() && this.SetAwake(true), this.m_force.x += t.x, this.m_force.y += t.y, this.m_torque += (e.x - this.m_sweep.c.x) * t.y - (e.y - this.m_sweep.c.y) * t.x);
      }, g.prototype.ApplyTorque = function (t) {
        void 0 === t && (t = 0), this.m_type == g.b2_dynamicBody && (0 == this.IsAwake() && this.SetAwake(true), this.m_torque += t);
      }, g.prototype.ApplyImpulse = function (t, e) {
        this.m_type == g.b2_dynamicBody && (0 == this.IsAwake() && this.SetAwake(true), this.m_linearVelocity.x += this.m_invMass * t.x, this.m_linearVelocity.y += this.m_invMass * t.y, this.m_angularVelocity += this.m_invI * ((e.x - this.m_sweep.c.x) * t.y - (e.y - this.m_sweep.c.y) * t.x));
      }, g.prototype.Split = function (e) {
        for (var i, n = this.GetLinearVelocity().Copy(), r = this.GetAngularVelocity(), o = this.GetWorldCenter(), s = this, a = this.m_world.CreateBody(this.GetDefinition()), l = s.m_fixtureList; l;) if (e(l)) {
          var c = l.m_next;
          i ? i.m_next = c : s.m_fixtureList = c, s.m_fixtureCount--, l.m_next = a.m_fixtureList, a.m_fixtureList = l, a.m_fixtureCount++, l.m_body = a, l = c;
        } else i = l, l = l.m_next;
        s.ResetMassData(), a.ResetMassData();
        var h = s.GetWorldCenter(), u = a.GetWorldCenter(), p = t.AddVV(n, t.CrossFV(r, t.SubtractVV(h, o))), m = t.AddVV(n, t.CrossFV(r, t.SubtractVV(u, o)));
        return s.SetLinearVelocity(p), a.SetLinearVelocity(m), s.SetAngularVelocity(r), a.SetAngularVelocity(r), s.SynchronizeFixtures(), a.SynchronizeFixtures(), a;
      }, g.prototype.Merge = function (t) {
        var e;
        for (e = t.m_fixtureList; e;) {
          var i = e.m_next;
          t.m_fixtureCount--, e.m_next = this.m_fixtureList, this.m_fixtureList = e, this.m_fixtureCount++, e.m_body = r, e = i;
        }
        n.m_fixtureCount = 0;
        var n = this, r = t;
        n.GetWorldCenter(), r.GetWorldCenter(), n.GetLinearVelocity().Copy(), r.GetLinearVelocity().Copy(), n.GetAngularVelocity(), r.GetAngularVelocity();
        n.ResetMassData(), this.SynchronizeFixtures();
      }, g.prototype.GetMass = function () {
        return this.m_mass;
      }, g.prototype.GetInertia = function () {
        return this.m_I;
      }, g.prototype.GetMassData = function (t) {
        t.mass = this.m_mass, t.I = this.m_I, t.center.SetV(this.m_sweep.localCenter);
      }, g.prototype.SetMassData = function (e) {
        if (s.b2Assert(0 == this.m_world.IsLocked()), 1 != this.m_world.IsLocked() && this.m_type == g.b2_dynamicBody) {
          this.m_invMass = 0, this.m_I = 0, this.m_invI = 0, this.m_mass = e.mass, this.m_mass <= 0 && (this.m_mass = 1), this.m_invMass = 1 / this.m_mass, e.I > 0 && 0 == (this.m_flags & g.e_fixedRotationFlag) && (this.m_I = e.I - this.m_mass * (e.center.x * e.center.x + e.center.y * e.center.y), this.m_invI = 1 / this.m_I);
          var i = this.m_sweep.c.Copy();
          this.m_sweep.localCenter.SetV(e.center), this.m_sweep.c0.SetV(t.MulX(this.m_xf, this.m_sweep.localCenter)), this.m_sweep.c.SetV(this.m_sweep.c0), this.m_linearVelocity.x += this.m_angularVelocity * -(this.m_sweep.c.y - i.y), this.m_linearVelocity.y += this.m_angularVelocity * +(this.m_sweep.c.x - i.x);
        }
      }, g.prototype.ResetMassData = function () {
        if (this.m_mass = 0, this.m_invMass = 0, this.m_I = 0, this.m_invI = 0, this.m_sweep.localCenter.SetZero(), this.m_type != g.b2_staticBody && this.m_type != g.b2_kinematicBody) {
          for (var e = r.Make(0, 0), i = this.m_fixtureList; i; i = i.m_next) if (0 != i.m_density) {
            var n = i.GetMassData();
            this.m_mass += n.mass, e.x += n.center.x * n.mass, e.y += n.center.y * n.mass, this.m_I += n.I;
          }
          this.m_mass > 0 ? (this.m_invMass = 1 / this.m_mass, e.x *= this.m_invMass, e.y *= this.m_invMass) : (this.m_mass = 1, this.m_invMass = 1), this.m_I > 0 && 0 == (this.m_flags & g.e_fixedRotationFlag) ? (this.m_I -= this.m_mass * (e.x * e.x + e.y * e.y), this.m_I *= this.m_inertiaScale, s.b2Assert(this.m_I > 0), this.m_invI = 1 / this.m_I) : (this.m_I = 0, this.m_invI = 0);
          var o = this.m_sweep.c.Copy();
          this.m_sweep.localCenter.SetV(e), this.m_sweep.c0.SetV(t.MulX(this.m_xf, this.m_sweep.localCenter)), this.m_sweep.c.SetV(this.m_sweep.c0), this.m_linearVelocity.x += this.m_angularVelocity * -(this.m_sweep.c.y - o.y), this.m_linearVelocity.y += this.m_angularVelocity * +(this.m_sweep.c.x - o.x);
        }
      }, g.prototype.GetWorldPoint = function (t) {
        var e = this.m_xf.R, i = new r(e.col1.x * t.x + e.col2.x * t.y, e.col1.y * t.x + e.col2.y * t.y);
        return i.x += this.m_xf.position.x, i.y += this.m_xf.position.y, i;
      }, g.prototype.GetWorldVector = function (e) {
        return t.MulMV(this.m_xf.R, e);
      }, g.prototype.GetLocalPoint = function (e) {
        return t.MulXT(this.m_xf, e);
      }, g.prototype.GetLocalVector = function (e) {
        return t.MulTMV(this.m_xf.R, e);
      }, g.prototype.GetLinearVelocityFromWorldPoint = function (t) {
        return new r(this.m_linearVelocity.x - this.m_angularVelocity * (t.y - this.m_sweep.c.y), this.m_linearVelocity.y + this.m_angularVelocity * (t.x - this.m_sweep.c.x));
      }, g.prototype.GetLinearVelocityFromLocalPoint = function (t) {
        var e = this.m_xf.R, i = new r(e.col1.x * t.x + e.col2.x * t.y, e.col1.y * t.x + e.col2.y * t.y);
        return i.x += this.m_xf.position.x, i.y += this.m_xf.position.y, new r(this.m_linearVelocity.x - this.m_angularVelocity * (i.y - this.m_sweep.c.y), this.m_linearVelocity.y + this.m_angularVelocity * (i.x - this.m_sweep.c.x));
      }, g.prototype.GetLinearDamping = function () {
        return this.m_linearDamping;
      }, g.prototype.SetLinearDamping = function (t) {
        void 0 === t && (t = 0), this.m_linearDamping = t;
      }, g.prototype.GetAngularDamping = function () {
        return this.m_angularDamping;
      }, g.prototype.SetAngularDamping = function (t) {
        void 0 === t && (t = 0), this.m_angularDamping = t;
      }, g.prototype.SetType = function (t) {
        if (void 0 === t && (t = 0), this.m_type != t) {
          this.m_type = t, this.ResetMassData(), this.m_type == g.b2_staticBody && (this.m_linearVelocity.SetZero(), this.m_angularVelocity = 0), this.SetAwake(true), this.m_force.SetZero(), this.m_torque = 0;
          for (var e = this.m_contactList; e; e = e.next) e.contact.FlagForFiltering();
        }
      }, g.prototype.GetType = function () {
        return this.m_type;
      }, g.prototype.SetBullet = function (t) {
        t ? this.m_flags |= g.e_bulletFlag : this.m_flags &= ~g.e_bulletFlag;
      }, g.prototype.IsBullet = function () {
        return (this.m_flags & g.e_bulletFlag) == g.e_bulletFlag;
      }, g.prototype.SetSleepingAllowed = function (t) {
        t ? this.m_flags |= g.e_allowSleepFlag : (this.m_flags &= ~g.e_allowSleepFlag, this.SetAwake(true));
      }, g.prototype.SetAwake = function (t) {
        t ? (this.m_flags |= g.e_awakeFlag, this.m_sleepTime = 0) : (this.m_flags &= ~g.e_awakeFlag, this.m_sleepTime = 0, this.m_linearVelocity.SetZero(), this.m_angularVelocity = 0, this.m_force.SetZero(), this.m_torque = 0);
      }, g.prototype.IsAwake = function () {
        return (this.m_flags & g.e_awakeFlag) == g.e_awakeFlag;
      }, g.prototype.SetFixedRotation = function (t) {
        t ? this.m_flags |= g.e_fixedRotationFlag : this.m_flags &= ~g.e_fixedRotationFlag, this.ResetMassData();
      }, g.prototype.IsFixedRotation = function () {
        return (this.m_flags & g.e_fixedRotationFlag) == g.e_fixedRotationFlag;
      }, g.prototype.SetActive = function (t) {
        var e, i;
        if (t != this.IsActive()) if (t) for (this.m_flags |= g.e_activeFlag, e = this.m_world.m_contactManager.m_broadPhase, i = this.m_fixtureList; i; i = i.m_next) i.CreateProxy(e, this.m_xf); else {
          for (this.m_flags &= ~g.e_activeFlag, e = this.m_world.m_contactManager.m_broadPhase, i = this.m_fixtureList; i; i = i.m_next) i.DestroyProxy(e);
          for (var n = this.m_contactList; n;) {
            var r = n;
            n = n.next, this.m_world.m_contactManager.Destroy(r.contact);
          }
          this.m_contactList = null;
        }
      }, g.prototype.IsActive = function () {
        return (this.m_flags & g.e_activeFlag) == g.e_activeFlag;
      }, g.prototype.IsSleepingAllowed = function () {
        return (this.m_flags & g.e_allowSleepFlag) == g.e_allowSleepFlag;
      }, g.prototype.GetFixtureList = function () {
        return this.m_fixtureList;
      }, g.prototype.GetJointList = function () {
        return this.m_jointList;
      }, g.prototype.GetControllerList = function () {
        return this.m_controllerList;
      }, g.prototype.GetContactList = function () {
        return this.m_contactList;
      }, g.prototype.GetNext = function () {
        return this.m_next;
      }, g.prototype.GetUserData = function () {
        return this.m_userData;
      }, g.prototype.SetUserData = function (t) {
        this.m_userData = t;
      }, g.prototype.GetWorld = function () {
        return this.m_world;
      }, g.prototype.b2Body = function (t, e) {
        this.m_flags = 0, t.bullet && (this.m_flags |= g.e_bulletFlag), t.fixedRotation && (this.m_flags |= g.e_fixedRotationFlag), t.allowSleep && (this.m_flags |= g.e_allowSleepFlag), t.awake && (this.m_flags |= g.e_awakeFlag), t.active && (this.m_flags |= g.e_activeFlag), this.m_world = e, this.m_xf.position.SetV(t.position), this.m_xf.R.Set(t.angle), this.m_sweep.localCenter.SetZero(), this.m_sweep.t0 = 1, this.m_sweep.a0 = this.m_sweep.a = t.angle;
        var i = this.m_xf.R, n = this.m_sweep.localCenter;
        this.m_sweep.c.x = i.col1.x * n.x + i.col2.x * n.y, this.m_sweep.c.y = i.col1.y * n.x + i.col2.y * n.y, this.m_sweep.c.x += this.m_xf.position.x, this.m_sweep.c.y += this.m_xf.position.y, this.m_sweep.c0.SetV(this.m_sweep.c), this.m_jointList = null, this.m_controllerList = null, this.m_contactList = null, this.m_controllerCount = 0, this.m_prev = null, this.m_next = null, this.m_linearVelocity.SetV(t.linearVelocity), this.m_angularVelocity = t.angularVelocity, this.m_linearDamping = t.linearDamping, this.m_angularDamping = t.angularDamping, this.m_force.Set(0, 0), this.m_torque = 0, this.m_sleepTime = 0, this.m_type = t.type, this.m_type == g.b2_dynamicBody ? (this.m_mass = 1, this.m_invMass = 1) : (this.m_mass = 0, this.m_invMass = 0), this.m_I = 0, this.m_invI = 0, this.m_inertiaScale = t.inertiaScale, this.m_userData = t.userData, this.m_fixtureList = null, this.m_fixtureCount = 0;
      }, g.prototype.SynchronizeFixtures = function () {
        var t = g.s_xf1;
        t.R.Set(this.m_sweep.a0);
        var e, i = t.R, n = this.m_sweep.localCenter;
        t.position.x = this.m_sweep.c0.x - (i.col1.x * n.x + i.col2.x * n.y), t.position.y = this.m_sweep.c0.y - (i.col1.y * n.x + i.col2.y * n.y);
        var r = this.m_world.m_contactManager.m_broadPhase;
        for (e = this.m_fixtureList; e; e = e.m_next) e.Synchronize(r, t, this.m_xf);
      }, g.prototype.SynchronizeTransform = function () {
        this.m_xf.R.Set(this.m_sweep.a);
        var t = this.m_xf.R, e = this.m_sweep.localCenter;
        this.m_xf.position.x = this.m_sweep.c.x - (t.col1.x * e.x + t.col2.x * e.y), this.m_xf.position.y = this.m_sweep.c.y - (t.col1.y * e.x + t.col2.y * e.y);
      }, g.prototype.ShouldCollide = function (t) {
        if (this.m_type != g.b2_dynamicBody && t.m_type != g.b2_dynamicBody) return false;
        for (var e = this.m_jointList; e; e = e.next) if (e.other == t && 0 == e.joint.m_collideConnected) return false;
        return true;
      }, g.prototype.Advance = function (t) {
        void 0 === t && (t = 0), this.m_sweep.Advance(t), this.m_sweep.c.SetV(this.m_sweep.c0), this.m_sweep.a = this.m_sweep.a0, this.SynchronizeTransform();
      }, e.postDefs.push(function () {
        e.Dynamics.b2Body.s_xf1 = new n, e.Dynamics.b2Body.e_islandFlag = 1, e.Dynamics.b2Body.e_awakeFlag = 2, e.Dynamics.b2Body.e_allowSleepFlag = 4, e.Dynamics.b2Body.e_bulletFlag = 8, e.Dynamics.b2Body.e_fixedRotationFlag = 16, e.Dynamics.b2Body.e_activeFlag = 32, e.Dynamics.b2Body.b2_staticBody = 0, e.Dynamics.b2Body.b2_kinematicBody = 1, e.Dynamics.b2Body.b2_dynamicBody = 2;
      }), x.b2BodyDef = function () {
        this.position = new r, this.linearVelocity = new r;
      }, x.prototype.b2BodyDef = function () {
        this.userData = null, this.position.Set(0, 0), this.angle = 0, this.linearVelocity.Set(0, 0), this.angularVelocity = 0, this.linearDamping = 0, this.angularDamping = 0, this.allowSleep = true, this.awake = true, this.fixedRotation = false, this.bullet = false, this.type = g.b2_staticBody, this.active = true, this.inertiaScale = 1;
      }, v.b2ContactFilter = function () {}, v.prototype.ShouldCollide = function (t, e) {
        var i = t.GetFilterData(), n = e.GetFilterData();
        return i.groupIndex == n.groupIndex && 0 != i.groupIndex ? i.groupIndex > 0 : 0 != (i.maskBits & n.categoryBits) && 0 != (i.categoryBits & n.maskBits);
      }, v.prototype.RayCollide = function (t, e) {
        return !t || this.ShouldCollide(t instanceof T ? t : null, e);
      }, e.postDefs.push(function () {
        e.Dynamics.b2ContactFilter.b2_defaultFilter = new v;
      }), b.b2ContactImpulse = function () {
        this.normalImpulses = new W(s.b2_maxManifoldPoints), this.tangentImpulses = new W(s.b2_maxManifoldPoints);
      }, w.b2ContactListener = function () {}, w.prototype.BeginContact = function (t) {}, w.prototype.EndContact = function (t) {}, w.prototype.PreSolve = function (t, e) {}, w.prototype.PostSolve = function (t, e) {}, e.postDefs.push(function () {
        e.Dynamics.b2ContactListener.b2_defaultListener = new w;
      }), S.b2ContactManager = function () {}, S.prototype.b2ContactManager = function () {
        this.m_world = null, this.m_contactCount = 0, this.m_contactFilter = v.b2_defaultFilter, this.m_contactListener = w.b2_defaultListener, this.m_contactFactory = new P(this.m_allocator), this.m_broadPhase = new c;
      }, S.prototype.AddPair = function (t, e) {
        var i = t instanceof T ? t : null, n = e instanceof T ? e : null, r = i.GetBody(), o = n.GetBody();
        if (r != o) {
          for (var s = o.GetContactList(); s;) {
            if (s.other == r) {
              var a = s.contact.GetFixtureA(), l = s.contact.GetFixtureB();
              if (a == i && l == n) return;
              if (a == n && l == i) return;
            }
            s = s.next;
          }
          if (0 != o.ShouldCollide(r) && 0 != this.m_contactFilter.ShouldCollide(i, n)) {
            var c = this.m_contactFactory.Create(i, n);
            i = c.GetFixtureA(), n = c.GetFixtureB(), r = i.m_body, o = n.m_body, c.m_prev = null, c.m_next = this.m_world.m_contactList, null != this.m_world.m_contactList && (this.m_world.m_contactList.m_prev = c), this.m_world.m_contactList = c, c.m_nodeA.contact = c, c.m_nodeA.other = o, c.m_nodeA.prev = null, c.m_nodeA.next = r.m_contactList, null != r.m_contactList && (r.m_contactList.prev = c.m_nodeA), r.m_contactList = c.m_nodeA, c.m_nodeB.contact = c, c.m_nodeB.other = r, c.m_nodeB.prev = null, c.m_nodeB.next = o.m_contactList, null != o.m_contactList && (o.m_contactList.prev = c.m_nodeB), o.m_contactList = c.m_nodeB, ++this.m_world.m_contactCount;
          }
        }
      }, S.prototype.FindNewContacts = function () {
        this.m_broadPhase.UpdatePairs(e.generateCallback(this, this.AddPair));
      }, S.prototype.Destroy = function (t) {
        var e = t.GetFixtureA(), i = t.GetFixtureB(), n = e.GetBody(), r = i.GetBody();
        t.IsTouching() && this.m_contactListener.EndContact(t), t.m_prev && (t.m_prev.m_next = t.m_next), t.m_next && (t.m_next.m_prev = t.m_prev), t == this.m_world.m_contactList && (this.m_world.m_contactList = t.m_next), t.m_nodeA.prev && (t.m_nodeA.prev.next = t.m_nodeA.next), t.m_nodeA.next && (t.m_nodeA.next.prev = t.m_nodeA.prev), t.m_nodeA == n.m_contactList && (n.m_contactList = t.m_nodeA.next), t.m_nodeB.prev && (t.m_nodeB.prev.next = t.m_nodeB.next), t.m_nodeB.next && (t.m_nodeB.next.prev = t.m_nodeB.prev), t.m_nodeB == r.m_contactList && (r.m_contactList = t.m_nodeB.next), this.m_contactFactory.Destroy(t), --this.m_contactCount;
      }, S.prototype.Collide = function () {
        for (var t = this.m_world.m_contactList; t;) {
          var e = t.GetFixtureA(), i = t.GetFixtureB(), n = e.GetBody(), r = i.GetBody();
          if (0 != n.IsAwake() || 0 != r.IsAwake()) {
            if (t.m_flags & B.e_filterFlag) {
              if (0 == r.ShouldCollide(n)) {
                var o = t;
                t = o.GetNext(), this.Destroy(o);
                continue;
              }
              if (0 == this.m_contactFilter.ShouldCollide(e, i)) {
                t = (o = t).GetNext(), this.Destroy(o);
                continue;
              }
              t.m_flags &= ~B.e_filterFlag;
            }
            var s = e.m_proxy, a = i.m_proxy;
            0 != this.m_broadPhase.TestOverlap(s, a) ? (t.Update(this.m_contactListener), t = t.GetNext()) : (t = (o = t).GetNext(), this.Destroy(o));
          } else t = t.GetNext();
        }
      }, e.postDefs.push(function () {
        e.Dynamics.b2ContactManager.s_evalCP = new l;
      }), M.b2DebugDraw = function () {}, M.prototype.b2DebugDraw = function () {}, M.prototype.SetFlags = function (t) {
        void 0 === t && (t = 0);
      }, M.prototype.GetFlags = function () {}, M.prototype.AppendFlags = function (t) {
        void 0 === t && (t = 0);
      }, M.prototype.ClearFlags = function (t) {
        void 0 === t && (t = 0);
      }, M.prototype.SetSprite = function (t) {}, M.prototype.GetSprite = function () {}, M.prototype.SetDrawScale = function (t) {
        void 0 === t && (t = 0);
      }, M.prototype.GetDrawScale = function () {}, M.prototype.SetLineThickness = function (t) {
        void 0 === t && (t = 0);
      }, M.prototype.GetLineThickness = function () {}, M.prototype.SetAlpha = function (t) {
        void 0 === t && (t = 0);
      }, M.prototype.GetAlpha = function () {}, M.prototype.SetFillAlpha = function (t) {
        void 0 === t && (t = 0);
      }, M.prototype.GetFillAlpha = function () {}, M.prototype.SetXFormScale = function (t) {
        void 0 === t && (t = 0);
      }, M.prototype.GetXFormScale = function () {}, M.prototype.DrawPolygon = function (t, e, i) {
        void 0 === e && (e = 0);
      }, M.prototype.DrawSolidPolygon = function (t, e, i) {
        void 0 === e && (e = 0);
      }, M.prototype.DrawCircle = function (t, e, i) {
        void 0 === e && (e = 0);
      }, M.prototype.DrawSolidCircle = function (t, e, i, n) {
        void 0 === e && (e = 0);
      }, M.prototype.DrawSegment = function (t, e, i) {}, M.prototype.DrawTransform = function (t) {}, e.postDefs.push(function () {
        e.Dynamics.b2DebugDraw.e_shapeBit = 1, e.Dynamics.b2DebugDraw.e_jointBit = 2, e.Dynamics.b2DebugDraw.e_aabbBit = 4, e.Dynamics.b2DebugDraw.e_pairBit = 8, e.Dynamics.b2DebugDraw.e_centerOfMassBit = 16, e.Dynamics.b2DebugDraw.e_controllerBit = 32;
      }), A.b2DestructionListener = function () {}, A.prototype.SayGoodbyeJoint = function (t) {}, A.prototype.SayGoodbyeFixture = function (t) {}, C.b2FilterData = function () {
        this.categoryBits = 1, this.maskBits = 65535, this.groupIndex = 0;
      }, C.prototype.Copy = function () {
        var t = new C;
        return t.categoryBits = this.categoryBits, t.maskBits = this.maskBits, t.groupIndex = this.groupIndex, t;
      }, T.b2Fixture = function () {
        this.m_filter = new C;
      }, T.prototype.GetType = function () {
        return this.m_shape.GetType();
      }, T.prototype.GetShape = function () {
        return this.m_shape;
      }, T.prototype.SetSensor = function (t) {
        if (this.m_isSensor != t && (this.m_isSensor = t, null != this.m_body)) for (var e = this.m_body.GetContactList(); e;) {
          var i = e.contact, n = i.GetFixtureA(), r = i.GetFixtureB();
          n != this && r != this || i.SetSensor(n.IsSensor() || r.IsSensor()), e = e.next;
        }
      }, T.prototype.IsSensor = function () {
        return this.m_isSensor;
      }, T.prototype.SetFilterData = function (t) {
        if (this.m_filter = t.Copy(), !this.m_body) for (var e = this.m_body.GetContactList(); e;) {
          var i = e.contact, n = i.GetFixtureA(), r = i.GetFixtureB();
          n != this && r != this || i.FlagForFiltering(), e = e.next;
        }
      }, T.prototype.GetFilterData = function () {
        return this.m_filter.Copy();
      }, T.prototype.GetBody = function () {
        return this.m_body;
      }, T.prototype.GetNext = function () {
        return this.m_next;
      }, T.prototype.GetUserData = function () {
        return this.m_userData;
      }, T.prototype.SetUserData = function (t) {
        this.m_userData = t;
      }, T.prototype.TestPoint = function (t) {
        return this.m_shape.TestPoint(this.m_body.GetTransform(), t);
      }, T.prototype.RayCast = function (t, e) {
        return this.m_shape.RayCast(t, e, this.m_body.GetTransform());
      }, T.prototype.GetMassData = function (t) {
        return void 0 === t && (t = null), null == t && (t = new d), this.m_shape.ComputeMass(t, this.m_density), t;
      }, T.prototype.SetDensity = function (t) {
        void 0 === t && (t = 0), this.m_density = t;
      }, T.prototype.GetDensity = function () {
        return this.m_density;
      }, T.prototype.GetFriction = function () {
        return this.m_friction;
      }, T.prototype.SetFriction = function (t) {
        void 0 === t && (t = 0), this.m_friction = t;
      }, T.prototype.GetRestitution = function () {
        return this.m_restitution;
      }, T.prototype.SetRestitution = function (t) {
        void 0 === t && (t = 0), this.m_restitution = t;
      }, T.prototype.GetAABB = function () {
        return this.m_aabb;
      }, T.prototype.b2Fixture = function () {
        this.m_aabb = new a, this.m_userData = null, this.m_body = null, this.m_next = null, this.m_shape = null, this.m_density = 0, this.m_friction = 0, this.m_restitution = 0;
      }, T.prototype.Create = function (t, e, i) {
        this.m_userData = i.userData, this.m_friction = i.friction, this.m_restitution = i.restitution, this.m_body = t, this.m_next = null, this.m_filter = i.filter.Copy(), this.m_isSensor = i.isSensor, this.m_shape = i.shape.Copy(), this.m_density = i.density;
      }, T.prototype.Destroy = function () {
        this.m_shape = null;
      }, T.prototype.CreateProxy = function (t, e) {
        this.m_shape.ComputeAABB(this.m_aabb, e), this.m_proxy = t.CreateProxy(this.m_aabb, this);
      }, T.prototype.DestroyProxy = function (t) {
        null != this.m_proxy && (t.DestroyProxy(this.m_proxy), this.m_proxy = null);
      }, T.prototype.Synchronize = function (e, i, n) {
        if (this.m_proxy) {
          var r = new a, o = new a;
          this.m_shape.ComputeAABB(r, i), this.m_shape.ComputeAABB(o, n), this.m_aabb.Combine(r, o);
          var s = t.SubtractVV(n.position, i.position);
          e.MoveProxy(this.m_proxy, this.m_aabb, s);
        }
      }, E.b2FixtureDef = function () {
        this.filter = new C;
      }, E.prototype.b2FixtureDef = function () {
        this.shape = null, this.userData = null, this.friction = 0.2, this.restitution = 0, this.density = 0, this.filter.categoryBits = 1, this.filter.maskBits = 65535, this.filter.groupIndex = 0, this.isSensor = false;
      }, L.b2Island = function () {}, L.prototype.b2Island = function () {
        this.m_bodies = new H, this.m_contacts = new H, this.m_joints = new H;
      }, L.prototype.Initialize = function (t, e, i, n, r, o) {
        void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0);
        var s = 0;
        for (this.m_bodyCapacity = t, this.m_contactCapacity = e, this.m_jointCapacity = i, this.m_bodyCount = 0, this.m_contactCount = 0, this.m_jointCount = 0, this.m_allocator = n, this.m_listener = r, this.m_contactSolver = o, s = this.m_bodies.length; s < t; s++) this.m_bodies[s] = null;
        for (s = this.m_contacts.length; s < e; s++) this.m_contacts[s] = null;
        for (s = this.m_joints.length; s < i; s++) this.m_joints[s] = null;
      }, L.prototype.Clear = function () {
        this.m_bodyCount = 0, this.m_contactCount = 0, this.m_jointCount = 0;
      }, L.prototype.Solve = function (e, i, n) {
        var r, o = 0, a = 0;
        for (o = 0; o < this.m_bodyCount; ++o) (r = this.m_bodies[o]).GetType() == g.b2_dynamicBody && (r.m_linearVelocity.x += e.dt * (i.x + r.m_invMass * r.m_force.x), r.m_linearVelocity.y += e.dt * (i.y + r.m_invMass * r.m_force.y), r.m_angularVelocity += e.dt * r.m_invI * r.m_torque, r.m_linearVelocity.Multiply(t.Clamp(1 - e.dt * r.m_linearDamping, 0, 1)), r.m_angularVelocity *= t.Clamp(1 - e.dt * r.m_angularDamping, 0, 1));
        this.m_contactSolver.Initialize(e, this.m_contacts, this.m_contactCount, this.m_allocator);
        var l = this.m_contactSolver;
        for (l.InitVelocityConstraints(e), o = 0; o < this.m_jointCount; ++o) this.m_joints[o].InitVelocityConstraints(e);
        for (o = 0; o < e.velocityIterations; ++o) {
          for (a = 0; a < this.m_jointCount; ++a) this.m_joints[a].SolveVelocityConstraints(e);
          l.SolveVelocityConstraints();
        }
        for (o = 0; o < this.m_jointCount; ++o) this.m_joints[o].FinalizeVelocityConstraints();
        for (l.FinalizeVelocityConstraints(), o = 0; o < this.m_bodyCount; ++o) if ((r = this.m_bodies[o]).GetType() != g.b2_staticBody) {
          var c = e.dt * r.m_linearVelocity.x, h = e.dt * r.m_linearVelocity.y;
          c * c + h * h > s.b2_maxTranslationSquared && (r.m_linearVelocity.Normalize(), r.m_linearVelocity.x *= s.b2_maxTranslation * e.inv_dt, r.m_linearVelocity.y *= s.b2_maxTranslation * e.inv_dt);
          var u = e.dt * r.m_angularVelocity;
          u * u > s.b2_maxRotationSquared && (r.m_angularVelocity < 0 ? r.m_angularVelocity = -s.b2_maxRotation * e.inv_dt : r.m_angularVelocity = s.b2_maxRotation * e.inv_dt), r.m_sweep.c0.SetV(r.m_sweep.c), r.m_sweep.a0 = r.m_sweep.a, r.m_sweep.c.x += e.dt * r.m_linearVelocity.x, r.m_sweep.c.y += e.dt * r.m_linearVelocity.y, r.m_sweep.a += e.dt * r.m_angularVelocity, r.SynchronizeTransform();
        }
        for (o = 0; o < e.positionIterations; ++o) {
          var p = l.SolvePositionConstraints(s.b2_contactBaumgarte), m = true;
          for (a = 0; a < this.m_jointCount; ++a) {
            var d = this.m_joints[a].SolvePositionConstraints(s.b2_contactBaumgarte);
            m = m && d;
          }
          if (p && m) break;
        }
        if (this.Report(l.m_constraints), n) {
          var _ = Number.MAX_VALUE, y = s.b2_linearSleepTolerance * s.b2_linearSleepTolerance, x = s.b2_angularSleepTolerance * s.b2_angularSleepTolerance;
          for (o = 0; o < this.m_bodyCount; ++o) (r = this.m_bodies[o]).GetType() != g.b2_staticBody && (0 == (r.m_flags & g.e_allowSleepFlag) && (r.m_sleepTime = 0, _ = 0), 0 == (r.m_flags & g.e_allowSleepFlag) || r.m_angularVelocity * r.m_angularVelocity > x || t.Dot(r.m_linearVelocity, r.m_linearVelocity) > y ? (r.m_sleepTime = 0, _ = 0) : (r.m_sleepTime += e.dt, _ = t.Min(_, r.m_sleepTime)));
          if (_ >= s.b2_timeToSleep) for (o = 0; o < this.m_bodyCount; ++o) (r = this.m_bodies[o]).SetAwake(false);
        }
      }, L.prototype.SolveTOI = function (t) {
        var e = 0, i = 0;
        this.m_contactSolver.Initialize(t, this.m_contacts, this.m_contactCount, this.m_allocator);
        var n = this.m_contactSolver;
        for (e = 0; e < this.m_jointCount; ++e) this.m_joints[e].InitVelocityConstraints(t);
        for (e = 0; e < t.velocityIterations; ++e) for (n.SolveVelocityConstraints(), i = 0; i < this.m_jointCount; ++i) this.m_joints[i].SolveVelocityConstraints(t);
        for (e = 0; e < this.m_bodyCount; ++e) {
          var r = this.m_bodies[e];
          if (r.GetType() != g.b2_staticBody) {
            var o = t.dt * r.m_linearVelocity.x, a = t.dt * r.m_linearVelocity.y;
            o * o + a * a > s.b2_maxTranslationSquared && (r.m_linearVelocity.Normalize(), r.m_linearVelocity.x *= s.b2_maxTranslation * t.inv_dt, r.m_linearVelocity.y *= s.b2_maxTranslation * t.inv_dt);
            var l = t.dt * r.m_angularVelocity;
            l * l > s.b2_maxRotationSquared && (r.m_angularVelocity < 0 ? r.m_angularVelocity = -s.b2_maxRotation * t.inv_dt : r.m_angularVelocity = s.b2_maxRotation * t.inv_dt), r.m_sweep.c0.SetV(r.m_sweep.c), r.m_sweep.a0 = r.m_sweep.a, r.m_sweep.c.x += t.dt * r.m_linearVelocity.x, r.m_sweep.c.y += t.dt * r.m_linearVelocity.y, r.m_sweep.a += t.dt * r.m_angularVelocity, r.SynchronizeTransform();
          }
        }
        for (e = 0; e < t.positionIterations; ++e) {
          var c = n.SolvePositionConstraints(0.75), h = true;
          for (i = 0; i < this.m_jointCount; ++i) {
            var u = this.m_joints[i].SolvePositionConstraints(s.b2_contactBaumgarte);
            h = h && u;
          }
          if (c && h) break;
        }
        this.Report(n.m_constraints);
      }, L.prototype.Report = function (t) {
        if (null != this.m_listener) for (var e = 0; e < this.m_contactCount; ++e) {
          for (var i = this.m_contacts[e], n = t[e], r = 0; r < n.pointCount; ++r) L.s_impulse.normalImpulses[r] = n.points[r].normalImpulse, L.s_impulse.tangentImpulses[r] = n.points[r].tangentImpulse;
          this.m_listener.PostSolve(i, L.s_impulse);
        }
      }, L.prototype.AddBody = function (t) {
        t.m_islandIndex = this.m_bodyCount, this.m_bodies[this.m_bodyCount++] = t;
      }, L.prototype.AddContact = function (t) {
        this.m_contacts[this.m_contactCount++] = t;
      }, L.prototype.AddJoint = function (t) {
        this.m_joints[this.m_jointCount++] = t;
      }, e.postDefs.push(function () {
        e.Dynamics.b2Island.s_impulse = new b;
      }), D.b2TimeStep = function () {}, D.prototype.Set = function (t) {
        this.dt = t.dt, this.inv_dt = t.inv_dt, this.positionIterations = t.positionIterations, this.velocityIterations = t.velocityIterations, this.warmStarting = t.warmStarting;
      }, R.b2World = function () {
        this.s_stack = new H, this.m_contactManager = new S, this.m_contactSolver = new I, this.m_island = new L;
      }, R.prototype.b2World = function (t, e) {
        this.m_destructionListener = null, this.m_debugDraw = null, this.m_bodyList = null, this.m_contactList = null, this.m_jointList = null, this.m_controllerList = null, this.m_bodyCount = 0, this.m_contactCount = 0, this.m_jointCount = 0, this.m_controllerCount = 0, R.m_warmStarting = true, R.m_continuousPhysics = true, this.m_allowSleep = e, this.m_gravity = t, this.m_inv_dt0 = 0, this.m_contactManager.m_world = this;
        var i = new x;
        this.m_groundBody = this.CreateBody(i);
      }, R.prototype.SetDestructionListener = function (t) {
        this.m_destructionListener = t;
      }, R.prototype.SetContactFilter = function (t) {
        this.m_contactManager.m_contactFilter = t;
      }, R.prototype.SetContactListener = function (t) {
        this.m_contactManager.m_contactListener = t;
      }, R.prototype.SetDebugDraw = function (t) {
        this.m_debugDraw = t;
      }, R.prototype.SetBroadPhase = function (t) {
        var e = this.m_contactManager.m_broadPhase;
        this.m_contactManager.m_broadPhase = t;
        for (var i = this.m_bodyList; i; i = i.m_next) for (var n = i.m_fixtureList; n; n = n.m_next) n.m_proxy = t.CreateProxy(e.GetFatAABB(n.m_proxy), n);
      }, R.prototype.Validate = function () {
        this.m_contactManager.m_broadPhase.Validate();
      }, R.prototype.GetProxyCount = function () {
        return this.m_contactManager.m_broadPhase.GetProxyCount();
      }, R.prototype.CreateBody = function (t) {
        if (1 == this.IsLocked()) return null;
        var e = new g(t, this);
        return e.m_prev = null, e.m_next = this.m_bodyList, this.m_bodyList && (this.m_bodyList.m_prev = e), this.m_bodyList = e, ++this.m_bodyCount, e;
      }, R.prototype.DestroyBody = function (t) {
        if (1 != this.IsLocked()) {
          for (var e = t.m_jointList; e;) {
            var i = e;
            e = e.next, this.m_destructionListener && this.m_destructionListener.SayGoodbyeJoint(i.joint), this.DestroyJoint(i.joint);
          }
          for (var n = t.m_controllerList; n;) {
            var r = n;
            n = n.nextController, r.controller.RemoveBody(t);
          }
          for (var o = t.m_contactList; o;) {
            var s = o;
            o = o.next, this.m_contactManager.Destroy(s.contact);
          }
          t.m_contactList = null;
          for (var a = t.m_fixtureList; a;) {
            var l = a;
            a = a.m_next, this.m_destructionListener && this.m_destructionListener.SayGoodbyeFixture(l), l.DestroyProxy(this.m_contactManager.m_broadPhase), l.Destroy();
          }
          t.m_fixtureList = null, t.m_fixtureCount = 0, t.m_prev && (t.m_prev.m_next = t.m_next), t.m_next && (t.m_next.m_prev = t.m_prev), t == this.m_bodyList && (this.m_bodyList = t.m_next), --this.m_bodyCount;
        }
      }, R.prototype.CreateJoint = function (t) {
        var e = V.Create(t, null);
        e.m_prev = null, e.m_next = this.m_jointList, this.m_jointList && (this.m_jointList.m_prev = e), this.m_jointList = e, ++this.m_jointCount, e.m_edgeA.joint = e, e.m_edgeA.other = e.m_bodyB, e.m_edgeA.prev = null, e.m_edgeA.next = e.m_bodyA.m_jointList, e.m_bodyA.m_jointList && (e.m_bodyA.m_jointList.prev = e.m_edgeA), e.m_bodyA.m_jointList = e.m_edgeA, e.m_edgeB.joint = e, e.m_edgeB.other = e.m_bodyA, e.m_edgeB.prev = null, e.m_edgeB.next = e.m_bodyB.m_jointList, e.m_bodyB.m_jointList && (e.m_bodyB.m_jointList.prev = e.m_edgeB), e.m_bodyB.m_jointList = e.m_edgeB;
        var i = t.bodyA, n = t.bodyB;
        if (0 == t.collideConnected) for (var r = n.GetContactList(); r;) r.other == i && r.contact.FlagForFiltering(), r = r.next;
        return e;
      }, R.prototype.DestroyJoint = function (t) {
        var e = t.m_collideConnected;
        t.m_prev && (t.m_prev.m_next = t.m_next), t.m_next && (t.m_next.m_prev = t.m_prev), t == this.m_jointList && (this.m_jointList = t.m_next);
        var i = t.m_bodyA, n = t.m_bodyB;
        if (i.SetAwake(true), n.SetAwake(true), t.m_edgeA.prev && (t.m_edgeA.prev.next = t.m_edgeA.next), t.m_edgeA.next && (t.m_edgeA.next.prev = t.m_edgeA.prev), t.m_edgeA == i.m_jointList && (i.m_jointList = t.m_edgeA.next), t.m_edgeA.prev = null, t.m_edgeA.next = null, t.m_edgeB.prev && (t.m_edgeB.prev.next = t.m_edgeB.next), t.m_edgeB.next && (t.m_edgeB.next.prev = t.m_edgeB.prev), t.m_edgeB == n.m_jointList && (n.m_jointList = t.m_edgeB.next), t.m_edgeB.prev = null, t.m_edgeB.next = null, V.Destroy(t, null), --this.m_jointCount, 0 == e) for (var r = n.GetContactList(); r;) r.other == i && r.contact.FlagForFiltering(), r = r.next;
      }, R.prototype.AddController = function (t) {
        return t.m_next = this.m_controllerList, t.m_prev = null, this.m_controllerList = t, t.m_world = this, this.m_controllerCount++, t;
      }, R.prototype.RemoveController = function (t) {
        t.m_prev && (t.m_prev.m_next = t.m_next), t.m_next && (t.m_next.m_prev = t.m_prev), this.m_controllerList == t && (this.m_controllerList = t.m_next), this.m_controllerCount--;
      }, R.prototype.CreateController = function (t) {
        if (t.m_world != this) throw new Error("Controller can only be a member of one world");
        return t.m_next = this.m_controllerList, t.m_prev = null, this.m_controllerList && (this.m_controllerList.m_prev = t), this.m_controllerList = t, ++this.m_controllerCount, t.m_world = this, t;
      }, R.prototype.DestroyController = function (t) {
        t.Clear(), t.m_next && (t.m_next.m_prev = t.m_prev), t.m_prev && (t.m_prev.m_next = t.m_next), t == this.m_controllerList && (this.m_controllerList = t.m_next), --this.m_controllerCount;
      }, R.prototype.SetWarmStarting = function (t) {
        R.m_warmStarting = t;
      }, R.prototype.SetContinuousPhysics = function (t) {
        R.m_continuousPhysics = t;
      }, R.prototype.GetBodyCount = function () {
        return this.m_bodyCount;
      }, R.prototype.GetJointCount = function () {
        return this.m_jointCount;
      }, R.prototype.GetContactCount = function () {
        return this.m_contactCount;
      }, R.prototype.SetGravity = function (t) {
        this.m_gravity = t;
      }, R.prototype.GetGravity = function () {
        return this.m_gravity;
      }, R.prototype.GetGroundBody = function () {
        return this.m_groundBody;
      }, R.prototype.Step = function (t, e, i) {
        void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), this.m_flags & R.e_newFixture && (this.m_contactManager.FindNewContacts(), this.m_flags &= ~R.e_newFixture), this.m_flags |= R.e_locked;
        var n = R.s_timestep2;
        n.dt = t, n.velocityIterations = e, n.positionIterations = i, n.inv_dt = t > 0 ? 1 / t : 0, n.dtRatio = this.m_inv_dt0 * t, n.warmStarting = R.m_warmStarting, this.m_contactManager.Collide(), n.dt > 0 && this.Solve(n), R.m_continuousPhysics && n.dt > 0 && this.SolveTOI(n), n.dt > 0 && (this.m_inv_dt0 = n.inv_dt), this.m_flags &= ~R.e_locked;
      }, R.prototype.ClearForces = function () {
        for (var t = this.m_bodyList; t; t = t.m_next) t.m_force.SetZero(), t.m_torque = 0;
      }, R.prototype.DrawDebugData = function () {
        if (null != this.m_debugDraw) {
          this.m_debugDraw.m_sprite.graphics.clear();
          var t, e, i, n, s, l, c = this.m_debugDraw.GetFlags(), h = (new r, new r, new r, new a, new a, [new r, new r, new r, new r]), u = new o(0, 0, 0);
          if (c & M.e_shapeBit) for (t = this.m_bodyList; t; t = t.m_next) for (l = t.m_xf, e = t.GetFixtureList(); e; e = e.m_next) i = e.GetShape(), 0 == t.IsActive() ? (u.Set(0.5, 0.5, 0.3), this.DrawShape(i, l, u)) : t.GetType() == g.b2_staticBody ? (u.Set(0.5, 0.9, 0.5), this.DrawShape(i, l, u)) : t.GetType() == g.b2_kinematicBody ? (u.Set(0.5, 0.5, 0.9), this.DrawShape(i, l, u)) : 0 == t.IsAwake() ? (u.Set(0.6, 0.6, 0.6), this.DrawShape(i, l, u)) : (u.Set(0.9, 0.7, 0.7), this.DrawShape(i, l, u));
          if (c & M.e_jointBit) for (n = this.m_jointList; n; n = n.m_next) this.DrawJoint(n);
          if (c & M.e_controllerBit) for (var p = this.m_controllerList; p; p = p.m_next) p.Draw(this.m_debugDraw);
          if (c & M.e_pairBit) {
            u.Set(0.3, 0.9, 0.9);
            for (var m = this.m_contactManager.m_contactList; m; m = m.GetNext()) {
              var d = m.GetFixtureA(), _ = m.GetFixtureB(), y = d.GetAABB().GetCenter(), x = _.GetAABB().GetCenter();
              this.m_debugDraw.DrawSegment(y, x, u);
            }
          }
          if (c & M.e_aabbBit) for (s = this.m_contactManager.m_broadPhase, h = [new r, new r, new r, new r], t = this.m_bodyList; t; t = t.GetNext()) if (0 != t.IsActive()) for (e = t.GetFixtureList(); e; e = e.GetNext()) {
            var v = s.GetFatAABB(e.m_proxy);
            h[0].Set(v.lowerBound.x, v.lowerBound.y), h[1].Set(v.upperBound.x, v.lowerBound.y), h[2].Set(v.upperBound.x, v.upperBound.y), h[3].Set(v.lowerBound.x, v.upperBound.y), this.m_debugDraw.DrawPolygon(h, 4, u);
          }
          if (c & M.e_centerOfMassBit) for (t = this.m_bodyList; t; t = t.m_next) (l = R.s_xf).R = t.m_xf.R, l.position = t.GetWorldCenter(), this.m_debugDraw.DrawTransform(l);
        }
      }, R.prototype.QueryAABB = function (t, e) {
        var i = this.m_contactManager.m_broadPhase;
        i.Query(function (e) {
          return t(i.GetUserData(e));
        }, e);
      }, R.prototype.QueryShape = function (t, e, i) {
        void 0 === i && (i = null), null == i && (i = new n).SetIdentity();
        var r = this.m_contactManager.m_broadPhase;
        var o = new a;
        e.ComputeAABB(o, i), r.Query(function (n) {
          var o = r.GetUserData(n) instanceof T ? r.GetUserData(n) : null;
          return !y.TestOverlap(e, i, o.GetShape(), o.GetBody().GetTransform()) || t(o);
        }, o);
      }, R.prototype.QueryPoint = function (t, e) {
        var i = this.m_contactManager.m_broadPhase;
        var n = new a;
        n.lowerBound.Set(e.x - s.b2_linearSlop, e.y - s.b2_linearSlop), n.upperBound.Set(e.x + s.b2_linearSlop, e.y + s.b2_linearSlop), i.Query(function (n) {
          var r = i.GetUserData(n) instanceof T ? i.GetUserData(n) : null;
          return !r.TestPoint(e) || t(r);
        }, n);
      }, R.prototype.RayCast = function (t, e, i) {
        var n = this.m_contactManager.m_broadPhase, o = new u;
        var s = new h(e, i);
        n.RayCast(function (s, a) {
          var l = n.GetUserData(a), c = l instanceof T ? l : null;
          if (c.RayCast(o, s)) {
            var h = o.fraction, u = new r((1 - h) * e.x + h * i.x, (1 - h) * e.y + h * i.y);
            return t(c, u, o.normal, h);
          }
          return s.maxFraction;
        }, s);
      }, R.prototype.RayCastOne = function (t, e) {
        var i;
        return this.RayCast(function (t, e, n, r) {
          return void 0 === r && (r = 0), i = t, r;
        }, t, e), i;
      }, R.prototype.RayCastAll = function (t, e) {
        var i = new H;
        return this.RayCast(function (t, e, n, r) {
          return void 0 === r && (r = 0), i[i.length] = t, 1;
        }, t, e), i;
      }, R.prototype.GetBodyList = function () {
        return this.m_bodyList;
      }, R.prototype.GetJointList = function () {
        return this.m_jointList;
      }, R.prototype.GetContactList = function () {
        return this.m_contactList;
      }, R.prototype.IsLocked = function () {
        return (this.m_flags & R.e_locked) > 0;
      }, R.prototype.Solve = function (t) {
        for (var e, i = this.m_controllerList; i; i = i.m_next) i.Step(t);
        var n = this.m_island;
        for (n.Initialize(this.m_bodyCount, this.m_contactCount, this.m_jointCount, null, this.m_contactManager.m_contactListener, this.m_contactSolver), e = this.m_bodyList; e; e = e.m_next) e.m_flags &= ~g.e_islandFlag;
        for (var r = this.m_contactList; r; r = r.m_next) r.m_flags &= ~B.e_islandFlag;
        for (var o = this.m_jointList; o; o = o.m_next) o.m_islandFlag = false;
        parseInt(this.m_bodyCount);
        for (var s = this.s_stack, a = this.m_bodyList; a; a = a.m_next) if (!(a.m_flags & g.e_islandFlag) && 0 != a.IsAwake() && 0 != a.IsActive() && a.GetType() != g.b2_staticBody) {
          n.Clear();
          var l = 0;
          for (s[l++] = a, a.m_flags |= g.e_islandFlag; l > 0;) if (e = s[--l], n.AddBody(e), 0 == e.IsAwake() && e.SetAwake(true), e.GetType() != g.b2_staticBody) {
            for (var c, h = e.m_contactList; h; h = h.next) h.contact.m_flags & B.e_islandFlag || 1 != h.contact.IsSensor() && 0 != h.contact.IsEnabled() && 0 != h.contact.IsTouching() && (n.AddContact(h.contact), h.contact.m_flags |= B.e_islandFlag, (c = h.other).m_flags & g.e_islandFlag || (s[l++] = c, c.m_flags |= g.e_islandFlag));
            for (var u = e.m_jointList; u; u = u.next) 1 != u.joint.m_islandFlag && 0 != (c = u.other).IsActive() && (n.AddJoint(u.joint), u.joint.m_islandFlag = true, c.m_flags & g.e_islandFlag || (s[l++] = c, c.m_flags |= g.e_islandFlag));
          }
          n.Solve(t, this.m_gravity, this.m_allowSleep);
          for (var p = 0; p < n.m_bodyCount; ++p) (e = n.m_bodies[p]).GetType() == g.b2_staticBody && (e.m_flags &= ~g.e_islandFlag);
        }
        for (p = 0; p < s.length && s[p]; ++p) s[p] = null;
        for (e = this.m_bodyList; e; e = e.m_next) 0 != e.IsAwake() && 0 != e.IsActive() && e.GetType() != g.b2_staticBody && e.SynchronizeFixtures();
        this.m_contactManager.FindNewContacts();
      }, R.prototype.SolveTOI = function (t) {
        var e, i, n, r, o, a, l, c = this.m_island;
        c.Initialize(this.m_bodyCount, s.b2_maxTOIContactsPerIsland, s.b2_maxTOIJointsPerIsland, null, this.m_contactManager.m_contactListener, this.m_contactSolver);
        var h, u = R.s_queue;
        for (e = this.m_bodyList; e; e = e.m_next) e.m_flags &= ~g.e_islandFlag, e.m_sweep.t0 = 0;
        for (h = this.m_contactList; h; h = h.m_next) h.m_flags &= ~(B.e_toiFlag | B.e_islandFlag);
        for (l = this.m_jointList; l; l = l.m_next) l.m_islandFlag = false;
        for (;;) {
          var p = null, m = 1;
          for (h = this.m_contactList; h; h = h.m_next) if (1 != h.IsSensor() && 0 != h.IsEnabled() && 0 != h.IsContinuous()) {
            var d = 1;
            if (h.m_flags & B.e_toiFlag) d = h.m_toi; else {
              if (i = h.m_fixtureA, n = h.m_fixtureB, r = i.m_body, o = n.m_body, !(r.GetType() == g.b2_dynamicBody && 0 != r.IsAwake() || o.GetType() == g.b2_dynamicBody && 0 != o.IsAwake())) continue;
              var _ = r.m_sweep.t0;
              r.m_sweep.t0 < o.m_sweep.t0 ? (_ = o.m_sweep.t0, r.m_sweep.Advance(_)) : o.m_sweep.t0 < r.m_sweep.t0 && (_ = r.m_sweep.t0, o.m_sweep.Advance(_)), d = h.ComputeTOI(r.m_sweep, o.m_sweep), s.b2Assert(0 <= d && d <= 1), d > 0 && d < 1 && (d = (1 - d) * _ + d) > 1 && (d = 1), h.m_toi = d, h.m_flags |= B.e_toiFlag;
            }
            Number.MIN_VALUE < d && d < m && (p = h, m = d);
          }
          if (null == p || 1 - 100 * Number.MIN_VALUE < m) break;
          if (i = p.m_fixtureA, n = p.m_fixtureB, r = i.m_body, o = n.m_body, R.s_backupA.Set(r.m_sweep), R.s_backupB.Set(o.m_sweep), r.Advance(m), o.Advance(m), p.Update(this.m_contactManager.m_contactListener), p.m_flags &= ~B.e_toiFlag, 1 != p.IsSensor() && 0 != p.IsEnabled()) {
            if (0 != p.IsTouching()) {
              var y = r;
              y.GetType() != g.b2_dynamicBody && (y = o), c.Clear();
              var x = 0, v = 0;
              for (u[x + v++] = y, y.m_flags |= g.e_islandFlag; v > 0;) if (e = u[x++], --v, c.AddBody(e), 0 == e.IsAwake() && e.SetAwake(true), e.GetType() == g.b2_dynamicBody) {
                for (a = e.m_contactList; a && c.m_contactCount != c.m_contactCapacity; a = a.next) if (!(a.contact.m_flags & B.e_islandFlag) && 1 != a.contact.IsSensor() && 0 != a.contact.IsEnabled() && 0 != a.contact.IsTouching()) {
                  c.AddContact(a.contact), a.contact.m_flags |= B.e_islandFlag;
                  var b = a.other;
                  b.m_flags & g.e_islandFlag || (b.GetType() != g.b2_staticBody && (b.Advance(m), b.SetAwake(true)), u[x + v] = b, ++v, b.m_flags |= g.e_islandFlag);
                }
                for (var w = e.m_jointList; w; w = w.next) c.m_jointCount != c.m_jointCapacity && 1 != w.joint.m_islandFlag && 0 != (b = w.other).IsActive() && (c.AddJoint(w.joint), w.joint.m_islandFlag = true, b.m_flags & g.e_islandFlag || (b.GetType() != g.b2_staticBody && (b.Advance(m), b.SetAwake(true)), u[x + v] = b, ++v, b.m_flags |= g.e_islandFlag));
              }
              var S = R.s_timestep;
              S.warmStarting = false, S.dt = (1 - m) * t.dt, S.inv_dt = 1 / S.dt, S.dtRatio = 0, S.velocityIterations = t.velocityIterations, S.positionIterations = t.positionIterations, c.SolveTOI(S);
              var M = 0;
              for (M = 0; M < c.m_bodyCount; ++M) if ((e = c.m_bodies[M]).m_flags &= ~g.e_islandFlag, 0 != e.IsAwake() && e.GetType() == g.b2_dynamicBody) for (e.SynchronizeFixtures(), a = e.m_contactList; a; a = a.next) a.contact.m_flags &= ~B.e_toiFlag;
              for (M = 0; M < c.m_contactCount; ++M) (h = c.m_contacts[M]).m_flags &= ~(B.e_toiFlag | B.e_islandFlag);
              for (M = 0; M < c.m_jointCount; ++M) (l = c.m_joints[M]).m_islandFlag = false;
              this.m_contactManager.FindNewContacts();
            }
          } else r.m_sweep.Set(R.s_backupA), o.m_sweep.Set(R.s_backupB), r.SynchronizeTransform(), o.SynchronizeTransform();
        }
      }, R.prototype.DrawJoint = function (t) {
        var e = t.GetBodyA(), i = t.GetBodyB(), n = e.m_xf, r = i.m_xf, o = n.position, s = r.position, a = t.GetAnchorA(), l = t.GetAnchorB(), c = R.s_jointColor;
        switch (t.m_type) {
          case V.e_distanceJoint:
            this.m_debugDraw.DrawSegment(a, l, c);
            break;
          case V.e_pulleyJoint:
            var h = t instanceof F ? t : null, u = h.GetGroundAnchorA(), p = h.GetGroundAnchorB();
            this.m_debugDraw.DrawSegment(u, a, c), this.m_debugDraw.DrawSegment(p, l, c), this.m_debugDraw.DrawSegment(u, p, c);
            break;
          case V.e_mouseJoint:
            this.m_debugDraw.DrawSegment(a, l, c);
            break;
          default:
            e != this.m_groundBody && this.m_debugDraw.DrawSegment(o, a, c), this.m_debugDraw.DrawSegment(a, l, c), i != this.m_groundBody && this.m_debugDraw.DrawSegment(s, l, c);
        }
      }, R.prototype.DrawShape = function (e, i, n) {
        switch (e.m_type) {
          case y.e_circleShape:
            var r = e instanceof p ? e : null, o = t.MulX(i, r.m_p), s = r.m_radius, a = i.R.col1;
            this.m_debugDraw.DrawSolidCircle(o, s, a, n);
            break;
          case y.e_polygonShape:
            var l = 0, c = e instanceof _ ? e : null, h = parseInt(c.GetVertexCount()), u = c.GetVertices(), d = new H(h);
            for (l = 0; l < h; ++l) d[l] = t.MulX(i, u[l]);
            this.m_debugDraw.DrawSolidPolygon(d, h, n);
            break;
          case y.e_edgeShape:
            var g = e instanceof m ? e : null;
            this.m_debugDraw.DrawSegment(t.MulX(i, g.GetVertex1()), t.MulX(i, g.GetVertex2()), n);
        }
      }, e.postDefs.push(function () {
        e.Dynamics.b2World.s_timestep2 = new D, e.Dynamics.b2World.s_xf = new n, e.Dynamics.b2World.s_backupA = new i, e.Dynamics.b2World.s_backupB = new i, e.Dynamics.b2World.s_timestep = new D, e.Dynamics.b2World.s_queue = new H, e.Dynamics.b2World.s_jointColor = new o(0.5, 0.8, 0.8), e.Dynamics.b2World.e_newFixture = 1, e.Dynamics.b2World.e_locked = 2;
      });
    }(), function () {
      var t = e.Collision.Shapes.b2CircleShape, i = (e.Collision.Shapes.b2EdgeChainDef, e.Collision.Shapes.b2EdgeShape), n = (e.Collision.Shapes.b2MassData, e.Collision.Shapes.b2PolygonShape), r = e.Collision.Shapes.b2Shape, o = e.Dynamics.Contacts.b2CircleContact, s = e.Dynamics.Contacts.b2Contact, a = e.Dynamics.Contacts.b2ContactConstraint, l = e.Dynamics.Contacts.b2ContactConstraintPoint, c = e.Dynamics.Contacts.b2ContactEdge, h = e.Dynamics.Contacts.b2ContactFactory, u = e.Dynamics.Contacts.b2ContactRegister, p = e.Dynamics.Contacts.b2ContactResult, m = e.Dynamics.Contacts.b2ContactSolver, d = e.Dynamics.Contacts.b2EdgeAndCircleContact, _ = e.Dynamics.Contacts.b2NullContact, y = e.Dynamics.Contacts.b2PolyAndCircleContact, g = e.Dynamics.Contacts.b2PolyAndEdgeContact, x = e.Dynamics.Contacts.b2PolygonContact, v = e.Dynamics.Contacts.b2PositionSolverManifold, b = e.Dynamics.b2Body, w = (e.Dynamics.b2BodyDef, e.Dynamics.b2ContactFilter, e.Dynamics.b2ContactImpulse, e.Dynamics.b2ContactListener, e.Dynamics.b2ContactManager, e.Dynamics.b2DebugDraw, e.Dynamics.b2DestructionListener, e.Dynamics.b2FilterData, e.Dynamics.b2Fixture, e.Dynamics.b2FixtureDef, e.Dynamics.b2Island, e.Dynamics.b2TimeStep), S = (e.Dynamics.b2World, e.Common.b2Color, e.Common.b2internal, e.Common.b2Settings), M = e.Common.Math.b2Mat22, A = (e.Common.Math.b2Mat33, e.Common.Math.b2Math), C = (e.Common.Math.b2Sweep, e.Common.Math.b2Transform, e.Common.Math.b2Vec2), T = (e.Common.Math.b2Vec3, e.Collision.b2AABB, e.Collision.b2Bound, e.Collision.b2BoundValues, e.Collision.b2Collision), E = e.Collision.b2ContactID, L = (e.Collision.b2ContactPoint, e.Collision.b2Distance, e.Collision.b2DistanceInput, e.Collision.b2DistanceOutput, e.Collision.b2DistanceProxy, e.Collision.b2DynamicTree, e.Collision.b2DynamicTreeBroadPhase, e.Collision.b2DynamicTreeNode, e.Collision.b2DynamicTreePair, e.Collision.b2Manifold), D = (e.Collision.b2ManifoldPoint, e.Collision.b2Point, e.Collision.b2RayCastInput, e.Collision.b2RayCastOutput, e.Collision.b2Segment, e.Collision.b2SeparationFunction, e.Collision.b2Simplex, e.Collision.b2SimplexCache, e.Collision.b2SimplexVertex, e.Collision.b2TimeOfImpact), R = e.Collision.b2TOIInput, B = e.Collision.b2WorldManifold;
      e.Collision.ClipVertex, e.Collision.Features, e.Collision.IBroadPhase;
      e.inherit(o, e.Dynamics.Contacts.b2Contact), o.prototype.__super = e.Dynamics.Contacts.b2Contact.prototype, o.b2CircleContact = function () {
        e.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
      }, o.Create = function (t) {
        return new o;
      }, o.Destroy = function (t, e) {}, o.prototype.Reset = function (t, e) {
        this.__super.Reset.call(this, t, e);
      }, o.prototype.Evaluate = function () {
        var e = this.m_fixtureA.GetBody(), i = this.m_fixtureB.GetBody();
        T.CollideCircles(this.m_manifold, this.m_fixtureA.GetShape() instanceof t ? this.m_fixtureA.GetShape() : null, e.m_xf, this.m_fixtureB.GetShape() instanceof t ? this.m_fixtureB.GetShape() : null, i.m_xf);
      }, s.b2Contact = function () {
        this.m_nodeA = new c, this.m_nodeB = new c, this.m_manifold = new L, this.m_oldManifold = new L;
      }, s.prototype.GetManifold = function () {
        return this.m_manifold;
      }, s.prototype.GetWorldManifold = function (t) {
        var e = this.m_fixtureA.GetBody(), i = this.m_fixtureB.GetBody(), n = this.m_fixtureA.GetShape(), r = this.m_fixtureB.GetShape();
        t.Initialize(this.m_manifold, e.GetTransform(), n.m_radius, i.GetTransform(), r.m_radius);
      }, s.prototype.IsTouching = function () {
        return (this.m_flags & s.e_touchingFlag) == s.e_touchingFlag;
      }, s.prototype.IsContinuous = function () {
        return (this.m_flags & s.e_continuousFlag) == s.e_continuousFlag;
      }, s.prototype.SetSensor = function (t) {
        t ? this.m_flags |= s.e_sensorFlag : this.m_flags &= ~s.e_sensorFlag;
      }, s.prototype.IsSensor = function () {
        return (this.m_flags & s.e_sensorFlag) == s.e_sensorFlag;
      }, s.prototype.SetEnabled = function (t) {
        t ? this.m_flags |= s.e_enabledFlag : this.m_flags &= ~s.e_enabledFlag;
      }, s.prototype.IsEnabled = function () {
        return (this.m_flags & s.e_enabledFlag) == s.e_enabledFlag;
      }, s.prototype.GetNext = function () {
        return this.m_next;
      }, s.prototype.GetFixtureA = function () {
        return this.m_fixtureA;
      }, s.prototype.GetFixtureB = function () {
        return this.m_fixtureB;
      }, s.prototype.FlagForFiltering = function () {
        this.m_flags |= s.e_filterFlag;
      }, s.prototype.b2Contact = function () {}, s.prototype.Reset = function (t, e) {
        if (void 0 === t && (t = null), void 0 === e && (e = null), this.m_flags = s.e_enabledFlag, !t || !e) return this.m_fixtureA = null, void (this.m_fixtureB = null);
        (t.IsSensor() || e.IsSensor()) && (this.m_flags |= s.e_sensorFlag);
        var i = t.GetBody(), n = e.GetBody();
        (i.GetType() != b.b2_dynamicBody || i.IsBullet() || n.GetType() != b.b2_dynamicBody || n.IsBullet()) && (this.m_flags |= s.e_continuousFlag), this.m_fixtureA = t, this.m_fixtureB = e, this.m_manifold.m_pointCount = 0, this.m_prev = null, this.m_next = null, this.m_nodeA.contact = null, this.m_nodeA.prev = null, this.m_nodeA.next = null, this.m_nodeA.other = null, this.m_nodeB.contact = null, this.m_nodeB.prev = null, this.m_nodeB.next = null, this.m_nodeB.other = null;
      }, s.prototype.Update = function (t) {
        var e = this.m_oldManifold;
        this.m_oldManifold = this.m_manifold, this.m_manifold = e, this.m_flags |= s.e_enabledFlag;
        var i = false, n = (this.m_flags & s.e_touchingFlag) == s.e_touchingFlag, o = this.m_fixtureA.m_body, a = this.m_fixtureB.m_body, l = this.m_fixtureA.m_aabb.TestOverlap(this.m_fixtureB.m_aabb);
        if (this.m_flags & s.e_sensorFlag) {
          if (l) {
            var c = this.m_fixtureA.GetShape(), h = this.m_fixtureB.GetShape(), u = o.GetTransform(), p = a.GetTransform();
            i = r.TestOverlap(c, u, h, p);
          }
          this.m_manifold.m_pointCount = 0;
        } else {
          if (o.GetType() != b.b2_dynamicBody || o.IsBullet() || a.GetType() != b.b2_dynamicBody || a.IsBullet() ? this.m_flags |= s.e_continuousFlag : this.m_flags &= ~s.e_continuousFlag, l) {
            this.Evaluate(), i = this.m_manifold.m_pointCount > 0;
            for (var m = 0; m < this.m_manifold.m_pointCount; ++m) {
              var d = this.m_manifold.m_points[m];
              d.m_normalImpulse = 0, d.m_tangentImpulse = 0;
              for (var _ = d.m_id, y = 0; y < this.m_oldManifold.m_pointCount; ++y) {
                var g = this.m_oldManifold.m_points[y];
                if (g.m_id.key == _.key) {
                  d.m_normalImpulse = g.m_normalImpulse, d.m_tangentImpulse = g.m_tangentImpulse;
                  break;
                }
              }
            }
          } else this.m_manifold.m_pointCount = 0;
          i != n && (o.SetAwake(true), a.SetAwake(true));
        }
        i ? this.m_flags |= s.e_touchingFlag : this.m_flags &= ~s.e_touchingFlag, 0 == n && 1 == i && t.BeginContact(this), 1 == n && 0 == i && t.EndContact(this), 0 == (this.m_flags & s.e_sensorFlag) && t.PreSolve(this, this.m_oldManifold);
      }, s.prototype.Evaluate = function () {}, s.prototype.ComputeTOI = function (t, e) {
        return s.s_input.proxyA.Set(this.m_fixtureA.GetShape()), s.s_input.proxyB.Set(this.m_fixtureB.GetShape()), s.s_input.sweepA = t, s.s_input.sweepB = e, s.s_input.tolerance = S.b2_linearSlop, D.TimeOfImpact(s.s_input);
      }, e.postDefs.push(function () {
        e.Dynamics.Contacts.b2Contact.e_sensorFlag = 1, e.Dynamics.Contacts.b2Contact.e_continuousFlag = 2, e.Dynamics.Contacts.b2Contact.e_islandFlag = 4, e.Dynamics.Contacts.b2Contact.e_toiFlag = 8, e.Dynamics.Contacts.b2Contact.e_touchingFlag = 16, e.Dynamics.Contacts.b2Contact.e_enabledFlag = 32, e.Dynamics.Contacts.b2Contact.e_filterFlag = 64, e.Dynamics.Contacts.b2Contact.s_input = new R;
      }), a.b2ContactConstraint = function () {
        this.localPlaneNormal = new C, this.localPoint = new C, this.normal = new C, this.normalMass = new M, this.K = new M;
      }, a.prototype.b2ContactConstraint = function () {
        this.points = new H(S.b2_maxManifoldPoints);
        for (var t = 0; t < S.b2_maxManifoldPoints; t++) this.points[t] = new l;
      }, l.b2ContactConstraintPoint = function () {
        this.localPoint = new C, this.rA = new C, this.rB = new C;
      }, c.b2ContactEdge = function () {}, h.b2ContactFactory = function () {}, h.prototype.b2ContactFactory = function (t) {
        this.m_allocator = t, this.InitializeRegisters();
      }, h.prototype.AddType = function (t, e, i, n) {
        void 0 === i && (i = 0), void 0 === n && (n = 0), this.m_registers[i][n].createFcn = t, this.m_registers[i][n].destroyFcn = e, this.m_registers[i][n].primary = true, i != n && (this.m_registers[n][i].createFcn = t, this.m_registers[n][i].destroyFcn = e, this.m_registers[n][i].primary = false);
      }, h.prototype.InitializeRegisters = function () {
        this.m_registers = new H(r.e_shapeTypeCount);
        for (var t = 0; t < r.e_shapeTypeCount; t++) {
          this.m_registers[t] = new H(r.e_shapeTypeCount);
          for (var e = 0; e < r.e_shapeTypeCount; e++) this.m_registers[t][e] = new u;
        }
        this.AddType(o.Create, o.Destroy, r.e_circleShape, r.e_circleShape), this.AddType(y.Create, y.Destroy, r.e_polygonShape, r.e_circleShape), this.AddType(x.Create, x.Destroy, r.e_polygonShape, r.e_polygonShape), this.AddType(d.Create, d.Destroy, r.e_edgeShape, r.e_circleShape), this.AddType(g.Create, g.Destroy, r.e_polygonShape, r.e_edgeShape);
      }, h.prototype.Create = function (t, e) {
        var i, n = parseInt(t.GetType()), r = parseInt(e.GetType()), o = this.m_registers[n][r];
        if (o.pool) return i = o.pool, o.pool = i.m_next, o.poolCount--, i.Reset(t, e), i;
        var s = o.createFcn;
        return null != s ? o.primary ? ((i = s(this.m_allocator)).Reset(t, e), i) : ((i = s(this.m_allocator)).Reset(e, t), i) : null;
      }, h.prototype.Destroy = function (t) {
        t.m_manifold.m_pointCount > 0 && (t.m_fixtureA.m_body.SetAwake(true), t.m_fixtureB.m_body.SetAwake(true));
        var e = parseInt(t.m_fixtureA.GetType()), i = parseInt(t.m_fixtureB.GetType()), n = this.m_registers[e][i];
        n.poolCount++, t.m_next = n.pool, n.pool = t, (0, n.destroyFcn)(t, this.m_allocator);
      }, u.b2ContactRegister = function () {}, p.b2ContactResult = function () {
        this.position = new C, this.normal = new C, this.id = new E;
      }, m.b2ContactSolver = function () {
        this.m_step = new w, this.m_constraints = new H;
      }, m.prototype.b2ContactSolver = function () {}, m.prototype.Initialize = function (t, e, i, n) {
        var r;
        void 0 === i && (i = 0), this.m_step.Set(t), this.m_allocator = n;
        var o = 0;
        for (this.m_constraintCount = i; this.m_constraints.length < this.m_constraintCount;) this.m_constraints[this.m_constraints.length] = new a;
        for (o = 0; o < i; ++o) {
          var s = (r = e[o]).m_fixtureA, l = r.m_fixtureB, c = s.m_shape, h = l.m_shape, u = c.m_radius, p = h.m_radius, d = s.m_body, _ = l.m_body, y = r.GetManifold(), g = S.b2MixFriction(s.GetFriction(), l.GetFriction()), x = S.b2MixRestitution(s.GetRestitution(), l.GetRestitution()), v = d.m_linearVelocity.x, b = d.m_linearVelocity.y, w = _.m_linearVelocity.x, M = _.m_linearVelocity.y, A = d.m_angularVelocity, C = _.m_angularVelocity;
          S.b2Assert(y.m_pointCount > 0), m.s_worldManifold.Initialize(y, d.m_xf, u, _.m_xf, p);
          var T = m.s_worldManifold.m_normal.x, E = m.s_worldManifold.m_normal.y, L = this.m_constraints[o];
          L.bodyA = d, L.bodyB = _, L.manifold = y, L.normal.x = T, L.normal.y = E, L.pointCount = y.m_pointCount, L.friction = g, L.restitution = x, L.localPlaneNormal.x = y.m_localPlaneNormal.x, L.localPlaneNormal.y = y.m_localPlaneNormal.y, L.localPoint.x = y.m_localPoint.x, L.localPoint.y = y.m_localPoint.y, L.radius = u + p, L.type = y.m_type;
          for (var D = 0; D < L.pointCount; ++D) {
            var R = y.m_points[D], B = L.points[D];
            B.normalImpulse = R.m_normalImpulse, B.tangentImpulse = R.m_tangentImpulse, B.localPoint.SetV(R.m_localPoint);
            var P = B.rA.x = m.s_worldManifold.m_points[D].x - d.m_sweep.c.x, I = B.rA.y = m.s_worldManifold.m_points[D].y - d.m_sweep.c.y, V = B.rB.x = m.s_worldManifold.m_points[D].x - _.m_sweep.c.x, F = B.rB.y = m.s_worldManifold.m_points[D].y - _.m_sweep.c.y, k = P * E - I * T, N = V * E - F * T;
            k *= k, N *= N;
            var G = d.m_invMass + _.m_invMass + d.m_invI * k + _.m_invI * N;
            B.normalMass = 1 / G;
            var U = d.m_mass * d.m_invMass + _.m_mass * _.m_invMass;
            U += d.m_mass * d.m_invI * k + _.m_mass * _.m_invI * N, B.equalizedMass = 1 / U;
            var z = -T, O = P * z - I * E, H = V * z - F * E;
            O *= O, H *= H;
            var W = d.m_invMass + _.m_invMass + d.m_invI * O + _.m_invI * H;
            B.tangentMass = 1 / W, B.velocityBias = 0;
            var J = w + -C * F - v - -A * I, X = M + C * V - b - A * P, q = L.normal.x * J + L.normal.y * X;
            q < -S.b2_velocityThreshold && (B.velocityBias += -L.restitution * q);
          }
          if (2 == L.pointCount) {
            var Y = L.points[0], Z = L.points[1], K = d.m_invMass, $ = d.m_invI, Q = _.m_invMass, tt = _.m_invI, et = Y.rA.x * E - Y.rA.y * T, it = Y.rB.x * E - Y.rB.y * T, nt = Z.rA.x * E - Z.rA.y * T, rt = Z.rB.x * E - Z.rB.y * T, ot = K + Q + $ * et * et + tt * it * it, st = K + Q + $ * nt * nt + tt * rt * rt, at = K + Q + $ * et * nt + tt * it * rt;
            ot * ot < 100 * (ot * st - at * at) ? (L.K.col1.Set(ot, at), L.K.col2.Set(at, st), L.K.GetInverse(L.normalMass)) : L.pointCount = 1;
          }
        }
      }, m.prototype.InitVelocityConstraints = function (t) {
        for (var e = 0; e < this.m_constraintCount; ++e) {
          var i = this.m_constraints[e], n = i.bodyA, r = i.bodyB, o = n.m_invMass, s = n.m_invI, a = r.m_invMass, l = r.m_invI, c = i.normal.x, h = i.normal.y, u = h, p = -c, m = 0, d = 0;
          if (t.warmStarting) for (d = i.pointCount, m = 0; m < d; ++m) {
            var _ = i.points[m];
            _.normalImpulse *= t.dtRatio, _.tangentImpulse *= t.dtRatio;
            var y = _.normalImpulse * c + _.tangentImpulse * u, g = _.normalImpulse * h + _.tangentImpulse * p;
            n.m_angularVelocity -= s * (_.rA.x * g - _.rA.y * y), n.m_linearVelocity.x -= o * y, n.m_linearVelocity.y -= o * g, r.m_angularVelocity += l * (_.rB.x * g - _.rB.y * y), r.m_linearVelocity.x += a * y, r.m_linearVelocity.y += a * g;
          } else for (d = i.pointCount, m = 0; m < d; ++m) {
            var x = i.points[m];
            x.normalImpulse = 0, x.tangentImpulse = 0;
          }
        }
      }, m.prototype.SolveVelocityConstraints = function () {
        for (var t, e, i = 0, n = 0, r = 0, o = 0, s = 0, a = 0, l = 0, c = 0, h = 0, u = 0, p = 0, m = 0, d = 0, _ = 0, y = 0; y < this.m_constraintCount; ++y) {
          var g = this.m_constraints[y], x = g.bodyA, v = g.bodyB, b = x.m_angularVelocity, w = v.m_angularVelocity, S = x.m_linearVelocity, M = v.m_linearVelocity, C = x.m_invMass, T = x.m_invI, E = v.m_invMass, L = v.m_invI, D = g.normal.x, R = g.normal.y, B = R, P = -D, I = g.friction;
          for (i = 0; i < g.pointCount; i++) t = g.points[i], r = (M.x - w * t.rB.y - S.x + b * t.rA.y) * B + (M.y + w * t.rB.x - S.y - b * t.rA.x) * P, o = t.tangentMass * -r, s = I * t.normalImpulse, l = (o = (a = A.Clamp(t.tangentImpulse + o, -s, s)) - t.tangentImpulse) * B, c = o * P, S.x -= C * l, S.y -= C * c, b -= T * (t.rA.x * c - t.rA.y * l), M.x += E * l, M.y += E * c, w += L * (t.rB.x * c - t.rB.y * l), t.tangentImpulse = a;
          parseInt(g.pointCount);
          if (1 == g.pointCount) t = g.points[0], n = (M.x + -w * t.rB.y - S.x - -b * t.rA.y) * D + (M.y + w * t.rB.x - S.y - b * t.rA.x) * R, o = -t.normalMass * (n - t.velocityBias), l = (o = (a = (a = t.normalImpulse + o) > 0 ? a : 0) - t.normalImpulse) * D, c = o * R, S.x -= C * l, S.y -= C * c, b -= T * (t.rA.x * c - t.rA.y * l), M.x += E * l, M.y += E * c, w += L * (t.rB.x * c - t.rB.y * l), t.normalImpulse = a; else {
            var V = g.points[0], F = g.points[1], k = V.normalImpulse, N = F.normalImpulse, G = (M.x - w * V.rB.y - S.x + b * V.rA.y) * D + (M.y + w * V.rB.x - S.y - b * V.rA.x) * R, U = (M.x - w * F.rB.y - S.x + b * F.rA.y) * D + (M.y + w * F.rB.x - S.y - b * F.rA.x) * R, z = G - V.velocityBias, O = U - F.velocityBias;
            z -= (e = g.K).col1.x * k + e.col2.x * N, O -= e.col1.y * k + e.col2.y * N;
            for (;;) {
              var H = -((e = g.normalMass).col1.x * z + e.col2.x * O), W = -(e.col1.y * z + e.col2.y * O);
              if (H >= 0 && W >= 0) {
                p = (h = H - k) * D, m = h * R, d = (u = W - N) * D, _ = u * R, S.x -= C * (p + d), S.y -= C * (m + _), b -= T * (V.rA.x * m - V.rA.y * p + F.rA.x * _ - F.rA.y * d), M.x += E * (p + d), M.y += E * (m + _), w += L * (V.rB.x * m - V.rB.y * p + F.rB.x * _ - F.rB.y * d), V.normalImpulse = H, F.normalImpulse = W;
                break;
              }
              if (H = -V.normalMass * z, W = 0, G = 0, U = g.K.col1.y * H + O, H >= 0 && U >= 0) {
                p = (h = H - k) * D, m = h * R, d = (u = W - N) * D, _ = u * R, S.x -= C * (p + d), S.y -= C * (m + _), b -= T * (V.rA.x * m - V.rA.y * p + F.rA.x * _ - F.rA.y * d), M.x += E * (p + d), M.y += E * (m + _), w += L * (V.rB.x * m - V.rB.y * p + F.rB.x * _ - F.rB.y * d), V.normalImpulse = H, F.normalImpulse = W;
                break;
              }
              if (H = 0, W = -F.normalMass * O, G = g.K.col2.x * W + z, U = 0, W >= 0 && G >= 0) {
                p = (h = H - k) * D, m = h * R, d = (u = W - N) * D, _ = u * R, S.x -= C * (p + d), S.y -= C * (m + _), b -= T * (V.rA.x * m - V.rA.y * p + F.rA.x * _ - F.rA.y * d), M.x += E * (p + d), M.y += E * (m + _), w += L * (V.rB.x * m - V.rB.y * p + F.rB.x * _ - F.rB.y * d), V.normalImpulse = H, F.normalImpulse = W;
                break;
              }
              if (H = 0, W = 0, U = O, (G = z) >= 0 && U >= 0) {
                p = (h = H - k) * D, m = h * R, d = (u = W - N) * D, _ = u * R, S.x -= C * (p + d), S.y -= C * (m + _), b -= T * (V.rA.x * m - V.rA.y * p + F.rA.x * _ - F.rA.y * d), M.x += E * (p + d), M.y += E * (m + _), w += L * (V.rB.x * m - V.rB.y * p + F.rB.x * _ - F.rB.y * d), V.normalImpulse = H, F.normalImpulse = W;
                break;
              }
              break;
            }
          }
          x.m_angularVelocity = b, v.m_angularVelocity = w;
        }
      }, m.prototype.FinalizeVelocityConstraints = function () {
        for (var t = 0; t < this.m_constraintCount; ++t) for (var e = this.m_constraints[t], i = e.manifold, n = 0; n < e.pointCount; ++n) {
          var r = i.m_points[n], o = e.points[n];
          r.m_normalImpulse = o.normalImpulse, r.m_tangentImpulse = o.tangentImpulse;
        }
      }, m.prototype.SolvePositionConstraints = function (t) {
        void 0 === t && (t = 0);
        for (var e = 0, i = 0; i < this.m_constraintCount; i++) {
          var n = this.m_constraints[i], r = n.bodyA, o = n.bodyB, s = r.m_mass * r.m_invMass, a = r.m_mass * r.m_invI, l = o.m_mass * o.m_invMass, c = o.m_mass * o.m_invI;
          m.s_psm.Initialize(n);
          for (var h = m.s_psm.m_normal, u = 0; u < n.pointCount; u++) {
            var p = n.points[u], d = m.s_psm.m_points[u], _ = m.s_psm.m_separations[u], y = d.x - r.m_sweep.c.x, g = d.y - r.m_sweep.c.y, x = d.x - o.m_sweep.c.x, v = d.y - o.m_sweep.c.y;
            e = e < _ ? e : _;
            var b = A.Clamp(t * (_ + S.b2_linearSlop), -S.b2_maxLinearCorrection, 0), w = -p.equalizedMass * b, M = w * h.x, C = w * h.y;
            r.m_sweep.c.x -= s * M, r.m_sweep.c.y -= s * C, r.m_sweep.a -= a * (y * C - g * M), r.SynchronizeTransform(), o.m_sweep.c.x += l * M, o.m_sweep.c.y += l * C, o.m_sweep.a += c * (x * C - v * M), o.SynchronizeTransform();
          }
        }
        return e > -1.5 * S.b2_linearSlop;
      }, e.postDefs.push(function () {
        e.Dynamics.Contacts.b2ContactSolver.s_worldManifold = new B, e.Dynamics.Contacts.b2ContactSolver.s_psm = new v;
      }), e.inherit(d, e.Dynamics.Contacts.b2Contact), d.prototype.__super = e.Dynamics.Contacts.b2Contact.prototype, d.b2EdgeAndCircleContact = function () {
        e.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
      }, d.Create = function (t) {
        return new d;
      }, d.Destroy = function (t, e) {}, d.prototype.Reset = function (t, e) {
        this.__super.Reset.call(this, t, e);
      }, d.prototype.Evaluate = function () {
        var e = this.m_fixtureA.GetBody(), n = this.m_fixtureB.GetBody();
        this.b2CollideEdgeAndCircle(this.m_manifold, this.m_fixtureA.GetShape() instanceof i ? this.m_fixtureA.GetShape() : null, e.m_xf, this.m_fixtureB.GetShape() instanceof t ? this.m_fixtureB.GetShape() : null, n.m_xf);
      }, d.prototype.b2CollideEdgeAndCircle = function (t, e, i, n, r) {}, e.inherit(_, e.Dynamics.Contacts.b2Contact), _.prototype.__super = e.Dynamics.Contacts.b2Contact.prototype, _.b2NullContact = function () {
        e.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
      }, _.prototype.b2NullContact = function () {
        this.__super.b2Contact.call(this);
      }, _.prototype.Evaluate = function () {}, e.inherit(y, e.Dynamics.Contacts.b2Contact), y.prototype.__super = e.Dynamics.Contacts.b2Contact.prototype, y.b2PolyAndCircleContact = function () {
        e.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
      }, y.Create = function (t) {
        return new y;
      }, y.Destroy = function (t, e) {}, y.prototype.Reset = function (t, e) {
        this.__super.Reset.call(this, t, e), S.b2Assert(t.GetType() == r.e_polygonShape), S.b2Assert(e.GetType() == r.e_circleShape);
      }, y.prototype.Evaluate = function () {
        var e = this.m_fixtureA.m_body, i = this.m_fixtureB.m_body;
        T.CollidePolygonAndCircle(this.m_manifold, this.m_fixtureA.GetShape() instanceof n ? this.m_fixtureA.GetShape() : null, e.m_xf, this.m_fixtureB.GetShape() instanceof t ? this.m_fixtureB.GetShape() : null, i.m_xf);
      }, e.inherit(g, e.Dynamics.Contacts.b2Contact), g.prototype.__super = e.Dynamics.Contacts.b2Contact.prototype, g.b2PolyAndEdgeContact = function () {
        e.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
      }, g.Create = function (t) {
        return new g;
      }, g.Destroy = function (t, e) {}, g.prototype.Reset = function (t, e) {
        this.__super.Reset.call(this, t, e), S.b2Assert(t.GetType() == r.e_polygonShape), S.b2Assert(e.GetType() == r.e_edgeShape);
      }, g.prototype.Evaluate = function () {
        var t = this.m_fixtureA.GetBody(), e = this.m_fixtureB.GetBody();
        this.b2CollidePolyAndEdge(this.m_manifold, this.m_fixtureA.GetShape() instanceof n ? this.m_fixtureA.GetShape() : null, t.m_xf, this.m_fixtureB.GetShape() instanceof i ? this.m_fixtureB.GetShape() : null, e.m_xf);
      }, g.prototype.b2CollidePolyAndEdge = function (t, e, i, n, r) {}, e.inherit(x, e.Dynamics.Contacts.b2Contact), x.prototype.__super = e.Dynamics.Contacts.b2Contact.prototype, x.b2PolygonContact = function () {
        e.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
      }, x.Create = function (t) {
        return new x;
      }, x.Destroy = function (t, e) {}, x.prototype.Reset = function (t, e) {
        this.__super.Reset.call(this, t, e);
      }, x.prototype.Evaluate = function () {
        var t = this.m_fixtureA.GetBody(), e = this.m_fixtureB.GetBody();
        T.CollidePolygons(this.m_manifold, this.m_fixtureA.GetShape() instanceof n ? this.m_fixtureA.GetShape() : null, t.m_xf, this.m_fixtureB.GetShape() instanceof n ? this.m_fixtureB.GetShape() : null, e.m_xf);
      }, v.b2PositionSolverManifold = function () {}, v.prototype.b2PositionSolverManifold = function () {
        this.m_normal = new C, this.m_separations = new W(S.b2_maxManifoldPoints), this.m_points = new H(S.b2_maxManifoldPoints);
        for (var t = 0; t < S.b2_maxManifoldPoints; t++) this.m_points[t] = new C;
      }, v.prototype.Initialize = function (t) {
        S.b2Assert(t.pointCount > 0);
        var e, i, n = 0, r = 0, o = 0, s = 0, a = 0;
        switch (t.type) {
          case L.e_circles:
            e = t.bodyA.m_xf.R, i = t.localPoint;
            var l = t.bodyA.m_xf.position.x + (e.col1.x * i.x + e.col2.x * i.y), c = t.bodyA.m_xf.position.y + (e.col1.y * i.x + e.col2.y * i.y);
            e = t.bodyB.m_xf.R, i = t.points[0].localPoint;
            var h = t.bodyB.m_xf.position.x + (e.col1.x * i.x + e.col2.x * i.y), u = t.bodyB.m_xf.position.y + (e.col1.y * i.x + e.col2.y * i.y), p = h - l, m = u - c, d = p * p + m * m;
            if (d > Number.MIN_VALUE * Number.MIN_VALUE) {
              var _ = Math.sqrt(d);
              this.m_normal.x = p / _, this.m_normal.y = m / _;
            } else this.m_normal.x = 1, this.m_normal.y = 0;
            this.m_points[0].x = 0.5 * (l + h), this.m_points[0].y = 0.5 * (c + u), this.m_separations[0] = p * this.m_normal.x + m * this.m_normal.y - t.radius;
            break;
          case L.e_faceA:
            for (e = t.bodyA.m_xf.R, i = t.localPlaneNormal, this.m_normal.x = e.col1.x * i.x + e.col2.x * i.y, this.m_normal.y = e.col1.y * i.x + e.col2.y * i.y, e = t.bodyA.m_xf.R, i = t.localPoint, s = t.bodyA.m_xf.position.x + (e.col1.x * i.x + e.col2.x * i.y), a = t.bodyA.m_xf.position.y + (e.col1.y * i.x + e.col2.y * i.y), e = t.bodyB.m_xf.R, n = 0; n < t.pointCount; ++n) i = t.points[n].localPoint, r = t.bodyB.m_xf.position.x + (e.col1.x * i.x + e.col2.x * i.y), o = t.bodyB.m_xf.position.y + (e.col1.y * i.x + e.col2.y * i.y), this.m_separations[n] = (r - s) * this.m_normal.x + (o - a) * this.m_normal.y - t.radius, this.m_points[n].x = r, this.m_points[n].y = o;
            break;
          case L.e_faceB:
            for (e = t.bodyB.m_xf.R, i = t.localPlaneNormal, this.m_normal.x = e.col1.x * i.x + e.col2.x * i.y, this.m_normal.y = e.col1.y * i.x + e.col2.y * i.y, e = t.bodyB.m_xf.R, i = t.localPoint, s = t.bodyB.m_xf.position.x + (e.col1.x * i.x + e.col2.x * i.y), a = t.bodyB.m_xf.position.y + (e.col1.y * i.x + e.col2.y * i.y), e = t.bodyA.m_xf.R, n = 0; n < t.pointCount; ++n) i = t.points[n].localPoint, r = t.bodyA.m_xf.position.x + (e.col1.x * i.x + e.col2.x * i.y), o = t.bodyA.m_xf.position.y + (e.col1.y * i.x + e.col2.y * i.y), this.m_separations[n] = (r - s) * this.m_normal.x + (o - a) * this.m_normal.y - t.radius, this.m_points[n].Set(r, o);
            this.m_normal.x *= -1, this.m_normal.y *= -1;
        }
      }, e.postDefs.push(function () {
        e.Dynamics.Contacts.b2PositionSolverManifold.circlePointA = new C, e.Dynamics.Contacts.b2PositionSolverManifold.circlePointB = new C;
      });
    }(), function () {
      e.Dynamics.b2Body, e.Dynamics.b2BodyDef, e.Dynamics.b2ContactFilter, e.Dynamics.b2ContactImpulse, e.Dynamics.b2ContactListener, e.Dynamics.b2ContactManager, e.Dynamics.b2DebugDraw, e.Dynamics.b2DestructionListener, e.Dynamics.b2FilterData, e.Dynamics.b2Fixture, e.Dynamics.b2FixtureDef, e.Dynamics.b2Island, e.Dynamics.b2TimeStep, e.Dynamics.b2World;
      var t = e.Common.Math.b2Mat22, i = (e.Common.Math.b2Mat33, e.Common.Math.b2Math), n = (e.Common.Math.b2Sweep, e.Common.Math.b2Transform, e.Common.Math.b2Vec2), r = (e.Common.Math.b2Vec3, e.Common.b2Color), o = (e.Common.b2internal, e.Common.b2Settings, e.Collision.Shapes.b2CircleShape, e.Collision.Shapes.b2EdgeChainDef, e.Collision.Shapes.b2EdgeShape, e.Collision.Shapes.b2MassData, e.Collision.Shapes.b2PolygonShape, e.Collision.Shapes.b2Shape, e.Dynamics.Controllers.b2BuoyancyController), s = e.Dynamics.Controllers.b2ConstantAccelController, a = e.Dynamics.Controllers.b2ConstantForceController, l = e.Dynamics.Controllers.b2Controller, c = e.Dynamics.Controllers.b2ControllerEdge, h = e.Dynamics.Controllers.b2GravityController, u = e.Dynamics.Controllers.b2TensorDampingController;
      e.inherit(o, e.Dynamics.Controllers.b2Controller), o.prototype.__super = e.Dynamics.Controllers.b2Controller.prototype, o.b2BuoyancyController = function () {
        e.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments), this.normal = new n(0, -1), this.offset = 0, this.density = 0, this.velocity = new n(0, 0), this.linearDrag = 2, this.angularDrag = 1, this.useDensity = false, this.useWorldGravity = true, this.gravity = null;
      }, o.prototype.Step = function (t) {
        if (this.m_bodyList) {
          this.useWorldGravity && (this.gravity = this.GetWorld().GetGravity().Copy());
          for (var e = this.m_bodyList; e; e = e.nextBody) {
            var i = e.body;
            if (0 != i.IsAwake()) {
              for (var r = new n, o = new n, s = 0, a = 0, l = i.GetFixtureList(); l; l = l.GetNext()) {
                var c = new n, h = l.GetShape().ComputeSubmergedArea(this.normal, this.offset, i.GetTransform(), c);
                s += h, r.x += h * c.x, r.y += h * c.y;
                var u = 0;
                a += h * (u = (this.useDensity, 1)), o.x += h * c.x * u, o.y += h * c.y * u;
              }
              if (r.x /= s, r.y /= s, o.x /= a, o.y /= a, !(s < Number.MIN_VALUE)) {
                var p = this.gravity.GetNegative();
                p.Multiply(this.density * s), i.ApplyForce(p, o);
                var m = i.GetLinearVelocityFromWorldPoint(r);
                m.Subtract(this.velocity), m.Multiply(-this.linearDrag * s), i.ApplyForce(m, r), i.ApplyTorque(-i.GetInertia() / i.GetMass() * s * i.GetAngularVelocity() * this.angularDrag);
              }
            }
          }
        }
      }, o.prototype.Draw = function (t) {
        var e = 1e3, i = new n, o = new n;
        i.x = this.normal.x * this.offset + this.normal.y * e, i.y = this.normal.y * this.offset - this.normal.x * e, o.x = this.normal.x * this.offset - this.normal.y * e, o.y = this.normal.y * this.offset + this.normal.x * e;
        var s = new r(0, 0, 1);
        t.DrawSegment(i, o, s);
      }, e.inherit(s, e.Dynamics.Controllers.b2Controller), s.prototype.__super = e.Dynamics.Controllers.b2Controller.prototype, s.b2ConstantAccelController = function () {
        e.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments), this.A = new n(0, 0);
      }, s.prototype.Step = function (t) {
        for (var e = new n(this.A.x * t.dt, this.A.y * t.dt), i = this.m_bodyList; i; i = i.nextBody) {
          var r = i.body;
          r.IsAwake() && r.SetLinearVelocity(new n(r.GetLinearVelocity().x + e.x, r.GetLinearVelocity().y + e.y));
        }
      }, e.inherit(a, e.Dynamics.Controllers.b2Controller), a.prototype.__super = e.Dynamics.Controllers.b2Controller.prototype, a.b2ConstantForceController = function () {
        e.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments), this.F = new n(0, 0);
      }, a.prototype.Step = function (t) {
        for (var e = this.m_bodyList; e; e = e.nextBody) {
          var i = e.body;
          i.IsAwake() && i.ApplyForce(this.F, i.GetWorldCenter());
        }
      }, l.b2Controller = function () {}, l.prototype.Step = function (t) {}, l.prototype.Draw = function (t) {}, l.prototype.AddBody = function (t) {
        var e = new c;
        e.controller = this, e.body = t, e.nextBody = this.m_bodyList, e.prevBody = null, this.m_bodyList = e, e.nextBody && (e.nextBody.prevBody = e), this.m_bodyCount++, e.nextController = t.m_controllerList, e.prevController = null, t.m_controllerList = e, e.nextController && (e.nextController.prevController = e), t.m_controllerCount++;
      }, l.prototype.RemoveBody = function (t) {
        for (var e = t.m_controllerList; e && e.controller != this;) e = e.nextController;
        e.prevBody && (e.prevBody.nextBody = e.nextBody), e.nextBody && (e.nextBody.prevBody = e.prevBody), e.nextController && (e.nextController.prevController = e.prevController), e.prevController && (e.prevController.nextController = e.nextController), this.m_bodyList == e && (this.m_bodyList = e.nextBody), t.m_controllerList == e && (t.m_controllerList = e.nextController), t.m_controllerCount--, this.m_bodyCount--;
      }, l.prototype.Clear = function () {
        for (; this.m_bodyList;) this.RemoveBody(this.m_bodyList.body);
      }, l.prototype.GetNext = function () {
        return this.m_next;
      }, l.prototype.GetWorld = function () {
        return this.m_world;
      }, l.prototype.GetBodyList = function () {
        return this.m_bodyList;
      }, c.b2ControllerEdge = function () {}, e.inherit(h, e.Dynamics.Controllers.b2Controller), h.prototype.__super = e.Dynamics.Controllers.b2Controller.prototype, h.b2GravityController = function () {
        e.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments), this.G = 1, this.invSqr = true;
      }, h.prototype.Step = function (t) {
        var e = null, i = null, r = null, o = 0, s = null, a = null, l = null, c = 0, h = 0, u = 0, p = null;
        if (this.invSqr) for (e = this.m_bodyList; e; e = e.nextBody) for (r = (i = e.body).GetWorldCenter(), o = i.GetMass(), s = this.m_bodyList; s != e; s = s.nextBody) (u = (c = (l = (a = s.body).GetWorldCenter()).x - r.x) * c + (h = l.y - r.y) * h) < Number.MIN_VALUE || ((p = new n(c, h)).Multiply(this.G / u / Math.sqrt(u) * o * a.GetMass()), i.IsAwake() && i.ApplyForce(p, r), p.Multiply(-1), a.IsAwake() && a.ApplyForce(p, l)); else for (e = this.m_bodyList; e; e = e.nextBody) for (r = (i = e.body).GetWorldCenter(), o = i.GetMass(), s = this.m_bodyList; s != e; s = s.nextBody) (u = (c = (l = (a = s.body).GetWorldCenter()).x - r.x) * c + (h = l.y - r.y) * h) < Number.MIN_VALUE || ((p = new n(c, h)).Multiply(this.G / u * o * a.GetMass()), i.IsAwake() && i.ApplyForce(p, r), p.Multiply(-1), a.IsAwake() && a.ApplyForce(p, l));
      }, e.inherit(u, e.Dynamics.Controllers.b2Controller), u.prototype.__super = e.Dynamics.Controllers.b2Controller.prototype, u.b2TensorDampingController = function () {
        e.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments), this.T = new t, this.maxTimestep = 0;
      }, u.prototype.SetAxisAligned = function (t, e) {
        void 0 === t && (t = 0), void 0 === e && (e = 0), this.T.col1.x = -t, this.T.col1.y = 0, this.T.col2.x = 0, this.T.col2.y = -e, this.maxTimestep = t > 0 || e > 0 ? 1 / Math.max(t, e) : 0;
      }, u.prototype.Step = function (t) {
        var e = t.dt;
        if (!(e <= Number.MIN_VALUE)) {
          e > this.maxTimestep && this.maxTimestep > 0 && (e = this.maxTimestep);
          for (var r = this.m_bodyList; r; r = r.nextBody) {
            var o = r.body;
            if (o.IsAwake()) {
              var s = o.GetWorldVector(i.MulMV(this.T, o.GetLocalVector(o.GetLinearVelocity())));
              o.SetLinearVelocity(new n(o.GetLinearVelocity().x + s.x * e, o.GetLinearVelocity().y + s.y * e));
            }
          }
        }
      };
    }(), function () {
      e.Common.b2Color, e.Common.b2internal;
      var t = e.Common.b2Settings, i = e.Common.Math.b2Mat22, n = e.Common.Math.b2Mat33, r = e.Common.Math.b2Math, o = (e.Common.Math.b2Sweep, e.Common.Math.b2Transform, e.Common.Math.b2Vec2), s = e.Common.Math.b2Vec3, a = e.Dynamics.Joints.b2DistanceJoint, l = e.Dynamics.Joints.b2DistanceJointDef, c = e.Dynamics.Joints.b2FrictionJoint, h = e.Dynamics.Joints.b2FrictionJointDef, u = e.Dynamics.Joints.b2GearJoint, p = e.Dynamics.Joints.b2GearJointDef, m = e.Dynamics.Joints.b2Jacobian, d = e.Dynamics.Joints.b2Joint, _ = e.Dynamics.Joints.b2JointDef, y = e.Dynamics.Joints.b2JointEdge, g = e.Dynamics.Joints.b2LineJoint, x = e.Dynamics.Joints.b2LineJointDef, v = e.Dynamics.Joints.b2MouseJoint, b = e.Dynamics.Joints.b2MouseJointDef, w = e.Dynamics.Joints.b2PrismaticJoint, S = e.Dynamics.Joints.b2PrismaticJointDef, M = e.Dynamics.Joints.b2PulleyJoint, A = e.Dynamics.Joints.b2PulleyJointDef, C = e.Dynamics.Joints.b2RevoluteJoint, T = e.Dynamics.Joints.b2RevoluteJointDef, E = e.Dynamics.Joints.b2WeldJoint, L = e.Dynamics.Joints.b2WeldJointDef;
      e.Dynamics.b2Body, e.Dynamics.b2BodyDef, e.Dynamics.b2ContactFilter, e.Dynamics.b2ContactImpulse, e.Dynamics.b2ContactListener, e.Dynamics.b2ContactManager, e.Dynamics.b2DebugDraw, e.Dynamics.b2DestructionListener, e.Dynamics.b2FilterData, e.Dynamics.b2Fixture, e.Dynamics.b2FixtureDef, e.Dynamics.b2Island, e.Dynamics.b2TimeStep, e.Dynamics.b2World;
      e.inherit(a, e.Dynamics.Joints.b2Joint), a.prototype.__super = e.Dynamics.Joints.b2Joint.prototype, a.b2DistanceJoint = function () {
        e.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments), this.m_localAnchor1 = new o, this.m_localAnchor2 = new o, this.m_u = new o;
      }, a.prototype.GetAnchorA = function () {
        return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
      }, a.prototype.GetAnchorB = function () {
        return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
      }, a.prototype.GetReactionForce = function (t) {
        return void 0 === t && (t = 0), new o(t * this.m_impulse * this.m_u.x, t * this.m_impulse * this.m_u.y);
      }, a.prototype.GetReactionTorque = function (t) {
        return void 0 === t && (t = 0), 0;
      }, a.prototype.GetLength = function () {
        return this.m_length;
      }, a.prototype.SetLength = function (t) {
        void 0 === t && (t = 0), this.m_length = t;
      }, a.prototype.GetFrequency = function () {
        return this.m_frequencyHz;
      }, a.prototype.SetFrequency = function (t) {
        void 0 === t && (t = 0), this.m_frequencyHz = t;
      }, a.prototype.GetDampingRatio = function () {
        return this.m_dampingRatio;
      }, a.prototype.SetDampingRatio = function (t) {
        void 0 === t && (t = 0), this.m_dampingRatio = t;
      }, a.prototype.b2DistanceJoint = function (t) {
        this.__super.b2Joint.call(this, t);
        this.m_localAnchor1.SetV(t.localAnchorA), this.m_localAnchor2.SetV(t.localAnchorB), this.m_length = t.length, this.m_frequencyHz = t.frequencyHz, this.m_dampingRatio = t.dampingRatio, this.m_impulse = 0, this.m_gamma = 0, this.m_bias = 0;
      }, a.prototype.InitVelocityConstraints = function (e) {
        var i, n = 0, r = this.m_bodyA, o = this.m_bodyB;
        i = r.m_xf.R;
        var s = this.m_localAnchor1.x - r.m_sweep.localCenter.x, a = this.m_localAnchor1.y - r.m_sweep.localCenter.y;
        n = i.col1.x * s + i.col2.x * a, a = i.col1.y * s + i.col2.y * a, s = n, i = o.m_xf.R;
        var l = this.m_localAnchor2.x - o.m_sweep.localCenter.x, c = this.m_localAnchor2.y - o.m_sweep.localCenter.y;
        n = i.col1.x * l + i.col2.x * c, c = i.col1.y * l + i.col2.y * c, l = n, this.m_u.x = o.m_sweep.c.x + l - r.m_sweep.c.x - s, this.m_u.y = o.m_sweep.c.y + c - r.m_sweep.c.y - a;
        var h = Math.sqrt(this.m_u.x * this.m_u.x + this.m_u.y * this.m_u.y);
        h > t.b2_linearSlop ? this.m_u.Multiply(1 / h) : this.m_u.SetZero();
        var u = s * this.m_u.y - a * this.m_u.x, p = l * this.m_u.y - c * this.m_u.x, m = r.m_invMass + r.m_invI * u * u + o.m_invMass + o.m_invI * p * p;
        if (this.m_mass = 0 != m ? 1 / m : 0, this.m_frequencyHz > 0) {
          var d = h - this.m_length, _ = 2 * Math.PI * this.m_frequencyHz, y = 2 * this.m_mass * this.m_dampingRatio * _, g = this.m_mass * _ * _;
          this.m_gamma = e.dt * (y + e.dt * g), this.m_gamma = 0 != this.m_gamma ? 1 / this.m_gamma : 0, this.m_bias = d * e.dt * g * this.m_gamma, this.m_mass = m + this.m_gamma, this.m_mass = 0 != this.m_mass ? 1 / this.m_mass : 0;
        }
        if (e.warmStarting) {
          this.m_impulse *= e.dtRatio;
          var x = this.m_impulse * this.m_u.x, v = this.m_impulse * this.m_u.y;
          r.m_linearVelocity.x -= r.m_invMass * x, r.m_linearVelocity.y -= r.m_invMass * v, r.m_angularVelocity -= r.m_invI * (s * v - a * x), o.m_linearVelocity.x += o.m_invMass * x, o.m_linearVelocity.y += o.m_invMass * v, o.m_angularVelocity += o.m_invI * (l * v - c * x);
        } else this.m_impulse = 0;
      }, a.prototype.SolveVelocityConstraints = function (t) {
        var e, i = this.m_bodyA, n = this.m_bodyB;
        e = i.m_xf.R;
        var r = this.m_localAnchor1.x - i.m_sweep.localCenter.x, o = this.m_localAnchor1.y - i.m_sweep.localCenter.y, s = e.col1.x * r + e.col2.x * o;
        o = e.col1.y * r + e.col2.y * o, r = s, e = n.m_xf.R;
        var a = this.m_localAnchor2.x - n.m_sweep.localCenter.x, l = this.m_localAnchor2.y - n.m_sweep.localCenter.y;
        s = e.col1.x * a + e.col2.x * l, l = e.col1.y * a + e.col2.y * l, a = s;
        var c = i.m_linearVelocity.x + -i.m_angularVelocity * o, h = i.m_linearVelocity.y + i.m_angularVelocity * r, u = n.m_linearVelocity.x + -n.m_angularVelocity * l, p = n.m_linearVelocity.y + n.m_angularVelocity * a, m = this.m_u.x * (u - c) + this.m_u.y * (p - h), d = -this.m_mass * (m + this.m_bias + this.m_gamma * this.m_impulse);
        this.m_impulse += d;
        var _ = d * this.m_u.x, y = d * this.m_u.y;
        i.m_linearVelocity.x -= i.m_invMass * _, i.m_linearVelocity.y -= i.m_invMass * y, i.m_angularVelocity -= i.m_invI * (r * y - o * _), n.m_linearVelocity.x += n.m_invMass * _, n.m_linearVelocity.y += n.m_invMass * y, n.m_angularVelocity += n.m_invI * (a * y - l * _);
      }, a.prototype.SolvePositionConstraints = function (e) {
        var i;
        if (void 0 === e && (e = 0), this.m_frequencyHz > 0) return true;
        var n = this.m_bodyA, o = this.m_bodyB;
        i = n.m_xf.R;
        var s = this.m_localAnchor1.x - n.m_sweep.localCenter.x, a = this.m_localAnchor1.y - n.m_sweep.localCenter.y, l = i.col1.x * s + i.col2.x * a;
        a = i.col1.y * s + i.col2.y * a, s = l, i = o.m_xf.R;
        var c = this.m_localAnchor2.x - o.m_sweep.localCenter.x, h = this.m_localAnchor2.y - o.m_sweep.localCenter.y;
        l = i.col1.x * c + i.col2.x * h, h = i.col1.y * c + i.col2.y * h, c = l;
        var u = o.m_sweep.c.x + c - n.m_sweep.c.x - s, p = o.m_sweep.c.y + h - n.m_sweep.c.y - a, m = Math.sqrt(u * u + p * p);
        u /= m, p /= m;
        var d = m - this.m_length;
        d = r.Clamp(d, -t.b2_maxLinearCorrection, t.b2_maxLinearCorrection);
        var _ = -this.m_mass * d;
        this.m_u.Set(u, p);
        var y = _ * this.m_u.x, g = _ * this.m_u.y;
        return n.m_sweep.c.x -= n.m_invMass * y, n.m_sweep.c.y -= n.m_invMass * g, n.m_sweep.a -= n.m_invI * (s * g - a * y), o.m_sweep.c.x += o.m_invMass * y, o.m_sweep.c.y += o.m_invMass * g, o.m_sweep.a += o.m_invI * (c * g - h * y), n.SynchronizeTransform(), o.SynchronizeTransform(), r.Abs(d) < t.b2_linearSlop;
      }, e.inherit(l, e.Dynamics.Joints.b2JointDef), l.prototype.__super = e.Dynamics.Joints.b2JointDef.prototype, l.b2DistanceJointDef = function () {
        e.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments), this.localAnchorA = new o, this.localAnchorB = new o;
      }, l.prototype.b2DistanceJointDef = function () {
        this.__super.b2JointDef.call(this), this.type = d.e_distanceJoint, this.length = 1, this.frequencyHz = 0, this.dampingRatio = 0;
      }, l.prototype.Initialize = function (t, e, i, n) {
        this.bodyA = t, this.bodyB = e, this.localAnchorA.SetV(this.bodyA.GetLocalPoint(i)), this.localAnchorB.SetV(this.bodyB.GetLocalPoint(n));
        var r = n.x - i.x, o = n.y - i.y;
        this.length = Math.sqrt(r * r + o * o), this.frequencyHz = 0, this.dampingRatio = 0;
      }, e.inherit(c, e.Dynamics.Joints.b2Joint), c.prototype.__super = e.Dynamics.Joints.b2Joint.prototype, c.b2FrictionJoint = function () {
        e.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments), this.m_localAnchorA = new o, this.m_localAnchorB = new o, this.m_linearMass = new i, this.m_linearImpulse = new o;
      }, c.prototype.GetAnchorA = function () {
        return this.m_bodyA.GetWorldPoint(this.m_localAnchorA);
      }, c.prototype.GetAnchorB = function () {
        return this.m_bodyB.GetWorldPoint(this.m_localAnchorB);
      }, c.prototype.GetReactionForce = function (t) {
        return void 0 === t && (t = 0), new o(t * this.m_linearImpulse.x, t * this.m_linearImpulse.y);
      }, c.prototype.GetReactionTorque = function (t) {
        return void 0 === t && (t = 0), t * this.m_angularImpulse;
      }, c.prototype.SetMaxForce = function (t) {
        void 0 === t && (t = 0), this.m_maxForce = t;
      }, c.prototype.GetMaxForce = function () {
        return this.m_maxForce;
      }, c.prototype.SetMaxTorque = function (t) {
        void 0 === t && (t = 0), this.m_maxTorque = t;
      }, c.prototype.GetMaxTorque = function () {
        return this.m_maxTorque;
      }, c.prototype.b2FrictionJoint = function (t) {
        this.__super.b2Joint.call(this, t), this.m_localAnchorA.SetV(t.localAnchorA), this.m_localAnchorB.SetV(t.localAnchorB), this.m_linearMass.SetZero(), this.m_angularMass = 0, this.m_linearImpulse.SetZero(), this.m_angularImpulse = 0, this.m_maxForce = t.maxForce, this.m_maxTorque = t.maxTorque;
      }, c.prototype.InitVelocityConstraints = function (t) {
        var e, n = 0, r = this.m_bodyA, o = this.m_bodyB;
        e = r.m_xf.R;
        var s = this.m_localAnchorA.x - r.m_sweep.localCenter.x, a = this.m_localAnchorA.y - r.m_sweep.localCenter.y;
        n = e.col1.x * s + e.col2.x * a, a = e.col1.y * s + e.col2.y * a, s = n, e = o.m_xf.R;
        var l = this.m_localAnchorB.x - o.m_sweep.localCenter.x, c = this.m_localAnchorB.y - o.m_sweep.localCenter.y;
        n = e.col1.x * l + e.col2.x * c, c = e.col1.y * l + e.col2.y * c, l = n;
        var h = r.m_invMass, u = o.m_invMass, p = r.m_invI, m = o.m_invI, d = new i;
        if (d.col1.x = h + u, d.col2.x = 0, d.col1.y = 0, d.col2.y = h + u, d.col1.x += p * a * a, d.col2.x += -p * s * a, d.col1.y += -p * s * a, d.col2.y += p * s * s, d.col1.x += m * c * c, d.col2.x += -m * l * c, d.col1.y += -m * l * c, d.col2.y += m * l * l, d.GetInverse(this.m_linearMass), this.m_angularMass = p + m, this.m_angularMass > 0 && (this.m_angularMass = 1 / this.m_angularMass), t.warmStarting) {
          this.m_linearImpulse.x *= t.dtRatio, this.m_linearImpulse.y *= t.dtRatio, this.m_angularImpulse *= t.dtRatio;
          var _ = this.m_linearImpulse;
          r.m_linearVelocity.x -= h * _.x, r.m_linearVelocity.y -= h * _.y, r.m_angularVelocity -= p * (s * _.y - a * _.x + this.m_angularImpulse), o.m_linearVelocity.x += u * _.x, o.m_linearVelocity.y += u * _.y, o.m_angularVelocity += m * (l * _.y - c * _.x + this.m_angularImpulse);
        } else this.m_linearImpulse.SetZero(), this.m_angularImpulse = 0;
      }, c.prototype.SolveVelocityConstraints = function (t) {
        var e, i = 0, n = this.m_bodyA, s = this.m_bodyB, a = n.m_linearVelocity, l = n.m_angularVelocity, c = s.m_linearVelocity, h = s.m_angularVelocity, u = n.m_invMass, p = s.m_invMass, m = n.m_invI, d = s.m_invI;
        e = n.m_xf.R;
        var _ = this.m_localAnchorA.x - n.m_sweep.localCenter.x, y = this.m_localAnchorA.y - n.m_sweep.localCenter.y;
        i = e.col1.x * _ + e.col2.x * y, y = e.col1.y * _ + e.col2.y * y, _ = i, e = s.m_xf.R;
        var g = this.m_localAnchorB.x - s.m_sweep.localCenter.x, x = this.m_localAnchorB.y - s.m_sweep.localCenter.y;
        i = e.col1.x * g + e.col2.x * x, x = e.col1.y * g + e.col2.y * x, g = i;
        var v = 0, b = h - l, w = -this.m_angularMass * b, S = this.m_angularImpulse;
        v = t.dt * this.m_maxTorque, this.m_angularImpulse = r.Clamp(this.m_angularImpulse + w, -v, v), l -= m * (w = this.m_angularImpulse - S), h += d * w;
        var M = c.x - h * x - a.x + l * y, A = c.y + h * g - a.y - l * _, C = r.MulMV(this.m_linearMass, new o(-M, -A)), T = this.m_linearImpulse.Copy();
        this.m_linearImpulse.Add(C), v = t.dt * this.m_maxForce, this.m_linearImpulse.LengthSquared() > v * v && (this.m_linearImpulse.Normalize(), this.m_linearImpulse.Multiply(v)), C = r.SubtractVV(this.m_linearImpulse, T), a.x -= u * C.x, a.y -= u * C.y, l -= m * (_ * C.y - y * C.x), c.x += p * C.x, c.y += p * C.y, h += d * (g * C.y - x * C.x), n.m_angularVelocity = l, s.m_angularVelocity = h;
      }, c.prototype.SolvePositionConstraints = function (t) {
        return void 0 === t && (t = 0), true;
      }, e.inherit(h, e.Dynamics.Joints.b2JointDef), h.prototype.__super = e.Dynamics.Joints.b2JointDef.prototype, h.b2FrictionJointDef = function () {
        e.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments), this.localAnchorA = new o, this.localAnchorB = new o;
      }, h.prototype.b2FrictionJointDef = function () {
        this.__super.b2JointDef.call(this), this.type = d.e_frictionJoint, this.maxForce = 0, this.maxTorque = 0;
      }, h.prototype.Initialize = function (t, e, i) {
        this.bodyA = t, this.bodyB = e, this.localAnchorA.SetV(this.bodyA.GetLocalPoint(i)), this.localAnchorB.SetV(this.bodyB.GetLocalPoint(i));
      }, e.inherit(u, e.Dynamics.Joints.b2Joint), u.prototype.__super = e.Dynamics.Joints.b2Joint.prototype, u.b2GearJoint = function () {
        e.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments), this.m_groundAnchor1 = new o, this.m_groundAnchor2 = new o, this.m_localAnchor1 = new o, this.m_localAnchor2 = new o, this.m_J = new m;
      }, u.prototype.GetAnchorA = function () {
        return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
      }, u.prototype.GetAnchorB = function () {
        return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
      }, u.prototype.GetReactionForce = function (t) {
        return void 0 === t && (t = 0), new o(t * this.m_impulse * this.m_J.linearB.x, t * this.m_impulse * this.m_J.linearB.y);
      }, u.prototype.GetReactionTorque = function (t) {
        void 0 === t && (t = 0);
        var e = this.m_bodyB.m_xf.R, i = this.m_localAnchor1.x - this.m_bodyB.m_sweep.localCenter.x, n = this.m_localAnchor1.y - this.m_bodyB.m_sweep.localCenter.y, r = e.col1.x * i + e.col2.x * n;
        n = e.col1.y * i + e.col2.y * n, i = r;
        var o = this.m_impulse * this.m_J.linearB.x, s = this.m_impulse * this.m_J.linearB.y;
        return t * (this.m_impulse * this.m_J.angularB - i * s + n * o);
      }, u.prototype.GetRatio = function () {
        return this.m_ratio;
      }, u.prototype.SetRatio = function (t) {
        void 0 === t && (t = 0), this.m_ratio = t;
      }, u.prototype.b2GearJoint = function (t) {
        this.__super.b2Joint.call(this, t);
        var e = parseInt(t.joint1.m_type), i = parseInt(t.joint2.m_type);
        this.m_revolute1 = null, this.m_prismatic1 = null, this.m_revolute2 = null, this.m_prismatic2 = null;
        var n = 0, r = 0;
        this.m_ground1 = t.joint1.GetBodyA(), this.m_bodyA = t.joint1.GetBodyB(), e == d.e_revoluteJoint ? (this.m_revolute1 = t.joint1 instanceof C ? t.joint1 : null, this.m_groundAnchor1.SetV(this.m_revolute1.m_localAnchor1), this.m_localAnchor1.SetV(this.m_revolute1.m_localAnchor2), n = this.m_revolute1.GetJointAngle()) : (this.m_prismatic1 = t.joint1 instanceof w ? t.joint1 : null, this.m_groundAnchor1.SetV(this.m_prismatic1.m_localAnchor1), this.m_localAnchor1.SetV(this.m_prismatic1.m_localAnchor2), n = this.m_prismatic1.GetJointTranslation()), this.m_ground2 = t.joint2.GetBodyA(), this.m_bodyB = t.joint2.GetBodyB(), i == d.e_revoluteJoint ? (this.m_revolute2 = t.joint2 instanceof C ? t.joint2 : null, this.m_groundAnchor2.SetV(this.m_revolute2.m_localAnchor1), this.m_localAnchor2.SetV(this.m_revolute2.m_localAnchor2), r = this.m_revolute2.GetJointAngle()) : (this.m_prismatic2 = t.joint2 instanceof w ? t.joint2 : null, this.m_groundAnchor2.SetV(this.m_prismatic2.m_localAnchor1), this.m_localAnchor2.SetV(this.m_prismatic2.m_localAnchor2), r = this.m_prismatic2.GetJointTranslation()), this.m_ratio = t.ratio, this.m_constant = n + this.m_ratio * r, this.m_impulse = 0;
      }, u.prototype.InitVelocityConstraints = function (t) {
        var e, i, n = this.m_ground1, r = this.m_ground2, o = this.m_bodyA, s = this.m_bodyB, a = 0, l = 0, c = 0, h = 0, u = 0, p = 0, m = 0;
        this.m_J.SetZero(), this.m_revolute1 ? (this.m_J.angularA = -1, m += o.m_invI) : (e = n.m_xf.R, i = this.m_prismatic1.m_localXAxis1, a = e.col1.x * i.x + e.col2.x * i.y, l = e.col1.y * i.x + e.col2.y * i.y, e = o.m_xf.R, c = this.m_localAnchor1.x - o.m_sweep.localCenter.x, h = this.m_localAnchor1.y - o.m_sweep.localCenter.y, p = e.col1.x * c + e.col2.x * h, h = e.col1.y * c + e.col2.y * h, u = (c = p) * l - h * a, this.m_J.linearA.Set(-a, -l), this.m_J.angularA = -u, m += o.m_invMass + o.m_invI * u * u), this.m_revolute2 ? (this.m_J.angularB = -this.m_ratio, m += this.m_ratio * this.m_ratio * s.m_invI) : (e = r.m_xf.R, i = this.m_prismatic2.m_localXAxis1, a = e.col1.x * i.x + e.col2.x * i.y, l = e.col1.y * i.x + e.col2.y * i.y, e = s.m_xf.R, c = this.m_localAnchor2.x - s.m_sweep.localCenter.x, h = this.m_localAnchor2.y - s.m_sweep.localCenter.y, p = e.col1.x * c + e.col2.x * h, h = e.col1.y * c + e.col2.y * h, u = (c = p) * l - h * a, this.m_J.linearB.Set(-this.m_ratio * a, -this.m_ratio * l), this.m_J.angularB = -this.m_ratio * u, m += this.m_ratio * this.m_ratio * (s.m_invMass + s.m_invI * u * u)), this.m_mass = m > 0 ? 1 / m : 0, t.warmStarting ? (o.m_linearVelocity.x += o.m_invMass * this.m_impulse * this.m_J.linearA.x, o.m_linearVelocity.y += o.m_invMass * this.m_impulse * this.m_J.linearA.y, o.m_angularVelocity += o.m_invI * this.m_impulse * this.m_J.angularA, s.m_linearVelocity.x += s.m_invMass * this.m_impulse * this.m_J.linearB.x, s.m_linearVelocity.y += s.m_invMass * this.m_impulse * this.m_J.linearB.y, s.m_angularVelocity += s.m_invI * this.m_impulse * this.m_J.angularB) : this.m_impulse = 0;
      }, u.prototype.SolveVelocityConstraints = function (t) {
        var e = this.m_bodyA, i = this.m_bodyB, n = this.m_J.Compute(e.m_linearVelocity, e.m_angularVelocity, i.m_linearVelocity, i.m_angularVelocity), r = -this.m_mass * n;
        this.m_impulse += r, e.m_linearVelocity.x += e.m_invMass * r * this.m_J.linearA.x, e.m_linearVelocity.y += e.m_invMass * r * this.m_J.linearA.y, e.m_angularVelocity += e.m_invI * r * this.m_J.angularA, i.m_linearVelocity.x += i.m_invMass * r * this.m_J.linearB.x, i.m_linearVelocity.y += i.m_invMass * r * this.m_J.linearB.y, i.m_angularVelocity += i.m_invI * r * this.m_J.angularB;
      }, u.prototype.SolvePositionConstraints = function (e) {
        void 0 === e && (e = 0);
        var i = this.m_bodyA, n = this.m_bodyB, r = 0, o = 0;
        r = this.m_revolute1 ? this.m_revolute1.GetJointAngle() : this.m_prismatic1.GetJointTranslation(), o = this.m_revolute2 ? this.m_revolute2.GetJointAngle() : this.m_prismatic2.GetJointTranslation();
        var s = this.m_constant - (r + this.m_ratio * o), a = -this.m_mass * s;
        return i.m_sweep.c.x += i.m_invMass * a * this.m_J.linearA.x, i.m_sweep.c.y += i.m_invMass * a * this.m_J.linearA.y, i.m_sweep.a += i.m_invI * a * this.m_J.angularA, n.m_sweep.c.x += n.m_invMass * a * this.m_J.linearB.x, n.m_sweep.c.y += n.m_invMass * a * this.m_J.linearB.y, n.m_sweep.a += n.m_invI * a * this.m_J.angularB, i.SynchronizeTransform(), n.SynchronizeTransform(), 0 < t.b2_linearSlop;
      }, e.inherit(p, e.Dynamics.Joints.b2JointDef), p.prototype.__super = e.Dynamics.Joints.b2JointDef.prototype, p.b2GearJointDef = function () {
        e.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
      }, p.prototype.b2GearJointDef = function () {
        this.__super.b2JointDef.call(this), this.type = d.e_gearJoint, this.joint1 = null, this.joint2 = null, this.ratio = 1;
      }, m.b2Jacobian = function () {
        this.linearA = new o, this.linearB = new o;
      }, m.prototype.SetZero = function () {
        this.linearA.SetZero(), this.angularA = 0, this.linearB.SetZero(), this.angularB = 0;
      }, m.prototype.Set = function (t, e, i, n) {
        void 0 === e && (e = 0), void 0 === n && (n = 0), this.linearA.SetV(t), this.angularA = e, this.linearB.SetV(i), this.angularB = n;
      }, m.prototype.Compute = function (t, e, i, n) {
        return void 0 === e && (e = 0), void 0 === n && (n = 0), this.linearA.x * t.x + this.linearA.y * t.y + this.angularA * e + (this.linearB.x * i.x + this.linearB.y * i.y) + this.angularB * n;
      }, d.b2Joint = function () {
        this.m_edgeA = new y, this.m_edgeB = new y, this.m_localCenterA = new o, this.m_localCenterB = new o;
      }, d.prototype.GetType = function () {
        return this.m_type;
      }, d.prototype.GetAnchorA = function () {
        return null;
      }, d.prototype.GetAnchorB = function () {
        return null;
      }, d.prototype.GetReactionForce = function (t) {
        return void 0 === t && (t = 0), null;
      }, d.prototype.GetReactionTorque = function (t) {
        return void 0 === t && (t = 0), 0;
      }, d.prototype.GetBodyA = function () {
        return this.m_bodyA;
      }, d.prototype.GetBodyB = function () {
        return this.m_bodyB;
      }, d.prototype.GetNext = function () {
        return this.m_next;
      }, d.prototype.GetUserData = function () {
        return this.m_userData;
      }, d.prototype.SetUserData = function (t) {
        this.m_userData = t;
      }, d.prototype.IsActive = function () {
        return this.m_bodyA.IsActive() && this.m_bodyB.IsActive();
      }, d.Create = function (t, e) {
        var i = null;
        switch (t.type) {
          case d.e_distanceJoint:
            i = new a(t instanceof l ? t : null);
            break;
          case d.e_mouseJoint:
            i = new v(t instanceof b ? t : null);
            break;
          case d.e_prismaticJoint:
            i = new w(t instanceof S ? t : null);
            break;
          case d.e_revoluteJoint:
            i = new C(t instanceof T ? t : null);
            break;
          case d.e_pulleyJoint:
            i = new M(t instanceof A ? t : null);
            break;
          case d.e_gearJoint:
            i = new u(t instanceof p ? t : null);
            break;
          case d.e_lineJoint:
            i = new g(t instanceof x ? t : null);
            break;
          case d.e_weldJoint:
            i = new E(t instanceof L ? t : null);
            break;
          case d.e_frictionJoint:
            i = new c(t instanceof h ? t : null);
        }
        return i;
      }, d.Destroy = function (t, e) {}, d.prototype.b2Joint = function (e) {
        t.b2Assert(e.bodyA != e.bodyB), this.m_type = e.type, this.m_prev = null, this.m_next = null, this.m_bodyA = e.bodyA, this.m_bodyB = e.bodyB, this.m_collideConnected = e.collideConnected, this.m_islandFlag = false, this.m_userData = e.userData;
      }, d.prototype.InitVelocityConstraints = function (t) {}, d.prototype.SolveVelocityConstraints = function (t) {}, d.prototype.FinalizeVelocityConstraints = function () {}, d.prototype.SolvePositionConstraints = function (t) {
        return void 0 === t && (t = 0), false;
      }, e.postDefs.push(function () {
        e.Dynamics.Joints.b2Joint.e_unknownJoint = 0, e.Dynamics.Joints.b2Joint.e_revoluteJoint = 1, e.Dynamics.Joints.b2Joint.e_prismaticJoint = 2, e.Dynamics.Joints.b2Joint.e_distanceJoint = 3, e.Dynamics.Joints.b2Joint.e_pulleyJoint = 4, e.Dynamics.Joints.b2Joint.e_mouseJoint = 5, e.Dynamics.Joints.b2Joint.e_gearJoint = 6, e.Dynamics.Joints.b2Joint.e_lineJoint = 7, e.Dynamics.Joints.b2Joint.e_weldJoint = 8, e.Dynamics.Joints.b2Joint.e_frictionJoint = 9, e.Dynamics.Joints.b2Joint.e_inactiveLimit = 0, e.Dynamics.Joints.b2Joint.e_atLowerLimit = 1, e.Dynamics.Joints.b2Joint.e_atUpperLimit = 2, e.Dynamics.Joints.b2Joint.e_equalLimits = 3;
      }), _.b2JointDef = function () {}, _.prototype.b2JointDef = function () {
        this.type = d.e_unknownJoint, this.userData = null, this.bodyA = null, this.bodyB = null, this.collideConnected = false;
      }, y.b2JointEdge = function () {}, e.inherit(g, e.Dynamics.Joints.b2Joint), g.prototype.__super = e.Dynamics.Joints.b2Joint.prototype, g.b2LineJoint = function () {
        e.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments), this.m_localAnchor1 = new o, this.m_localAnchor2 = new o, this.m_localXAxis1 = new o, this.m_localYAxis1 = new o, this.m_axis = new o, this.m_perp = new o, this.m_K = new i, this.m_impulse = new o;
      }, g.prototype.GetAnchorA = function () {
        return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
      }, g.prototype.GetAnchorB = function () {
        return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
      }, g.prototype.GetReactionForce = function (t) {
        return void 0 === t && (t = 0), new o(t * (this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.x), t * (this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.y));
      }, g.prototype.GetReactionTorque = function (t) {
        return void 0 === t && (t = 0), t * this.m_impulse.y;
      }, g.prototype.GetJointTranslation = function () {
        var t = this.m_bodyA, e = this.m_bodyB, i = t.GetWorldPoint(this.m_localAnchor1), n = e.GetWorldPoint(this.m_localAnchor2), r = n.x - i.x, o = n.y - i.y, s = t.GetWorldVector(this.m_localXAxis1);
        return s.x * r + s.y * o;
      }, g.prototype.GetJointSpeed = function () {
        var t, e = this.m_bodyA, i = this.m_bodyB;
        t = e.m_xf.R;
        var n = this.m_localAnchor1.x - e.m_sweep.localCenter.x, r = this.m_localAnchor1.y - e.m_sweep.localCenter.y, o = t.col1.x * n + t.col2.x * r;
        r = t.col1.y * n + t.col2.y * r, n = o, t = i.m_xf.R;
        var s = this.m_localAnchor2.x - i.m_sweep.localCenter.x, a = this.m_localAnchor2.y - i.m_sweep.localCenter.y;
        o = t.col1.x * s + t.col2.x * a, a = t.col1.y * s + t.col2.y * a, s = o;
        var l = e.m_sweep.c.x + n, c = e.m_sweep.c.y + r, h = i.m_sweep.c.x + s - l, u = i.m_sweep.c.y + a - c, p = e.GetWorldVector(this.m_localXAxis1), m = e.m_linearVelocity, d = i.m_linearVelocity, _ = e.m_angularVelocity, y = i.m_angularVelocity;
        return h * (-_ * p.y) + u * (_ * p.x) + (p.x * (d.x + -y * a - m.x - -_ * r) + p.y * (d.y + y * s - m.y - _ * n));
      }, g.prototype.IsLimitEnabled = function () {
        return this.m_enableLimit;
      }, g.prototype.EnableLimit = function (t) {
        this.m_bodyA.SetAwake(true), this.m_bodyB.SetAwake(true), this.m_enableLimit = t;
      }, g.prototype.GetLowerLimit = function () {
        return this.m_lowerTranslation;
      }, g.prototype.GetUpperLimit = function () {
        return this.m_upperTranslation;
      }, g.prototype.SetLimits = function (t, e) {
        void 0 === t && (t = 0), void 0 === e && (e = 0), this.m_bodyA.SetAwake(true), this.m_bodyB.SetAwake(true), this.m_lowerTranslation = t, this.m_upperTranslation = e;
      }, g.prototype.IsMotorEnabled = function () {
        return this.m_enableMotor;
      }, g.prototype.EnableMotor = function (t) {
        this.m_bodyA.SetAwake(true), this.m_bodyB.SetAwake(true), this.m_enableMotor = t;
      }, g.prototype.SetMotorSpeed = function (t) {
        void 0 === t && (t = 0), this.m_bodyA.SetAwake(true), this.m_bodyB.SetAwake(true), this.m_motorSpeed = t;
      }, g.prototype.GetMotorSpeed = function () {
        return this.m_motorSpeed;
      }, g.prototype.SetMaxMotorForce = function (t) {
        void 0 === t && (t = 0), this.m_bodyA.SetAwake(true), this.m_bodyB.SetAwake(true), this.m_maxMotorForce = t;
      }, g.prototype.GetMaxMotorForce = function () {
        return this.m_maxMotorForce;
      }, g.prototype.GetMotorForce = function () {
        return this.m_motorImpulse;
      }, g.prototype.b2LineJoint = function (t) {
        this.__super.b2Joint.call(this, t);
        this.m_localAnchor1.SetV(t.localAnchorA), this.m_localAnchor2.SetV(t.localAnchorB), this.m_localXAxis1.SetV(t.localAxisA), this.m_localYAxis1.x = -this.m_localXAxis1.y, this.m_localYAxis1.y = this.m_localXAxis1.x, this.m_impulse.SetZero(), this.m_motorMass = 0, this.m_motorImpulse = 0, this.m_lowerTranslation = t.lowerTranslation, this.m_upperTranslation = t.upperTranslation, this.m_maxMotorForce = t.maxMotorForce, this.m_motorSpeed = t.motorSpeed, this.m_enableLimit = t.enableLimit, this.m_enableMotor = t.enableMotor, this.m_limitState = d.e_inactiveLimit, this.m_axis.SetZero(), this.m_perp.SetZero();
      }, g.prototype.InitVelocityConstraints = function (e) {
        var i, n = this.m_bodyA, o = this.m_bodyB, s = 0;
        this.m_localCenterA.SetV(n.GetLocalCenter()), this.m_localCenterB.SetV(o.GetLocalCenter());
        var a = n.GetTransform();
        o.GetTransform();
        i = n.m_xf.R;
        var l = this.m_localAnchor1.x - this.m_localCenterA.x, c = this.m_localAnchor1.y - this.m_localCenterA.y;
        s = i.col1.x * l + i.col2.x * c, c = i.col1.y * l + i.col2.y * c, l = s, i = o.m_xf.R;
        var h = this.m_localAnchor2.x - this.m_localCenterB.x, u = this.m_localAnchor2.y - this.m_localCenterB.y;
        s = i.col1.x * h + i.col2.x * u, u = i.col1.y * h + i.col2.y * u, h = s;
        var p = o.m_sweep.c.x + h - n.m_sweep.c.x - l, m = o.m_sweep.c.y + u - n.m_sweep.c.y - c;
        this.m_invMassA = n.m_invMass, this.m_invMassB = o.m_invMass, this.m_invIA = n.m_invI, this.m_invIB = o.m_invI, this.m_axis.SetV(r.MulMV(a.R, this.m_localXAxis1)), this.m_a1 = (p + l) * this.m_axis.y - (m + c) * this.m_axis.x, this.m_a2 = h * this.m_axis.y - u * this.m_axis.x, this.m_motorMass = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_a1 * this.m_a1 + this.m_invIB * this.m_a2 * this.m_a2, this.m_motorMass = this.m_motorMass > Number.MIN_VALUE ? 1 / this.m_motorMass : 0, this.m_perp.SetV(r.MulMV(a.R, this.m_localYAxis1)), this.m_s1 = (p + l) * this.m_perp.y - (m + c) * this.m_perp.x, this.m_s2 = h * this.m_perp.y - u * this.m_perp.x;
        var _ = this.m_invMassA, y = this.m_invMassB, g = this.m_invIA, x = this.m_invIB;
        if (this.m_K.col1.x = _ + y + g * this.m_s1 * this.m_s1 + x * this.m_s2 * this.m_s2, this.m_K.col1.y = g * this.m_s1 * this.m_a1 + x * this.m_s2 * this.m_a2, this.m_K.col2.x = this.m_K.col1.y, this.m_K.col2.y = _ + y + g * this.m_a1 * this.m_a1 + x * this.m_a2 * this.m_a2, this.m_enableLimit) {
          var v = this.m_axis.x * p + this.m_axis.y * m;
          r.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * t.b2_linearSlop ? this.m_limitState = d.e_equalLimits : v <= this.m_lowerTranslation ? this.m_limitState != d.e_atLowerLimit && (this.m_limitState = d.e_atLowerLimit, this.m_impulse.y = 0) : v >= this.m_upperTranslation ? this.m_limitState != d.e_atUpperLimit && (this.m_limitState = d.e_atUpperLimit, this.m_impulse.y = 0) : (this.m_limitState = d.e_inactiveLimit, this.m_impulse.y = 0);
        } else this.m_limitState = d.e_inactiveLimit;
        if (0 == this.m_enableMotor && (this.m_motorImpulse = 0), e.warmStarting) {
          this.m_impulse.x *= e.dtRatio, this.m_impulse.y *= e.dtRatio, this.m_motorImpulse *= e.dtRatio;
          var b = this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.x, w = this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.y, S = this.m_impulse.x * this.m_s1 + (this.m_motorImpulse + this.m_impulse.y) * this.m_a1, M = this.m_impulse.x * this.m_s2 + (this.m_motorImpulse + this.m_impulse.y) * this.m_a2;
          n.m_linearVelocity.x -= this.m_invMassA * b, n.m_linearVelocity.y -= this.m_invMassA * w, n.m_angularVelocity -= this.m_invIA * S, o.m_linearVelocity.x += this.m_invMassB * b, o.m_linearVelocity.y += this.m_invMassB * w, o.m_angularVelocity += this.m_invIB * M;
        } else this.m_impulse.SetZero(), this.m_motorImpulse = 0;
      }, g.prototype.SolveVelocityConstraints = function (t) {
        var e = this.m_bodyA, i = this.m_bodyB, n = e.m_linearVelocity, s = e.m_angularVelocity, a = i.m_linearVelocity, l = i.m_angularVelocity, c = 0, h = 0, u = 0, p = 0;
        if (this.m_enableMotor && this.m_limitState != d.e_equalLimits) {
          var m = this.m_axis.x * (a.x - n.x) + this.m_axis.y * (a.y - n.y) + this.m_a2 * l - this.m_a1 * s, _ = this.m_motorMass * (this.m_motorSpeed - m), y = this.m_motorImpulse, g = t.dt * this.m_maxMotorForce;
          this.m_motorImpulse = r.Clamp(this.m_motorImpulse + _, -g, g), c = (_ = this.m_motorImpulse - y) * this.m_axis.x, h = _ * this.m_axis.y, u = _ * this.m_a1, p = _ * this.m_a2, n.x -= this.m_invMassA * c, n.y -= this.m_invMassA * h, s -= this.m_invIA * u, a.x += this.m_invMassB * c, a.y += this.m_invMassB * h, l += this.m_invIB * p;
        }
        var x = this.m_perp.x * (a.x - n.x) + this.m_perp.y * (a.y - n.y) + this.m_s2 * l - this.m_s1 * s;
        if (this.m_enableLimit && this.m_limitState != d.e_inactiveLimit) {
          var v = this.m_axis.x * (a.x - n.x) + this.m_axis.y * (a.y - n.y) + this.m_a2 * l - this.m_a1 * s, b = this.m_impulse.Copy(), w = this.m_K.Solve(new o, -x, -v);
          this.m_impulse.Add(w), this.m_limitState == d.e_atLowerLimit ? this.m_impulse.y = r.Max(this.m_impulse.y, 0) : this.m_limitState == d.e_atUpperLimit && (this.m_impulse.y = r.Min(this.m_impulse.y, 0));
          var S = -x - (this.m_impulse.y - b.y) * this.m_K.col2.x, M = 0;
          M = 0 != this.m_K.col1.x ? S / this.m_K.col1.x + b.x : b.x, this.m_impulse.x = M, w.x = this.m_impulse.x - b.x, w.y = this.m_impulse.y - b.y, c = w.x * this.m_perp.x + w.y * this.m_axis.x, h = w.x * this.m_perp.y + w.y * this.m_axis.y, u = w.x * this.m_s1 + w.y * this.m_a1, p = w.x * this.m_s2 + w.y * this.m_a2, n.x -= this.m_invMassA * c, n.y -= this.m_invMassA * h, s -= this.m_invIA * u, a.x += this.m_invMassB * c, a.y += this.m_invMassB * h, l += this.m_invIB * p;
        } else {
          var A = 0;
          A = 0 != this.m_K.col1.x ? -x / this.m_K.col1.x : 0, this.m_impulse.x += A, c = A * this.m_perp.x, h = A * this.m_perp.y, u = A * this.m_s1, p = A * this.m_s2, n.x -= this.m_invMassA * c, n.y -= this.m_invMassA * h, s -= this.m_invIA * u, a.x += this.m_invMassB * c, a.y += this.m_invMassB * h, l += this.m_invIB * p;
        }
        e.m_linearVelocity.SetV(n), e.m_angularVelocity = s, i.m_linearVelocity.SetV(a), i.m_angularVelocity = l;
      }, g.prototype.SolvePositionConstraints = function (e) {
        void 0 === e && (e = 0);
        var n, s = this.m_bodyA, a = this.m_bodyB, l = s.m_sweep.c, c = s.m_sweep.a, h = a.m_sweep.c, u = a.m_sweep.a, p = 0, m = 0, d = 0, _ = 0, y = 0, g = 0, x = false, v = 0, b = i.FromAngle(c), w = i.FromAngle(u);
        n = b;
        var S = this.m_localAnchor1.x - this.m_localCenterA.x, M = this.m_localAnchor1.y - this.m_localCenterA.y;
        p = n.col1.x * S + n.col2.x * M, M = n.col1.y * S + n.col2.y * M, S = p, n = w;
        var A = this.m_localAnchor2.x - this.m_localCenterB.x, C = this.m_localAnchor2.y - this.m_localCenterB.y;
        p = n.col1.x * A + n.col2.x * C, C = n.col1.y * A + n.col2.y * C, A = p;
        var T = h.x + A - l.x - S, E = h.y + C - l.y - M;
        if (this.m_enableLimit) {
          this.m_axis = r.MulMV(b, this.m_localXAxis1), this.m_a1 = (T + S) * this.m_axis.y - (E + M) * this.m_axis.x, this.m_a2 = A * this.m_axis.y - C * this.m_axis.x;
          var L = this.m_axis.x * T + this.m_axis.y * E;
          r.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * t.b2_linearSlop ? (v = r.Clamp(L, -t.b2_maxLinearCorrection, t.b2_maxLinearCorrection), g = r.Abs(L), x = true) : L <= this.m_lowerTranslation ? (v = r.Clamp(L - this.m_lowerTranslation + t.b2_linearSlop, -t.b2_maxLinearCorrection, 0), g = this.m_lowerTranslation - L, x = true) : L >= this.m_upperTranslation && (v = r.Clamp(L - this.m_upperTranslation + t.b2_linearSlop, 0, t.b2_maxLinearCorrection), g = L - this.m_upperTranslation, x = true);
        }
        this.m_perp = r.MulMV(b, this.m_localYAxis1), this.m_s1 = (T + S) * this.m_perp.y - (E + M) * this.m_perp.x, this.m_s2 = A * this.m_perp.y - C * this.m_perp.x;
        var D = new o, R = this.m_perp.x * T + this.m_perp.y * E;
        if (g = r.Max(g, r.Abs(R)), 0, x) m = this.m_invMassA, d = this.m_invMassB, _ = this.m_invIA, y = this.m_invIB, this.m_K.col1.x = m + d + _ * this.m_s1 * this.m_s1 + y * this.m_s2 * this.m_s2, this.m_K.col1.y = _ * this.m_s1 * this.m_a1 + y * this.m_s2 * this.m_a2, this.m_K.col2.x = this.m_K.col1.y, this.m_K.col2.y = m + d + _ * this.m_a1 * this.m_a1 + y * this.m_a2 * this.m_a2, this.m_K.Solve(D, -R, -v); else {
          m = this.m_invMassA, d = this.m_invMassB, _ = this.m_invIA, y = this.m_invIB;
          var B = m + d + _ * this.m_s1 * this.m_s1 + y * this.m_s2 * this.m_s2, P = 0;
          P = 0 != B ? -R / B : 0, D.x = P, D.y = 0;
        }
        var I = D.x * this.m_perp.x + D.y * this.m_axis.x, V = D.x * this.m_perp.y + D.y * this.m_axis.y, F = D.x * this.m_s1 + D.y * this.m_a1, k = D.x * this.m_s2 + D.y * this.m_a2;
        return l.x -= this.m_invMassA * I, l.y -= this.m_invMassA * V, c -= this.m_invIA * F, h.x += this.m_invMassB * I, h.y += this.m_invMassB * V, u += this.m_invIB * k, s.m_sweep.a = c, a.m_sweep.a = u, s.SynchronizeTransform(), a.SynchronizeTransform(), g <= t.b2_linearSlop && 0 <= t.b2_angularSlop;
      }, e.inherit(x, e.Dynamics.Joints.b2JointDef), x.prototype.__super = e.Dynamics.Joints.b2JointDef.prototype, x.b2LineJointDef = function () {
        e.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments), this.localAnchorA = new o, this.localAnchorB = new o, this.localAxisA = new o;
      }, x.prototype.b2LineJointDef = function () {
        this.__super.b2JointDef.call(this), this.type = d.e_lineJoint, this.localAxisA.Set(1, 0), this.enableLimit = false, this.lowerTranslation = 0, this.upperTranslation = 0, this.enableMotor = false, this.maxMotorForce = 0, this.motorSpeed = 0;
      }, x.prototype.Initialize = function (t, e, i, n) {
        this.bodyA = t, this.bodyB = e, this.localAnchorA = this.bodyA.GetLocalPoint(i), this.localAnchorB = this.bodyB.GetLocalPoint(i), this.localAxisA = this.bodyA.GetLocalVector(n);
      }, e.inherit(v, e.Dynamics.Joints.b2Joint), v.prototype.__super = e.Dynamics.Joints.b2Joint.prototype, v.b2MouseJoint = function () {
        e.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments), this.K = new i, this.K1 = new i, this.K2 = new i, this.m_localAnchor = new o, this.m_target = new o, this.m_impulse = new o, this.m_mass = new i, this.m_C = new o;
      }, v.prototype.GetAnchorA = function () {
        return this.m_target;
      }, v.prototype.GetAnchorB = function () {
        return this.m_bodyB.GetWorldPoint(this.m_localAnchor);
      }, v.prototype.GetReactionForce = function (t) {
        return void 0 === t && (t = 0), new o(t * this.m_impulse.x, t * this.m_impulse.y);
      }, v.prototype.GetReactionTorque = function (t) {
        return void 0 === t && (t = 0), 0;
      }, v.prototype.GetTarget = function () {
        return this.m_target;
      }, v.prototype.SetTarget = function (t) {
        0 == this.m_bodyB.IsAwake() && this.m_bodyB.SetAwake(true), this.m_target = t;
      }, v.prototype.GetMaxForce = function () {
        return this.m_maxForce;
      }, v.prototype.SetMaxForce = function (t) {
        void 0 === t && (t = 0), this.m_maxForce = t;
      }, v.prototype.GetFrequency = function () {
        return this.m_frequencyHz;
      }, v.prototype.SetFrequency = function (t) {
        void 0 === t && (t = 0), this.m_frequencyHz = t;
      }, v.prototype.GetDampingRatio = function () {
        return this.m_dampingRatio;
      }, v.prototype.SetDampingRatio = function (t) {
        void 0 === t && (t = 0), this.m_dampingRatio = t;
      }, v.prototype.b2MouseJoint = function (t) {
        this.__super.b2Joint.call(this, t), this.m_target.SetV(t.target);
        var e = this.m_target.x - this.m_bodyB.m_xf.position.x, i = this.m_target.y - this.m_bodyB.m_xf.position.y, n = this.m_bodyB.m_xf.R;
        this.m_localAnchor.x = e * n.col1.x + i * n.col1.y, this.m_localAnchor.y = e * n.col2.x + i * n.col2.y, this.m_maxForce = t.maxForce, this.m_impulse.SetZero(), this.m_frequencyHz = t.frequencyHz, this.m_dampingRatio = t.dampingRatio, this.m_beta = 0, this.m_gamma = 0;
      }, v.prototype.InitVelocityConstraints = function (t) {
        var e, i = this.m_bodyB, n = i.GetMass(), r = 2 * Math.PI * this.m_frequencyHz, o = 2 * n * this.m_dampingRatio * r, s = n * r * r;
        this.m_gamma = t.dt * (o + t.dt * s), this.m_gamma = 0 != this.m_gamma ? 1 / this.m_gamma : 0, this.m_beta = t.dt * s * this.m_gamma, e = i.m_xf.R;
        var a = this.m_localAnchor.x - i.m_sweep.localCenter.x, l = this.m_localAnchor.y - i.m_sweep.localCenter.y, c = e.col1.x * a + e.col2.x * l;
        l = e.col1.y * a + e.col2.y * l, a = c;
        var h = i.m_invMass, u = i.m_invI;
        this.K1.col1.x = h, this.K1.col2.x = 0, this.K1.col1.y = 0, this.K1.col2.y = h, this.K2.col1.x = u * l * l, this.K2.col2.x = -u * a * l, this.K2.col1.y = -u * a * l, this.K2.col2.y = u * a * a, this.K.SetM(this.K1), this.K.AddM(this.K2), this.K.col1.x += this.m_gamma, this.K.col2.y += this.m_gamma, this.K.GetInverse(this.m_mass), this.m_C.x = i.m_sweep.c.x + a - this.m_target.x, this.m_C.y = i.m_sweep.c.y + l - this.m_target.y, i.m_angularVelocity *= 0.98, this.m_impulse.x *= t.dtRatio, this.m_impulse.y *= t.dtRatio, i.m_linearVelocity.x += h * this.m_impulse.x, i.m_linearVelocity.y += h * this.m_impulse.y, i.m_angularVelocity += u * (a * this.m_impulse.y - l * this.m_impulse.x);
      }, v.prototype.SolveVelocityConstraints = function (t) {
        var e, i, n = this.m_bodyB, r = 0;
        e = n.m_xf.R;
        var o = this.m_localAnchor.x - n.m_sweep.localCenter.x, s = this.m_localAnchor.y - n.m_sweep.localCenter.y;
        r = e.col1.x * o + e.col2.x * s, s = e.col1.y * o + e.col2.y * s, o = r;
        var a = n.m_linearVelocity.x + -n.m_angularVelocity * s, l = n.m_linearVelocity.y + n.m_angularVelocity * o;
        e = this.m_mass, r = a + this.m_beta * this.m_C.x + this.m_gamma * this.m_impulse.x, i = l + this.m_beta * this.m_C.y + this.m_gamma * this.m_impulse.y;
        var c = -(e.col1.x * r + e.col2.x * i), h = -(e.col1.y * r + e.col2.y * i), u = this.m_impulse.x, p = this.m_impulse.y;
        this.m_impulse.x += c, this.m_impulse.y += h;
        var m = t.dt * this.m_maxForce;
        this.m_impulse.LengthSquared() > m * m && this.m_impulse.Multiply(m / this.m_impulse.Length()), c = this.m_impulse.x - u, h = this.m_impulse.y - p, n.m_linearVelocity.x += n.m_invMass * c, n.m_linearVelocity.y += n.m_invMass * h, n.m_angularVelocity += n.m_invI * (o * h - s * c);
      }, v.prototype.SolvePositionConstraints = function (t) {
        return void 0 === t && (t = 0), true;
      }, e.inherit(b, e.Dynamics.Joints.b2JointDef), b.prototype.__super = e.Dynamics.Joints.b2JointDef.prototype, b.b2MouseJointDef = function () {
        e.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments), this.target = new o;
      }, b.prototype.b2MouseJointDef = function () {
        this.__super.b2JointDef.call(this), this.type = d.e_mouseJoint, this.maxForce = 0, this.frequencyHz = 5, this.dampingRatio = 0.7;
      }, e.inherit(w, e.Dynamics.Joints.b2Joint), w.prototype.__super = e.Dynamics.Joints.b2Joint.prototype, w.b2PrismaticJoint = function () {
        e.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments), this.m_localAnchor1 = new o, this.m_localAnchor2 = new o, this.m_localXAxis1 = new o, this.m_localYAxis1 = new o, this.m_axis = new o, this.m_perp = new o, this.m_K = new n, this.m_impulse = new s;
      }, w.prototype.GetAnchorA = function () {
        return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
      }, w.prototype.GetAnchorB = function () {
        return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
      }, w.prototype.GetReactionForce = function (t) {
        return void 0 === t && (t = 0), new o(t * (this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.x), t * (this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.y));
      }, w.prototype.GetReactionTorque = function (t) {
        return void 0 === t && (t = 0), t * this.m_impulse.y;
      }, w.prototype.GetJointTranslation = function () {
        var t = this.m_bodyA, e = this.m_bodyB, i = t.GetWorldPoint(this.m_localAnchor1), n = e.GetWorldPoint(this.m_localAnchor2), r = n.x - i.x, o = n.y - i.y, s = t.GetWorldVector(this.m_localXAxis1);
        return s.x * r + s.y * o;
      }, w.prototype.GetJointSpeed = function () {
        var t, e = this.m_bodyA, i = this.m_bodyB;
        t = e.m_xf.R;
        var n = this.m_localAnchor1.x - e.m_sweep.localCenter.x, r = this.m_localAnchor1.y - e.m_sweep.localCenter.y, o = t.col1.x * n + t.col2.x * r;
        r = t.col1.y * n + t.col2.y * r, n = o, t = i.m_xf.R;
        var s = this.m_localAnchor2.x - i.m_sweep.localCenter.x, a = this.m_localAnchor2.y - i.m_sweep.localCenter.y;
        o = t.col1.x * s + t.col2.x * a, a = t.col1.y * s + t.col2.y * a, s = o;
        var l = e.m_sweep.c.x + n, c = e.m_sweep.c.y + r, h = i.m_sweep.c.x + s - l, u = i.m_sweep.c.y + a - c, p = e.GetWorldVector(this.m_localXAxis1), m = e.m_linearVelocity, d = i.m_linearVelocity, _ = e.m_angularVelocity, y = i.m_angularVelocity;
        return h * (-_ * p.y) + u * (_ * p.x) + (p.x * (d.x + -y * a - m.x - -_ * r) + p.y * (d.y + y * s - m.y - _ * n));
      }, w.prototype.IsLimitEnabled = function () {
        return this.m_enableLimit;
      }, w.prototype.EnableLimit = function (t) {
        this.m_bodyA.SetAwake(true), this.m_bodyB.SetAwake(true), this.m_enableLimit = t;
      }, w.prototype.GetLowerLimit = function () {
        return this.m_lowerTranslation;
      }, w.prototype.GetUpperLimit = function () {
        return this.m_upperTranslation;
      }, w.prototype.SetLimits = function (t, e) {
        void 0 === t && (t = 0), void 0 === e && (e = 0), this.m_bodyA.SetAwake(true), this.m_bodyB.SetAwake(true), this.m_lowerTranslation = t, this.m_upperTranslation = e;
      }, w.prototype.IsMotorEnabled = function () {
        return this.m_enableMotor;
      }, w.prototype.EnableMotor = function (t) {
        this.m_bodyA.SetAwake(true), this.m_bodyB.SetAwake(true), this.m_enableMotor = t;
      }, w.prototype.SetMotorSpeed = function (t) {
        void 0 === t && (t = 0), this.m_bodyA.SetAwake(true), this.m_bodyB.SetAwake(true), this.m_motorSpeed = t;
      }, w.prototype.GetMotorSpeed = function () {
        return this.m_motorSpeed;
      }, w.prototype.SetMaxMotorForce = function (t) {
        void 0 === t && (t = 0), this.m_bodyA.SetAwake(true), this.m_bodyB.SetAwake(true), this.m_maxMotorForce = t;
      }, w.prototype.GetMotorForce = function () {
        return this.m_motorImpulse;
      }, w.prototype.b2PrismaticJoint = function (t) {
        this.__super.b2Joint.call(this, t);
        this.m_localAnchor1.SetV(t.localAnchorA), this.m_localAnchor2.SetV(t.localAnchorB), this.m_localXAxis1.SetV(t.localAxisA), this.m_localYAxis1.x = -this.m_localXAxis1.y, this.m_localYAxis1.y = this.m_localXAxis1.x, this.m_refAngle = t.referenceAngle, this.m_impulse.SetZero(), this.m_motorMass = 0, this.m_motorImpulse = 0, this.m_lowerTranslation = t.lowerTranslation, this.m_upperTranslation = t.upperTranslation, this.m_maxMotorForce = t.maxMotorForce, this.m_motorSpeed = t.motorSpeed, this.m_enableLimit = t.enableLimit, this.m_enableMotor = t.enableMotor, this.m_limitState = d.e_inactiveLimit, this.m_axis.SetZero(), this.m_perp.SetZero();
      }, w.prototype.InitVelocityConstraints = function (e) {
        var i, n = this.m_bodyA, o = this.m_bodyB, s = 0;
        this.m_localCenterA.SetV(n.GetLocalCenter()), this.m_localCenterB.SetV(o.GetLocalCenter());
        var a = n.GetTransform();
        o.GetTransform();
        i = n.m_xf.R;
        var l = this.m_localAnchor1.x - this.m_localCenterA.x, c = this.m_localAnchor1.y - this.m_localCenterA.y;
        s = i.col1.x * l + i.col2.x * c, c = i.col1.y * l + i.col2.y * c, l = s, i = o.m_xf.R;
        var h = this.m_localAnchor2.x - this.m_localCenterB.x, u = this.m_localAnchor2.y - this.m_localCenterB.y;
        s = i.col1.x * h + i.col2.x * u, u = i.col1.y * h + i.col2.y * u, h = s;
        var p = o.m_sweep.c.x + h - n.m_sweep.c.x - l, m = o.m_sweep.c.y + u - n.m_sweep.c.y - c;
        this.m_invMassA = n.m_invMass, this.m_invMassB = o.m_invMass, this.m_invIA = n.m_invI, this.m_invIB = o.m_invI, this.m_axis.SetV(r.MulMV(a.R, this.m_localXAxis1)), this.m_a1 = (p + l) * this.m_axis.y - (m + c) * this.m_axis.x, this.m_a2 = h * this.m_axis.y - u * this.m_axis.x, this.m_motorMass = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_a1 * this.m_a1 + this.m_invIB * this.m_a2 * this.m_a2, this.m_motorMass > Number.MIN_VALUE && (this.m_motorMass = 1 / this.m_motorMass), this.m_perp.SetV(r.MulMV(a.R, this.m_localYAxis1)), this.m_s1 = (p + l) * this.m_perp.y - (m + c) * this.m_perp.x, this.m_s2 = h * this.m_perp.y - u * this.m_perp.x;
        var _ = this.m_invMassA, y = this.m_invMassB, g = this.m_invIA, x = this.m_invIB;
        if (this.m_K.col1.x = _ + y + g * this.m_s1 * this.m_s1 + x * this.m_s2 * this.m_s2, this.m_K.col1.y = g * this.m_s1 + x * this.m_s2, this.m_K.col1.z = g * this.m_s1 * this.m_a1 + x * this.m_s2 * this.m_a2, this.m_K.col2.x = this.m_K.col1.y, this.m_K.col2.y = g + x, this.m_K.col2.z = g * this.m_a1 + x * this.m_a2, this.m_K.col3.x = this.m_K.col1.z, this.m_K.col3.y = this.m_K.col2.z, this.m_K.col3.z = _ + y + g * this.m_a1 * this.m_a1 + x * this.m_a2 * this.m_a2, this.m_enableLimit) {
          var v = this.m_axis.x * p + this.m_axis.y * m;
          r.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * t.b2_linearSlop ? this.m_limitState = d.e_equalLimits : v <= this.m_lowerTranslation ? this.m_limitState != d.e_atLowerLimit && (this.m_limitState = d.e_atLowerLimit, this.m_impulse.z = 0) : v >= this.m_upperTranslation ? this.m_limitState != d.e_atUpperLimit && (this.m_limitState = d.e_atUpperLimit, this.m_impulse.z = 0) : (this.m_limitState = d.e_inactiveLimit, this.m_impulse.z = 0);
        } else this.m_limitState = d.e_inactiveLimit;
        if (0 == this.m_enableMotor && (this.m_motorImpulse = 0), e.warmStarting) {
          this.m_impulse.x *= e.dtRatio, this.m_impulse.y *= e.dtRatio, this.m_motorImpulse *= e.dtRatio;
          var b = this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.x, w = this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.y, S = this.m_impulse.x * this.m_s1 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a1, M = this.m_impulse.x * this.m_s2 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a2;
          n.m_linearVelocity.x -= this.m_invMassA * b, n.m_linearVelocity.y -= this.m_invMassA * w, n.m_angularVelocity -= this.m_invIA * S, o.m_linearVelocity.x += this.m_invMassB * b, o.m_linearVelocity.y += this.m_invMassB * w, o.m_angularVelocity += this.m_invIB * M;
        } else this.m_impulse.SetZero(), this.m_motorImpulse = 0;
      }, w.prototype.SolveVelocityConstraints = function (t) {
        var e = this.m_bodyA, i = this.m_bodyB, n = e.m_linearVelocity, a = e.m_angularVelocity, l = i.m_linearVelocity, c = i.m_angularVelocity, h = 0, u = 0, p = 0, m = 0;
        if (this.m_enableMotor && this.m_limitState != d.e_equalLimits) {
          var _ = this.m_axis.x * (l.x - n.x) + this.m_axis.y * (l.y - n.y) + this.m_a2 * c - this.m_a1 * a, y = this.m_motorMass * (this.m_motorSpeed - _), g = this.m_motorImpulse, x = t.dt * this.m_maxMotorForce;
          this.m_motorImpulse = r.Clamp(this.m_motorImpulse + y, -x, x), h = (y = this.m_motorImpulse - g) * this.m_axis.x, u = y * this.m_axis.y, p = y * this.m_a1, m = y * this.m_a2, n.x -= this.m_invMassA * h, n.y -= this.m_invMassA * u, a -= this.m_invIA * p, l.x += this.m_invMassB * h, l.y += this.m_invMassB * u, c += this.m_invIB * m;
        }
        var v = this.m_perp.x * (l.x - n.x) + this.m_perp.y * (l.y - n.y) + this.m_s2 * c - this.m_s1 * a, b = c - a;
        if (this.m_enableLimit && this.m_limitState != d.e_inactiveLimit) {
          var w = this.m_axis.x * (l.x - n.x) + this.m_axis.y * (l.y - n.y) + this.m_a2 * c - this.m_a1 * a, S = this.m_impulse.Copy(), M = this.m_K.Solve33(new s, -v, -b, -w);
          this.m_impulse.Add(M), this.m_limitState == d.e_atLowerLimit ? this.m_impulse.z = r.Max(this.m_impulse.z, 0) : this.m_limitState == d.e_atUpperLimit && (this.m_impulse.z = r.Min(this.m_impulse.z, 0));
          var A = -v - (this.m_impulse.z - S.z) * this.m_K.col3.x, C = -b - (this.m_impulse.z - S.z) * this.m_K.col3.y, T = this.m_K.Solve22(new o, A, C);
          T.x += S.x, T.y += S.y, this.m_impulse.x = T.x, this.m_impulse.y = T.y, M.x = this.m_impulse.x - S.x, M.y = this.m_impulse.y - S.y, M.z = this.m_impulse.z - S.z, h = M.x * this.m_perp.x + M.z * this.m_axis.x, u = M.x * this.m_perp.y + M.z * this.m_axis.y, p = M.x * this.m_s1 + M.y + M.z * this.m_a1, m = M.x * this.m_s2 + M.y + M.z * this.m_a2, n.x -= this.m_invMassA * h, n.y -= this.m_invMassA * u, a -= this.m_invIA * p, l.x += this.m_invMassB * h, l.y += this.m_invMassB * u, c += this.m_invIB * m;
        } else {
          var E = this.m_K.Solve22(new o, -v, -b);
          this.m_impulse.x += E.x, this.m_impulse.y += E.y, h = E.x * this.m_perp.x, u = E.x * this.m_perp.y, p = E.x * this.m_s1 + E.y, m = E.x * this.m_s2 + E.y, n.x -= this.m_invMassA * h, n.y -= this.m_invMassA * u, a -= this.m_invIA * p, l.x += this.m_invMassB * h, l.y += this.m_invMassB * u, c += this.m_invIB * m;
        }
        e.m_linearVelocity.SetV(n), e.m_angularVelocity = a, i.m_linearVelocity.SetV(l), i.m_angularVelocity = c;
      }, w.prototype.SolvePositionConstraints = function (e) {
        void 0 === e && (e = 0);
        var n, a, l = this.m_bodyA, c = this.m_bodyB, h = l.m_sweep.c, u = l.m_sweep.a, p = c.m_sweep.c, m = c.m_sweep.a, d = 0, _ = 0, y = 0, g = 0, x = 0, v = 0, b = false, w = 0, S = i.FromAngle(u), M = i.FromAngle(m);
        n = S;
        var A = this.m_localAnchor1.x - this.m_localCenterA.x, C = this.m_localAnchor1.y - this.m_localCenterA.y;
        d = n.col1.x * A + n.col2.x * C, C = n.col1.y * A + n.col2.y * C, A = d, n = M;
        var T = this.m_localAnchor2.x - this.m_localCenterB.x, E = this.m_localAnchor2.y - this.m_localCenterB.y;
        d = n.col1.x * T + n.col2.x * E, E = n.col1.y * T + n.col2.y * E, T = d;
        var L = p.x + T - h.x - A, D = p.y + E - h.y - C;
        if (this.m_enableLimit) {
          this.m_axis = r.MulMV(S, this.m_localXAxis1), this.m_a1 = (L + A) * this.m_axis.y - (D + C) * this.m_axis.x, this.m_a2 = T * this.m_axis.y - E * this.m_axis.x;
          var R = this.m_axis.x * L + this.m_axis.y * D;
          r.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * t.b2_linearSlop ? (w = r.Clamp(R, -t.b2_maxLinearCorrection, t.b2_maxLinearCorrection), v = r.Abs(R), b = true) : R <= this.m_lowerTranslation ? (w = r.Clamp(R - this.m_lowerTranslation + t.b2_linearSlop, -t.b2_maxLinearCorrection, 0), v = this.m_lowerTranslation - R, b = true) : R >= this.m_upperTranslation && (w = r.Clamp(R - this.m_upperTranslation + t.b2_linearSlop, 0, t.b2_maxLinearCorrection), v = R - this.m_upperTranslation, b = true);
        }
        this.m_perp = r.MulMV(S, this.m_localYAxis1), this.m_s1 = (L + A) * this.m_perp.y - (D + C) * this.m_perp.x, this.m_s2 = T * this.m_perp.y - E * this.m_perp.x;
        var B = new s, P = this.m_perp.x * L + this.m_perp.y * D, I = m - u - this.m_refAngle;
        if (v = r.Max(v, r.Abs(P)), a = r.Abs(I), b) _ = this.m_invMassA, y = this.m_invMassB, g = this.m_invIA, x = this.m_invIB, this.m_K.col1.x = _ + y + g * this.m_s1 * this.m_s1 + x * this.m_s2 * this.m_s2, this.m_K.col1.y = g * this.m_s1 + x * this.m_s2, this.m_K.col1.z = g * this.m_s1 * this.m_a1 + x * this.m_s2 * this.m_a2, this.m_K.col2.x = this.m_K.col1.y, this.m_K.col2.y = g + x, this.m_K.col2.z = g * this.m_a1 + x * this.m_a2, this.m_K.col3.x = this.m_K.col1.z, this.m_K.col3.y = this.m_K.col2.z, this.m_K.col3.z = _ + y + g * this.m_a1 * this.m_a1 + x * this.m_a2 * this.m_a2, this.m_K.Solve33(B, -P, -I, -w); else {
          _ = this.m_invMassA, y = this.m_invMassB, g = this.m_invIA, x = this.m_invIB;
          var V = _ + y + g * this.m_s1 * this.m_s1 + x * this.m_s2 * this.m_s2, F = g * this.m_s1 + x * this.m_s2, k = g + x;
          this.m_K.col1.Set(V, F, 0), this.m_K.col2.Set(F, k, 0);
          var N = this.m_K.Solve22(new o, -P, -I);
          B.x = N.x, B.y = N.y, B.z = 0;
        }
        var G = B.x * this.m_perp.x + B.z * this.m_axis.x, U = B.x * this.m_perp.y + B.z * this.m_axis.y, z = B.x * this.m_s1 + B.y + B.z * this.m_a1, O = B.x * this.m_s2 + B.y + B.z * this.m_a2;
        return h.x -= this.m_invMassA * G, h.y -= this.m_invMassA * U, u -= this.m_invIA * z, p.x += this.m_invMassB * G, p.y += this.m_invMassB * U, m += this.m_invIB * O, l.m_sweep.a = u, c.m_sweep.a = m, l.SynchronizeTransform(), c.SynchronizeTransform(), v <= t.b2_linearSlop && a <= t.b2_angularSlop;
      }, e.inherit(S, e.Dynamics.Joints.b2JointDef), S.prototype.__super = e.Dynamics.Joints.b2JointDef.prototype, S.b2PrismaticJointDef = function () {
        e.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments), this.localAnchorA = new o, this.localAnchorB = new o, this.localAxisA = new o;
      }, S.prototype.b2PrismaticJointDef = function () {
        this.__super.b2JointDef.call(this), this.type = d.e_prismaticJoint, this.localAxisA.Set(1, 0), this.referenceAngle = 0, this.enableLimit = false, this.lowerTranslation = 0, this.upperTranslation = 0, this.enableMotor = false, this.maxMotorForce = 0, this.motorSpeed = 0;
      }, S.prototype.Initialize = function (t, e, i, n) {
        this.bodyA = t, this.bodyB = e, this.localAnchorA = this.bodyA.GetLocalPoint(i), this.localAnchorB = this.bodyB.GetLocalPoint(i), this.localAxisA = this.bodyA.GetLocalVector(n), this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle();
      }, e.inherit(M, e.Dynamics.Joints.b2Joint), M.prototype.__super = e.Dynamics.Joints.b2Joint.prototype, M.b2PulleyJoint = function () {
        e.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments), this.m_groundAnchor1 = new o, this.m_groundAnchor2 = new o, this.m_localAnchor1 = new o, this.m_localAnchor2 = new o, this.m_u1 = new o, this.m_u2 = new o;
      }, M.prototype.GetAnchorA = function () {
        return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
      }, M.prototype.GetAnchorB = function () {
        return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
      }, M.prototype.GetReactionForce = function (t) {
        return void 0 === t && (t = 0), new o(t * this.m_impulse * this.m_u2.x, t * this.m_impulse * this.m_u2.y);
      }, M.prototype.GetReactionTorque = function (t) {
        return void 0 === t && (t = 0), 0;
      }, M.prototype.GetGroundAnchorA = function () {
        var t = this.m_ground.m_xf.position.Copy();
        return t.Add(this.m_groundAnchor1), t;
      }, M.prototype.GetGroundAnchorB = function () {
        var t = this.m_ground.m_xf.position.Copy();
        return t.Add(this.m_groundAnchor2), t;
      }, M.prototype.GetLength1 = function () {
        var t = this.m_bodyA.GetWorldPoint(this.m_localAnchor1), e = this.m_ground.m_xf.position.x + this.m_groundAnchor1.x, i = this.m_ground.m_xf.position.y + this.m_groundAnchor1.y, n = t.x - e, r = t.y - i;
        return Math.sqrt(n * n + r * r);
      }, M.prototype.GetLength2 = function () {
        var t = this.m_bodyB.GetWorldPoint(this.m_localAnchor2), e = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x, i = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y, n = t.x - e, r = t.y - i;
        return Math.sqrt(n * n + r * r);
      }, M.prototype.GetRatio = function () {
        return this.m_ratio;
      }, M.prototype.b2PulleyJoint = function (t) {
        this.__super.b2Joint.call(this, t);
        this.m_ground = this.m_bodyA.m_world.m_groundBody, this.m_groundAnchor1.x = t.groundAnchorA.x - this.m_ground.m_xf.position.x, this.m_groundAnchor1.y = t.groundAnchorA.y - this.m_ground.m_xf.position.y, this.m_groundAnchor2.x = t.groundAnchorB.x - this.m_ground.m_xf.position.x, this.m_groundAnchor2.y = t.groundAnchorB.y - this.m_ground.m_xf.position.y, this.m_localAnchor1.SetV(t.localAnchorA), this.m_localAnchor2.SetV(t.localAnchorB), this.m_ratio = t.ratio, this.m_constant = t.lengthA + this.m_ratio * t.lengthB, this.m_maxLength1 = r.Min(t.maxLengthA, this.m_constant - this.m_ratio * M.b2_minPulleyLength), this.m_maxLength2 = r.Min(t.maxLengthB, (this.m_constant - M.b2_minPulleyLength) / this.m_ratio), this.m_impulse = 0, this.m_limitImpulse1 = 0, this.m_limitImpulse2 = 0;
      }, M.prototype.InitVelocityConstraints = function (e) {
        var i, n = this.m_bodyA, r = this.m_bodyB;
        i = n.m_xf.R;
        var o = this.m_localAnchor1.x - n.m_sweep.localCenter.x, s = this.m_localAnchor1.y - n.m_sweep.localCenter.y, a = i.col1.x * o + i.col2.x * s;
        s = i.col1.y * o + i.col2.y * s, o = a, i = r.m_xf.R;
        var l = this.m_localAnchor2.x - r.m_sweep.localCenter.x, c = this.m_localAnchor2.y - r.m_sweep.localCenter.y;
        a = i.col1.x * l + i.col2.x * c, c = i.col1.y * l + i.col2.y * c, l = a;
        var h = n.m_sweep.c.x + o, u = n.m_sweep.c.y + s, p = r.m_sweep.c.x + l, m = r.m_sweep.c.y + c, _ = this.m_ground.m_xf.position.x + this.m_groundAnchor1.x, y = this.m_ground.m_xf.position.y + this.m_groundAnchor1.y, g = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x, x = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y;
        this.m_u1.Set(h - _, u - y), this.m_u2.Set(p - g, m - x);
        var v = this.m_u1.Length(), b = this.m_u2.Length();
        v > t.b2_linearSlop ? this.m_u1.Multiply(1 / v) : this.m_u1.SetZero(), b > t.b2_linearSlop ? this.m_u2.Multiply(1 / b) : this.m_u2.SetZero(), this.m_constant - v - this.m_ratio * b > 0 ? (this.m_state = d.e_inactiveLimit, this.m_impulse = 0) : this.m_state = d.e_atUpperLimit, v < this.m_maxLength1 ? (this.m_limitState1 = d.e_inactiveLimit, this.m_limitImpulse1 = 0) : this.m_limitState1 = d.e_atUpperLimit, b < this.m_maxLength2 ? (this.m_limitState2 = d.e_inactiveLimit, this.m_limitImpulse2 = 0) : this.m_limitState2 = d.e_atUpperLimit;
        var w = o * this.m_u1.y - s * this.m_u1.x, S = l * this.m_u2.y - c * this.m_u2.x;
        if (this.m_limitMass1 = n.m_invMass + n.m_invI * w * w, this.m_limitMass2 = r.m_invMass + r.m_invI * S * S, this.m_pulleyMass = this.m_limitMass1 + this.m_ratio * this.m_ratio * this.m_limitMass2, this.m_limitMass1 = 1 / this.m_limitMass1, this.m_limitMass2 = 1 / this.m_limitMass2, this.m_pulleyMass = 1 / this.m_pulleyMass, e.warmStarting) {
          this.m_impulse *= e.dtRatio, this.m_limitImpulse1 *= e.dtRatio, this.m_limitImpulse2 *= e.dtRatio;
          var M = (-this.m_impulse - this.m_limitImpulse1) * this.m_u1.x, A = (-this.m_impulse - this.m_limitImpulse1) * this.m_u1.y, C = (-this.m_ratio * this.m_impulse - this.m_limitImpulse2) * this.m_u2.x, T = (-this.m_ratio * this.m_impulse - this.m_limitImpulse2) * this.m_u2.y;
          n.m_linearVelocity.x += n.m_invMass * M, n.m_linearVelocity.y += n.m_invMass * A, n.m_angularVelocity += n.m_invI * (o * A - s * M), r.m_linearVelocity.x += r.m_invMass * C, r.m_linearVelocity.y += r.m_invMass * T, r.m_angularVelocity += r.m_invI * (l * T - c * C);
        } else this.m_impulse = 0, this.m_limitImpulse1 = 0, this.m_limitImpulse2 = 0;
      }, M.prototype.SolveVelocityConstraints = function (t) {
        var e, i = this.m_bodyA, n = this.m_bodyB;
        e = i.m_xf.R;
        var o = this.m_localAnchor1.x - i.m_sweep.localCenter.x, s = this.m_localAnchor1.y - i.m_sweep.localCenter.y, a = e.col1.x * o + e.col2.x * s;
        s = e.col1.y * o + e.col2.y * s, o = a, e = n.m_xf.R;
        var l = this.m_localAnchor2.x - n.m_sweep.localCenter.x, c = this.m_localAnchor2.y - n.m_sweep.localCenter.y;
        a = e.col1.x * l + e.col2.x * c, c = e.col1.y * l + e.col2.y * c, l = a;
        var h = 0, u = 0, p = 0, m = 0, _ = 0, y = 0, g = 0, x = 0, v = 0, b = 0, w = 0;
        this.m_state == d.e_atUpperLimit && (h = i.m_linearVelocity.x + -i.m_angularVelocity * s, u = i.m_linearVelocity.y + i.m_angularVelocity * o, p = n.m_linearVelocity.x + -n.m_angularVelocity * c, m = n.m_linearVelocity.y + n.m_angularVelocity * l, v = -(this.m_u1.x * h + this.m_u1.y * u) - this.m_ratio * (this.m_u2.x * p + this.m_u2.y * m), b = this.m_pulleyMass * -v, w = this.m_impulse, this.m_impulse = r.Max(0, this.m_impulse + b), _ = -(b = this.m_impulse - w) * this.m_u1.x, y = -b * this.m_u1.y, g = -this.m_ratio * b * this.m_u2.x, x = -this.m_ratio * b * this.m_u2.y, i.m_linearVelocity.x += i.m_invMass * _, i.m_linearVelocity.y += i.m_invMass * y, i.m_angularVelocity += i.m_invI * (o * y - s * _), n.m_linearVelocity.x += n.m_invMass * g, n.m_linearVelocity.y += n.m_invMass * x, n.m_angularVelocity += n.m_invI * (l * x - c * g)), this.m_limitState1 == d.e_atUpperLimit && (h = i.m_linearVelocity.x + -i.m_angularVelocity * s, u = i.m_linearVelocity.y + i.m_angularVelocity * o, v = -(this.m_u1.x * h + this.m_u1.y * u), b = -this.m_limitMass1 * v, w = this.m_limitImpulse1, this.m_limitImpulse1 = r.Max(0, this.m_limitImpulse1 + b), _ = -(b = this.m_limitImpulse1 - w) * this.m_u1.x, y = -b * this.m_u1.y, i.m_linearVelocity.x += i.m_invMass * _, i.m_linearVelocity.y += i.m_invMass * y, i.m_angularVelocity += i.m_invI * (o * y - s * _)), this.m_limitState2 == d.e_atUpperLimit && (p = n.m_linearVelocity.x + -n.m_angularVelocity * c, m = n.m_linearVelocity.y + n.m_angularVelocity * l, v = -(this.m_u2.x * p + this.m_u2.y * m), b = -this.m_limitMass2 * v, w = this.m_limitImpulse2, this.m_limitImpulse2 = r.Max(0, this.m_limitImpulse2 + b), g = -(b = this.m_limitImpulse2 - w) * this.m_u2.x, x = -b * this.m_u2.y, n.m_linearVelocity.x += n.m_invMass * g, n.m_linearVelocity.y += n.m_invMass * x, n.m_angularVelocity += n.m_invI * (l * x - c * g));
      }, M.prototype.SolvePositionConstraints = function (e) {
        void 0 === e && (e = 0);
        var i, n = this.m_bodyA, o = this.m_bodyB, s = this.m_ground.m_xf.position.x + this.m_groundAnchor1.x, a = this.m_ground.m_xf.position.y + this.m_groundAnchor1.y, l = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x, c = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y, h = 0, u = 0, p = 0, m = 0, _ = 0, y = 0, g = 0, x = 0, v = 0, b = 0, w = 0, S = 0, M = 0, A = 0;
        return this.m_state == d.e_atUpperLimit && (i = n.m_xf.R, h = this.m_localAnchor1.x - n.m_sweep.localCenter.x, u = this.m_localAnchor1.y - n.m_sweep.localCenter.y, M = i.col1.x * h + i.col2.x * u, u = i.col1.y * h + i.col2.y * u, h = M, i = o.m_xf.R, p = this.m_localAnchor2.x - o.m_sweep.localCenter.x, m = this.m_localAnchor2.y - o.m_sweep.localCenter.y, M = i.col1.x * p + i.col2.x * m, m = i.col1.y * p + i.col2.y * m, p = M, _ = n.m_sweep.c.x + h, y = n.m_sweep.c.y + u, g = o.m_sweep.c.x + p, x = o.m_sweep.c.y + m, this.m_u1.Set(_ - s, y - a), this.m_u2.Set(g - l, x - c), v = this.m_u1.Length(), b = this.m_u2.Length(), v > t.b2_linearSlop ? this.m_u1.Multiply(1 / v) : this.m_u1.SetZero(), b > t.b2_linearSlop ? this.m_u2.Multiply(1 / b) : this.m_u2.SetZero(), w = this.m_constant - v - this.m_ratio * b, A = r.Max(A, -w), w = r.Clamp(w + t.b2_linearSlop, -t.b2_maxLinearCorrection, 0), _ = -(S = -this.m_pulleyMass * w) * this.m_u1.x, y = -S * this.m_u1.y, g = -this.m_ratio * S * this.m_u2.x, x = -this.m_ratio * S * this.m_u2.y, n.m_sweep.c.x += n.m_invMass * _, n.m_sweep.c.y += n.m_invMass * y, n.m_sweep.a += n.m_invI * (h * y - u * _), o.m_sweep.c.x += o.m_invMass * g, o.m_sweep.c.y += o.m_invMass * x, o.m_sweep.a += o.m_invI * (p * x - m * g), n.SynchronizeTransform(), o.SynchronizeTransform()), this.m_limitState1 == d.e_atUpperLimit && (i = n.m_xf.R, h = this.m_localAnchor1.x - n.m_sweep.localCenter.x, u = this.m_localAnchor1.y - n.m_sweep.localCenter.y, M = i.col1.x * h + i.col2.x * u, u = i.col1.y * h + i.col2.y * u, h = M, _ = n.m_sweep.c.x + h, y = n.m_sweep.c.y + u, this.m_u1.Set(_ - s, y - a), (v = this.m_u1.Length()) > t.b2_linearSlop ? (this.m_u1.x *= 1 / v, this.m_u1.y *= 1 / v) : this.m_u1.SetZero(), w = this.m_maxLength1 - v, A = r.Max(A, -w), w = r.Clamp(w + t.b2_linearSlop, -t.b2_maxLinearCorrection, 0), _ = -(S = -this.m_limitMass1 * w) * this.m_u1.x, y = -S * this.m_u1.y, n.m_sweep.c.x += n.m_invMass * _, n.m_sweep.c.y += n.m_invMass * y, n.m_sweep.a += n.m_invI * (h * y - u * _), n.SynchronizeTransform()), this.m_limitState2 == d.e_atUpperLimit && (i = o.m_xf.R, p = this.m_localAnchor2.x - o.m_sweep.localCenter.x, m = this.m_localAnchor2.y - o.m_sweep.localCenter.y, M = i.col1.x * p + i.col2.x * m, m = i.col1.y * p + i.col2.y * m, p = M, g = o.m_sweep.c.x + p, x = o.m_sweep.c.y + m, this.m_u2.Set(g - l, x - c), (b = this.m_u2.Length()) > t.b2_linearSlop ? (this.m_u2.x *= 1 / b, this.m_u2.y *= 1 / b) : this.m_u2.SetZero(), w = this.m_maxLength2 - b, A = r.Max(A, -w), w = r.Clamp(w + t.b2_linearSlop, -t.b2_maxLinearCorrection, 0), g = -(S = -this.m_limitMass2 * w) * this.m_u2.x, x = -S * this.m_u2.y, o.m_sweep.c.x += o.m_invMass * g, o.m_sweep.c.y += o.m_invMass * x, o.m_sweep.a += o.m_invI * (p * x - m * g), o.SynchronizeTransform()), A < t.b2_linearSlop;
      }, e.postDefs.push(function () {
        e.Dynamics.Joints.b2PulleyJoint.b2_minPulleyLength = 2;
      }), e.inherit(A, e.Dynamics.Joints.b2JointDef), A.prototype.__super = e.Dynamics.Joints.b2JointDef.prototype, A.b2PulleyJointDef = function () {
        e.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments), this.groundAnchorA = new o, this.groundAnchorB = new o, this.localAnchorA = new o, this.localAnchorB = new o;
      }, A.prototype.b2PulleyJointDef = function () {
        this.__super.b2JointDef.call(this), this.type = d.e_pulleyJoint, this.groundAnchorA.Set(-1, 1), this.groundAnchorB.Set(1, 1), this.localAnchorA.Set(-1, 0), this.localAnchorB.Set(1, 0), this.lengthA = 0, this.maxLengthA = 0, this.lengthB = 0, this.maxLengthB = 0, this.ratio = 1, this.collideConnected = true;
      }, A.prototype.Initialize = function (t, e, i, n, r, o, s) {
        void 0 === s && (s = 0), this.bodyA = t, this.bodyB = e, this.groundAnchorA.SetV(i), this.groundAnchorB.SetV(n), this.localAnchorA = this.bodyA.GetLocalPoint(r), this.localAnchorB = this.bodyB.GetLocalPoint(o);
        var a = r.x - i.x, l = r.y - i.y;
        this.lengthA = Math.sqrt(a * a + l * l);
        var c = o.x - n.x, h = o.y - n.y;
        this.lengthB = Math.sqrt(c * c + h * h), this.ratio = s;
        var u = this.lengthA + this.ratio * this.lengthB;
        this.maxLengthA = u - this.ratio * M.b2_minPulleyLength, this.maxLengthB = (u - M.b2_minPulleyLength) / this.ratio;
      }, e.inherit(C, e.Dynamics.Joints.b2Joint), C.prototype.__super = e.Dynamics.Joints.b2Joint.prototype, C.b2RevoluteJoint = function () {
        e.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments), this.K = new i, this.K1 = new i, this.K2 = new i, this.K3 = new i, this.impulse3 = new s, this.impulse2 = new o, this.reduced = new o, this.m_localAnchor1 = new o, this.m_localAnchor2 = new o, this.m_impulse = new s, this.m_mass = new n;
      }, C.prototype.GetAnchorA = function () {
        return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
      }, C.prototype.GetAnchorB = function () {
        return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
      }, C.prototype.GetReactionForce = function (t) {
        return void 0 === t && (t = 0), new o(t * this.m_impulse.x, t * this.m_impulse.y);
      }, C.prototype.GetReactionTorque = function (t) {
        return void 0 === t && (t = 0), t * this.m_impulse.z;
      }, C.prototype.GetJointAngle = function () {
        return this.m_bodyB.m_sweep.a - this.m_bodyA.m_sweep.a - this.m_referenceAngle;
      }, C.prototype.GetJointSpeed = function () {
        return this.m_bodyB.m_angularVelocity - this.m_bodyA.m_angularVelocity;
      }, C.prototype.IsLimitEnabled = function () {
        return this.m_enableLimit;
      }, C.prototype.EnableLimit = function (t) {
        this.m_enableLimit = t;
      }, C.prototype.GetLowerLimit = function () {
        return this.m_lowerAngle;
      }, C.prototype.GetUpperLimit = function () {
        return this.m_upperAngle;
      }, C.prototype.SetLimits = function (t, e) {
        void 0 === t && (t = 0), void 0 === e && (e = 0), this.m_lowerAngle = t, this.m_upperAngle = e;
      }, C.prototype.IsMotorEnabled = function () {
        return this.m_bodyA.SetAwake(true), this.m_bodyB.SetAwake(true), this.m_enableMotor;
      }, C.prototype.EnableMotor = function (t) {
        this.m_enableMotor = t;
      }, C.prototype.SetMotorSpeed = function (t) {
        void 0 === t && (t = 0), this.m_bodyA.SetAwake(true), this.m_bodyB.SetAwake(true), this.m_motorSpeed = t;
      }, C.prototype.GetMotorSpeed = function () {
        return this.m_motorSpeed;
      }, C.prototype.SetMaxMotorTorque = function (t) {
        void 0 === t && (t = 0), this.m_maxMotorTorque = t;
      }, C.prototype.GetMotorTorque = function () {
        return this.m_maxMotorTorque;
      }, C.prototype.b2RevoluteJoint = function (t) {
        this.__super.b2Joint.call(this, t), this.m_localAnchor1.SetV(t.localAnchorA), this.m_localAnchor2.SetV(t.localAnchorB), this.m_referenceAngle = t.referenceAngle, this.m_impulse.SetZero(), this.m_motorImpulse = 0, this.m_lowerAngle = t.lowerAngle, this.m_upperAngle = t.upperAngle, this.m_maxMotorTorque = t.maxMotorTorque, this.m_motorSpeed = t.motorSpeed, this.m_enableLimit = t.enableLimit, this.m_enableMotor = t.enableMotor, this.m_limitState = d.e_inactiveLimit;
      }, C.prototype.InitVelocityConstraints = function (e) {
        var i, n = this.m_bodyA, o = this.m_bodyB, s = 0;
        this.m_enableMotor || this.m_enableLimit, i = n.m_xf.R;
        var a = this.m_localAnchor1.x - n.m_sweep.localCenter.x, l = this.m_localAnchor1.y - n.m_sweep.localCenter.y;
        s = i.col1.x * a + i.col2.x * l, l = i.col1.y * a + i.col2.y * l, a = s, i = o.m_xf.R;
        var c = this.m_localAnchor2.x - o.m_sweep.localCenter.x, h = this.m_localAnchor2.y - o.m_sweep.localCenter.y;
        s = i.col1.x * c + i.col2.x * h, h = i.col1.y * c + i.col2.y * h, c = s;
        var u = n.m_invMass, p = o.m_invMass, m = n.m_invI, _ = o.m_invI;
        if (this.m_mass.col1.x = u + p + l * l * m + h * h * _, this.m_mass.col2.x = -l * a * m - h * c * _, this.m_mass.col3.x = -l * m - h * _, this.m_mass.col1.y = this.m_mass.col2.x, this.m_mass.col2.y = u + p + a * a * m + c * c * _, this.m_mass.col3.y = a * m + c * _, this.m_mass.col1.z = this.m_mass.col3.x, this.m_mass.col2.z = this.m_mass.col3.y, this.m_mass.col3.z = m + _, this.m_motorMass = 1 / (m + _), 0 == this.m_enableMotor && (this.m_motorImpulse = 0), this.m_enableLimit) {
          var y = o.m_sweep.a - n.m_sweep.a - this.m_referenceAngle;
          r.Abs(this.m_upperAngle - this.m_lowerAngle) < 2 * t.b2_angularSlop ? this.m_limitState = d.e_equalLimits : y <= this.m_lowerAngle ? (this.m_limitState != d.e_atLowerLimit && (this.m_impulse.z = 0), this.m_limitState = d.e_atLowerLimit) : y >= this.m_upperAngle ? (this.m_limitState != d.e_atUpperLimit && (this.m_impulse.z = 0), this.m_limitState = d.e_atUpperLimit) : (this.m_limitState = d.e_inactiveLimit, this.m_impulse.z = 0);
        } else this.m_limitState = d.e_inactiveLimit;
        if (e.warmStarting) {
          this.m_impulse.x *= e.dtRatio, this.m_impulse.y *= e.dtRatio, this.m_motorImpulse *= e.dtRatio;
          var g = this.m_impulse.x, x = this.m_impulse.y;
          n.m_linearVelocity.x -= u * g, n.m_linearVelocity.y -= u * x, n.m_angularVelocity -= m * (a * x - l * g + this.m_motorImpulse + this.m_impulse.z), o.m_linearVelocity.x += p * g, o.m_linearVelocity.y += p * x, o.m_angularVelocity += _ * (c * x - h * g + this.m_motorImpulse + this.m_impulse.z);
        } else this.m_impulse.SetZero(), this.m_motorImpulse = 0;
      }, C.prototype.SolveVelocityConstraints = function (t) {
        var e, i = this.m_bodyA, n = this.m_bodyB, o = 0, s = 0, a = 0, l = 0, c = 0, h = i.m_linearVelocity, u = i.m_angularVelocity, p = n.m_linearVelocity, m = n.m_angularVelocity, _ = i.m_invMass, y = n.m_invMass, g = i.m_invI, x = n.m_invI;
        if (this.m_enableMotor && this.m_limitState != d.e_equalLimits) {
          var v = m - u - this.m_motorSpeed, b = this.m_motorMass * -v, w = this.m_motorImpulse, S = t.dt * this.m_maxMotorTorque;
          this.m_motorImpulse = r.Clamp(this.m_motorImpulse + b, -S, S), u -= g * (b = this.m_motorImpulse - w), m += x * b;
        }
        if (this.m_enableLimit && this.m_limitState != d.e_inactiveLimit) {
          e = i.m_xf.R, s = this.m_localAnchor1.x - i.m_sweep.localCenter.x, a = this.m_localAnchor1.y - i.m_sweep.localCenter.y, o = e.col1.x * s + e.col2.x * a, a = e.col1.y * s + e.col2.y * a, s = o, e = n.m_xf.R, l = this.m_localAnchor2.x - n.m_sweep.localCenter.x, c = this.m_localAnchor2.y - n.m_sweep.localCenter.y, o = e.col1.x * l + e.col2.x * c, c = e.col1.y * l + e.col2.y * c, l = o;
          var M = p.x + -m * c - h.x - -u * a, A = p.y + m * l - h.y - u * s, C = m - u;
          this.m_mass.Solve33(this.impulse3, -M, -A, -C), this.m_limitState == d.e_equalLimits ? this.m_impulse.Add(this.impulse3) : this.m_limitState == d.e_atLowerLimit ? this.m_impulse.z + this.impulse3.z < 0 && (this.m_mass.Solve22(this.reduced, -M, -A), this.impulse3.x = this.reduced.x, this.impulse3.y = this.reduced.y, this.impulse3.z = -this.m_impulse.z, this.m_impulse.x += this.reduced.x, this.m_impulse.y += this.reduced.y, this.m_impulse.z = 0) : this.m_limitState == d.e_atUpperLimit && this.m_impulse.z + this.impulse3.z > 0 && (this.m_mass.Solve22(this.reduced, -M, -A), this.impulse3.x = this.reduced.x, this.impulse3.y = this.reduced.y, this.impulse3.z = -this.m_impulse.z, this.m_impulse.x += this.reduced.x, this.m_impulse.y += this.reduced.y, this.m_impulse.z = 0), h.x -= _ * this.impulse3.x, h.y -= _ * this.impulse3.y, u -= g * (s * this.impulse3.y - a * this.impulse3.x + this.impulse3.z), p.x += y * this.impulse3.x, p.y += y * this.impulse3.y, m += x * (l * this.impulse3.y - c * this.impulse3.x + this.impulse3.z);
        } else {
          e = i.m_xf.R, s = this.m_localAnchor1.x - i.m_sweep.localCenter.x, a = this.m_localAnchor1.y - i.m_sweep.localCenter.y, o = e.col1.x * s + e.col2.x * a, a = e.col1.y * s + e.col2.y * a, s = o, e = n.m_xf.R, l = this.m_localAnchor2.x - n.m_sweep.localCenter.x, c = this.m_localAnchor2.y - n.m_sweep.localCenter.y, o = e.col1.x * l + e.col2.x * c, c = e.col1.y * l + e.col2.y * c, l = o;
          var T = p.x + -m * c - h.x - -u * a, E = p.y + m * l - h.y - u * s;
          this.m_mass.Solve22(this.impulse2, -T, -E), this.m_impulse.x += this.impulse2.x, this.m_impulse.y += this.impulse2.y, h.x -= _ * this.impulse2.x, h.y -= _ * this.impulse2.y, u -= g * (s * this.impulse2.y - a * this.impulse2.x), p.x += y * this.impulse2.x, p.y += y * this.impulse2.y, m += x * (l * this.impulse2.y - c * this.impulse2.x);
        }
        i.m_linearVelocity.SetV(h), i.m_angularVelocity = u, n.m_linearVelocity.SetV(p), n.m_angularVelocity = m;
      }, C.prototype.SolvePositionConstraints = function (e) {
        void 0 === e && (e = 0);
        var i, n, o = 0, s = this.m_bodyA, a = this.m_bodyB, l = 0, c = 0, h = 0, u = 0;
        if (this.m_enableLimit && this.m_limitState != d.e_inactiveLimit) {
          var p = a.m_sweep.a - s.m_sweep.a - this.m_referenceAngle, m = 0;
          this.m_limitState == d.e_equalLimits ? (o = r.Clamp(p - this.m_lowerAngle, -t.b2_maxAngularCorrection, t.b2_maxAngularCorrection), m = -this.m_motorMass * o, l = r.Abs(o)) : this.m_limitState == d.e_atLowerLimit ? (l = -(o = p - this.m_lowerAngle), o = r.Clamp(o + t.b2_angularSlop, -t.b2_maxAngularCorrection, 0), m = -this.m_motorMass * o) : this.m_limitState == d.e_atUpperLimit && (l = o = p - this.m_upperAngle, o = r.Clamp(o - t.b2_angularSlop, 0, t.b2_maxAngularCorrection), m = -this.m_motorMass * o), s.m_sweep.a -= s.m_invI * m, a.m_sweep.a += a.m_invI * m, s.SynchronizeTransform(), a.SynchronizeTransform();
        }
        i = s.m_xf.R;
        var _ = this.m_localAnchor1.x - s.m_sweep.localCenter.x, y = this.m_localAnchor1.y - s.m_sweep.localCenter.y;
        c = i.col1.x * _ + i.col2.x * y, y = i.col1.y * _ + i.col2.y * y, _ = c, i = a.m_xf.R;
        var g = this.m_localAnchor2.x - a.m_sweep.localCenter.x, x = this.m_localAnchor2.y - a.m_sweep.localCenter.y;
        c = i.col1.x * g + i.col2.x * x, x = i.col1.y * g + i.col2.y * x, g = c;
        var v = a.m_sweep.c.x + g - s.m_sweep.c.x - _, b = a.m_sweep.c.y + x - s.m_sweep.c.y - y, w = v * v + b * b, S = Math.sqrt(w);
        n = S;
        var M = s.m_invMass, A = a.m_invMass, T = s.m_invI, E = a.m_invI, L = 10 * t.b2_linearSlop;
        if (w > L * L) {
          var D = 1 / (M + A);
          h = D * -v, u = D * -b;
          var R = 0.5;
          s.m_sweep.c.x -= R * M * h, s.m_sweep.c.y -= R * M * u, a.m_sweep.c.x += R * A * h, a.m_sweep.c.y += R * A * u, v = a.m_sweep.c.x + g - s.m_sweep.c.x - _, b = a.m_sweep.c.y + x - s.m_sweep.c.y - y;
        }
        return this.K1.col1.x = M + A, this.K1.col2.x = 0, this.K1.col1.y = 0, this.K1.col2.y = M + A, this.K2.col1.x = T * y * y, this.K2.col2.x = -T * _ * y, this.K2.col1.y = -T * _ * y, this.K2.col2.y = T * _ * _, this.K3.col1.x = E * x * x, this.K3.col2.x = -E * g * x, this.K3.col1.y = -E * g * x, this.K3.col2.y = E * g * g, this.K.SetM(this.K1), this.K.AddM(this.K2), this.K.AddM(this.K3), this.K.Solve(C.tImpulse, -v, -b), h = C.tImpulse.x, u = C.tImpulse.y, s.m_sweep.c.x -= s.m_invMass * h, s.m_sweep.c.y -= s.m_invMass * u, s.m_sweep.a -= s.m_invI * (_ * u - y * h), a.m_sweep.c.x += a.m_invMass * h, a.m_sweep.c.y += a.m_invMass * u, a.m_sweep.a += a.m_invI * (g * u - x * h), s.SynchronizeTransform(), a.SynchronizeTransform(), n <= t.b2_linearSlop && l <= t.b2_angularSlop;
      }, e.postDefs.push(function () {
        e.Dynamics.Joints.b2RevoluteJoint.tImpulse = new o;
      }), e.inherit(T, e.Dynamics.Joints.b2JointDef), T.prototype.__super = e.Dynamics.Joints.b2JointDef.prototype, T.b2RevoluteJointDef = function () {
        e.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments), this.localAnchorA = new o, this.localAnchorB = new o;
      }, T.prototype.b2RevoluteJointDef = function () {
        this.__super.b2JointDef.call(this), this.type = d.e_revoluteJoint, this.localAnchorA.Set(0, 0), this.localAnchorB.Set(0, 0), this.referenceAngle = 0, this.lowerAngle = 0, this.upperAngle = 0, this.maxMotorTorque = 0, this.motorSpeed = 0, this.enableLimit = false, this.enableMotor = false;
      }, T.prototype.Initialize = function (t, e, i) {
        this.bodyA = t, this.bodyB = e, this.localAnchorA = this.bodyA.GetLocalPoint(i), this.localAnchorB = this.bodyB.GetLocalPoint(i), this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle();
      }, e.inherit(E, e.Dynamics.Joints.b2Joint), E.prototype.__super = e.Dynamics.Joints.b2Joint.prototype, E.b2WeldJoint = function () {
        e.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments), this.m_localAnchorA = new o, this.m_localAnchorB = new o, this.m_impulse = new s, this.m_mass = new n;
      }, E.prototype.GetAnchorA = function () {
        return this.m_bodyA.GetWorldPoint(this.m_localAnchorA);
      }, E.prototype.GetAnchorB = function () {
        return this.m_bodyB.GetWorldPoint(this.m_localAnchorB);
      }, E.prototype.GetReactionForce = function (t) {
        return void 0 === t && (t = 0), new o(t * this.m_impulse.x, t * this.m_impulse.y);
      }, E.prototype.GetReactionTorque = function (t) {
        return void 0 === t && (t = 0), t * this.m_impulse.z;
      }, E.prototype.b2WeldJoint = function (t) {
        this.__super.b2Joint.call(this, t), this.m_localAnchorA.SetV(t.localAnchorA), this.m_localAnchorB.SetV(t.localAnchorB), this.m_referenceAngle = t.referenceAngle, this.m_impulse.SetZero(), this.m_mass = new n;
      }, E.prototype.InitVelocityConstraints = function (t) {
        var e, i = 0, n = this.m_bodyA, r = this.m_bodyB;
        e = n.m_xf.R;
        var o = this.m_localAnchorA.x - n.m_sweep.localCenter.x, s = this.m_localAnchorA.y - n.m_sweep.localCenter.y;
        i = e.col1.x * o + e.col2.x * s, s = e.col1.y * o + e.col2.y * s, o = i, e = r.m_xf.R;
        var a = this.m_localAnchorB.x - r.m_sweep.localCenter.x, l = this.m_localAnchorB.y - r.m_sweep.localCenter.y;
        i = e.col1.x * a + e.col2.x * l, l = e.col1.y * a + e.col2.y * l, a = i;
        var c = n.m_invMass, h = r.m_invMass, u = n.m_invI, p = r.m_invI;
        this.m_mass.col1.x = c + h + s * s * u + l * l * p, this.m_mass.col2.x = -s * o * u - l * a * p, this.m_mass.col3.x = -s * u - l * p, this.m_mass.col1.y = this.m_mass.col2.x, this.m_mass.col2.y = c + h + o * o * u + a * a * p, this.m_mass.col3.y = o * u + a * p, this.m_mass.col1.z = this.m_mass.col3.x, this.m_mass.col2.z = this.m_mass.col3.y, this.m_mass.col3.z = u + p, t.warmStarting ? (this.m_impulse.x *= t.dtRatio, this.m_impulse.y *= t.dtRatio, this.m_impulse.z *= t.dtRatio, n.m_linearVelocity.x -= c * this.m_impulse.x, n.m_linearVelocity.y -= c * this.m_impulse.y, n.m_angularVelocity -= u * (o * this.m_impulse.y - s * this.m_impulse.x + this.m_impulse.z), r.m_linearVelocity.x += h * this.m_impulse.x, r.m_linearVelocity.y += h * this.m_impulse.y, r.m_angularVelocity += p * (a * this.m_impulse.y - l * this.m_impulse.x + this.m_impulse.z)) : this.m_impulse.SetZero();
      }, E.prototype.SolveVelocityConstraints = function (t) {
        var e, i = 0, n = this.m_bodyA, r = this.m_bodyB, o = n.m_linearVelocity, a = n.m_angularVelocity, l = r.m_linearVelocity, c = r.m_angularVelocity, h = n.m_invMass, u = r.m_invMass, p = n.m_invI, m = r.m_invI;
        e = n.m_xf.R;
        var d = this.m_localAnchorA.x - n.m_sweep.localCenter.x, _ = this.m_localAnchorA.y - n.m_sweep.localCenter.y;
        i = e.col1.x * d + e.col2.x * _, _ = e.col1.y * d + e.col2.y * _, d = i, e = r.m_xf.R;
        var y = this.m_localAnchorB.x - r.m_sweep.localCenter.x, g = this.m_localAnchorB.y - r.m_sweep.localCenter.y;
        i = e.col1.x * y + e.col2.x * g, g = e.col1.y * y + e.col2.y * g, y = i;
        var x = l.x - c * g - o.x + a * _, v = l.y + c * y - o.y - a * d, b = c - a, w = new s;
        this.m_mass.Solve33(w, -x, -v, -b), this.m_impulse.Add(w), o.x -= h * w.x, o.y -= h * w.y, a -= p * (d * w.y - _ * w.x + w.z), l.x += u * w.x, l.y += u * w.y, c += m * (y * w.y - g * w.x + w.z), n.m_angularVelocity = a, r.m_angularVelocity = c;
      }, E.prototype.SolvePositionConstraints = function (e) {
        var i;
        void 0 === e && (e = 0);
        var n = 0, o = this.m_bodyA, a = this.m_bodyB;
        i = o.m_xf.R;
        var l = this.m_localAnchorA.x - o.m_sweep.localCenter.x, c = this.m_localAnchorA.y - o.m_sweep.localCenter.y;
        n = i.col1.x * l + i.col2.x * c, c = i.col1.y * l + i.col2.y * c, l = n, i = a.m_xf.R;
        var h = this.m_localAnchorB.x - a.m_sweep.localCenter.x, u = this.m_localAnchorB.y - a.m_sweep.localCenter.y;
        n = i.col1.x * h + i.col2.x * u, u = i.col1.y * h + i.col2.y * u, h = n;
        var p = o.m_invMass, m = a.m_invMass, d = o.m_invI, _ = a.m_invI, y = a.m_sweep.c.x + h - o.m_sweep.c.x - l, g = a.m_sweep.c.y + u - o.m_sweep.c.y - c, x = a.m_sweep.a - o.m_sweep.a - this.m_referenceAngle, v = 10 * t.b2_linearSlop, b = Math.sqrt(y * y + g * g), w = r.Abs(x);
        b > v && (d *= 1, _ *= 1), this.m_mass.col1.x = p + m + c * c * d + u * u * _, this.m_mass.col2.x = -c * l * d - u * h * _, this.m_mass.col3.x = -c * d - u * _, this.m_mass.col1.y = this.m_mass.col2.x, this.m_mass.col2.y = p + m + l * l * d + h * h * _, this.m_mass.col3.y = l * d + h * _, this.m_mass.col1.z = this.m_mass.col3.x, this.m_mass.col2.z = this.m_mass.col3.y, this.m_mass.col3.z = d + _;
        var S = new s;
        return this.m_mass.Solve33(S, -y, -g, -x), o.m_sweep.c.x -= p * S.x, o.m_sweep.c.y -= p * S.y, o.m_sweep.a -= d * (l * S.y - c * S.x + S.z), a.m_sweep.c.x += m * S.x, a.m_sweep.c.y += m * S.y, a.m_sweep.a += _ * (h * S.y - u * S.x + S.z), o.SynchronizeTransform(), a.SynchronizeTransform(), b <= t.b2_linearSlop && w <= t.b2_angularSlop;
      }, e.inherit(L, e.Dynamics.Joints.b2JointDef), L.prototype.__super = e.Dynamics.Joints.b2JointDef.prototype, L.b2WeldJointDef = function () {
        e.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments), this.localAnchorA = new o, this.localAnchorB = new o;
      }, L.prototype.b2WeldJointDef = function () {
        this.__super.b2JointDef.call(this), this.type = d.e_weldJoint, this.referenceAngle = 0;
      }, L.prototype.Initialize = function (t, e, i) {
        this.bodyA = t, this.bodyB = e, this.localAnchorA.SetV(this.bodyA.GetLocalPoint(i)), this.localAnchorB.SetV(this.bodyB.GetLocalPoint(i)), this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle();
      };
    }(), (z = e.Dynamics.b2DebugDraw).b2DebugDraw = function () {
      this.m_drawScale = 1, this.m_lineThickness = 1, this.m_alpha = 1, this.m_fillAlpha = 1, this.m_xformScale = 1, this.m_sprite = {graphics: {clear: function () {}}};
    }, z.prototype._color = function (t, e) {
      return "rgba(" + ((16711680 & t) >> 16) + "," + ((65280 & t) >> 8) + "," + (255 & t) + "," + e + ")";
    }, z.prototype.b2DebugDraw = function () {
      this.m_drawFlags = 0;
    }, z.prototype.SetFlags = function (t) {
      void 0 === t && (t = 0), this.m_drawFlags = t;
    }, z.prototype.GetFlags = function () {
      return this.m_drawFlags;
    }, z.prototype.AppendFlags = function (t) {
      void 0 === t && (t = 0), this.m_drawFlags |= t;
    }, z.prototype.ClearFlags = function (t) {
      void 0 === t && (t = 0), this.m_drawFlags &= ~t;
    }, z.prototype.SetSprite = function (t) {
      this.m_ctx = t;
    }, z.prototype.GetSprite = function () {
      return this.m_ctx;
    }, z.prototype.SetDrawScale = function (t) {
      void 0 === t && (t = 0), this.m_drawScale = t;
    }, z.prototype.GetDrawScale = function () {
      return this.m_drawScale;
    }, z.prototype.SetLineThickness = function (t) {
      void 0 === t && (t = 0), this.m_lineThickness = t, this.m_ctx.strokeWidth = t;
    }, z.prototype.GetLineThickness = function () {
      return this.m_lineThickness;
    }, z.prototype.SetAlpha = function (t) {
      void 0 === t && (t = 0), this.m_alpha = t;
    }, z.prototype.GetAlpha = function () {
      return this.m_alpha;
    }, z.prototype.SetFillAlpha = function (t) {
      void 0 === t && (t = 0), this.m_fillAlpha = t;
    }, z.prototype.GetFillAlpha = function () {
      return this.m_fillAlpha;
    }, z.prototype.SetXFormScale = function (t) {
      void 0 === t && (t = 0), this.m_xformScale = t;
    }, z.prototype.GetXFormScale = function () {
      return this.m_xformScale;
    }, z.prototype.DrawPolygon = function (t, e, i) {
      if (e) {
        var n = this.m_ctx, r = this.m_drawScale;
        n.beginPath(), n.strokeStyle = this._color(i.color, this.m_alpha), n.moveTo(t[0].x * r, t[0].y * r);
        for (var o = 1; o < e; o++) n.lineTo(t[o].x * r, t[o].y * r);
        n.lineTo(t[0].x * r, t[0].y * r), n.closePath(), n.stroke();
      }
    }, z.prototype.DrawSolidPolygon = function (t, e, i) {
      if (e) {
        var n = this.m_ctx, r = this.m_drawScale;
        n.beginPath(), n.strokeStyle = this._color(i.color, this.m_alpha), n.fillStyle = this._color(i.color, this.m_fillAlpha), n.moveTo(t[0].x * r, t[0].y * r);
        for (var o = 1; o < e; o++) n.lineTo(t[o].x * r, t[o].y * r);
        n.lineTo(t[0].x * r, t[0].y * r), n.closePath(), n.fill(), n.stroke();
      }
    }, z.prototype.DrawCircle = function (t, e, i) {
      if (e) {
        var n = this.m_ctx, r = this.m_drawScale;
        n.beginPath(), n.strokeStyle = this._color(i.color, this.m_alpha), n.arc(t.x * r, t.y * r, e * r, 0, 2 * Math.PI, true), n.closePath(), n.stroke();
      }
    }, z.prototype.DrawSolidCircle = function (t, e, i, n) {
      if (e) {
        var r = this.m_ctx, o = this.m_drawScale, s = t.x * o, a = t.y * o;
        r.moveTo(0, 0), r.beginPath(), r.strokeStyle = this._color(n.color, this.m_alpha), r.fillStyle = this._color(n.color, this.m_fillAlpha), r.arc(s, a, e * o, 0, 2 * Math.PI, true), r.moveTo(s, a), r.lineTo((t.x + i.x * e) * o, (t.y + i.y * e) * o), r.closePath(), r.fill(), r.stroke();
      }
    }, z.prototype.DrawSegment = function (t, e, i) {
      var n = this.m_ctx, r = this.m_drawScale;
      n.strokeStyle = this._color(i.color, this.m_alpha), n.beginPath(), n.moveTo(t.x * r, t.y * r), n.lineTo(e.x * r, e.y * r), n.closePath(), n.stroke();
    }, z.prototype.DrawTransform = function (t) {
      var e = this.m_ctx, i = this.m_drawScale;
      e.beginPath(), e.strokeStyle = this._color(16711680, this.m_alpha), e.moveTo(t.position.x * i, t.position.y * i), e.lineTo((t.position.x + this.m_xformScale * t.R.col1.x) * i, (t.position.y + this.m_xformScale * t.R.col1.y) * i), e.strokeStyle = this._color(65280, this.m_alpha), e.moveTo(t.position.x * i, t.position.y * i), e.lineTo((t.position.x + this.m_xformScale * t.R.col2.x) * i, (t.position.y + this.m_xformScale * t.R.col2.y) * i), e.closePath(), e.stroke();
    }, O = 0; O < e.postDefs.length; ++O) e.postDefs[O]();
    t.exports = e;
  }, 108: (t, e, i) => {
    t.exports = function t(e, i, n) {
      function r(s, a) {
        if (!i[s]) {
          if (!e[s]) {
            if (o) return o(s, true);
            var l = new Error("Cannot find module '" + s + "'");
            throw l.code = "MODULE_NOT_FOUND", l;
          }
          var c = i[s] = {exports: {}};
          e[s][0].call(c.exports, function (t) {
            var i = e[s][1][t];
            return r(i || t);
          }, c, c.exports, t, e, i, n);
        }
        return i[s].exports;
      }
      for (var o = void 0, s = 0; s < n.length; s++) r(n[s]);
      return r;
    }({1: [function (t, e, i) {
      i.encode = t("./encode").encode, i.decode = t("./decode").decode, i.Encoder = t("./encoder").Encoder, i.Decoder = t("./decoder").Decoder, i.createCodec = t("./ext").createCodec, i.codec = t("./codec").codec;
    }, {"./codec": 10, "./decode": 12, "./decoder": 13, "./encode": 15, "./encoder": 16, "./ext": 20}], 2: [function (t, e, i) {
      (function (t) {
        e.exports = void 0 !== t && t && (void 0 !== t && t).isBuffer && (void 0 !== t && t) || this.Buffer && this.Buffer.isBuffer && this.Buffer || "undefined" != typeof window && window.Buffer && ("undefined" != typeof window && window.Buffer).isBuffer && ("undefined" != typeof window && window.Buffer) || this.Buffer;
      }.call(this, t("buffer").Buffer));
    }, {buffer: 29}], 3: [function (t, e, i) {
      function n(t, e) {
        for (var i = this, n = e || (e |= 0), r = t.length, o = 0, s = 0; s < r;) (o = t.charCodeAt(s++)) < 128 ? i[n++] = o : o < 2048 ? (i[n++] = 192 | o >>> 6, i[n++] = 128 | 63 & o) : o < 55296 || o > 57343 ? (i[n++] = 224 | o >>> 12, i[n++] = 128 | o >>> 6 & 63, i[n++] = 128 | 63 & o) : (o = 65536 + (o - 55296 << 10 | t.charCodeAt(s++) - 56320), i[n++] = 240 | o >>> 18, i[n++] = 128 | o >>> 12 & 63, i[n++] = 128 | o >>> 6 & 63, i[n++] = 128 | 63 & o);
        return n - e;
      }
      function r(t, e, i) {
        var n = this, r = 0 | e;
        i || (i = n.length);
        for (var o = "", s = 0; r < i;) (s = n[r++]) < 128 ? o += String.fromCharCode(s) : (192 == (224 & s) ? s = (31 & s) << 6 | 63 & n[r++] : 224 == (240 & s) ? s = (15 & s) << 12 | (63 & n[r++]) << 6 | 63 & n[r++] : 240 == (248 & s) && (s = (7 & s) << 18 | (63 & n[r++]) << 12 | (63 & n[r++]) << 6 | 63 & n[r++]), s >= 65536 ? (s -= 65536, o += String.fromCharCode(55296 + (s >>> 10), 56320 + (1023 & s))) : o += String.fromCharCode(s));
        return o;
      }
      function o(t, e, i, n) {
        var r;
        i || (i = 0), n || 0 === n || (n = this.length), e || (e = 0);
        var o = n - i;
        if (t === this && i < e && e < n) for (r = o - 1; r >= 0; r--) t[r + e] = this[r + i]; else for (r = 0; r < o; r++) t[r + e] = this[r + i];
        return o;
      }
      i.copy = o, i.toString = r, i.write = n;
    }, {}], 4: [function (t, e, i) {
      function n(t) {
        return new Array(t);
      }
      function r(t) {
        if (!o.isBuffer(t) && o.isView(t)) t = o.Uint8Array.from(t); else if (o.isArrayBuffer(t)) t = new Uint8Array(t); else {
          if ("string" == typeof t) return o.from.call(i, t);
          if ("number" == typeof t) throw new TypeError('"value" argument must not be a number');
        }
        return Array.prototype.slice.call(t);
      }
      var o = t("./bufferish");
      (i = e.exports = n(0)).alloc = n, i.concat = o.concat, i.from = r;
    }, {"./bufferish": 8}], 5: [function (t, e, i) {
      function n(t) {
        return new s(t);
      }
      function r(t) {
        if (!o.isBuffer(t) && o.isView(t)) t = o.Uint8Array.from(t); else if (o.isArrayBuffer(t)) t = new Uint8Array(t); else {
          if ("string" == typeof t) return o.from.call(i, t);
          if ("number" == typeof t) throw new TypeError('"value" argument must not be a number');
        }
        return s.from && 1 !== s.from.length ? s.from(t) : new s(t);
      }
      var o = t("./bufferish"), s = o.global;
      (i = e.exports = o.hasBuffer ? n(0) : []).alloc = o.hasBuffer && s.alloc || n, i.concat = o.concat, i.from = r;
    }, {"./bufferish": 8}], 6: [function (t, e, i) {
      function n(t, e, i, n) {
        var o = l.isBuffer(this), s = l.isBuffer(t);
        if (o && s) return this.copy(t, e, i, n);
        if (u || o || s || !l.isView(this) || !l.isView(t)) return a.copy.call(this, t, e, i, n);
        var c = i || null != n ? r.call(this, i, n) : this;
        return t.set(c, e), c.length;
      }
      function r(t, e) {
        var i = this.slice || !u && this.subarray;
        if (i) return i.call(this, t, e);
        var r = l.alloc.call(this, e - t);
        return n.call(this, r, 0, t, e), r;
      }
      function s(t) {
        return e;
      }
      var a = t("./buffer-lite");
      i.copy = n, i.slice = r, i.toString = o, i.write = s("write");
      var l = t("./bufferish"), c = l.global, h = l.hasBuffer && "TYPED_ARRAY_SUPPORT" in c, u = h && !c.TYPED_ARRAY_SUPPORT;
    }, {"./buffer-lite": 3, "./bufferish": 8}], 7: [function (t, e, i) {
      function n(t) {
        return new Uint8Array(t);
      }
      function r(t) {
        if (o.isView(t)) {
          var e = t.byteOffset, n = t.byteLength;
          (t = t.buffer).byteLength !== n && (t.slice ? t = t.slice(e, e + n) : (t = new Uint8Array(t)).byteLength !== n && (t = Array.prototype.slice.call(t, e, e + n)));
        } else {
          if ("string" == typeof t) return o.from.call(i, t);
          if ("number" == typeof t) throw new TypeError('"value" argument must not be a number');
        }
        return new Uint8Array(t);
      }
      var o = t("./bufferish");
      (i = e.exports = o.hasArrayBuffer ? n(0) : []).alloc = n, i.concat = o.concat, i.from = r;
    }, {"./bufferish": 8}], 8: [function (t, e, i) {
      function n(t) {
        return "string" == typeof t ? a.call(this, t) : l(this).from(t);
      }
      function o(t, e) {
        function n(t) {
          e += t.length;
        }
        function o(t) {
          l += b.copy.call(t, a, l);
        }
        e || (e = 0, Array.prototype.forEach.call(t, n));
        var s = this !== i && this || t[0], a = r.call(s, e), l = 0;
        return Array.prototype.forEach.call(t, o), a;
      }
      function a(t) {
        var e = 3 * t.length, i = r.call(this, e), n = b.write.call(i, t);
        return e !== n && (i = b.slice.call(i, 0, n)), i;
      }
      function l(t) {
        return _(t) ? x : y(t) ? v : d(t) ? g : p ? x : m ? v : g;
      }
      function h(t, e) {
        return t = "[object " + t + "]", function (i) {
          return null != i && {}.toString.call(e ? i[e] : i) === t;
        };
      }
      var u = i.global = t("./buffer-global"), p = i.hasBuffer = u && !!u.isBuffer, m = i.hasArrayBuffer = "undefined" != typeof ArrayBuffer, d = i.isArray = t("isarray");
      i.isArrayBuffer = m ? s : c;
      var _ = i.isBuffer = p ? u.isBuffer : c, y = i.isView = m ? ArrayBuffer.isView || h("ArrayBuffer", "buffer") : c;
      i.alloc = r, i.concat = o, i.from = n;
      var g = i.Array = t("./bufferish-array"), x = i.Buffer = t("./bufferish-buffer"), v = i.Uint8Array = t("./bufferish-uint8array"), b = i.prototype = t("./bufferish-proto"), w = h("ArrayBuffer");
    }, {"./buffer-global": 2, "./bufferish-array": 4, "./bufferish-buffer": 5, "./bufferish-proto": 6, "./bufferish-uint8array": 7, isarray: 34}], 9: [function (t, e, i) {
      function n(t) {
        return this instanceof n ? (this.options = t, void this.init()) : new n(t);
      }
      function r(t) {
        for (var e in t) n.prototype[e] = o(n.prototype[e], t[e]);
      }
      function o(t, e) {
        return t && e ? i : t || e;
      }
      function s(t) {
        function e(t, e) {
          return e(t);
        }
        return t = t.slice(), function (i) {
          return t.reduce(e, i);
        };
      }
      function a(t) {
        return c(t) ? s(t) : t;
      }
      function l(t) {
        return new n(t);
      }
      var c = t("isarray");
      i.createCodec = l, i.install = r, i.filter = a;
      var h = t("./bufferish");
      n.prototype.init = function () {
        var t = this.options;
        return t && t.uint8array && (this.bufferish = h.Uint8Array), this;
      }, i.preset = l({preset: true});
    }, {"./bufferish": 8, isarray: 34}], 10: [function (t, e, i) {
      t("./read-core"), t("./write-core"), i.codec = {preset: t("./codec-base").preset};
    }, {"./codec-base": 9, "./read-core": 22, "./write-core": 25}], 11: [function (t, e, i) {
      function n(t) {
        if (!(this instanceof n)) return new n(t);
        if (t && (this.options = t, t.codec)) {
          var e = this.codec = t.codec;
          e.bufferish && (this.bufferish = e.bufferish);
        }
      }
      i.DecodeBuffer = n;
      var r = t("./read-core").preset;
      t("./flex-buffer").FlexDecoder.mixin(n.prototype), n.prototype.codec = r, n.prototype.fetch = function () {
        return this.codec.decode(this);
      };
    }, {"./flex-buffer": 21, "./read-core": 22}], 12: [function (t, e, i) {
      function n(t, e) {
        var i = new r(e);
        return i.write(t), i.read();
      }
      i.decode = n;
      var r = t("./decode-buffer").DecodeBuffer;
    }, {"./decode-buffer": 11}], 13: [function (t, e, i) {
      function n(t) {
        return this instanceof n ? void o.call(this, t) : new n(t);
      }
      i.Decoder = n;
      var r = t("event-lite"), o = t("./decode-buffer").DecodeBuffer;
      n.prototype = new o, r.mixin(n.prototype), n.prototype.decode = function (t) {
        arguments.length && this.write(t), this.flush();
      }, n.prototype.push = function (t) {
        this.emit("data", t);
      }, n.prototype.end = function (t) {
        this.decode(t), this.emit("end");
      };
    }, {"./decode-buffer": 11, "event-lite": 31}], 14: [function (t, e, i) {
      function n(t) {
        if (!(this instanceof n)) return new n(t);
        if (t && (this.options = t, t.codec)) {
          var e = this.codec = t.codec;
          e.bufferish && (this.bufferish = e.bufferish);
        }
      }
      i.EncodeBuffer = n;
      var r = t("./write-core").preset;
      t("./flex-buffer").FlexEncoder.mixin(n.prototype), n.prototype.codec = r, n.prototype.write = function (t) {
        this.codec.encode(this, t);
      };
    }, {"./flex-buffer": 21, "./write-core": 25}], 15: [function (t, e, i) {
      function n(t, e) {
        var i = new r(e);
        return i.write(t), i.read();
      }
      i.encode = n;
      var r = t("./encode-buffer").EncodeBuffer;
    }, {"./encode-buffer": 14}], 16: [function (t, e, i) {
      function n(t) {
        return this instanceof n ? void o.call(this, t) : new n(t);
      }
      i.Encoder = n;
      var r = t("event-lite"), o = t("./encode-buffer").EncodeBuffer;
      n.prototype = new o, r.mixin(n.prototype), n.prototype.encode = function (t) {
        this.write(t), this.emit("data", this.read());
      }, n.prototype.end = function (t) {
        arguments.length && this.encode(t), this.flush(), this.emit("end");
      };
    }, {"./encode-buffer": 14, "event-lite": 31}], 17: [function (t, e, i) {
      function n(t, e) {
        return this instanceof n ? (this.buffer = r.from(t), void (this.type = e)) : new n(t, e);
      }
      i.ExtBuffer = n;
      var r = t("./bufferish");
    }, {"./bufferish": 8}], 18: [function (t, e, i) {
      function n(t) {
        t.addExtPacker(14, Error, [a, r]), t.addExtPacker(1, EvalError, [a, r]), t.addExtPacker(2, RangeError, [a, r]), t.addExtPacker(3, ReferenceError, [a, r]), t.addExtPacker(4, SyntaxError, [a, r]), t.addExtPacker(5, TypeError, [a, r]), t.addExtPacker(6, URIError, [a, r]), t.addExtPacker(10, RegExp, [s, r]), t.addExtPacker(11, Boolean, [o, r]), t.addExtPacker(12, String, [o, r]), t.addExtPacker(13, Date, [Number, r]), t.addExtPacker(15, Number, [o, r]), "undefined" != typeof Uint8Array && (t.addExtPacker(17, Int8Array, u), t.addExtPacker(18, Uint8Array, u), t.addExtPacker(19, Int16Array, u), t.addExtPacker(20, Uint16Array, u), t.addExtPacker(21, Int32Array, u), t.addExtPacker(22, Uint32Array, u), t.addExtPacker(23, Float32Array, u), "undefined" != typeof Float64Array && t.addExtPacker(24, Float64Array, u), "undefined" != typeof Uint8ClampedArray && t.addExtPacker(25, Uint8ClampedArray, u), t.addExtPacker(26, ArrayBuffer, u), t.addExtPacker(29, DataView, u)), c.hasBuffer && t.addExtPacker(27, h, c.from);
      }
      function s(t) {
        (t = RegExp.prototype.toString.call(t).split("/")).shift();
        var e = [t.pop()];
        return e.unshift(t.join("/")), e;
      }
      function a(t) {
        var e = {};
        for (var i in p) e[i] = t[i];
        return e;
      }
      i.setExtPackers = n;
      var l, c = t("./bufferish"), h = c.global, u = c.Uint8Array.from, p = {name: 1, message: 1, stack: 1, columnNumber: 1, fileName: 1, lineNumber: 1};
    }, {"./bufferish": 8, "./encode": 15}], 19: [function (t, e, i) {
      function n(t) {
        t.addExtUnpacker(14, [r, s(Error)]), t.addExtUnpacker(1, [r, s(EvalError)]), t.addExtUnpacker(2, [r, s(RangeError)]), t.addExtUnpacker(3, [r, s(ReferenceError)]), t.addExtUnpacker(4, [r, s(SyntaxError)]), t.addExtUnpacker(5, [r, s(TypeError)]), t.addExtUnpacker(6, [r, s(URIError)]), t.addExtUnpacker(10, [r, o]), t.addExtUnpacker(11, [r, a(Boolean)]), t.addExtUnpacker(12, [r, a(String)]), t.addExtUnpacker(13, [r, a(Date)]), t.addExtUnpacker(15, [r, a(Number)]), "undefined" != typeof Uint8Array && (t.addExtUnpacker(17, a(Int8Array)), t.addExtUnpacker(18, a(Uint8Array)), t.addExtUnpacker(19, [l, a(Int16Array)]), t.addExtUnpacker(20, [l, a(Uint16Array)]), t.addExtUnpacker(21, [l, a(Int32Array)]), t.addExtUnpacker(22, [l, a(Uint32Array)]), t.addExtUnpacker(23, [l, a(Float32Array)]), "undefined" != typeof Float64Array && t.addExtUnpacker(24, [l, a(Float64Array)]), "undefined" != typeof Uint8ClampedArray && t.addExtUnpacker(25, a(Uint8ClampedArray)), t.addExtUnpacker(26, l), t.addExtUnpacker(29, [l, a(DataView)])), h.hasBuffer && t.addExtUnpacker(27, a(u));
      }
      function s(t) {
        return function (e) {
          var i = new t;
          for (var n in p) i[n] = e[n];
          return i;
        };
      }
      function a(t) {
        return function (e) {
          return new t(e);
        };
      }
      function l(t) {
        return new Uint8Array(t).buffer;
      }
      i.setExtUnpackers = n;
      var c, h = t("./bufferish"), u = h.global, p = {name: 1, message: 1, stack: 1, columnNumber: 1, fileName: 1, lineNumber: 1};
    }, {"./bufferish": 8, "./decode": 12}], 20: [function (t, e, i) {
      t("./read-core"), t("./write-core"), i.createCodec = t("./codec-base").createCodec;
    }, {"./codec-base": 9, "./read-core": 22, "./write-core": 25}], 21: [function (t, e, i) {
      function n() {
        if (!(this instanceof n)) return new n;
      }
      function r() {
        if (!(this instanceof r)) return new r;
      }
      function o() {
        function t(t) {
          var e = this.offset ? m.prototype.slice.call(this.buffer, this.offset) : this.buffer;
          this.buffer = e ? t ? this.bufferish.concat([e, t]) : e : t, this.offset = 0;
        }
        function e() {
          for (; this.offset < this.buffer.length;) {
            var t, e = this.offset;
            try {
              t = this.fetch();
            } catch (t) {
              if (t && t.message != y) throw t;
              this.offset = e;
              break;
            }
            this.push(t);
          }
        }
        function i(t) {
          var e = this.offset, i = e + t;
          if (i > this.buffer.length) throw new Error(y);
          return this.offset = i, e;
        }
        return {bufferish: m, write: t, fetch: l, flush: e, push: h, pull: u, read: c, reserve: i, offset: 0};
      }
      function s() {
        function t() {
          var t = this.start;
          if (t < this.offset) {
            var e = this.start = this.offset;
            return m.prototype.slice.call(this.buffer, t, e);
          }
        }
        function e() {
          for (; this.start < this.offset;) {
            var t = this.fetch();
            t && this.push(t);
          }
        }
        function i() {
          var t = this.buffers || (this.buffers = []), e = t.length > 1 ? this.bufferish.concat(t) : t[0];
          return t.length = 0, e;
        }
        function n(t) {
          var e = 0 | t;
          if (this.buffer) {
            var i = this.buffer.length, n = 0 | this.offset, r = n + e;
            if (r < i) return this.offset = r, n;
            this.flush(), t = Math.max(t, Math.min(2 * i, this.maxBufferSize));
          }
          return t = Math.max(t, this.minBufferSize), this.buffer = this.bufferish.alloc(t), this.start = 0, this.offset = e, 0;
        }
        function r(t) {
          var e = t.length;
          if (e > this.minBufferSize) this.flush(), this.push(t); else {
            var i = this.reserve(e);
            m.prototype.copy.call(t, this.buffer, i);
          }
        }
        return {bufferish: m, write: a, fetch: t, flush: e, push: h, pull: i, read: c, reserve: n, send: r, maxBufferSize: _, minBufferSize: d, offset: 0, start: 0};
      }
      function a() {
        throw new Error("method not implemented: write()");
      }
      function l() {
        throw new Error("method not implemented: fetch()");
      }
      function c() {
        return this.buffers && this.buffers.length ? (this.flush(), this.pull()) : this.fetch();
      }
      function h(t) {
        (this.buffers || (this.buffers = [])).push(t);
      }
      function p(t) {
        function e(e) {
          for (var i in t) e[i] = t[i];
          return e;
        }
        return e;
      }
      i.FlexDecoder = n, i.FlexEncoder = r;
      var m = t("./bufferish"), d = 2048, _ = 65536, y = "BUFFER_SHORTAGE";
      n.mixin = p(o()), n.mixin(n.prototype), r.mixin = p(s()), r.mixin(r.prototype);
    }, {"./bufferish": 8}], 22: [function (t, e, i) {
      function n(t) {
        function e(t) {
          var e = c(t), n = i[e];
          if (!n) throw new Error("Invalid type: " + (e ? "0x" + e.toString(16) : e));
          return n(t);
        }
        var i = h.getReadToken(t);
        return e;
      }
      function r() {
        var t = this.options;
        return this.decode = n(t), t && t.preset && l.setExtUnpackers(this), this;
      }
      function o(t, e) {
        (this.extUnpackers || (this.extUnpackers = []))[t] = u.filter(e);
      }
      function s(t) {
        function e(e) {
          return new a(e, t);
        }
        return (this.extUnpackers || (this.extUnpackers = []))[t] || e;
      }
      var a = t("./ext-buffer").ExtBuffer, l = t("./ext-unpacker"), c = t("./read-format").readUint8, h = t("./read-token"), u = t("./codec-base");
      u.install({addExtUnpacker: o, getExtUnpacker: s, init: r}), i.preset = r.call(u.preset);
    }, {"./codec-base": 9, "./ext-buffer": 17, "./ext-unpacker": 19, "./read-format": 23, "./read-token": 24}], 23: [function (t, e, i) {
      function n(t) {
        var e = L.hasArrayBuffer && t && t.binarraybuffer, i = t && t.int64;
        return {map: R && t && t.usemap ? o : r, array: s, str: a, bin: e ? c : l, ext: h, uint8: u, uint16: m, uint32: _, uint64: g(8, i ? b : x), int8: p, int16: d, int32: y, int64: g(8, i ? w : v), float32: g(4, S), float64: g(8, M)};
      }
      function r(t, e) {
        var i, n = {}, r = new Array(e), o = new Array(e), s = t.codec.decode;
        for (i = 0; i < e; i++) r[i] = s(t), o[i] = s(t);
        for (i = 0; i < e; i++) n[r[i]] = o[i];
        return n;
      }
      function o(t, e) {
        var i, n = new Map, r = new Array(e), o = new Array(e), s = t.codec.decode;
        for (i = 0; i < e; i++) r[i] = s(t), o[i] = s(t);
        for (i = 0; i < e; i++) n.set(r[i], o[i]);
        return n;
      }
      function s(t, e) {
        for (var i = new Array(e), n = t.codec.decode, r = 0; r < e; r++) i[r] = n(t);
        return i;
      }
      function a(t, e) {
        var i = t.reserve(e), n = i + e;
        return D.toString.call(t.buffer, "utf-8", i, n);
      }
      function l(t, e) {
        var i = t.reserve(e), n = i + e, r = D.slice.call(t.buffer, i, n);
        return L.from(r);
      }
      function c(t, e) {
        var i = t.reserve(e), n = i + e, r = D.slice.call(t.buffer, i, n);
        return L.Uint8Array.from(r).buffer;
      }
      function h(t, e) {
        var i = t.reserve(e + 1), n = t.buffer[i++], r = i + e, o = t.codec.getExtUnpacker(n);
        if (!o) throw new Error("Invalid ext type: " + (n ? "0x" + n.toString(16) : n));
        return o(D.slice.call(t.buffer, i, r));
      }
      function u(t) {
        var e = t.reserve(1);
        return t.buffer[e];
      }
      function p(t) {
        var e = t.reserve(1), i = t.buffer[e];
        return 128 & i ? i - 256 : i;
      }
      function m(t) {
        var e = t.reserve(2), i = t.buffer;
        return i[e++] << 8 | i[e];
      }
      function d(t) {
        var e = t.reserve(2), i = t.buffer, n = i[e++] << 8 | i[e];
        return 32768 & n ? n - 65536 : n;
      }
      function _(t) {
        var e = t.reserve(4), i = t.buffer;
        return 16777216 * i[e++] + (i[e++] << 16) + (i[e++] << 8) + i[e];
      }
      function y(t) {
        var e = t.reserve(4), i = t.buffer;
        return i[e++] << 24 | i[e++] << 16 | i[e++] << 8 | i[e];
      }
      function g(t, e) {
        return function (i) {
          var n = i.reserve(t);
          return e.call(i.buffer, n, B);
        };
      }
      function b(t) {
        return new T(this, t);
      }
      function w(t) {
        return new E(this, t);
      }
      var A = t("ieee754"), C = t("int64-buffer"), T = C.Uint64BE, E = C.Int64BE;
      i.getReadFormat = n, i.readUint8 = u;
      var L = t("./bufferish"), D = t("./bufferish-proto"), R = "undefined" != typeof Map, B = true;
    }, {"./bufferish": 8, "./bufferish-proto": 6, ieee754: 32, "int64-buffer": 33}], 24: [function (t, e, i) {
      function n(t) {
        var e = c.getReadFormat(t);
        return t && t.useraw ? o(e) : r(e);
      }
      function r(t) {
        var e, i = new Array(256);
        for (e = 0; e <= 127; e++) i[e] = s(e);
        for (e = 128; e <= 143; e++) i[e] = l(e - 128, t.map);
        for (e = 144; e <= 159; e++) i[e] = l(e - 144, t.array);
        for (e = 160; e <= 191; e++) i[e] = l(e - 160, t.str);
        for (i[192] = s(null), i[193] = null, i[194] = s(false), i[195] = s(true), i[196] = a(t.uint8, t.bin), i[197] = a(t.uint16, t.bin), i[198] = a(t.uint32, t.bin), i[199] = a(t.uint8, t.ext), i[200] = a(t.uint16, t.ext), i[201] = a(t.uint32, t.ext), i[202] = t.float32, i[203] = t.float64, i[204] = t.uint8, i[205] = t.uint16, i[206] = t.uint32, i[207] = t.uint64, i[208] = t.int8, i[209] = t.int16, i[210] = t.int32, i[211] = t.int64, i[212] = l(1, t.ext), i[213] = l(2, t.ext), i[214] = l(4, t.ext), i[215] = l(8, t.ext), i[216] = l(16, t.ext), i[217] = a(t.uint8, t.str), i[218] = a(t.uint16, t.str), i[219] = a(t.uint32, t.str), i[220] = a(t.uint16, t.array), i[221] = a(t.uint32, t.array), i[222] = a(t.uint16, t.map), i[223] = a(t.uint32, t.map), e = 224; e <= 255; e++) i[e] = s(e - 256);
        return i;
      }
      function o(t) {
        var e, i = r(t).slice();
        for (i[217] = i[196], i[218] = i[197], i[219] = i[198], e = 160; e <= 191; e++) i[e] = l(e - 160, t.bin);
        return i;
      }
      function s(t) {
        return function () {
          return t;
        };
      }
      function a(t, e) {
        return function (i) {
          var n = t(i);
          return e(i, n);
        };
      }
      function l(t, e) {
        return function (i) {
          return e(i, t);
        };
      }
      var c = t("./read-format");
      i.getReadToken = n;
    }, {"./read-format": 23}], 25: [function (t, e, i) {
      function n(t) {
        function e(t, e) {
          var n = i[typeof e];
          if (!n) throw new Error('Unsupported type "' + typeof e + '": ' + e);
          n(t, e);
        }
        var i = c.getWriteType(t);
        return e;
      }
      function r() {
        var t = this.options;
        return this.encode = n(t), t && t.preset && l.setExtPackers(this), this;
      }
      function o(t, e, i) {
        i = h.filter(i);
        var r = e.name;
        r && "Object" !== r ? (this.extPackers || (this.extPackers = {}))[r] = n : (this.extEncoderList || (this.extEncoderList = [])).unshift([e, n]);
      }
      function s(t) {
        var e = this.extPackers || (this.extPackers = {}), i = t.constructor, n = i && i.name && e[i.name];
        if (n) return n;
        for (var r = this.extEncoderList || (this.extEncoderList = []), o = r.length, s = 0; s < o; s++) {
          var a = r[s];
          if (i === a[0]) return a[1];
        }
      }
      var a = t("./ext-buffer").ExtBuffer, l = t("./ext-packer"), c = t("./write-type"), h = t("./codec-base");
      h.install({addExtPacker: o, getExtPacker: s, init: r}), i.preset = r.call(h.preset);
    }, {"./codec-base": 9, "./ext-buffer": 17, "./ext-packer": 18, "./write-type": 27}], 26: [function (t, e, i) {
      function n(t) {
        return t && t.uint8array ? r() : S || b.hasBuffer && t && t.safe ? s() : o();
      }
      function r() {
        var t = o();
        return t[202] = h(202, 4, m), t[203] = h(203, 8, d), t;
      }
      function o() {
        var t = v.slice();
        return t[196] = a(196), t[197] = l(197), t[198] = c(198), t[199] = a(199), t[200] = l(200), t[201] = c(201), t[202] = h(202, 4, M.writeFloatBE || m, true), t[203] = h(203, 8, M.writeDoubleBE || d, true), t[204] = a(204), t[205] = l(205), t[206] = c(206), t[207] = h(207, 8, u), t[208] = a(208), t[209] = l(209), t[210] = c(210), t[211] = h(211, 8, p), t[217] = a(217), t[218] = l(218), t[219] = c(219), t[220] = l(220), t[221] = c(221), t[222] = l(222), t[223] = c(223), t;
      }
      function s() {
        var t = v.slice();
        return t[196] = h(196, 1, w.prototype.writeUInt8), t[197] = h(197, 2, w.prototype.writeUInt16BE), t[198] = h(198, 4, w.prototype.writeUInt32BE), t[199] = h(199, 1, w.prototype.writeUInt8), t[200] = h(200, 2, w.prototype.writeUInt16BE), t[201] = h(201, 4, w.prototype.writeUInt32BE), t[202] = h(202, 4, w.prototype.writeFloatBE), t[203] = h(203, 8, w.prototype.writeDoubleBE), t[204] = h(204, 1, w.prototype.writeUInt8), t[205] = h(205, 2, w.prototype.writeUInt16BE), t[206] = h(206, 4, w.prototype.writeUInt32BE), t[207] = h(207, 8, u), t[208] = h(208, 1, w.prototype.writeInt8), t[209] = h(209, 2, w.prototype.writeInt16BE), t[210] = h(210, 4, w.prototype.writeInt32BE), t[211] = h(211, 8, p), t[217] = h(217, 1, w.prototype.writeUInt8), t[218] = h(218, 2, w.prototype.writeUInt16BE), t[219] = h(219, 4, w.prototype.writeUInt32BE), t[220] = h(220, 2, w.prototype.writeUInt16BE), t[221] = h(221, 4, w.prototype.writeUInt32BE), t[222] = h(222, 2, w.prototype.writeUInt16BE), t[223] = h(223, 4, w.prototype.writeUInt32BE), t;
      }
      function a(t) {
        return function (e, i) {
          var n = e.reserve(2), r = e.buffer;
          r[n++] = t, r[n] = i;
        };
      }
      function l(t) {
        return function (e, i) {
          var n = e.reserve(3), r = e.buffer;
          r[n++] = t, r[n++] = i >>> 8, r[n] = i;
        };
      }
      function c(t) {
        return function (e, i) {
          var n = e.reserve(5), r = e.buffer;
          r[n++] = t, r[n++] = i >>> 24, r[n++] = i >>> 16, r[n++] = i >>> 8, r[n] = i;
        };
      }
      function h(t, e, i, n) {
        return function (r, o) {
          var s = r.reserve(e + 1);
          r.buffer[s++] = t, i.call(r.buffer, o, s, n);
        };
      }
      function u(t, e) {
        new g(this, e, t);
      }
      function p(t, e) {
        new x(this, e, t);
      }
      function m(t, e) {
        _.write(this, t, e, false, 23, 4);
      }
      function d(t, e) {
        _.write(this, t, e, false, 52, 8);
      }
      var _ = t("ieee754"), y = t("int64-buffer"), g = y.Uint64BE, x = y.Int64BE, v = t("./write-uint8").uint8, b = t("./bufferish"), w = b.global, S = b.hasBuffer && "TYPED_ARRAY_SUPPORT" in w && !w.TYPED_ARRAY_SUPPORT, M = b.hasBuffer && w.prototype || {};
      i.getWriteToken = n;
    }, {"./bufferish": 8, "./write-uint8": 28, ieee754: 32, "int64-buffer": 33}], 27: [function (t, e, i) {
      function n(t) {
        function e(t, e) {
          D[e ? 195 : 194](t, e);
        }
        function i(t, e) {
          var i = 0 | e;
          return e !== i ? void D[203](t, e) : void D[-32 <= i && i <= 127 ? 255 & i : 0 <= i ? i <= 255 ? 204 : i <= 65535 ? 205 : 206 : -128 <= i ? 208 : -32768 <= i ? 209 : 210](t, i);
        }
        function n(t, e) {
          D[207](t, e.toArray());
        }
        function o(t, e) {
          D[211](t, e.toArray());
        }
        function y(t) {
          return t < 32 ? 1 : t <= 255 ? 2 : t <= 65535 ? 3 : 5;
        }
        function g(t) {
          return t < 32 ? 1 : t <= 65535 ? 3 : 5;
        }
        function x(t) {
          function e(e, i) {
            var n = i.length, r = 5 + 3 * n;
            e.offset = e.reserve(r);
            var o = e.buffer, s = t(n), a = e.offset + s;
            n = c.write.call(o, i, a);
            var l = t(n);
            if (s !== l) {
              var h = a + l - s, u = a + n;
              c.copy.call(o, o, h, a, u);
            }
            D[1 === l ? 160 + n : l <= 3 ? 215 + l : 219](e, n), e.offset += n;
          }
          return e;
        }
        function v(t, e) {
          if (null === e) return w(t, e);
          if (P(e)) return I(t, e);
          if (r(e)) return S(t, e);
          if (s.isUint64BE(e)) return n(t, e);
          if (a.isInt64BE(e)) return o(t, e);
          var i = t.codec.getExtPacker(e);
          return i && (e = i(e)), e instanceof p ? C(t, e) : void V(t, e);
        }
        function b(t, e) {
          return P(e) ? L(t, e) : void v(t, e);
        }
        function w(t, e) {
          D[192](t, e);
        }
        function S(t, e) {
          var i = e.length;
          D[i < 16 ? 144 + i : i <= 65535 ? 220 : 221](t, i);
          for (var n = t.codec.encode, r = 0; r < i; r++) n(t, e[r]);
        }
        function M(t, e) {
          var i = e.length;
          D[i < 255 ? 196 : i <= 65535 ? 197 : 198](t, i), t.send(e);
        }
        function A(t, e) {
          M(t, new Uint8Array(e));
        }
        function C(t, e) {
          var i = e.buffer, n = i.length, r = _[n] || (n < 255 ? 199 : n <= 65535 ? 200 : 201);
          D[r](t, n), u[e.type](t), t.send(i);
        }
        function T(t, e) {
          var i = Object.keys(e), n = i.length;
          D[n < 16 ? 128 + n : n <= 65535 ? 222 : 223](t, n);
          var r = t.codec.encode;
          i.forEach(function (i) {
            r(t, i), r(t, e[i]);
          });
        }
        function E(t, e) {
          if (!(e instanceof Map)) return T(t, e);
          var i = e.size;
          D[i < 16 ? 128 + i : i <= 65535 ? 222 : 223](t, i);
          var n = t.codec.encode;
          e.forEach(function (e, i, r) {
            n(t, i), n(t, e);
          });
        }
        function L(t, e) {
          var i = e.length;
          D[i < 32 ? 160 + i : i <= 65535 ? 218 : 219](t, i), t.send(e);
        }
        var D = h.getWriteToken(t), R = t && t.useraw, B = m && t && t.binarraybuffer, P = B ? l.isArrayBuffer : l.isBuffer, I = B ? A : M, V = d && t && t.usemap ? E : T;
        return {boolean: e, function: w, number: i, object: R ? b : v, string: x(R ? g : y), symbol: w, undefined: w};
      }
      var r = t("isarray"), o = t("int64-buffer"), s = o.Uint64BE, a = o.Int64BE, l = t("./bufferish"), c = t("./bufferish-proto"), h = t("./write-token"), u = t("./write-uint8").uint8, p = t("./ext-buffer").ExtBuffer, m = "undefined" != typeof Uint8Array, d = "undefined" != typeof Map, _ = [];
      _[1] = 212, _[2] = 213, _[4] = 214, _[8] = 215, _[16] = 216, i.getWriteType = n;
    }, {"./bufferish": 8, "./bufferish-proto": 6, "./ext-buffer": 17, "./write-token": 26, "./write-uint8": 28, "int64-buffer": 33, isarray: 34}], 28: [function (t, e, i) {
      function n(t) {
        return function (e) {
          var i = e.reserve(1);
          e.buffer[i] = t;
        };
      }
      for (var r = i.uint8 = new Array(256), o = 0; o <= 255; o++) r[o] = n(o);
    }, {}], 29: [function (t, e, n) {
      (function (e) {
        "use strict";
        function i() {
          try {
            var t = new Uint8Array(1);
            return t.__proto__ = {__proto__: Uint8Array.prototype, foo: function () {
              return 42;
            }}, 42 === t.foo() && "function" == typeof t.subarray && 0 === t.subarray(1, 1).byteLength;
          } catch (t) {
            return false;
          }
        }
        function r() {
          return s.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
        }
        function o(t, e) {
          if (r() < e) throw new RangeError("Invalid typed array length");
          return s.TYPED_ARRAY_SUPPORT ? (t = new Uint8Array(e)).__proto__ = s.prototype : (null === t && (t = new s(e)), t.length = e), t;
        }
        function s(t, e, i) {
          if (!(s.TYPED_ARRAY_SUPPORT || this instanceof s)) return new s(t, e, i);
          if ("number" == typeof t) {
            if ("string" == typeof e) throw new Error("If encoding is specified then the first argument must be a string");
            return h(this, t);
          }
          return a(this, t, e, i);
        }
        function a(t, e, i, n) {
          if ("number" == typeof e) throw new TypeError('"value" argument must not be a number');
          return "undefined" != typeof ArrayBuffer && e instanceof ArrayBuffer ? m(t, e, i, n) : "string" == typeof e ? u(t, e, i) : d(t, e);
        }
        function l(t) {
          if ("number" != typeof t) throw new TypeError('"size" argument must be a number');
          if (t < 0) throw new RangeError('"size" argument must not be negative');
        }
        function h(t, e) {
          if (l(e), t = o(t, e < 0 ? 0 : 0 | _(e)), !s.TYPED_ARRAY_SUPPORT) for (var i = 0; i < e; ++i) t[i] = 0;
          return t;
        }
        function u(t, e, i) {
          if ("string" == typeof i && "" !== i || (i = "utf8"), !s.isEncoding(i)) throw new TypeError('"encoding" must be a valid string encoding');
          var n = 0 | g(e, i), r = (t = o(t, n)).write(e, i);
          return r !== n && (t = t.slice(0, r)), t;
        }
        function p(t, e) {
          var i = e.length < 0 ? 0 : 0 | _(e.length);
          t = o(t, i);
          for (var n = 0; n < i; n += 1) t[n] = 255 & e[n];
          return t;
        }
        function m(t, e, i, n) {
          if (e.byteLength, i < 0 || e.byteLength < i) throw new RangeError("'offset' is out of bounds");
          if (e.byteLength < i + (n || 0)) throw new RangeError("'length' is out of bounds");
          return e = void 0 === i && void 0 === n ? new Uint8Array(e) : void 0 === n ? new Uint8Array(e, i) : new Uint8Array(e, i, n), s.TYPED_ARRAY_SUPPORT ? (t = e).__proto__ = s.prototype : t = p(t, e), t;
        }
        function d(t, e) {
          if (s.isBuffer(e)) {
            var i = 0 | _(e.length);
            return 0 === (t = o(t, i)).length || e.copy(t, 0, 0, i), t;
          }
          if (e) {
            if ("undefined" != typeof ArrayBuffer && e.buffer instanceof ArrayBuffer || "length" in e) return "number" != typeof e.length || e.length != e.length ? o(t, 0) : p(t, e);
            if ("Buffer" === e.type && et(e.data)) return p(t, e.data);
          }
          throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
        }
        function _(t) {
          if (t >= r()) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + r().toString(16) + " bytes");
          return 0 | t;
        }
        function g(t, e) {
          if (s.isBuffer(t)) return t.length;
          if ("undefined" != typeof ArrayBuffer && "function" == typeof ArrayBuffer.isView && (ArrayBuffer.isView(t) || t instanceof ArrayBuffer)) return t.byteLength;
          "string" != typeof t && (t = "" + t);
          var i = t.length;
          if (0 === i) return 0;
          for (var n = false;;) switch (e) {
            case "ascii":
            case "latin1":
            case "binary":
              return i;
            case "utf8":
            case "utf-8":
            case void 0:
              return X(t).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return 2 * i;
            case "hex":
              return i >>> 1;
            case "base64":
              return Q.toByteArray(H(t)).length;
            default:
              if (n) return X(t).length;
              e = ("" + e).toLowerCase(), n = true;
          }
        }
        function x(t, e, i) {
          var n = false;
          if ((void 0 === e || e < 0) && (e = 0), e > this.length) return "";
          if ((void 0 === i || i > this.length) && (i = this.length), i <= 0) return "";
          if ((i >>>= 0) <= (e >>>= 0)) return "";
          for (t || (t = "utf8");;) switch (t) {
            case "hex":
              return I(this, e, i);
            case "utf8":
            case "utf-8":
              return D(this, e, i);
            case "ascii":
              return B(this, e, i);
            case "latin1":
            case "binary":
              return P(this, e, i);
            case "base64":
              return L(this, e, i);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return V(this, e, i);
            default:
              if (n) throw new TypeError("Unknown encoding: " + t);
              t = (t + "").toLowerCase(), n = true;
          }
        }
        function v(t, e, i) {
          var n = t[e];
          t[e] = t[i], t[i] = n;
        }
        function b(t, e, i, n, r) {
          if (0 === t.length) return -1;
          if ("string" == typeof i ? (n = i, i = 0) : i > 2147483647 ? i = 2147483647 : i < -2147483648 && (i = -2147483648), i = +i, isNaN(i) && (i = r ? 0 : t.length - 1), i < 0 && (i = t.length + i), i >= t.length) {
            if (r) return -1;
            i = t.length - 1;
          } else if (i < 0) {
            if (!r) return -1;
            i = 0;
          }
          if ("string" == typeof e && (e = s.from(e, n)), s.isBuffer(e)) return 0 === e.length ? -1 : w(t, e, i, n, r);
          if ("number" == typeof e) return e &= 255, s.TYPED_ARRAY_SUPPORT && "function" == typeof Uint8Array.prototype.indexOf ? r ? Uint8Array.prototype.indexOf.call(t, e, i) : Uint8Array.prototype.lastIndexOf.call(t, e, i) : w(t, [e], i, n, r);
          throw new TypeError("val must be string, number or Buffer");
        }
        function w(t, e, i, n, r) {
          function o(t, e) {
            return 1 === a ? t[e] : t.readUInt16BE(e * a);
          }
          var s, a = 1, l = t.length, c = e.length;
          if (void 0 !== n && ("ucs2" === (n = String(n).toLowerCase()) || "ucs-2" === n || "utf16le" === n || "utf-16le" === n)) {
            if (t.length < 2 || e.length < 2) return -1;
            a = 2, l /= 2, c /= 2, i /= 2;
          }
          if (r) {
            var h = -1;
            for (s = i; s < l; s++) if (o(t, s) === o(e, -1 === h ? 0 : s - h)) {
              if (-1 === h && (h = s), s - h + 1 === c) return h * a;
            } else -1 !== h && (s -= s - h), h = -1;
          } else for (i + c > l && (i = l - c), s = i; s >= 0; s--) {
            for (var u = true, p = 0; p < c; p++) if (o(t, s + p) !== o(e, p)) {
              u = false;
              break;
            }
            if (u) return s;
          }
          return -1;
        }
        function S(t, e, i, n) {
          i = Number(i) || 0;
          var r = t.length - i;
          n ? (n = Number(n)) > r && (n = r) : n = r;
          var o = e.length;
          if (o % 2 != 0) throw new TypeError("Invalid hex string");
          n > o / 2 && (n = o / 2);
          for (var s = 0; s < n; ++s) {
            var a = parseInt(e.substr(2 * s, 2), 16);
            if (isNaN(a)) return s;
            t[i + s] = a;
          }
          return s;
        }
        function L(t, e, i) {
          return 0 === e && i === t.length ? Q.fromByteArray(t) : Q.fromByteArray(t.slice(e, i));
        }
        function D(t, e, i) {
          i = Math.min(t.length, i);
          for (var n = [], r = e; r < i;) {
            var o, s, a, l, c = t[r], h = null, u = c > 239 ? 4 : c > 223 ? 3 : c > 191 ? 2 : 1;
            if (r + u <= i) switch (u) {
              case 1:
                c < 128 && (h = c);
                break;
              case 2:
                128 == (192 & (o = t[r + 1])) && (l = (31 & c) << 6 | 63 & o) > 127 && (h = l);
                break;
              case 3:
                o = t[r + 1], s = t[r + 2], 128 == (192 & o) && 128 == (192 & s) && (l = (15 & c) << 12 | (63 & o) << 6 | 63 & s) > 2047 && (l < 55296 || l > 57343) && (h = l);
                break;
              case 4:
                o = t[r + 1], s = t[r + 2], a = t[r + 3], 128 == (192 & o) && 128 == (192 & s) && 128 == (192 & a) && (l = (15 & c) << 18 | (63 & o) << 12 | (63 & s) << 6 | 63 & a) > 65535 && l < 1114112 && (h = l);
            }
            null === h ? (h = 65533, u = 1) : h > 65535 && (h -= 65536, n.push(h >>> 10 & 1023 | 55296), h = 56320 | 1023 & h), n.push(h), r += u;
          }
          return R(n);
        }
        function R(t) {
          var e = t.length;
          if (e <= it) return String.fromCharCode.apply(String, t);
          for (var i = "", n = 0; n < e;) i += String.fromCharCode.apply(String, t.slice(n, n += it));
          return i;
        }
        function B(t, e, i) {
          var n = "";
          i = Math.min(t.length, i);
          for (var r = e; r < i; ++r) n += String.fromCharCode(127 & t[r]);
          return n;
        }
        function P(t, e, i) {
          var n = "";
          i = Math.min(t.length, i);
          for (var r = e; r < i; ++r) n += String.fromCharCode(t[r]);
          return n;
        }
        function I(t, e, i) {
          var n = t.length;
          (!e || e < 0) && (e = 0), (!i || i < 0 || i > n) && (i = n);
          for (var r = "", o = e; o < i; ++o) r += J(t[o]);
          return r;
        }
        function V(t, e, i) {
          for (var n = t.slice(e, i), r = "", o = 0; o < n.length; o += 2) r += String.fromCharCode(n[o] + 256 * n[o + 1]);
          return r;
        }
        function F(t, e, i) {
          if (t % 1 != 0 || t < 0) throw new RangeError("offset is not uint");
          if (t + e > i) throw new RangeError("Trying to access beyond buffer length");
        }
        function k(t, e, i, n, r, o) {
          if (!s.isBuffer(t)) throw new TypeError('"buffer" argument must be a Buffer instance');
          if (e > r || e < o) throw new RangeError('"value" argument is out of bounds');
          if (i + n > t.length) throw new RangeError("Index out of range");
        }
        function N(t, e, i, n) {
          e < 0 && (e = 65535 + e + 1);
          for (var r = 0, o = Math.min(t.length - i, 2); r < o; ++r) t[i + r] = (e & 255 << 8 * (n ? r : 1 - r)) >>> 8 * (n ? r : 1 - r);
        }
        function G(t, e, i, n) {
          e < 0 && (e = 4294967295 + e + 1);
          for (var r = 0, o = Math.min(t.length - i, 4); r < o; ++r) t[i + r] = e >>> 8 * (n ? r : 3 - r) & 255;
        }
        function U(t, e, i, n, r, o) {
          if (i + n > t.length) throw new RangeError("Index out of range");
          if (i < 0) throw new RangeError("Index out of range");
        }
        function H(t) {
          if ((t = W(t).replace(nt, "")).length < 2) return "";
          for (; t.length % 4 != 0;) t += "=";
          return t;
        }
        function W(t) {
          return t.trim ? t.trim() : t.replace(/^\s+|\s+$/g, "");
        }
        function J(t) {
          return t < 16 ? "0" + t.toString(16) : t.toString(16);
        }
        function X(t, e) {
          e = e || Infinity;
          for (var i, n = t.length, r = null, o = [], s = 0; s < n; ++s) {
            if ((i = t.charCodeAt(s)) > 55295 && i < 57344) {
              if (!r) {
                if (i > 56319) {
                  (e -= 3) > -1 && o.push(239, 191, 189);
                  continue;
                }
                if (s + 1 === n) {
                  (e -= 3) > -1 && o.push(239, 191, 189);
                  continue;
                }
                r = i;
                continue;
              }
              if (i < 56320) {
                (e -= 3) > -1 && o.push(239, 191, 189), r = i;
                continue;
              }
              i = 65536 + (r - 55296 << 10 | i - 56320);
            } else r && (e -= 3) > -1 && o.push(239, 191, 189);
            if (r = null, i < 128) {
              if ((e -= 1) < 0) break;
              o.push(i);
            } else if (i < 2048) {
              if ((e -= 2) < 0) break;
              o.push(i >> 6 | 192, 63 & i | 128);
            } else if (i < 65536) {
              if ((e -= 3) < 0) break;
              o.push(i >> 12 | 224, i >> 6 & 63 | 128, 63 & i | 128);
            } else {
              if (!(i < 1114112)) throw new Error("Invalid code point");
              if ((e -= 4) < 0) break;
              o.push(i >> 18 | 240, i >> 12 & 63 | 128, i >> 6 & 63 | 128, 63 & i | 128);
            }
          }
          return o;
        }
        function q(t) {
          for (var e = [], i = 0; i < t.length; ++i) e.push(255 & t.charCodeAt(i));
          return e;
        }
        function Y(t, e) {
          for (var i, n, r, o = [], s = 0; s < t.length && !((e -= 2) < 0); ++s) n = (i = t.charCodeAt(s)) >> 8, r = i % 256, o.push(r), o.push(n);
          return o;
        }
        function K(t, e, i, n) {
          for (var r = 0; r < n && !(r + i >= e.length || r >= t.length); ++r) e[r + i] = t[r];
          return r;
        }
        var Q = t("base64-js"), tt = t("ieee754"), et = t("isarray");
        n.Buffer = s, n.SlowBuffer = y, n.INSPECT_MAX_BYTES = 50, s.TYPED_ARRAY_SUPPORT = void 0 !== e.TYPED_ARRAY_SUPPORT ? e.TYPED_ARRAY_SUPPORT : i(), n.kMaxLength = r(), s.poolSize = 8192, s._augment = function (t) {
          return t.__proto__ = s.prototype, t;
        }, s.from = function (t, e, i) {
          return a(null, t, e, i);
        }, s.TYPED_ARRAY_SUPPORT && (s.prototype.__proto__ = Uint8Array.prototype, s.__proto__ = Uint8Array, "undefined" != typeof Symbol && Symbol.species && s[Symbol.species] === s && Object.defineProperty(s, Symbol.species, {value: null, configurable: true})), s.alloc = function (t, e, i) {
          return l(t), t <= 0 ? o(null, t) : void 0 !== e ? "string" == typeof i ? o(null, t).fill(e, i) : o(null, t).fill(e) : o(null, t);
        }, s.allocUnsafe = function (t) {
          return h(null, t);
        }, s.allocUnsafeSlow = function (t) {
          return h(null, t);
        }, s.isBuffer = function (t) {
          return !(null == t || !t._isBuffer);
        }, s.compare = function (t, e) {
          if (!s.isBuffer(t) || !s.isBuffer(e)) throw new TypeError("Arguments must be Buffers");
          if (t === e) return 0;
          for (var i = t.length, n = e.length, r = 0, o = Math.min(i, n); r < o; ++r) if (t[r] !== e[r]) {
            i = t[r], n = e[r];
            break;
          }
          return i < n ? -1 : n < i ? 1 : 0;
        }, s.isEncoding = function (t) {
          switch (String(t).toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "latin1":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return true;
            default:
              return false;
          }
        }, s.concat = function (t, e) {
          if (!et(t)) throw new TypeError('"list" argument must be an Array of Buffers');
          if (0 === t.length) return s.alloc(0);
          var i;
          if (void 0 === e) for (e = 0, i = 0; i < t.length; ++i) e += t[i].length;
          var n = s.allocUnsafe(e), r = 0;
          for (i = 0; i < t.length; ++i) {
            var o = t[i];
            if (!s.isBuffer(o)) throw new TypeError('"list" argument must be an Array of Buffers');
            o.copy(n, r), r += o.length;
          }
          return n;
        }, s.byteLength = g, s.prototype._isBuffer = true, s.prototype.swap16 = function () {
          var t = this.length;
          if (t % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
          for (var e = 0; e < t; e += 2) v(this, e, e + 1);
          return this;
        }, s.prototype.swap32 = function () {
          var t = this.length;
          if (t % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
          for (var e = 0; e < t; e += 4) v(this, e, e + 3), v(this, e + 1, e + 2);
          return this;
        }, s.prototype.swap64 = function () {
          var t = this.length;
          if (t % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
          for (var e = 0; e < t; e += 8) v(this, e, e + 7), v(this, e + 1, e + 6), v(this, e + 2, e + 5), v(this, e + 3, e + 4);
          return this;
        }, s.prototype.toString = function () {
          var t = 0 | this.length;
          return 0 === t ? "" : 0 === arguments.length ? D(this, 0, t) : x.apply(this, arguments);
        }, s.prototype.equals = function (t) {
          if (!s.isBuffer(t)) throw new TypeError("Argument must be a Buffer");
          return this === t || 0 === s.compare(this, t);
        }, s.prototype.inspect = function () {
          var t = "", e = n.INSPECT_MAX_BYTES;
          return this.length > 0 && (t = this.toString("hex", 0, e).match(/.{2}/g).join(" "), this.length > e && (t += " ... ")), "<Buffer " + t + ">";
        }, s.prototype.compare = function (t, e, i, n, r) {
          if (!s.isBuffer(t)) throw new TypeError("Argument must be a Buffer");
          if (void 0 === e && (e = 0), void 0 === i && (i = t ? t.length : 0), void 0 === n && (n = 0), void 0 === r && (r = this.length), e < 0 || i > t.length || n < 0 || r > this.length) throw new RangeError("out of range index");
          if (n >= r && e >= i) return 0;
          if (n >= r) return -1;
          if (e >= i) return 1;
          if (this === t) return 0;
          for (var o = (r >>>= 0) - (n >>>= 0), a = (i >>>= 0) - (e >>>= 0), l = Math.min(o, a), c = this.slice(n, r), h = t.slice(e, i), u = 0; u < l; ++u) if (c[u] !== h[u]) {
            o = c[u], a = h[u];
            break;
          }
          return o < a ? -1 : a < o ? 1 : 0;
        }, s.prototype.includes = function (t, e, i) {
          return -1 !== this.indexOf(t, e, i);
        }, s.prototype.indexOf = function (t, e, i) {
          return b(this, t, e, i, true);
        }, s.prototype.lastIndexOf = function (t, e, i) {
          return b(this, t, e, i, false);
        }, s.prototype.write = function (t, e, i, n) {
          if (void 0 === e) n = "utf8", i = this.length, e = 0; else if (void 0 === i && "string" == typeof e) n = e, i = this.length, e = 0; else {
            if (!isFinite(e)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
            e |= 0, isFinite(i) ? (i |= 0, void 0 === n && (n = "utf8")) : (n = i, i = void 0);
          }
          var r = this.length - e;
          if ((void 0 === i || i > r) && (i = r), t.length > 0 && (i < 0 || e < 0) || e > this.length) throw new RangeError("Attempt to write outside buffer bounds");
          n || (n = "utf8");
          for (var o = false;;) switch (n) {
            case "hex":
              return S(this, t, e, i);
            case "utf8":
            case "utf-8":
              return K(X(t, this.length - e), this, e, i);
            case "ascii":
              return K(q(t), this, e, i);
            case "latin1":
            case "binary":
              return K(q(t), this, e, i);
            case "base64":
              return K(Q.toByteArray(H(t)), this, e, i);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return K(Y(t, this.length - e), this, e, i);
            default:
              if (o) throw new TypeError("Unknown encoding: " + n);
              n = ("" + n).toLowerCase(), o = true;
          }
        }, s.prototype.toJSON = function () {
          return {type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0)};
        };
        var it = 4096;
        s.prototype.slice = function (t, e) {
          var i, n = this.length;
          if ((t = ~~t) < 0 ? (t += n) < 0 && (t = 0) : t > n && (t = n), (e = void 0 === e ? n : ~~e) < 0 ? (e += n) < 0 && (e = 0) : e > n && (e = n), e < t && (e = t), s.TYPED_ARRAY_SUPPORT) (i = this.subarray(t, e)).__proto__ = s.prototype; else {
            var r = e - t;
            i = new s(r, void 0);
            for (var o = 0; o < r; ++o) i[o] = this[o + t];
          }
          return i;
        }, s.prototype.readUIntLE = function (t, e, i) {
          t |= 0, e |= 0, i || F(t, e, this.length);
          for (var n = this[t], r = 1, o = 0; ++o < e && (r *= 256);) n += this[t + o] * r;
          return n;
        }, s.prototype.readUIntBE = function (t, e, i) {
          t |= 0, e |= 0, i || F(t, e, this.length);
          for (var n = this[t + --e], r = 1; e > 0 && (r *= 256);) n += this[t + --e] * r;
          return n;
        }, s.prototype.readUInt8 = function (t, e) {
          return e || F(t, 1, this.length), this[t];
        }, s.prototype.readUInt16LE = function (t, e) {
          return e || F(t, 2, this.length), this[t] | this[t + 1] << 8;
        }, s.prototype.readUInt16BE = function (t, e) {
          return e || F(t, 2, this.length), this[t] << 8 | this[t + 1];
        }, s.prototype.readUInt32LE = function (t, e) {
          return e || F(t, 4, this.length), (this[t] | this[t + 1] << 8 | this[t + 2] << 16) + 16777216 * this[t + 3];
        }, s.prototype.readUInt32BE = function (t, e) {
          return e || F(t, 4, this.length), 16777216 * this[t] + (this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3]);
        }, s.prototype.readIntLE = function (t, e, i) {
          t |= 0, e |= 0, i || F(t, e, this.length);
          for (var n = this[t], r = 1, o = 0; ++o < e && (r *= 256);) n += this[t + o] * r;
          return n >= (r *= 128) && (n -= Math.pow(2, 8 * e)), n;
        }, s.prototype.readIntBE = function (t, e, i) {
          t |= 0, e |= 0, i || F(t, e, this.length);
          for (var n = e, r = 1, o = this[t + --n]; n > 0 && (r *= 256);) o += this[t + --n] * r;
          return o >= (r *= 128) && (o -= Math.pow(2, 8 * e)), o;
        }, s.prototype.readInt8 = function (t, e) {
          return e || F(t, 1, this.length), 128 & this[t] ? -1 * (255 - this[t] + 1) : this[t];
        }, s.prototype.readInt16LE = function (t, e) {
          e || F(t, 2, this.length);
          var i = this[t] | this[t + 1] << 8;
          return 32768 & i ? 4294901760 | i : i;
        }, s.prototype.readInt16BE = function (t, e) {
          e || F(t, 2, this.length);
          var i = this[t + 1] | this[t] << 8;
          return 32768 & i ? 4294901760 | i : i;
        }, s.prototype.readInt32LE = function (t, e) {
          return e || F(t, 4, this.length), this[t] | this[t + 1] << 8 | this[t + 2] << 16 | this[t + 3] << 24;
        }, s.prototype.readInt32BE = function (t, e) {
          return e || F(t, 4, this.length), this[t] << 24 | this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3];
        }, s.prototype.readFloatLE = function (t, e) {
          return e || F(t, 4, this.length), tt.read(this, t, true, 23, 4);
        }, s.prototype.readFloatBE = function (t, e) {
          return e || F(t, 4, this.length), tt.read(this, t, false, 23, 4);
        }, s.prototype.readDoubleLE = function (t, e) {
          return e || F(t, 8, this.length), tt.read(this, t, true, 52, 8);
        }, s.prototype.readDoubleBE = function (t, e) {
          return e || F(t, 8, this.length), tt.read(this, t, false, 52, 8);
        }, s.prototype.writeUIntLE = function (t, e, i, n) {
          t = +t, e |= 0, i |= 0, n || k(this, t, e, i, Math.pow(2, 8 * i) - 1, 0);
          var r = 1, o = 0;
          for (this[e] = 255 & t; ++o < i && (r *= 256);) this[e + o] = t / r & 255;
          return e + i;
        }, s.prototype.writeUIntBE = function (t, e, i, n) {
          t = +t, e |= 0, i |= 0, n || k(this, t, e, i, Math.pow(2, 8 * i) - 1, 0);
          var r = i - 1, o = 1;
          for (this[e + r] = 255 & t; --r >= 0 && (o *= 256);) this[e + r] = t / o & 255;
          return e + i;
        }, s.prototype.writeUInt8 = function (t, e, i) {
          return t = +t, e |= 0, i || k(this, t, e, 1, 255, 0), s.TYPED_ARRAY_SUPPORT || (t = Math.floor(t)), this[e] = 255 & t, e + 1;
        }, s.prototype.writeUInt16LE = function (t, e, i) {
          return t = +t, e |= 0, i || k(this, t, e, 2, 65535, 0), s.TYPED_ARRAY_SUPPORT ? (this[e] = 255 & t, this[e + 1] = t >>> 8) : N(this, t, e, true), e + 2;
        }, s.prototype.writeUInt16BE = function (t, e, i) {
          return t = +t, e |= 0, i || k(this, t, e, 2, 65535, 0), s.TYPED_ARRAY_SUPPORT ? (this[e] = t >>> 8, this[e + 1] = 255 & t) : N(this, t, e, false), e + 2;
        }, s.prototype.writeUInt32LE = function (t, e, i) {
          return t = +t, e |= 0, i || k(this, t, e, 4, 4294967295, 0), s.TYPED_ARRAY_SUPPORT ? (this[e + 3] = t >>> 24, this[e + 2] = t >>> 16, this[e + 1] = t >>> 8, this[e] = 255 & t) : G(this, t, e, true), e + 4;
        }, s.prototype.writeUInt32BE = function (t, e, i) {
          return t = +t, e |= 0, i || k(this, t, e, 4, 4294967295, 0), s.TYPED_ARRAY_SUPPORT ? (this[e] = t >>> 24, this[e + 1] = t >>> 16, this[e + 2] = t >>> 8, this[e + 3] = 255 & t) : G(this, t, e, false), e + 4;
        }, s.prototype.writeIntLE = function (t, e, i, n) {
          if (t = +t, e |= 0, !n) {
            var r = Math.pow(2, 8 * i - 1);
            k(this, t, e, i, r - 1, -r);
          }
          var o = 0, s = 1, a = 0;
          for (this[e] = 255 & t; ++o < i && (s *= 256);) t < 0 && 0 === a && 0 !== this[e + o - 1] && (a = 1), this[e + o] = (t / s >> 0) - a & 255;
          return e + i;
        }, s.prototype.writeIntBE = function (t, e, i, n) {
          if (t = +t, e |= 0, !n) {
            var r = Math.pow(2, 8 * i - 1);
            k(this, t, e, i, r - 1, -r);
          }
          var o = i - 1, s = 1, a = 0;
          for (this[e + o] = 255 & t; --o >= 0 && (s *= 256);) t < 0 && 0 === a && 0 !== this[e + o + 1] && (a = 1), this[e + o] = (t / s >> 0) - a & 255;
          return e + i;
        }, s.prototype.writeInt8 = function (t, e, i) {
          return t = +t, e |= 0, i || k(this, t, e, 1, 127, -128), s.TYPED_ARRAY_SUPPORT || (t = Math.floor(t)), t < 0 && (t = 255 + t + 1), this[e] = 255 & t, e + 1;
        }, s.prototype.writeInt16LE = function (t, e, i) {
          return t = +t, e |= 0, i || k(this, t, e, 2, 32767, -32768), s.TYPED_ARRAY_SUPPORT ? (this[e] = 255 & t, this[e + 1] = t >>> 8) : N(this, t, e, true), e + 2;
        }, s.prototype.writeInt16BE = function (t, e, i) {
          return t = +t, e |= 0, i || k(this, t, e, 2, 32767, -32768), s.TYPED_ARRAY_SUPPORT ? (this[e] = t >>> 8, this[e + 1] = 255 & t) : N(this, t, e, false), e + 2;
        }, s.prototype.writeInt32LE = function (t, e, i) {
          return t = +t, e |= 0, i || k(this, t, e, 4, 2147483647, -2147483648), s.TYPED_ARRAY_SUPPORT ? (this[e] = 255 & t, this[e + 1] = t >>> 8, this[e + 2] = t >>> 16, this[e + 3] = t >>> 24) : G(this, t, e, true), e + 4;
        }, s.prototype.writeInt32BE = function (t, e, i) {
          return t = +t, e |= 0, i || k(this, t, e, 4, 2147483647, -2147483648), t < 0 && (t = 4294967295 + t + 1), s.TYPED_ARRAY_SUPPORT ? (this[e] = t >>> 24, this[e + 1] = t >>> 16, this[e + 2] = t >>> 8, this[e + 3] = 255 & t) : G(this, t, e, false), e + 4;
        }, s.prototype.writeFloatLE = function (t, e, i) {
          return i || U(this, t, e, 4, 3.4028234663852886e38, -3.4028234663852886e38), tt.write(this, t, e, true, 23, 4), e + 4;
        }, s.prototype.writeFloatBE = function (t, e, i) {
          return i || U(this, t, e, 4, 3.4028234663852886e38, -3.4028234663852886e38), tt.write(this, t, e, false, 23, 4), e + 4;
        }, s.prototype.writeDoubleLE = function (t, e, i) {
          return i || U(this, t, e, 8, 1.7976931348623157e308, -1.7976931348623157e308), tt.write(this, t, e, true, 52, 8), e + 8;
        }, s.prototype.writeDoubleBE = function (t, e, i) {
          return i || U(this, t, e, 8, 1.7976931348623157e308, -1.7976931348623157e308), tt.write(this, t, e, false, 52, 8), e + 8;
        }, s.prototype.copy = function (t, e, i, n) {
          if (i || (i = 0), n || 0 === n || (n = this.length), e >= t.length && (e = t.length), e || (e = 0), n > 0 && n < i && (n = i), n === i) return 0;
          if (0 === t.length || 0 === this.length) return 0;
          if (e < 0) throw new RangeError("targetStart out of bounds");
          if (i < 0 || i >= this.length) throw new RangeError("sourceStart out of bounds");
          if (n < 0) throw new RangeError("sourceEnd out of bounds");
          n > this.length && (n = this.length), t.length - e < n - i && (n = t.length - e + i);
          var r, o = n - i;
          if (this === t && i < e && e < n) for (r = o - 1; r >= 0; --r) t[r + e] = this[r + i]; else if (o < 1e3 || !s.TYPED_ARRAY_SUPPORT) for (r = 0; r < o; ++r) t[r + e] = this[r + i]; else Uint8Array.prototype.set.call(t, this.subarray(i, i + o), e);
          return o;
        }, s.prototype.fill = function (t, e, i, n) {
          if ("string" == typeof t) {
            if ("string" == typeof e ? (n = e, e = 0, i = this.length) : "string" == typeof i && (n = i, i = this.length), 1 === t.length) {
              var r = t.charCodeAt(0);
              r < 256 && (t = r);
            }
            if (void 0 !== n && "string" != typeof n) throw new TypeError("encoding must be a string");
            if ("string" == typeof n && !s.isEncoding(n)) throw new TypeError("Unknown encoding: " + n);
          } else "number" == typeof t && (t &= 255);
          if (e < 0 || this.length < e || this.length < i) throw new RangeError("Out of range index");
          if (i <= e) return this;
          var o;
          if (e >>>= 0, i = void 0 === i ? this.length : i >>> 0, t || (t = 0), "number" == typeof t) for (o = e; o < i; ++o) this[o] = t; else {
            var a = s.isBuffer(t) ? t : X(new s(t, n).toString()), l = a.length;
            for (o = 0; o < i - e; ++o) this[o + e] = a[o % l];
          }
          return this;
        };
        var nt = /[^+\/0-9A-Za-z-_]/g;
      }.call(this, void 0 !== i.g ? i.g : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}));
    }, {"base64-js": 30, ieee754: 32, isarray: 34}], 30: [function (t, e, i) {
      "use strict";
      function n(t) {
        var e = t.length;
        if (e % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
        return "=" === t[e - 2] ? 2 : "=" === t[e - 1] ? 1 : 0;
      }
      function o(t) {
        var e, i, r, o, s, a, l = t.length;
        s = n(t), a = new u(3 * l / 4 - s), r = s > 0 ? l - 4 : l;
        var c = 0;
        for (e = 0, i = 0; e < r; e += 4, i += 3) o = h[t.charCodeAt(e)] << 18 | h[t.charCodeAt(e + 1)] << 12 | h[t.charCodeAt(e + 2)] << 6 | h[t.charCodeAt(e + 3)], a[c++] = o >> 16 & 255, a[c++] = o >> 8 & 255, a[c++] = 255 & o;
        return 2 === s ? (o = h[t.charCodeAt(e)] << 2 | h[t.charCodeAt(e + 1)] >> 4, a[c++] = 255 & o) : 1 === s && (o = h[t.charCodeAt(e)] << 10 | h[t.charCodeAt(e + 1)] << 4 | h[t.charCodeAt(e + 2)] >> 2, a[c++] = o >> 8 & 255, a[c++] = 255 & o), a;
      }
      function a(t, e, i) {
        for (var n, r = [], o = e; o < i; o += 3) n = (t[o] << 16) + (t[o + 1] << 8) + t[o + 2], r.push(c[n >> 18 & 63] + c[n >> 12 & 63] + c[n >> 6 & 63] + c[63 & n]);
        return r.join("");
      }
      function l(t) {
        for (var e, i = t.length, n = i % 3, r = "", o = [], s = 16383, l = 0, h = i - n; l < h; l += s) o.push(a(t, l, l + s > h ? h : l + s));
        return 1 === n ? (e = t[i - 1], r += c[e >> 2], r += c[e << 4 & 63], r += "==") : 2 === n && (e = (t[i - 2] << 8) + t[i - 1], r += c[e >> 10], r += c[e >> 4 & 63], r += c[e << 2 & 63], r += "="), o.push(r), o.join("");
      }
      i.byteLength = r, i.toByteArray = o, i.fromByteArray = l;
      for (var c = [], h = [], u = "undefined" != typeof Uint8Array ? Uint8Array : Array, p = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", m = 0, d = p.length; m < d; ++m) c[m] = p[m], h[p.charCodeAt(m)] = m;
      h["-".charCodeAt(0)] = 62, h["_".charCodeAt(0)] = 63;
    }, {}], 31: [function (t, e, i) {
      function n() {
        if (!(this instanceof n)) return new n;
      }
      !function (t) {
        function i(t) {
          for (var e in c) t[e] = c[e];
          return t;
        }
        function r(t, e) {
          function i() {
            o.call(n, t, i), e.apply(this, arguments);
          }
          var n = this;
          return i.originalListener = e, a(n, t).push(i), n;
        }
        function o(t, e) {
          var n, r = this;
          if (arguments.length) {
            if (e) {
              if (n = a(r, t, true)) {
                if (!(n = n.filter(i)).length) return o.call(r, t);
                r[l][t] = n;
              }
            } else if ((n = r[l]) && (delete n[t], !Object.keys(n).length)) return o.call(r);
          } else delete r[l];
          return r;
        }
        function s(t, e) {
          function i(t) {
            t.call(o);
          }
          function n(t) {
            t.call(o, e);
          }
          function r(t) {
            t.apply(o, c);
          }
          var o = this, s = a(o, t, true);
          if (!s) return false;
          var l = arguments.length;
          if (1 === l) s.forEach(i); else if (2 === l) s.forEach(n); else {
            var c = Array.prototype.slice.call(arguments, 1);
            s.forEach(r);
          }
          return !!s.length;
        }
        function a(t, e, i) {
          if (!i || t[l]) {
            var n = t[l] || (t[l] = {});
            return n[e] || (n[e] = []);
          }
        }
        void 0 !== e && (e.exports = t);
        var l = "listeners", c = {on: n, once: r, off: o, emit: s};
        i(t.prototype), t.mixin = i;
      }(n);
    }, {}], 32: [function (t, e, i) {
      i.read = function (t, e, i, n, r) {
        var o, s, a = 8 * r - n - 1, l = (1 << a) - 1, c = l >> 1, h = -7, u = i ? r - 1 : 0, p = i ? -1 : 1, m = t[e + u];
        for (u += p, o = m & (1 << -h) - 1, m >>= -h, h += a; h > 0; o = 256 * o + t[e + u], u += p, h -= 8) ;
        for (s = o & (1 << -h) - 1, o >>= -h, h += n; h > 0; s = 256 * s + t[e + u], u += p, h -= 8) ;
        if (0 === o) o = 1 - c; else {
          if (o === l) return s ? NaN : Infinity * (m ? -1 : 1);
          s += Math.pow(2, n), o -= c;
        }
        return (m ? -1 : 1) * s * Math.pow(2, o - n);
      }, i.write = function (t, e, i, n, r, o) {
        var s, a, l, c = 8 * o - r - 1, h = (1 << c) - 1, u = h >> 1, p = 23 === r ? Math.pow(2, -24) - Math.pow(2, -77) : 0, m = n ? 0 : o - 1, d = n ? 1 : -1, _ = e < 0 || 0 === e && 1 / e < 0 ? 1 : 0;
        for (e = Math.abs(e), isNaN(e) || e === Infinity ? (a = isNaN(e) ? 1 : 0, s = h) : (s = Math.floor(Math.log(e) / Math.LN2), e * (l = Math.pow(2, -s)) < 1 && (s--, l *= 2), (e += s + u >= 1 ? p / l : p * Math.pow(2, 1 - u)) * l >= 2 && (s++, l /= 2), s + u >= h ? (a = 0, s = h) : s + u >= 1 ? (a = (e * l - 1) * Math.pow(2, r), s += u) : (a = e * Math.pow(2, u - 1) * Math.pow(2, r), s = 0)); r >= 8; t[i + m] = 255 & a, m += d, a /= 256, r -= 8) ;
        for (s = s << r | a, c += r; c > 0; t[i + m] = 255 & s, m += d, s /= 256, c -= 8) ;
        t[i + m - d] |= 128 * _;
      };
    }, {}], 33: [function (t, e, i) {
      (function (t) {
        !function (e) {
          function i(t, i, m) {
            function b(t, e, i, n) {
              return this instanceof b ? A(this, t, e, i, n) : new b(t, e, i, n);
            }
            function A(t, e, i, n, r) {
              g && x && (e instanceof x && (e = new g(e)), n instanceof x && (n = new g(n))), e || i || n || d ? (s(e, i) || (r = i, n = e, i = 0, e = new (d || Array)(8)), t.buffer = e, t.offset = i |= 0, _ !== typeof n && ("string" == typeof n ? C(e, i, n, r || 10) : s(n, r) ? a(e, i, n, r) : "number" == typeof r ? (L(e, i + R, n), L(e, i + B, r)) : n > 0 ? k(e, i, n) : n < 0 ? N(e, i, n) : a(e, i, v, 0))) : t.buffer = Array.prototype.slice.call(v, 0, 8);
            }
            function C(t, e, i, n) {
              var r = 0, o = i.length, s = 0, a = 0;
              "-" === i[0] && r++;
              for (var l = r; r < o;) {
                var c = parseInt(i[r++], n);
                if (!(c >= 0)) break;
                a = a * n + c, s = s * n + Math.floor(a / w), a %= w;
              }
              l && (s = ~s, a ? a = w - a : s++), L(t, e + R, s), L(t, e + B, a);
            }
            function T() {
              var t = this.buffer, e = this.offset, i = t[e + R + P] * S + (t[e + R + I] << 16) + (t[e + R + V] << 8) + t[e + R + F], n = t[e + B + P] * S + (t[e + B + I] << 16) + (t[e + B + V] << 8) + t[e + B + F];
              return m || (i |= 0), i ? i * w + n : n;
            }
            function E(t) {
              var e = this.buffer, i = this.offset, n = e[i + R + P] * S + (e[i + R + I] << 16) + (e[i + R + V] << 8) + e[i + R + F], r = e[i + B + P] * S + (e[i + B + I] << 16) + (e[i + B + V] << 8) + e[i + B + F], o = "", s = !m && 2147483648 & n;
              for (s && (n = ~n, r = w - r), t = t || 10;;) {
                var a = n % t * w + r;
                if (n = Math.floor(n / t), r = Math.floor(a / t), o = (a % t).toString(t) + o, !n && !r) break;
              }
              return s && (o = "-" + o), o;
            }
            function L(t, e, i) {
              t[e + F] = 255 & i, i >>= 8, t[e + V] = 255 & i, i >>= 8, t[e + I] = 255 & i, i >>= 8, t[e + P] = 255 & i;
            }
            var R = i ? 0 : 4, B = i ? 4 : 0, P = i ? 0 : 3, I = i ? 1 : 2, V = i ? 2 : 1, F = i ? 3 : 0, k = i ? c : u, N = i ? h : p, G = b.prototype, U = "is" + t, z = "_" + U;
            return G.buffer = void 0, G.offset = 0, G[z] = true, G.toNumber = T, G.toString = E, G.toJSON = T, G.toArray = n, y && (G.toBuffer = r), g && (G.toArrayBuffer = o), b[U] = M, e[t] = b, b;
          }
          function n(t) {
            var e = this.buffer, i = this.offset;
            return d = null, false !== t && 0 === i && 8 === e.length && b(e) ? e : Array.prototype.slice.call(e, i, i + 8);
          }
          function r(e) {
            var i = this.buffer, n = this.offset;
            if (d = y, false !== e && 0 === n && 8 === i.length && t.isBuffer(i)) return i;
            var r = new y(8);
            return a(r, 0, i, n), r;
          }
          function o(t) {
            var e = this.buffer, i = this.offset, n = e.buffer;
            if (d = g, false !== t && 0 === i && n instanceof x && 8 === n.byteLength) return n;
            var r = new g(8);
            return a(r, 0, e, i), r.buffer;
          }
          function s(t, e) {
            var i = t && t.length;
            return e |= 0, i && e + 8 <= i && "string" != typeof t[e];
          }
          function a(t, e, i, n) {
            e |= 0, n |= 0;
            for (var r = 0; r < 8; r++) t[e++] = 255 & i[n++];
          }
          function c(t, e, i) {
            for (var n = e + 8; n > e;) t[--n] = 255 & i, i /= 256;
          }
          function h(t, e, i) {
            var n = e + 8;
            for (i++; n > e;) t[--n] = 255 & -i ^ 255, i /= 256;
          }
          function u(t, e, i) {
            for (var n = e + 8; e < n;) t[e++] = 255 & i, i /= 256;
          }
          function p(t, e, i) {
            var n = e + 8;
            for (i++; e < n;) t[e++] = 255 & -i ^ 255, i /= 256;
          }
          var d, _ = "undefined", y = _ !== typeof t && t, g = _ !== typeof Uint8Array && Uint8Array, x = _ !== typeof ArrayBuffer && ArrayBuffer, v = [0, 0, 0, 0, 0, 0, 0, 0], b = Array.isArray || m, w = 4294967296, S = 16777216;
          i("Uint64BE", true, true), i("Int64BE", true, false), i("Uint64LE", false, true), i("Int64LE", false, false);
        }("object" == typeof i && "string" != typeof i.nodeName ? i : this || {});
      }.call(this, t("buffer").Buffer));
    }, {buffer: 29}], 34: [function (t, e, i) {
      var n = {}.toString;
      e.exports = Array.isArray || function (t) {
        return "[object Array]" == n.call(t);
      };
    }, {}]}, {}, [1])(1);
  }, 658: (t, e, i) => {
    "use strict";
    i.r(e), i.d(e, {decode: () => a, encode: () => s});
    for (var n = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", r = "undefined" == typeof Uint8Array ? [] : new Uint8Array(256), o = 0; o < n.length; o++) r[n.charCodeAt(o)] = o;
    var s = function (t) {
      var e, i = new Uint8Array(t), r = i.length, o = "";
      for (e = 0; e < r; e += 3) o += n[i[e] >> 2], o += n[(3 & i[e]) << 4 | i[e + 1] >> 4], o += n[(15 & i[e + 1]) << 2 | i[e + 2] >> 6], o += n[63 & i[e + 2]];
      return r % 3 == 2 ? o = o.substring(0, o.length - 1) + "=" : r % 3 == 1 && (o = o.substring(0, o.length - 2) + "=="), o;
    }, a = function (t) {
      var e, i, n, o, s, a = 0.75 * t.length, l = t.length, c = 0;
      "=" === t[t.length - 1] && (a--, "=" === t[t.length - 2] && a--);
      var h = new ArrayBuffer(a), u = new Uint8Array(h);
      for (e = 0; e < l; e += 4) i = r[t.charCodeAt(e)], n = r[t.charCodeAt(e + 1)], o = r[t.charCodeAt(e + 2)], s = r[t.charCodeAt(e + 3)], u[c++] = i << 2 | n >> 4, u[c++] = (15 & n) << 4 | o >> 2, u[c++] = (3 & o) << 6 | 63 & s;
      return h;
    };
  }, 912: (t, e, i) => {
    "use strict";
    t.exports = function (t) {
      const e = i(444), n = t ? t.preset : "ru", r = {а: "a", б: "b", в: "v", д: "d", з: "z", й: "y", к: "k", л: "l", м: "m", н: "n", о: "o", п: "p", р: "r", с: "s", т: "t", у: "u", ф: "f", ь: ""};
      let o;
      "ru" === n ? Object.assign(r, {г: "g", и: "i", ъ: "", ы: "i", э: "e"}) : "uk" === n ? Object.assign(r, {г: "h", ґ: "g", е: "e", и: "y", і: "i", "'": "", "’": "", ʼ: ""}) : "mn" === n && Object.assign(r, {г: "g", ө: "o", ү: "u", и: "i", ы: "y", э: "e", ъ: ""}), "ru" === n ? o = Object.assign(e(r), {i: "и", "": ""}) : ("uk" === n || "mn" === n) && (o = Object.assign(e(r), {"": ""}));
      const s = "ru" === n ? {е: "ye"} : {є: "ye", ї: "yi"}, a = {ё: "yo", ж: "zh", х: "kh", ц: "ts", ч: "ch", ш: "sh", щ: "shch", ю: "yu", я: "ya"}, l = Object.assign({}, a, s), c = Object.assign(e(l)), h = Object.assign(r, l), u = Object.assign({}, r, {й: "i"});
      let p;
      "ru" === n ? Object.assign(u, {е: "e"}) : "uk" === n ? Object.assign(u, {ї: "i"}) : "mn" === n && Object.assign(u, {е: "e"}), "ru" === n ? p = Object.assign(e(r), {i: "и", y: "ы", e: "е", "": ""}) : "uk" === n && (p = Object.assign(e(r), {"": ""}));
      let m = {};
      "uk" === n && (m = {є: "ie", ю: "iu", я: "ia"});
      const d = Object.assign(a, m), _ = Object.assign(e(d)), y = Object.assign(u, d);
      return {transform: function (t, e) {
        if (!t) return "";
        const i = t.normalize();
        let r = "", o = false;
        for (let t = 0; t < i.length; t++) {
          const s = i[t] === i[t].toUpperCase();
          let a, l = i[t].toLowerCase();
          " " !== l ? ("uk" === n && "зг" === i.slice(t - 1, t + 1).toLowerCase() ? a = "gh" : 0 === t || o ? (a = h[l], o = false) : a = y[l], void 0 === a ? r += s ? l.toUpperCase() : l : s ? a.length > 1 ? r += a[0].toUpperCase() + a.slice(1) : r += a.toUpperCase() : r += a) : (r += e || " ", o = true);
        }
        return r;
      }, reverse: function (t, e) {
        if (!t) return "";
        const i = t.normalize();
        let n = "", r = false, s = 0;
        for (; s < i.length;) {
          const t = i[s] === i[s].toUpperCase();
          let a, l = i[s].toLowerCase(), h = s;
          if (" " === l || l === e) {
            n += " ", r = true, s++;
            continue;
          }
          let u = i.slice(s, s + 2).toLowerCase();
          0 === s || r ? (a = c[u], a ? s += 2 : (a = o[l], s++), r = false) : (a = _[u], a ? s += 2 : (a = p[l], s++)), "shch" === i.slice(h, h + 4).toLowerCase() ? (a = "щ", s = h + 4) : "zgh" === i.slice(h - 1, h + 2).toLowerCase() && (a = "г", s = h + 2), void 0 === a ? n += t ? l.toUpperCase() : l : t ? a.length > 1 ? n += a[0].toUpperCase() + a.slice(1) : n += a.toUpperCase() : n += a;
        }
        return n;
      }};
    };
  }, 444: t => {
    var e = 0x1FFFFFFFFFFFFF, i = "[object Arguments]", n = "[object Function]", r = "[object GeneratorFunction]", o = /^(?:0|[1-9]\d*)$/;
    var s, a, l = Object.prototype, c = l.hasOwnProperty, h = l.toString, u = l.propertyIsEnumerable, p = (s = Object.keys, a = Object, function (t) {
      return s(a(t));
    });
    function m(t, e) {
      var n = v(t) || function (t) {
        return function (t) {
          return function (t) {
            return !!t && "object" == typeof t;
          }(t) && b(t);
        }(t) && c.call(t, "callee") && (!u.call(t, "callee") || h.call(t) == i);
      }(t) ? function (t, e) {
        for (var i = -1, n = Array(t); ++i < t;) n[i] = e(i);
        return n;
      }(t.length, String) : [], r = n.length, o = !!r;
      for (var s in t) !e && !c.call(t, s) || o && ("length" == s || !!(r = null == r ? e : r) && ("number" == typeof s || o.test(s)) && s > -1 && s % 1 == 0 && s < r) || n.push(s);
      return n;
    }
    var d, _ = function (t, e, i) {
      for (var n = -1, r = Object(t), o = i(t), s = o.length; s--;) {
        var a = o[d ? s : ++n];
        if (false === e(r[a], a, r)) break;
      }
      return t;
    };
    function y(t, e, i, n) {
      return function (t, e) {
        t && _(t, e, C);
      }(t, function (t, r, o) {
        e(n, i(t), r, o);
      }), n;
    }
    function g(t) {
      if (i = (e = t) && e.constructor, n = "function" == typeof i && i.prototype || l, e !== n) return p(t);
      var e, i, n, r = [];
      for (var o in Object(t)) c.call(t, o) && "constructor" != o && r.push(o);
      return r;
    }
    var v = Array.isArray;
    function b(t) {
      return null != t && function (t) {
        return "number" == typeof t && t > -1 && t % 1 == 0 && t <= e;
      }(t.length) && !function (t) {
        var e = function (t) {
          var e = typeof t;
          return !!t && ("object" == e || "function" == e);
        }(t) ? h.call(t) : "";
        return e == n || e == r;
      }(t);
    }
    var w, S, M, A = (w = function (t, e, i) {
      t[e] = i;
    }, M = function (t) {
      return t;
    }, S = function () {
      return M;
    }, function (t, e) {
      return y(t, w, S(e), {});
    });
    function C(t) {
      return b(t) ? m(t) : g(t);
    }
    t.exports = A;
  }, 797: (module, exports, __webpack_require__) => {
    var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
    module = __webpack_require__.nmd(module);
    var io = module.exports;
    (function () {
      if (function (t, e) {
        var i = t;
        i.version = "0.9.17", i.protocol = 1, i.transports = [], i.j = [], i.sockets = {}, i.connect = function (t, n) {
          var r, o, s = i.util.parseUri(t);
          e && e.location && (s.protocol = s.protocol || e.location.protocol.slice(0, -1), s.host = s.host || (e.document ? e.document.domain : e.location.hostname), s.port = s.port || e.location.port), r = i.util.uniqueUri(s);
          var a = {host: s.host, secure: "https" == s.protocol, port: s.port || ("https" == s.protocol ? 443 : 80), query: s.query || ""};
          return i.util.merge(a, n), !a["force new connection"] && i.sockets[r] || (o = new i.Socket(a)), !a["force new connection"] && o && (i.sockets[r] = o), (o = o || i.sockets[r]).of(s.path.length > 1 ? s.path : "");
        };
      }(module.exports, this), function (t, e) {
        var i = t.util = {}, n = /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/, r = ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"];
        i.parseUri = function (t) {
          for (var e = n.exec(t || ""), i = {}, o = 14; o--;) i[r[o]] = e[o] || "";
          return i;
        }, i.uniqueUri = function (t) {
          var i = t.protocol, n = t.host, r = t.port;
          return "document" in e ? (n = n || document.domain, r = r || ("https" == i && "https:" !== document.location.protocol ? 443 : document.location.port)) : (n = n || "localhost", r || "https" != i || (r = 443)), (i || "http") + "://" + n + ":" + (r || 80);
        }, i.query = function (t, e) {
          var n = i.chunkQuery(t || ""), r = [];
          for (var o in i.merge(n, i.chunkQuery(e || "")), n) n.hasOwnProperty(o) && r.push(o + "=" + n[o]);
          return r.length ? "?" + r.join("&") : "";
        }, i.chunkQuery = function (t) {
          for (var e, i = {}, n = t.split("&"), r = 0, o = n.length; r < o; ++r) (e = n[r].split("="))[0] && (i[e[0]] = e[1]);
          return i;
        };
        var o = false;
        i.load = function (t) {
          if ("document" in e && "complete" === document.readyState || o) return t();
          i.on(e, "load", t, false);
        }, i.on = function (t, e, i, n) {
          t.attachEvent ? t.attachEvent("on" + e, i) : t.addEventListener && t.addEventListener(e, i, n);
        }, i.request = function (t) {
          if (t && "undefined" != typeof XDomainRequest && !i.ua.hasCORS) return new XDomainRequest;
          if ("undefined" != typeof XMLHttpRequest && (!t || i.ua.hasCORS)) return new XMLHttpRequest;
          if (!t) try {
            return new window[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
          } catch (t) {}
          return null;
        }, "undefined" != typeof window && i.load(function () {
          o = true;
        }), i.defer = function (t) {
          if (!i.ua.webkit || "undefined" != typeof importScripts) return t();
          i.load(function () {
            setTimeout(t, 100);
          });
        }, i.merge = function (t, e, n, r) {
          var o, s = r || [], a = void 0 === n ? 2 : n;
          for (o in e) e.hasOwnProperty(o) && i.indexOf(s, o) < 0 && ("object" == typeof t[o] && a ? i.merge(t[o], e[o], a - 1, s) : (t[o] = e[o], s.push(e[o])));
          return t;
        }, i.mixin = function (t, e) {
          i.merge(t.prototype, e.prototype);
        }, i.inherit = function (t, e) {
          function i() {}
          i.prototype = e.prototype, t.prototype = new i;
        }, i.isArray = Array.isArray || function (t) {
          return "[object Array]" === Object.prototype.toString.call(t);
        }, i.intersect = function (t, e) {
          for (var n = [], r = t.length > e.length ? t : e, o = t.length > e.length ? e : t, s = 0, a = o.length; s < a; s++) ~i.indexOf(r, o[s]) && n.push(o[s]);
          return n;
        }, i.indexOf = function (t, e, i) {
          var n = t.length;
          for (i = i < 0 ? i + n < 0 ? 0 : i + n : i || 0; i < n && t[i] !== e; i++) ;
          return n <= i ? -1 : i;
        }, i.toArray = function (t) {
          for (var e = [], i = 0, n = t.length; i < n; i++) e.push(t[i]);
          return e;
        }, i.ua = {}, i.ua.hasCORS = "undefined" != typeof XMLHttpRequest && function () {
          try {
            var t = new XMLHttpRequest;
          } catch (t) {
            return false;
          }
          return null != t.withCredentials;
        }(), i.ua.webkit = "undefined" != typeof navigator && /webkit/i.test(navigator.userAgent), i.ua.iDevice = "undefined" != typeof navigator && /iPad|iPhone|iPod/i.test(navigator.userAgent);
      }(void 0 !== io ? io : module.exports, this), function (t, e) {
        function i() {}
        t.EventEmitter = i, i.prototype.on = function (t, i) {
          return this.$events || (this.$events = {}), this.$events[t] ? e.util.isArray(this.$events[t]) ? this.$events[t].push(i) : this.$events[t] = [this.$events[t], i] : this.$events[t] = i, this;
        }, i.prototype.addListener = i.prototype.on, i.prototype.once = function (t, e) {
          var i = this;
          function n() {
            i.removeListener(t, n), e.apply(this, arguments);
          }
          return n.listener = e, this.on(t, n), this;
        }, i.prototype.removeListener = function (t, i) {
          if (this.$events && this.$events[t]) {
            var n = this.$events[t];
            if (e.util.isArray(n)) {
              for (var r = -1, o = 0, s = n.length; o < s; o++) if (n[o] === i || n[o].listener && n[o].listener === i) {
                r = o;
                break;
              }
              if (r < 0) return this;
              n.splice(r, 1), n.length || delete this.$events[t];
            } else (n === i || n.listener && n.listener === i) && delete this.$events[t];
          }
          return this;
        }, i.prototype.removeAllListeners = function (t) {
          return void 0 === t ? (this.$events = {}, this) : (this.$events && this.$events[t] && (this.$events[t] = null), this);
        }, i.prototype.listeners = function (t) {
          return this.$events || (this.$events = {}), this.$events[t] || (this.$events[t] = []), e.util.isArray(this.$events[t]) || (this.$events[t] = [this.$events[t]]), this.$events[t];
        }, i.prototype.emit = function (t) {
          if (!this.$events) return false;
          var i = this.$events[t];
          if (!i) return false;
          var n = Array.prototype.slice.call(arguments, 1);
          if ("function" == typeof i) i.apply(this, n); else {
            if (!e.util.isArray(i)) return false;
            for (var r = i.slice(), o = 0, s = r.length; o < s; o++) r[o].apply(this, n);
          }
          return true;
        };
      }(void 0 !== io ? io : module.exports, void 0 !== io ? io : module.parent.exports), function (exports, nativeJSON) {
        "use strict";
        if (nativeJSON && nativeJSON.parse) return exports.JSON = {parse: nativeJSON.parse, stringify: nativeJSON.stringify};
        var JSON = exports.JSON = {};
        function f(t) {
          return t < 10 ? "0" + t : t;
        }
        function date(t, e) {
          return isFinite(t.valueOf()) ? t.getUTCFullYear() + "-" + f(t.getUTCMonth() + 1) + "-" + f(t.getUTCDate()) + "T" + f(t.getUTCHours()) + ":" + f(t.getUTCMinutes()) + ":" + f(t.getUTCSeconds()) + "Z" : null;
        }
        var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, gap, indent, meta = {"": "\\b", "	": "\\t", "\n": "\\n", "": "\\f", "\r": "\\r", '"': '\\"', "\\": "\\\\"}, rep;
        function quote(t) {
          return escapable.lastIndex = 0, escapable.test(t) ? '"' + t.replace(escapable, function (t) {
            var e = meta[t];
            return "string" == typeof e ? e : "\\u" + ("0000" + t.charCodeAt(0).toString(16)).slice(-4);
          }) + '"' : '"' + t + '"';
        }
        function str(t, e) {
          var i, n, r, o, s, a = gap, l = e[t];
          switch (l instanceof Date && (l = date(t)), "function" == typeof rep && (l = rep.call(e, t, l)), typeof l) {
            case "string":
              return quote(l);
            case "number":
              return isFinite(l) ? String(l) : "null";
            case "boolean":
            case "null":
              return String(l);
            case "object":
              if (!l) return "null";
              if (gap += indent, s = [], "[object Array]" === Object.prototype.toString.apply(l)) {
                for (o = l.length, i = 0; i < o; i += 1) s[i] = str(i, l) || "null";
                return r = 0 === s.length ? "[]" : gap ? "[\n" + gap + s.join(",\n" + gap) + "\n" + a + "]" : "[" + s.join(",") + "]", gap = a, r;
              }
              if (rep && "object" == typeof rep) for (o = rep.length, i = 0; i < o; i += 1) "string" == typeof rep[i] && (r = str(n = rep[i], l)) && s.push(quote(n) + (gap ? ": " : ":") + r); else for (n in l) Object.prototype.hasOwnProperty.call(l, n) && (r = str(n, l)) && s.push(quote(n) + (gap ? ": " : ":") + r);
              return r = 0 === s.length ? "{}" : gap ? "{\n" + gap + s.join(",\n" + gap) + "\n" + a + "}" : "{" + s.join(",") + "}", gap = a, r;
          }
        }
        JSON.stringify = function (t, e, i) {
          var n;
          if (gap = "", indent = "", "number" == typeof i) for (n = 0; n < i; n += 1) indent += " "; else "string" == typeof i && (indent = i);
          if (rep = e, e && "function" != typeof e && ("object" != typeof e || "number" != typeof e.length)) throw new Error("JSON.stringify");
          return str("", {"": t});
        }, JSON.parse = function (text, reviver) {
          var j;
          function walk(t, e) {
            var i, n, r = t[e];
            if (r && "object" == typeof r) for (i in r) Object.prototype.hasOwnProperty.call(r, i) && (void 0 !== (n = walk(r, i)) ? r[i] = n : delete r[i]);
            return reviver.call(t, e, r);
          }
          if (text = String(text), cx.lastIndex = 0, cx.test(text) && (text = text.replace(cx, function (t) {
            return "\\u" + ("0000" + t.charCodeAt(0).toString(16)).slice(-4);
          })), /^[\],:{}\s]*$/.test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, "@").replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, "]").replace(/(?:^|:|,)(?:\s*\[)+/g, ""))) return j = eval("(" + text + ")"), "function" == typeof reviver ? walk({"": j}, "") : j;
          throw new SyntaxError("JSON.parse");
        };
      }(void 0 !== io ? io : module.exports, "undefined" != typeof JSON ? JSON : void 0), function (t, e) {
        var i = t.parser = {}, n = i.packets = ["disconnect", "connect", "heartbeat", "message", "json", "event", "ack", "error", "noop"], r = i.reasons = ["transport not supported", "client not handshaken", "unauthorized"], o = i.advice = ["reconnect"], s = e.JSON, a = e.util.indexOf;
        i.encodePacket = function (t) {
          var e = a(n, t.type), i = t.id || "", l = t.endpoint || "", c = t.ack, h = null;
          switch (t.type) {
            case "error":
              var u = t.reason ? a(r, t.reason) : "", p = t.advice ? a(o, t.advice) : "";
              "" === u && "" === p || (h = u + ("" !== p ? "+" + p : ""));
              break;
            case "message":
              "" !== t.data && (h = t.data);
              break;
            case "event":
              var m = {name: t.name};
              t.args && t.args.length && (m.args = t.args), h = s.stringify(m);
              break;
            case "json":
              h = s.stringify(t.data);
              break;
            case "connect":
              t.qs && (h = t.qs);
              break;
            case "ack":
              h = t.ackId + (t.args && t.args.length ? "+" + s.stringify(t.args) : "");
          }
          var d = [e, i + ("data" == c ? "+" : ""), l];
          return null != h && d.push(h), d.join(":");
        }, i.encodePayload = function (t) {
          var e = "";
          if (1 == t.length) return t[0];
          for (var i = 0, n = t.length; i < n; i++) {
            e += "�" + t[i].length + "�" + t[i];
          }
          return e;
        };
        var l = /([^:]+):([0-9]+)?(\+)?:([^:]+)?:?([\s\S]*)?/;
        i.decodePacket = function (t) {
          if (!(a = t.match(l))) return {};
          var e = a[2] || "", i = (t = a[5] || "", {type: n[a[1]], endpoint: a[4] || ""});
          switch (e && (i.id = e, a[3] ? i.ack = "data" : i.ack = true), i.type) {
            case "error":
              var a = t.split("+");
              i.reason = r[a[0]] || "", i.advice = o[a[1]] || "";
              break;
            case "message":
              i.data = t || "";
              break;
            case "event":
              try {
                var c = s.parse(t);
                i.name = c.name, i.args = c.args;
              } catch (t) {}
              i.args = i.args || [];
              break;
            case "json":
              try {
                i.data = s.parse(t);
              } catch (t) {}
              break;
            case "connect":
              i.qs = t || "";
              break;
            case "ack":
              if ((a = t.match(/^([0-9]+)(\+)?(.*)/)) && (i.ackId = a[1], i.args = [], a[3])) try {
                i.args = a[3] ? s.parse(a[3]) : [];
              } catch (t) {}
          }
          return i;
        }, i.decodePayload = function (t) {
          if ("�" == t.charAt(0)) {
            for (var e = [], n = 1, r = ""; n < t.length; n++) "�" == t.charAt(n) ? (e.push(i.decodePacket(t.substr(n + 1).substr(0, r))), n += Number(r) + 1, r = "") : r += t.charAt(n);
            return e;
          }
          return [i.decodePacket(t)];
        };
      }(void 0 !== io ? io : module.exports, void 0 !== io ? io : module.parent.exports), function (t, e) {
        function i(t, e) {
          this.socket = t, this.sessid = e;
        }
        t.Transport = i, e.util.mixin(i, e.EventEmitter), i.prototype.heartbeats = function () {
          return true;
        }, i.prototype.onData = function (t) {
          if (this.clearCloseTimeout(), (this.socket.connected || this.socket.connecting || this.socket.reconnecting) && this.setCloseTimeout(), "" !== t) {
            var i = e.parser.decodePayload(t);
            if (i && i.length) for (var n = 0, r = i.length; n < r; n++) this.onPacket(i[n]);
          }
          return this;
        }, i.prototype.onPacket = function (t) {
          return this.socket.setHeartbeatTimeout(), "heartbeat" == t.type ? this.onHeartbeat() : ("connect" == t.type && "" == t.endpoint && this.onConnect(), "error" == t.type && "reconnect" == t.advice && (this.isOpen = false), this.socket.onPacket(t), this);
        }, i.prototype.setCloseTimeout = function () {
          if (!this.closeTimeout) {
            var t = this;
            this.closeTimeout = setTimeout(function () {
              t.onDisconnect();
            }, this.socket.closeTimeout);
          }
        }, i.prototype.onDisconnect = function () {
          return this.isOpen && this.close(), this.clearTimeouts(), this.socket.onDisconnect(), this;
        }, i.prototype.onConnect = function () {
          return this.socket.onConnect(), this;
        }, i.prototype.clearCloseTimeout = function () {
          this.closeTimeout && (clearTimeout(this.closeTimeout), this.closeTimeout = null);
        }, i.prototype.clearTimeouts = function () {
          this.clearCloseTimeout(), this.reopenTimeout && clearTimeout(this.reopenTimeout);
        }, i.prototype.packet = function (t) {
          this.send(e.parser.encodePacket(t));
        }, i.prototype.onHeartbeat = function (t) {
          this.packet({type: "heartbeat"});
        }, i.prototype.onOpen = function () {
          this.isOpen = true, this.clearCloseTimeout(), this.socket.onOpen();
        }, i.prototype.onClose = function () {
          this.isOpen = false, this.socket.onClose(), this.onDisconnect();
        }, i.prototype.prepareUrl = function () {
          var t = this.socket.options;
          return this.scheme() + "://" + t.host + ":" + t.port + "/" + t.resource + "/" + e.protocol + "/" + this.name + "/" + this.sessid;
        }, i.prototype.ready = function (t, e) {
          e.call(this);
        };
      }(void 0 !== io ? io : module.exports, void 0 !== io ? io : module.parent.exports), function (t, e, i) {
        function n(t) {
          if (this.options = {port: 80, secure: false, document: "document" in i && document, resource: "socket.io", transports: e.transports, "connect timeout": 1e4, "try multiple transports": true, reconnect: true, "reconnection delay": 500, "reconnection limit": Infinity, "reopen delay": 3e3, "max reconnection attempts": 10, "sync disconnect on unload": false, "auto connect": true, "flash policy port": 10843, manualFlush: false}, e.util.merge(this.options, t), this.connected = false, this.open = false, this.connecting = false, this.reconnecting = false, this.namespaces = {}, this.buffer = [], this.doBuffer = false, this.options["sync disconnect on unload"] && (!this.isXDomain() || e.util.ua.hasCORS)) {
            var n = this;
            e.util.on(i, "beforeunload", function () {
              n.disconnectSync();
            }, false);
          }
          this.options["auto connect"] && this.connect();
        }
        function r() {}
        t.Socket = n, e.util.mixin(n, e.EventEmitter), n.prototype.of = function (t) {
          return this.namespaces[t] || (this.namespaces[t] = new e.SocketNamespace(this, t), "" !== t && this.namespaces[t].packet({type: "connect"})), this.namespaces[t];
        }, n.prototype.publish = function () {
          var t;
          for (var e in this.emit.apply(this, arguments), this.namespaces) this.namespaces.hasOwnProperty(e) && (t = this.of(e)).$emit.apply(t, arguments);
        }, n.prototype.handshake = function (t) {
          var i = this, n = this.options;
          function o(e) {
            e instanceof Error ? (i.connecting = false, i.onError(e.message)) : t.apply(null, e.split(":"));
          }
          var s = ["http" + (n.secure ? "s" : "") + ":/", n.host + ":" + n.port, n.resource, e.protocol, e.util.query(this.options.query, "t=" + +new Date)].join("/");
          if (this.isXDomain() && !e.util.ua.hasCORS) {
            var a = document.getElementsByTagName("script")[0], l = document.createElement("script");
            l.src = s + "&jsonp=" + e.j.length, a.parentNode.insertBefore(l, a), e.j.push(function (t) {
              o(t), l.parentNode.removeChild(l);
            });
          } else {
            var c = e.util.request();
            c.open("GET", s, true), this.isXDomain() && (c.withCredentials = true), c.onreadystatechange = function () {
              4 == c.readyState && (c.onreadystatechange = r, 200 == c.status ? o(c.responseText) : 403 == c.status ? i.onError(c.responseText) : (i.connecting = false, !i.reconnecting && i.onError(c.responseText)));
            }, c.send(null);
          }
        }, n.prototype.getTransport = function (t) {
          for (var i, n = t || this.transports, r = 0; i = n[r]; r++) if (e.Transport[i] && e.Transport[i].check(this) && (!this.isXDomain() || e.Transport[i].xdomainCheck(this))) return new e.Transport[i](this, this.sessionid);
          return null;
        }, n.prototype.connect = function (t) {
          if (this.connecting) return this;
          var i = this;
          return i.connecting = true, this.handshake(function (n, r, o, s) {
            i.sessionid = n, i.closeTimeout = 1e3 * o, i.heartbeatTimeout = 1e3 * r, i.transports || (i.transports = i.origTransports = s ? e.util.intersect(s.split(","), i.options.transports) : i.options.transports), i.setHeartbeatTimeout(), function t(e) {
              if (i.transport && i.transport.clearTimeouts(), i.transport = i.getTransport(e), !i.transport) return i.publish("connect_failed");
              i.transport.ready(i, function () {
                i.connecting = true, i.publish("connecting", i.transport.name), i.transport.open(), i.options["connect timeout"] && (i.connectTimeoutTimer = setTimeout(function () {
                  if (!i.connected && (i.connecting = false, i.options["try multiple transports"])) {
                    for (var e = i.transports; e.length > 0 && e.splice(0, 1)[0] != i.transport.name;) ;
                    e.length ? t(e) : i.publish("connect_failed");
                  }
                }, i.options["connect timeout"]));
              });
            }(i.transports), i.once("connect", function () {
              clearTimeout(i.connectTimeoutTimer), t && "function" == typeof t && t();
            });
          }), this;
        }, n.prototype.setHeartbeatTimeout = function () {
          if (clearTimeout(this.heartbeatTimeoutTimer), !this.transport || this.transport.heartbeats()) {
            var t = this;
            this.heartbeatTimeoutTimer = setTimeout(function () {
              t.transport.onClose();
            }, this.heartbeatTimeout);
          }
        }, n.prototype.packet = function (t) {
          return this.connected && !this.doBuffer ? this.transport.packet(t) : this.buffer.push(t), this;
        }, n.prototype.setBuffer = function (t) {
          this.doBuffer = t, !t && this.connected && this.buffer.length && (this.options.manualFlush || this.flushBuffer());
        }, n.prototype.flushBuffer = function () {
          this.transport.payload(this.buffer), this.buffer = [];
        }, n.prototype.disconnect = function () {
          return (this.connected || this.connecting) && (this.open && this.of("").packet({type: "disconnect"}), this.onDisconnect("booted")), this;
        }, n.prototype.disconnectSync = function () {
          var t = e.util.request(), i = ["http" + (this.options.secure ? "s" : "") + ":/", this.options.host + ":" + this.options.port, this.options.resource, e.protocol, "", this.sessionid].join("/") + "/?disconnect=1";
          t.open("GET", i, false), t.send(null), this.onDisconnect("booted");
        }, n.prototype.isXDomain = function () {
          var t = i.location.port || ("https:" == i.location.protocol ? 443 : 80);
          return this.options.host !== i.location.hostname || this.options.port != t;
        }, n.prototype.onConnect = function () {
          this.connected || (this.connected = true, this.connecting = false, this.doBuffer || this.setBuffer(false), this.emit("connect"));
        }, n.prototype.onOpen = function () {
          this.open = true;
        }, n.prototype.onClose = function () {
          this.open = false, clearTimeout(this.heartbeatTimeoutTimer);
        }, n.prototype.onPacket = function (t) {
          this.of(t.endpoint).onPacket(t);
        }, n.prototype.onError = function (t) {
          t && t.advice && "reconnect" === t.advice && (this.connected || this.connecting) && (this.disconnect(), this.options.reconnect && this.reconnect()), this.publish("error", t && t.reason ? t.reason : t);
        }, n.prototype.onDisconnect = function (t) {
          var e = this.connected, i = this.connecting;
          this.connected = false, this.connecting = false, this.open = false, (e || i) && (this.transport.close(), this.transport.clearTimeouts(), e && (this.publish("disconnect", t), "booted" != t && this.options.reconnect && !this.reconnecting && this.reconnect()));
        }, n.prototype.reconnect = function () {
          this.reconnecting = true, this.reconnectionAttempts = 0, this.reconnectionDelay = this.options["reconnection delay"];
          var t = this, e = this.options["max reconnection attempts"], i = this.options["try multiple transports"], n = this.options["reconnection limit"];
          function r() {
            if (t.connected) {
              for (var e in t.namespaces) t.namespaces.hasOwnProperty(e) && "" !== e && t.namespaces[e].packet({type: "connect"});
              t.publish("reconnect", t.transport.name, t.reconnectionAttempts);
            }
            clearTimeout(t.reconnectionTimer), t.removeListener("connect_failed", o), t.removeListener("connect", o), t.reconnecting = false, delete t.reconnectionAttempts, delete t.reconnectionDelay, delete t.reconnectionTimer, delete t.redoTransports, t.options["try multiple transports"] = i;
          }
          function o() {
            if (t.reconnecting) return t.connected ? r() : t.connecting && t.reconnecting ? t.reconnectionTimer = setTimeout(o, 1e3) : void (t.reconnectionAttempts++ >= e ? t.redoTransports ? (t.publish("reconnect_failed"), r()) : (t.on("connect_failed", o), t.options["try multiple transports"] = true, t.transports = t.origTransports, t.transport = t.getTransport(), t.redoTransports = true, t.connect()) : (t.reconnectionDelay < n && (t.reconnectionDelay *= 2), t.connect(), t.publish("reconnecting", t.reconnectionDelay, t.reconnectionAttempts), t.reconnectionTimer = setTimeout(o, t.reconnectionDelay)));
          }
          this.options["try multiple transports"] = false, this.reconnectionTimer = setTimeout(o, this.reconnectionDelay), this.on("connect", o);
        };
      }(void 0 !== io ? io : module.exports, void 0 !== io ? io : module.parent.exports, this), function (t, e) {
        function i(t, e) {
          this.socket = t, this.name = e || "", this.flags = {}, this.json = new n(this, "json"), this.ackPackets = 0, this.acks = {};
        }
        function n(t, e) {
          this.namespace = t, this.name = e;
        }
        t.SocketNamespace = i, e.util.mixin(i, e.EventEmitter), i.prototype.$emit = e.EventEmitter.prototype.emit, i.prototype.of = function () {
          return this.socket.of.apply(this.socket, arguments);
        }, i.prototype.packet = function (t) {
          return t.endpoint = this.name, this.socket.packet(t), this.flags = {}, this;
        }, i.prototype.send = function (t, e) {
          var i = {type: this.flags.json ? "json" : "message", data: t};
          return "function" == typeof e && (i.id = ++this.ackPackets, i.ack = true, this.acks[i.id] = e), this.packet(i);
        }, i.prototype.emit = function (t) {
          var e = Array.prototype.slice.call(arguments, 1), i = e[e.length - 1], n = {type: "event", name: t};
          return "function" == typeof i && (n.id = ++this.ackPackets, n.ack = "data", this.acks[n.id] = i, e = e.slice(0, e.length - 1)), n.args = e, this.packet(n);
        }, i.prototype.disconnect = function () {
          return "" === this.name ? this.socket.disconnect() : (this.packet({type: "disconnect"}), this.$emit("disconnect")), this;
        }, i.prototype.onPacket = function (t) {
          var i = this;
          function n() {
            i.packet({type: "ack", args: e.util.toArray(arguments), ackId: t.id});
          }
          switch (t.type) {
            case "connect":
              this.$emit("connect");
              break;
            case "disconnect":
              "" === this.name ? this.socket.onDisconnect(t.reason || "booted") : this.$emit("disconnect", t.reason);
              break;
            case "message":
            case "json":
              var r = ["message", t.data];
              "data" == t.ack ? r.push(n) : t.ack && this.packet({type: "ack", ackId: t.id}), this.$emit.apply(this, r);
              break;
            case "event":
              r = [t.name].concat(t.args);
              "data" == t.ack && r.push(n), this.$emit.apply(this, r);
              break;
            case "ack":
              this.acks[t.ackId] && (this.acks[t.ackId].apply(this, t.args), delete this.acks[t.ackId]);
              break;
            case "error":
              t.advice ? this.socket.onError(t) : "unauthorized" == t.reason ? this.$emit("connect_failed", t.reason) : this.$emit("error", t.reason);
          }
        }, n.prototype.send = function () {
          this.namespace.flags[this.name] = true, this.namespace.send.apply(this.namespace, arguments);
        }, n.prototype.emit = function () {
          this.namespace.flags[this.name] = true, this.namespace.emit.apply(this.namespace, arguments);
        };
      }(void 0 !== io ? io : module.exports, void 0 !== io ? io : module.parent.exports), function (t, e, i) {
        function n(t) {
          e.Transport.apply(this, arguments);
        }
        t.websocket = n, e.util.inherit(n, e.Transport), n.prototype.name = "websocket", n.prototype.open = function () {
          var t, n = e.util.query(this.socket.options.query), r = this;
          return t || (t = i.MozWebSocket || i.WebSocket), this.websocket = new t(this.prepareUrl() + n), this.websocket.onopen = function () {
            r.onOpen(), r.socket.setBuffer(false);
          }, this.websocket.onmessage = function (t) {
            r.onData(t.data);
          }, this.websocket.onclose = function () {
            r.onClose(), r.socket.setBuffer(true);
          }, this.websocket.onerror = function (t) {
            r.onError(t);
          }, this;
        }, e.util.ua.iDevice ? n.prototype.send = function (t) {
          var e = this;
          return setTimeout(function () {
            e.websocket.send(t);
          }, 0), this;
        } : n.prototype.send = function (t) {
          return this.websocket.send(t), this;
        }, n.prototype.payload = function (t) {
          for (var e = 0, i = t.length; e < i; e++) this.packet(t[e]);
          return this;
        }, n.prototype.close = function () {
          return this.websocket.close(), this;
        }, n.prototype.onError = function (t) {
          this.socket.onError(t);
        }, n.prototype.scheme = function () {
          return this.socket.options.secure ? "wss" : "ws";
        }, n.check = function () {
          return "WebSocket" in i && !("__addTask" in WebSocket) || "MozWebSocket" in i;
        }, n.xdomainCheck = function () {
          return true;
        }, e.transports.push("websocket");
      }(void 0 !== io ? io.Transport : module.exports, void 0 !== io ? io : module.parent.exports, this), function (t, e) {
        function i() {
          e.Transport.websocket.apply(this, arguments);
        }
        t.flashsocket = i, e.util.inherit(i, e.Transport.websocket), i.prototype.name = "flashsocket", i.prototype.open = function () {
          var t = this, i = arguments;
          return WebSocket.__addTask(function () {
            e.Transport.websocket.prototype.open.apply(t, i);
          }), this;
        }, i.prototype.send = function () {
          var t = this, i = arguments;
          return WebSocket.__addTask(function () {
            e.Transport.websocket.prototype.send.apply(t, i);
          }), this;
        }, i.prototype.close = function () {
          return WebSocket.__tasks.length = 0, e.Transport.websocket.prototype.close.call(this), this;
        }, i.prototype.ready = function (t, n) {
          function r() {
            var e = t.options, r = e["flash policy port"], s = ["http" + (e.secure ? "s" : "") + ":/", e.host + ":" + e.port, e.resource, "static/flashsocket", "WebSocketMain" + (t.isXDomain() ? "Insecure" : "") + ".swf"];
            i.loaded || ("undefined" == typeof WEB_SOCKET_SWF_LOCATION && (WEB_SOCKET_SWF_LOCATION = s.join("/")), 843 !== r && WebSocket.loadFlashPolicyFile("xmlsocket://" + e.host + ":" + r), WebSocket.__initialize(), i.loaded = true), n.call(o);
          }
          var o = this;
          if (document.body) return r();
          e.util.load(r);
        }, i.check = function () {
          return !("undefined" == typeof WebSocket || !("__initialize" in WebSocket) || !swfobject) && swfobject.getFlashPlayerVersion().major >= 10;
        }, i.xdomainCheck = function () {
          return true;
        }, "undefined" != typeof window && (WEB_SOCKET_DISABLE_AUTO_INITIALIZATION = true), e.transports.push("flashsocket");
      }(void 0 !== io ? io.Transport : module.exports, void 0 !== io ? io : module.parent.exports), "undefined" != typeof window) var swfobject = function () {
        var t, e, i, n, r, o, s = "undefined", a = "object", l = "Shockwave Flash", c = "application/x-shockwave-flash", h = "SWFObjectExprInst", u = "onreadystatechange", p = window, m = document, d = navigator, _ = false, y = [function () {
          _ ? function () {
            var t = m.getElementsByTagName("body")[0], e = m.createElement(a);
            e.setAttribute("type", c);
            var i = t.appendChild(e);
            if (i) {
              var n = 0;
              !function () {
                if (typeof i.GetVariable != s) {
                  var r = i.GetVariable("$version");
                  r && (r = r.split(" ")[1].split(","), M.pv = [parseInt(r[0], 10), parseInt(r[1], 10), parseInt(r[2], 10)]);
                } else if (n < 10) return n++, void setTimeout(arguments.callee, 10);
                t.removeChild(e), i = null, E();
              }();
            } else E();
          }() : E();
        }], g = [], x = [], v = [], b = false, w = false, S = true, M = function () {
          var t = typeof m.getElementById != s && typeof m.getElementsByTagName != s && typeof m.createElement != s, e = d.userAgent.toLowerCase(), i = d.platform.toLowerCase(), n = /win/.test(i || e), r = /mac/.test(i || e), o = !!/webkit/.test(e) && parseFloat(e.replace(/^.*webkit\/(\d+(\.\d+)?).*$/, "$1")), h = false, u = [0, 0, 0], y = null;
          if (typeof d.plugins != s && typeof d.plugins[l] == a) !(y = d.plugins[l].description) || typeof d.mimeTypes != s && d.mimeTypes[c] && !d.mimeTypes[c].enabledPlugin || (_ = true, h = false, y = y.replace(/^.*\s+(\S+\s+\S+$)/, "$1"), u[0] = parseInt(y.replace(/^(.*)\..*$/, "$1"), 10), u[1] = parseInt(y.replace(/^.*\.(.*)\s.*$/, "$1"), 10), u[2] = /[a-zA-Z]/.test(y) ? parseInt(y.replace(/^.*[a-zA-Z]+(.*)$/, "$1"), 10) : 0); else if (typeof p[["Active"].concat("Object").join("X")] != s) try {
            var g = new window[["Active"].concat("Object").join("X")]("ShockwaveFlash.ShockwaveFlash");
            g && (y = g.GetVariable("$version")) && (h = true, y = y.split(" ")[1].split(","), u = [parseInt(y[0], 10), parseInt(y[1], 10), parseInt(y[2], 10)]);
          } catch (t) {}
          return {w3: t, pv: u, wk: o, ie: h, win: n, mac: r};
        }();
        M.w3 && ((typeof m.readyState != s && "complete" == m.readyState || typeof m.readyState == s && (m.getElementsByTagName("body")[0] || m.body)) && A(), b || (typeof m.addEventListener != s && m.addEventListener("DOMContentLoaded", A, false), M.ie && M.win && (m.attachEvent(u, function () {
          "complete" == m.readyState && (m.detachEvent(u, arguments.callee), A());
        }), p == top && function () {
          if (!b) {
            try {
              m.documentElement.doScroll("left");
            } catch (t) {
              return void setTimeout(arguments.callee, 0);
            }
            A();
          }
        }()), M.wk && function () {
          b || (/loaded|complete/.test(m.readyState) ? A() : setTimeout(arguments.callee, 0));
        }(), T(A)));
        function A() {
          if (!b) {
            try {
              var t = m.getElementsByTagName("body")[0].appendChild(m.createElement("span"));
              t.parentNode.removeChild(t);
            } catch (t) {
              return;
            }
            b = true;
            for (var e = y.length, i = 0; i < e; i++) y[i]();
          }
        }
        function C(t) {
          b ? t() : y[y.length] = t;
        }
        function T(t) {
          if (typeof p.addEventListener != s) p.addEventListener("load", t, false); else if (typeof m.addEventListener != s) m.addEventListener("load", t, false); else if (typeof p.attachEvent != s) !function (t, e, i) {
            t.attachEvent(e, i), v[v.length] = [t, e, i];
          }(p, "onload", t); else if ("function" == typeof p.onload) {
            var e = p.onload;
            p.onload = function () {
              e(), t();
            };
          } else p.onload = t;
        }
        function E() {
          var t = g.length;
          if (t > 0) for (var e = 0; e < t; e++) {
            var i = g[e].id, n = g[e].callbackFn, r = {success: false, id: i};
            if (M.pv[0] > 0) {
              var o = N(i);
              if (o) if (!U(g[e].swfVersion) || M.wk && M.wk < 312) if (g[e].expressInstall && (!w && U("6.0.65") && (M.win || M.mac) && !(M.wk && M.wk < 312))) {
                var a = {};
                a.data = g[e].expressInstall, a.width = o.getAttribute("width") || "0", a.height = o.getAttribute("height") || "0", o.getAttribute("class") && (a.styleclass = o.getAttribute("class")), o.getAttribute("align") && (a.align = o.getAttribute("align"));
                for (var l = {}, c = o.getElementsByTagName("param"), h = c.length, u = 0; u < h; u++) "movie" != c[u].getAttribute("name").toLowerCase() && (l[c[u].getAttribute("name")] = c[u].getAttribute("value"));
                R(a, l, i, n);
              } else B(o), n && n(r); else O(i, true), n && (r.success = true, r.ref = L(i), n(r));
            } else if (O(i, true), n) {
              var p = L(i);
              p && typeof p.SetVariable != s && (r.success = true, r.ref = p), n(r);
            }
          }
        }
        function L(t) {
          var e = null, i = N(t);
          if (i && "OBJECT" == i.nodeName) if (typeof i.SetVariable != s) e = i; else {
            var n = i.getElementsByTagName(a)[0];
            n && (e = n);
          }
          return e;
        }
        function R(r, o, a, l) {
          w = true, i = l || null, n = {success: false, id: a};
          var c = N(a);
          if (c) {
            "OBJECT" == c.nodeName ? (t = P(c), e = null) : (t = c, e = a), r.id = h, (typeof r.width == s || !/%$/.test(r.width) && parseInt(r.width, 10) < 310) && (r.width = "310"), (typeof r.height == s || !/%$/.test(r.height) && parseInt(r.height, 10) < 137) && (r.height = "137"), m.title = m.title.slice(0, 47) + " - Flash Player Installation";
            var u = M.ie && M.win ? ["Active"].concat("").join("X") : "PlugIn", d = "MMredirectURL=" + p.location.toString().replace(/&/g, "%26") + "&MMplayerType=" + u + "&MMdoctitle=" + m.title;
            if (typeof o.flashvars != s ? o.flashvars += "&" + d : o.flashvars = d, M.ie && M.win && 4 != c.readyState) {
              var _ = m.createElement("div");
              a += "SWFObjectNew", _.setAttribute("id", a), c.parentNode.insertBefore(_, c), c.style.display = "none", function () {
                4 == c.readyState ? c.parentNode.removeChild(c) : setTimeout(arguments.callee, 10);
              }();
            }
            I(r, o, a);
          }
        }
        function B(t) {
          if (M.ie && M.win && 4 != t.readyState) {
            var e = m.createElement("div");
            t.parentNode.insertBefore(e, t), e.parentNode.replaceChild(P(t), e), t.style.display = "none", function () {
              4 == t.readyState ? t.parentNode.removeChild(t) : setTimeout(arguments.callee, 10);
            }();
          } else t.parentNode.replaceChild(P(t), t);
        }
        function P(t) {
          var e = m.createElement("div");
          if (M.win && M.ie) e.innerHTML = t.innerHTML; else {
            var i = t.getElementsByTagName(a)[0];
            if (i) {
              var n = i.childNodes;
              if (n) for (var r = n.length, o = 0; o < r; o++) 1 == n[o].nodeType && "PARAM" == n[o].nodeName || 8 == n[o].nodeType || e.appendChild(n[o].cloneNode(true));
            }
          }
          return e;
        }
        function I(t, e, i) {
          var n, r = N(i);
          if (M.wk && M.wk < 312) return n;
          if (r) if (typeof t.id == s && (t.id = i), M.ie && M.win) {
            var o = "";
            for (var l in t) t[l] != Object.prototype[l] && ("data" == l.toLowerCase() ? e.movie = t[l] : "styleclass" == l.toLowerCase() ? o += ' class="' + t[l] + '"' : "classid" != l.toLowerCase() && (o += " " + l + '="' + t[l] + '"'));
            var h = "";
            for (var u in e) e[u] != Object.prototype[u] && (h += '<param name="' + u + '" value="' + e[u] + '" />');
            r.outerHTML = '<object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"' + o + ">" + h + "</object>", x[x.length] = t.id, n = N(t.id);
          } else {
            var p = m.createElement(a);
            for (var m in p.setAttribute("type", c), t) t[m] != Object.prototype[m] && ("styleclass" == m.toLowerCase() ? p.setAttribute("class", t[m]) : "classid" != m.toLowerCase() && p.setAttribute(m, t[m]));
            for (var d in e) e[d] != Object.prototype[d] && "movie" != d.toLowerCase() && V(p, d, e[d]);
            r.parentNode.replaceChild(p, r), n = p;
          }
          return n;
        }
        function V(t, e, i) {
          var n = m.createElement("param");
          n.setAttribute("name", e), n.setAttribute("value", i), t.appendChild(n);
        }
        function F(t) {
          var e = N(t);
          e && "OBJECT" == e.nodeName && (M.ie && M.win ? (e.style.display = "none", function () {
            4 == e.readyState ? k(t) : setTimeout(arguments.callee, 10);
          }()) : e.parentNode.removeChild(e));
        }
        function k(t) {
          var e = N(t);
          if (e) {
            for (var i in e) "function" == typeof e[i] && (e[i] = null);
            e.parentNode.removeChild(e);
          }
        }
        function N(t) {
          var e = null;
          try {
            e = m.getElementById(t);
          } catch (t) {}
          return e;
        }
        function U(t) {
          var e = M.pv, i = t.split(".");
          return i[0] = parseInt(i[0], 10), i[1] = parseInt(i[1], 10) || 0, i[2] = parseInt(i[2], 10) || 0, e[0] > i[0] || e[0] == i[0] && e[1] > i[1] || e[0] == i[0] && e[1] == i[1] && e[2] >= i[2];
        }
        function z(t, e, i, n) {
          if (!M.ie || !M.mac) {
            var l = m.getElementsByTagName("head")[0];
            if (l) {
              var c = i && "string" == typeof i ? i : "screen";
              if (n && (r = null, o = null), !r || o != c) {
                var h = m.createElement("style");
                h.setAttribute("type", "text/css"), h.setAttribute("media", c), r = l.appendChild(h), M.ie && M.win && typeof m.styleSheets != s && m.styleSheets.length > 0 && (r = m.styleSheets[m.styleSheets.length - 1]), o = c;
              }
              M.ie && M.win ? r && typeof r.addRule == a && r.addRule(t, e) : r && typeof m.createTextNode != s && r.appendChild(m.createTextNode(t + " {" + e + "}"));
            }
          }
        }
        function O(t, e) {
          if (S) {
            var i = e ? "visible" : "hidden";
            b && N(t) ? N(t).style.visibility = i : z("#" + t, "visibility:" + i);
          }
        }
        function H(t) {
          return null != /[\\\"<>\.;]/.exec(t) && typeof encodeURIComponent != s ? encodeURIComponent(t) : t;
        }
        M.ie && M.win && window.attachEvent("onunload", function () {
          for (var t = v.length, e = 0; e < t; e++) v[e][0].detachEvent(v[e][1], v[e][2]);
          for (var i = x.length, n = 0; n < i; n++) F(x[n]);
          for (var r in M) M[r] = null;
          for (var o in M = null, swfobject) swfobject[o] = null;
          swfobject = null;
        });
        return {registerObject: function (t, e, i, n) {
          if (M.w3 && t && e) {
            var r = {};
            r.id = t, r.swfVersion = e, r.expressInstall = i, r.callbackFn = n, g[g.length] = r, O(t, false);
          } else n && n({success: false, id: t});
        }, getObjectById: function (t) {
          if (M.w3) return L(t);
        }, embedSWF: function (t, e, i, n, r, o, l, c, h, u) {
          var p = {success: false, id: e};
          M.w3 && !(M.wk && M.wk < 312) && t && e && i && n && r ? (O(e, false), C(function () {
            i += "", n += "";
            var m = {};
            if (h && typeof h === a) for (var d in h) m[d] = h[d];
            m.data = t, m.width = i, m.height = n;
            var _ = {};
            if (c && typeof c === a) for (var y in c) _[y] = c[y];
            if (l && typeof l === a) for (var g in l) typeof _.flashvars != s ? _.flashvars += "&" + g + "=" + l[g] : _.flashvars = g + "=" + l[g];
            if (U(r)) {
              var x = I(m, _, e);
              m.id == e && O(e, true), p.success = true, p.ref = x;
            } else {
              if (o && (!w && U("6.0.65") && (M.win || M.mac) && !(M.wk && M.wk < 312))) return m.data = o, void R(m, _, e, u);
              O(e, true);
            }
            u && u(p);
          })) : u && u(p);
        }, switchOffAutoHideShow: function () {
          S = false;
        }, ua: M, getFlashPlayerVersion: function () {
          return {major: M.pv[0], minor: M.pv[1], release: M.pv[2]};
        }, hasFlashPlayerVersion: U, createSWF: function (t, e, i) {
          return M.w3 ? I(t, e, i) : void 0;
        }, showExpressInstall: function (t, e, i, n) {
          M.w3 && (!w && U("6.0.65") && (M.win || M.mac) && !(M.wk && M.wk < 312)) && R(t, e, i, n);
        }, removeSWF: function (t) {
          M.w3 && F(t);
        }, createCSS: function (t, e, i, n) {
          M.w3 && z(t, e, i, n);
        }, addDomLoadEvent: C, addLoadEvent: T, getQueryParamValue: function (t) {
          var e = m.location.search || m.location.hash;
          if (e) {
            if (/\?/.test(e) && (e = e.split("?")[1]), null == t) return H(e);
            for (var i = e.split("&"), n = 0; n < i.length; n++) if (i[n].substring(0, i[n].indexOf("=")) == t) return H(i[n].substring(i[n].indexOf("=") + 1));
          }
          return "";
        }, expressInstallCallback: function () {
          if (w) {
            var r = N(h);
            r && t && (r.parentNode.replaceChild(t, r), e && (O(e, true), M.ie && M.win && (t.style.display = "block")), i && i(n)), w = false;
          }
        }};
      }();
      !function () {
        if ("undefined" != typeof window && !window.WebSocket) {
          var t = window.console;
          t && t.log && t.error || (t = {log: function () {}, error: function () {}}), swfobject.hasFlashPlayerVersion("10.0.0") ? ("file:" == location.protocol && t.error("WARNING: web-socket-js doesn't work in file:///... URL unless you set Flash Security Settings properly. Open the page via Web server i.e. http://..."), WebSocket = function (t, e, i, n, r) {
            var o = this;
            o.__id = WebSocket.__nextId++, WebSocket.__instances[o.__id] = o, o.readyState = WebSocket.CONNECTING, o.bufferedAmount = 0, o.__events = {}, e ? "string" == typeof e && (e = [e]) : e = [], setTimeout(function () {
              WebSocket.__addTask(function () {
                WebSocket.__flash.create(o.__id, t, e, i || null, n || 0, r || null);
              });
            }, 0);
          }, WebSocket.prototype.send = function (t) {
            if (this.readyState == WebSocket.CONNECTING) throw "INVALID_STATE_ERR: Web Socket connection has not been established";
            var e = WebSocket.__flash.send(this.__id, encodeURIComponent(t));
            return e < 0 || (this.bufferedAmount += e, false);
          }, WebSocket.prototype.close = function () {
            this.readyState != WebSocket.CLOSED && this.readyState != WebSocket.CLOSING && (this.readyState = WebSocket.CLOSING, WebSocket.__flash.close(this.__id));
          }, WebSocket.prototype.addEventListener = function (t, e, i) {
            t in this.__events || (this.__events[t] = []), this.__events[t].push(e);
          }, WebSocket.prototype.removeEventListener = function (t, e, i) {
            if (t in this.__events) for (var n = this.__events[t], r = n.length - 1; r >= 0; --r) if (n[r] === e) {
              n.splice(r, 1);
              break;
            }
          }, WebSocket.prototype.dispatchEvent = function (t) {
            for (var e = this.__events[t.type] || [], i = 0; i < e.length; ++i) e[i](t);
            var n = this["on" + t.type];
            n && n(t);
          }, WebSocket.prototype.__handleEvent = function (t) {
            var e;
            if ("readyState" in t && (this.readyState = t.readyState), "protocol" in t && (this.protocol = t.protocol), "open" == t.type || "error" == t.type) e = this.__createSimpleEvent(t.type); else if ("close" == t.type) e = this.__createSimpleEvent("close"); else {
              if ("message" != t.type) throw "unknown event type: " + t.type;
              var i = decodeURIComponent(t.message);
              e = this.__createMessageEvent("message", i);
            }
            this.dispatchEvent(e);
          }, WebSocket.prototype.__createSimpleEvent = function (t) {
            if (document.createEvent && window.Event) {
              var e = document.createEvent("Event");
              return e.initEvent(t, false, false), e;
            }
            return {type: t, bubbles: false, cancelable: false};
          }, WebSocket.prototype.__createMessageEvent = function (t, e) {
            if (document.createEvent && window.MessageEvent && !window.opera) {
              var i = document.createEvent("MessageEvent");
              return i.initMessageEvent("message", false, false, e, null, null, window, null), i;
            }
            return {type: t, data: e, bubbles: false, cancelable: false};
          }, WebSocket.CONNECTING = 0, WebSocket.OPEN = 1, WebSocket.CLOSING = 2, WebSocket.CLOSED = 3, WebSocket.__flash = null, WebSocket.__instances = {}, WebSocket.__tasks = [], WebSocket.__nextId = 0, WebSocket.loadFlashPolicyFile = function (t) {
            WebSocket.__addTask(function () {
              WebSocket.__flash.loadManualPolicyFile(t);
            });
          }, WebSocket.__initialize = function () {
            if (!WebSocket.__flash) if (WebSocket.__swfLocation && (window.WEB_SOCKET_SWF_LOCATION = WebSocket.__swfLocation), window.WEB_SOCKET_SWF_LOCATION) {
              var e = document.createElement("div");
              e.id = "webSocketContainer", e.style.position = "absolute", WebSocket.__isFlashLite() ? (e.style.left = "0px", e.style.top = "0px") : (e.style.left = "-100px", e.style.top = "-100px");
              var i = document.createElement("div");
              i.id = "webSocketFlash", e.appendChild(i), document.body.appendChild(e), swfobject.embedSWF(WEB_SOCKET_SWF_LOCATION, "webSocketFlash", "1", "1", "10.0.0", null, null, {hasPriority: true, swliveconnect: true, allowScriptAccess: "always"}, null, function (e) {
                e.success || t.error("[WebSocket] swfobject.embedSWF failed");
              });
            } else t.error("[WebSocket] set WEB_SOCKET_SWF_LOCATION to location of WebSocketMain.swf");
          }, WebSocket.__onFlashInitialized = function () {
            setTimeout(function () {
              WebSocket.__flash = document.getElementById("webSocketFlash"), WebSocket.__flash.setCallerUrl(location.href), WebSocket.__flash.setDebug(!!window.WEB_SOCKET_DEBUG);
              for (var t = 0; t < WebSocket.__tasks.length; ++t) WebSocket.__tasks[t]();
              WebSocket.__tasks = [];
            }, 0);
          }, WebSocket.__onFlashEvent = function () {
            return setTimeout(function () {
              try {
                for (var e = WebSocket.__flash.receiveEvents(), i = 0; i < e.length; ++i) WebSocket.__instances[e[i].webSocketId].__handleEvent(e[i]);
              } catch (e) {
                t.error(e);
              }
            }, 0), true;
          }, WebSocket.__log = function (e) {
            t.log(decodeURIComponent(e));
          }, WebSocket.__error = function (e) {
            t.error(decodeURIComponent(e));
          }, WebSocket.__addTask = function (t) {
            WebSocket.__flash ? t() : WebSocket.__tasks.push(t);
          }, WebSocket.__isFlashLite = function () {
            if (!window.navigator || !window.navigator.mimeTypes) return false;
            var t = window.navigator.mimeTypes["application/x-shockwave-flash"];
            return !!(t && t.enabledPlugin && t.enabledPlugin.filename) && !!t.enabledPlugin.filename.match(/flashlite/i);
          }, window.WEB_SOCKET_DISABLE_AUTO_INITIALIZATION || (window.addEventListener ? window.addEventListener("load", function () {
            WebSocket.__initialize();
          }, false) : window.attachEvent("onload", function () {
            WebSocket.__initialize();
          }))) : t.error("Flash Player >= 10.0.0 is required.");
        }
      }(), function (t, e, i) {
        function n(t) {
          t && (e.Transport.apply(this, arguments), this.sendBuffer = []);
        }
        function r() {}
        t.XHR = n, e.util.inherit(n, e.Transport), n.prototype.open = function () {
          return this.socket.setBuffer(false), this.onOpen(), this.get(), this.setCloseTimeout(), this;
        }, n.prototype.payload = function (t) {
          for (var i = [], n = 0, r = t.length; n < r; n++) i.push(e.parser.encodePacket(t[n]));
          this.send(e.parser.encodePayload(i));
        }, n.prototype.send = function (t) {
          return this.post(t), this;
        }, n.prototype.post = function (t) {
          var e = this;
          this.socket.setBuffer(true), this.sendXHR = this.request("POST"), i.XDomainRequest && this.sendXHR instanceof XDomainRequest ? this.sendXHR.onload = this.sendXHR.onerror = function () {
            this.onload = r, e.socket.setBuffer(false);
          } : this.sendXHR.onreadystatechange = function () {
            4 == this.readyState && (this.onreadystatechange = r, e.posting = false, 200 == this.status ? e.socket.setBuffer(false) : e.onClose());
          }, this.sendXHR.send(t);
        }, n.prototype.close = function () {
          return this.onClose(), this;
        }, n.prototype.request = function (t) {
          var i = e.util.request(this.socket.isXDomain()), n = e.util.query(this.socket.options.query, "t=" + +new Date);
          if (i.open(t || "GET", this.prepareUrl() + n, true), "POST" == t) try {
            i.setRequestHeader ? i.setRequestHeader("Content-type", "text/plain;charset=UTF-8") : i.contentType = "text/plain";
          } catch (t) {}
          return i;
        }, n.prototype.scheme = function () {
          return this.socket.options.secure ? "https" : "http";
        }, n.check = function (t, n) {
          try {
            var r = e.util.request(n), o = i.XDomainRequest && r instanceof XDomainRequest, s = t && t.options && t.options.secure ? "https:" : "http:", a = i.location && s != i.location.protocol;
            if (r && (!o || !a)) return true;
          } catch (t) {}
          return false;
        }, n.xdomainCheck = function (t) {
          return n.check(t, true);
        };
      }(void 0 !== io ? io.Transport : module.exports, void 0 !== io ? io : module.parent.exports, this), function (t, e) {
        function i(t) {
          e.Transport.XHR.apply(this, arguments);
        }
        t.htmlfile = i, e.util.inherit(i, e.Transport.XHR), i.prototype.name = "htmlfile", i.prototype.get = function () {
          this.doc = new window[["Active"].concat("Object").join("X")]("htmlfile"), this.doc.open(), this.doc.write("<html></html>"), this.doc.close(), this.doc.parentWindow.s = this;
          var t = this.doc.createElement("div");
          t.className = "socketio", this.doc.body.appendChild(t), this.iframe = this.doc.createElement("iframe"), t.appendChild(this.iframe);
          var i = this, n = e.util.query(this.socket.options.query, "t=" + +new Date);
          this.iframe.src = this.prepareUrl() + n, e.util.on(window, "unload", function () {
            i.destroy();
          });
        }, i.prototype._ = function (t, e) {
          t = t.replace(/\\\//g, "/"), this.onData(t);
          try {
            var i = e.getElementsByTagName("script")[0];
            i.parentNode.removeChild(i);
          } catch (t) {}
        }, i.prototype.destroy = function () {
          if (this.iframe) {
            try {
              this.iframe.src = "about:blank";
            } catch (t) {}
            this.doc = null, this.iframe.parentNode.removeChild(this.iframe), this.iframe = null, CollectGarbage();
          }
        }, i.prototype.close = function () {
          return this.destroy(), e.Transport.XHR.prototype.close.call(this);
        }, i.check = function (t) {
          if ("undefined" != typeof window && ["Active"].concat("Object").join("X") in window) try {
            return new window[["Active"].concat("Object").join("X")]("htmlfile") && e.Transport.XHR.check(t);
          } catch (t) {}
          return false;
        }, i.xdomainCheck = function () {
          return false;
        }, e.transports.push("htmlfile");
      }(void 0 !== io ? io.Transport : module.exports, void 0 !== io ? io : module.parent.exports), function (t, e, i) {
        function n() {
          e.Transport.XHR.apply(this, arguments);
        }
        function r() {}
        t["xhr-polling"] = n, e.util.inherit(n, e.Transport.XHR), e.util.merge(n, e.Transport.XHR), n.prototype.name = "xhr-polling", n.prototype.heartbeats = function () {
          return false;
        }, n.prototype.open = function () {
          return e.Transport.XHR.prototype.open.call(this), false;
        }, n.prototype.get = function () {
          if (this.isOpen) {
            var t = this;
            this.xhr = this.request(), i.XDomainRequest && this.xhr instanceof XDomainRequest ? (this.xhr.onload = function () {
              this.onload = r, this.onerror = r, t.retryCounter = 1, t.onData(this.responseText), t.get();
            }, this.xhr.onerror = function () {
              t.retryCounter++, !t.retryCounter || t.retryCounter > 3 ? t.onClose() : t.get();
            }) : this.xhr.onreadystatechange = function () {
              4 == this.readyState && (this.onreadystatechange = r, 200 == this.status ? (t.onData(this.responseText), t.get()) : t.onClose());
            }, this.xhr.send(null);
          }
        }, n.prototype.onClose = function () {
          if (e.Transport.XHR.prototype.onClose.call(this), this.xhr) {
            this.xhr.onreadystatechange = this.xhr.onload = this.xhr.onerror = r;
            try {
              this.xhr.abort();
            } catch (t) {}
            this.xhr = null;
          }
        }, n.prototype.ready = function (t, i) {
          var n = this;
          e.util.defer(function () {
            i.call(n);
          });
        }, e.transports.push("xhr-polling");
      }(void 0 !== io ? io.Transport : module.exports, void 0 !== io ? io : module.parent.exports, this), function (t, e, i) {
        var n = i.document && "MozAppearance" in i.document.documentElement.style;
        function r(t) {
          e.Transport["xhr-polling"].apply(this, arguments), this.index = e.j.length;
          var i = this;
          e.j.push(function (t) {
            i._(t);
          });
        }
        t["jsonp-polling"] = r, e.util.inherit(r, e.Transport["xhr-polling"]), r.prototype.name = "jsonp-polling", r.prototype.post = function (t) {
          var i = this, n = e.util.query(this.socket.options.query, "t=" + +new Date + "&i=" + this.index);
          if (!this.form) {
            var r, o = document.createElement("form"), s = document.createElement("textarea"), a = this.iframeId = "socketio_iframe_" + this.index;
            o.className = "socketio", o.style.position = "absolute", o.style.top = "0px", o.style.left = "0px", o.style.display = "none", o.target = a, o.method = "POST", o.setAttribute("accept-charset", "utf-8"), s.name = "d", o.appendChild(s), document.body.appendChild(o), this.form = o, this.area = s;
          }
          function l() {
            c(), i.socket.setBuffer(false);
          }
          function c() {
            i.iframe && i.form.removeChild(i.iframe);
            try {
              r = document.createElement('<iframe name="' + i.iframeId + '">');
            } catch (t) {
              (r = document.createElement("iframe")).name = i.iframeId;
            }
            r.id = i.iframeId, i.form.appendChild(r), i.iframe = r;
          }
          this.form.action = this.prepareUrl() + n, c(), this.area.value = e.JSON.stringify(t);
          try {
            this.form.submit();
          } catch (t) {}
          this.iframe.attachEvent ? r.onreadystatechange = function () {
            "complete" == i.iframe.readyState && l();
          } : this.iframe.onload = l, this.socket.setBuffer(true);
        }, r.prototype.get = function () {
          var t = this, i = document.createElement("script"), r = e.util.query(this.socket.options.query, "t=" + +new Date + "&i=" + this.index);
          this.script && (this.script.parentNode.removeChild(this.script), this.script = null), i.async = true, i.src = this.prepareUrl() + r, i.onerror = function () {
            t.onClose();
          };
          var o = document.getElementsByTagName("script")[0];
          o.parentNode.insertBefore(i, o), this.script = i, n && setTimeout(function () {
            var t = document.createElement("iframe");
            document.body.appendChild(t), document.body.removeChild(t);
          }, 100);
        }, r.prototype._ = function (t) {
          return this.onData(t), this.isOpen && this.get(), this;
        }, r.prototype.ready = function (t, i) {
          var r = this;
          if (!n) return i.call(this);
          e.util.load(function () {
            i.call(r);
          });
        }, r.check = function () {
          return "document" in i;
        }, r.xdomainCheck = function () {
          return true;
        }, e.transports.push("jsonp-polling");
      }(void 0 !== io ? io.Transport : module.exports, void 0 !== io ? io : module.parent.exports, this), __WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
        return io;
      }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), void 0 === __WEBPACK_AMD_DEFINE_RESULT__ || (module.exports = __WEBPACK_AMD_DEFINE_RESULT__);
    }());
  }}, __webpack_module_cache__ = {};
  function __webpack_require__(t) {
    var e = __webpack_module_cache__[t];
    if (void 0 !== e) return e.exports;
    var i = __webpack_module_cache__[t] = {id: t, loaded: false, exports: {}};
    return __webpack_modules__[t](i, i.exports, __webpack_require__), i.loaded = true, i.exports;
  }
  __webpack_require__.d = (t, e) => {
    for (var i in e) __webpack_require__.o(e, i) && !__webpack_require__.o(t, i) && Object.defineProperty(t, i, {enumerable: true, get: e[i]});
  }, __webpack_require__.g = function () {
    if ("object" == typeof globalThis) return globalThis;
    try {
      return this || new Function("return this")();
    } catch (t) {
      if ("object" == typeof window) return window;
    }
  }(), __webpack_require__.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e), __webpack_require__.r = t => {
    "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {value: "Module"}), Object.defineProperty(t, "__esModule", {value: true});
  }, __webpack_require__.nmd = t => (t.paths = [], t.children || (t.children = []), t);
  var __webpack_exports__ = {};
  (() => {
    "use strict";
    class ValueUtils {
      static smoothValue(t, e = 0, i = 12, n = 0.01, r = 0.001) {
        const o = (t - e) / i, s = 1 === i || Math.abs(o) <= n ? t : e + o;
        return Math.abs(s) < r ? 0 : s;
      }
      static smoothAngle(t, e = 0, i = 12, n = 0.001) {
        let r = ValueUtils.absAngle(t), o = ValueUtils.absAngle(e);
        return o - r > Math.PI && (r += 2 * Math.PI, o > 2 * Math.PI && (o -= 2 * Math.PI, r = t)), r - o > Math.PI && (r = -(2 * Math.PI - r), o < 0 && (o = 2 * Math.PI, r = t)), ValueUtils.smoothValue(r, o, i, n);
      }
      static isEqual(t, e, i = 0.01) {
        let n = Math.abs(t - e);
        return console.log("diff", t, e, n), n <= i;
      }
      static mergeOptions(t = {}, e = {}) {
        for (const i in e) t[i] = e[i];
      }
      static isUpper(t) {
        return t === t.toUpperCase();
      }
      static getAvg(t) {
        let e = 0;
        for (let i = 0; i < t.length; i++) e += parseInt(t[i], 10);
        return e / t.length;
      }
      static getMax(t) {
        return Math.max.apply(null, t);
      }
      static getMin(t) {
        return Math.min.apply(null, t);
      }
      static objectUnFreeze(t) {
        let e;
        if (t instanceof Array) {
          e = [];
          const i = t => {
            e.push(t);
          };
          t.forEach(i);
        } else if (t instanceof String) e = String(t).toString(); else if ("object" == typeof t) {
          e = {};
          for (const i in t) e[i] = t[i];
        }
        return e;
      }
      static hashString(t) {
        let e, i = 0;
        if (0 === t.length) return i;
        for (let n = 0; n < t.length; n++) e = t.charCodeAt(n), i = (i << 5) - i + e, i |= 0;
        return i;
      }
      static isNumberChanged(t, e, i = ValueUtils.FACTOR) {
        return Math.abs(t - e) > i;
      }
      static isVector2Changed(t, e, i = ValueUtils.FACTOR) {
        return ValueUtils.isNumberChanged(t.x, e.x, i) || ValueUtils.isNumberChanged(t.y, e.y, i);
      }
      static isPoint2Changed(t, e, i = ValueUtils.FACTOR) {
        return ValueUtils.isNumberChanged(t.x, e.x, i) || ValueUtils.isNumberChanged(t.y, e.y, i);
      }
      static isVector3Changed(t, e, i = ValueUtils.FACTOR) {
        return ValueUtils.isNumberChanged(t.x, e.x, i) || ValueUtils.isNumberChanged(t.y, e.y, i) || ValueUtils.isNumberChanged(t.z, e.z, i);
      }
      static isThreeVector3AndVector3Changed(t, e, i = ValueUtils.FACTOR) {
        return ValueUtils.isNumberChanged(t.x, e.x, i) || ValueUtils.isNumberChanged(t.y, e.y, i) || ValueUtils.isNumberChanged(t.z, e.z, i);
      }
      static isVector4Changed(t, e, i = ValueUtils.FACTOR) {
        return ValueUtils.isNumberChanged(t.x, e.x, i) || ValueUtils.isNumberChanged(t.y, e.y, i) || ValueUtils.isNumberChanged(t.z, e.z, i) || ValueUtils.isNumberChanged(t.w, e.w, i);
      }
      static isEulerChanged(t, e, i = ValueUtils.FACTOR) {
        return ValueUtils.isNumberChanged(t.x, e.x, i) || ValueUtils.isNumberChanged(t.y, e.y, i) || ValueUtils.isNumberChanged(t.z, e.z, i);
      }
      static isThreeEulerAndVector3Changed(t, e, i = ValueUtils.FACTOR) {
        return ValueUtils.isNumberChanged(t.x, e.x, i) || ValueUtils.isNumberChanged(t.y, e.y, i) || ValueUtils.isNumberChanged(t.z, e.z, i);
      }
      static firstNonNull(...t) {
        for (const e in t) {
          const i = t[e];
          if (!this.isUndefinedOrNull(i)) return i;
        }
        return null;
      }
      static firstNonNullOr(t, ...e) {
        for (const t in e) {
          const i = e[t];
          if (!this.isUndefinedOrNull(i)) return i;
        }
        return t;
      }
      static limit(t, e, i) {
        return t = Math.max(e, t), Math.min(i, t);
      }
      static countObjectsKeys(...t) {
        let e = 0;
        for (const i in t) e += Object.keys(t[i]).length;
        return e;
      }
      static copyToClipboard(t) {
        let e, i;
        document.body.createTextRange ? (e = document.body.createTextRange(), e.moveToElementText(t), e.select()) : window.getSelection && (i = window.getSelection(), e = document.createRange(), e.selectNodeContents(t), i.removeAllRanges(), i.addRange(e)), document.execCommand("Copy");
      }
      static fallbackCopyTextToClipboard(t) {
        const e = document.createElement("textarea");
        e.value = t, document.body.appendChild(e), e.focus(), e.select();
        try {
          const t = document.execCommand("copy") ? "successful" : "unsuccessful";
          console.log("Fallback: Copying text command was " + t);
        } catch (t) {
          console.error("Fallback: Oops, unable to copy", t);
        }
        document.body.removeChild(e);
      }
      static copyTextToClipboard(t) {
        navigator.clipboard ? navigator.clipboard.writeText(t).then(() => console.log("Async: Copying to clipboard was successful!")).catch(t => console.error("Async: Could not copy text: ", t)) : ValueUtils.fallbackCopyTextToClipboard(t);
      }
      static cosAngle(t, e) {
        const i = t.length() * e.length();
        return 0 === i ? 0 : t.dot(e) / i;
      }
      static sinAngle(t, e) {
        return 1 - ValueUtils.cosAngle(t, e);
      }
      static toFixed(t, e) {
        return parseFloat(t.toFixed(e));
      }
      static getUpdatedDiff(t, e, i = {}) {
        try {
          for (const n in e) if (false !== e.hasOwnProperty(n)) if (null !== e[n]) {
            if ("Array" === e[n].constructor.name) {
              i[n] = e[n];
              continue;
            }
            if ("Object" === e[n].constructor.name) {
              i[n] = {}, void 0 !== t[n] && null !== t[n] || "Object" === e[n].constructor.name && (t[n] = {});
              const r = ValueUtils.getUpdatedDiff(t[n], e[n], i[n]);
              r && false === ValueUtils.objectIsEmpty(r) && (i[n] = r), 0 === Object.keys(i[n]).length && delete i[n];
            } else null !== t && e[n] !== t[n] && (i[n] = e[n]);
          } else null !== t && e[n] !== t[n] && (i[n] = e[n]);
          return i;
        } catch (n) {
          console.error(n, {oldObject: t, newObject: e, updatedDiff: i});
        }
      }
      static fastMerge(t, e) {
        for (const i in e) false !== e.hasOwnProperty(i) && (null !== e[i] ? "Array" !== e[i].constructor.name && "Object" === e[i].constructor.name ? (void 0 !== t[i] && null !== t[i] || (t[i] = {}), ValueUtils.fastMerge(t[i], e[i])) : t[i] = e[i] : delete t[i]);
      }
      static objectIsEmpty(t) {
        for (const e in t) if (t.hasOwnProperty(e)) return false;
        return true;
      }
      static humanToThreeJsAngle(t) {
        return ValueUtils.absAngle(t - Math.PI / 2);
      }
      static threeJsToHumanAngle(t) {
        return ValueUtils.absAngle(t + Math.PI / 2);
      }
      static absAngle(t) {
        const e = ValueUtils.normalizeAngle(t);
        return e < 0 ? 2 * Math.PI + e : e;
      }
      static absAngleVector3(t) {
        const e = t.clone();
        return e.x = ValueUtils.absAngle(t.x), e.y = ValueUtils.absAngle(t.y), e.z = ValueUtils.absAngle(t.z), e;
      }
      static normalizeAngle(t) {
        const e = 2 * Math.PI;
        return t < e || t > e ? t % e : t;
      }
      static absAngleDeg(t) {
        const e = ValueUtils.normalizeAngleDeg(t);
        return e < 0 ? 360 + e : e;
      }
      static normalizeAngleDeg(t) {
        return t % 360;
      }
      static getHumanityNumber(t) {
        const e = {num: t, suffix: "", text: t.toString()};
        return t >= 1e15 ? (e.num = Math.floor(t / 1e15 * 10) / 10, e.suffix = "Q") : t >= 1e12 ? (e.num = Math.floor(t / 1e12 * 10) / 10, e.suffix = "T") : t >= 1e9 ? (e.num = Math.floor(t / 1e9 * 10) / 10, e.suffix = "B") : t >= 1e6 ? (e.num = Math.floor(t / 1e6 * 10) / 10, e.suffix = "M") : t >= 1e3 && (e.num = Math.floor(t / 1e3 * 10) / 10, e.suffix = "K"), e.text = `${e.num}${e.suffix}`, e;
      }
      static getRawNumberFromHumanity(t) {
        return (t = t.toLowerCase()).endsWith("q") ? 1e15 * parseFloat(t) : t.endsWith("t") ? 1e12 * parseFloat(t) : t.endsWith("b") ? 1e9 * parseFloat(t) : t.endsWith("m") ? 1e6 * parseFloat(t) : t.endsWith("k") ? 1e3 * parseFloat(t) : parseFloat(t);
      }
      static formatMoney(t, e = 2, i = ".", n = ",") {
        const r = t < 0 ? "-" : "", o = String(parseInt(t = Math.abs(Number(t) || 0).toFixed(e), 10)), s = o.length > 3 ? o.length % 3 : 0;
        return r + (s ? o.substr(0, s) + n : "") + o.substr(s).replace(/(\d{3})(?=\d)/g, "$1" + n) + (e ? i + Math.abs(t - o).toFixed(e).slice(2) : "");
      }
      static declOfNum(t, e) {
        return e[t % 10 == 1 && t % 100 != 11 ? 0 : t % 10 >= 2 && t % 10 <= 4 && (t % 100 < 10 || t % 100 >= 20) ? 1 : 2];
      }
      static getCamelCaseForCss(t) {
        const e = t.split("_"), i = e[e.length - 1];
        return i.charAt(0).toLowerCase() + i.slice(1);
      }
      static getValidClassName(t) {
        const e = t.split("_");
        return e[e.length - 1];
      }
      static radianToDegrees(t) {
        return 180 * t / Math.PI;
      }
      static degreesToRadian(t) {
        return t * Math.PI / 180;
      }
      static isUndefinedOrNull(t) {
        return null == t;
      }
      static isNotUndefinedAndNotNull(t) {
        return false === ValueUtils.isUndefinedOrNull(t);
      }
      static isNumber(t) {
        return "number" == typeof t && false === isNaN(t) && isFinite(t);
      }
      static isBoolean(t) {
        return "boolean" == typeof t;
      }
      static isString(t) {
        return "string" == typeof t;
      }
      static objectToBase64(t) {
        return btoa(unescape(encodeURIComponent(JSON.stringify(t))));
      }
      static uniqueValues(t) {
        const e = {}, i = [];
        for (const n of t) e[n] || i.push(e[n] = n);
        return i;
      }
    }
    ValueUtils.FACTOR = 0.01, ValueUtils.OBJECTS = {Object: true, Array: true};
    class DateUtils {
      static getDateTime(t = Date.now()) {
        const e = new Date(t), i = e.getDate(), n = e.getMonth() + 1, r = e.getHours(), o = e.getMinutes(), s = r < 10 ? `0${r}` : r, a = o < 10 ? `0${o}` : o;
        return `${i < 10 ? `0${i}` : i}.${n < 10 ? `0${n}` : n}.${e.getFullYear()} ${s}:${a}`;
      }
      static getTime(t = Date.now()) {
        const e = new Date(t), i = e.getHours(), n = e.getMinutes(), r = e.getSeconds();
        return `${i < 10 ? `0${i}` : i}:${n < 10 ? `0${n}` : n}:${r < 10 ? `0${r}` : r}`;
      }
      static getReadableTimeFromSeconds(t, e = true) {
        const i = Math.floor(t % 60), n = Math.floor(t / 60 % 60), r = Math.floor(t / 3600 % 24), o = Math.floor(t / 86400);
        let s = i.toString(), a = "00", l = "", c = "";
        return i < 10 && (s = `0${i}`), n > 0 && (a = `${n}`, n < 10 && (a = `0${a}`)), r > 0 && (l = `${r}`, r < 10 && (l = `0${l}`)), o > 0 && (c = `${o} day `), `${c}${l}:${a}${e ? `:${s}` : ""}`;
      }
      static getRelativeTime(t) {
        const e = 1e3, i = 6e4, n = 60 * i, r = 24 * n, o = 7 * r, s = 30 * o, a = 12 * s, l = Date.now(), c = Math.abs(l - t), h = t > l ? "in " : "", u = t < l ? " ago" : "";
        let p = "";
        return p = c > a ? Math.round(c / a) + " years" : c > s ? Math.round(c / s) + " months" : c > o ? Math.round(c / o) + " weeks" : c > r ? Math.round(c / r) + " days" : c > n ? Math.round(c / n) + " hours" : c > i ? Math.round(c / i) + " min" : c > e ? Math.round(c / e) + " sec" : c + " millis", h + p + u;
      }
      static getLeftTime(t, e = true) {
        const i = 1e3, n = 6e4, r = 60 * n, o = 24 * r, s = 7 * o, a = 30 * s, l = 12 * a, c = Math.abs(t);
        let h = "";
        return h = c > l ? Math.round(c / l) + " years" : c > a ? Math.round(c / a) + " months" : c > s ? Math.round(c / s) + " weeks" : c > o ? Math.round(c / o) + " days" : c > r ? Math.round(c / r) + " hours" : c > n ? Math.round(c / n) + " min" : c > i ? Math.round(c / i) + " sec" : e ? c + " millis" : "0 sec", h;
      }
      static getMinOrHoursFromSeconds(t) {
        return Math.floor(t / 3600) > 0 ? DateUtils.getHoursFromSeconds(t) : DateUtils.getMinFromSeconds(t);
      }
      static getMinFromSeconds(t) {
        return `${Math.floor(t / 60)} min`;
      }
      static getHoursFromSeconds(t) {
        const e = Math.floor(t / 3600);
        return `${e} ${ValueUtils.declOfNum(e, ["hour", "hours", "hours"])}`;
      }
      static timestamp() {
        return Math.floor(Date.now() / 1e3);
      }
    }
    class StringUtils {
      static stringIsBoolean(t) {
        return "true" === t || "false" === t;
      }
      static stringToBoolean(t) {
        return "true" === t;
      }
      static isExistsExtension(t, e) {
        return !!t.includes("." + e);
      }
      static isExistsAnyExtension(t) {
        return /\w+\.\w+$/.test(t);
      }
      static getFileNameWithoutExt(t) {
        const e = t.split(".");
        return e.pop(), e.join(".");
      }
      static getExtension(t) {
        return t.split(".").pop();
      }
      static getLastSubStr(t, e) {
        return e.split(t).pop();
      }
      static replaceAll(t, e, i) {
        return t.replace(new RegExp(StringUtils.escapeRegExp(e), "g"), i);
      }
      static insertValues(t, e) {
        let i = t;
        for (const t in e) i = StringUtils.replaceAll(i, "${" + t + "}", e[t]);
        return i;
      }
      static escapeRegExp(t) {
        return t.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1");
      }
      static copyToClipboard(t) {
        try {
          const e = document.createElement("textarea");
          return e.value = t, e.setAttribute("readonly", ""), e.style.position = "absolute", e.style.left = "-9999px", document.body.appendChild(e), e.select(), document.execCommand("copy"), document.body.removeChild(e), true;
        } catch (t) {}
        return false;
      }
      static mask(t, e) {
        let i = "";
        for (let n = 0; n < t.length; n++) i += e;
        return i;
      }
      static createHyperLinksFromPlainText(t, e = true, i = "_blank", n) {
        return t.replace(UrlUtils.LINK_REGEX, (t, r, o) => {
          let s = t;
          e && (s = s.replace(/http[s]?\:\/\//g, ""));
          let a = "";
          n && (a = `style="color: ${n.getHex()};"`);
          return `<a href="${t.match(/http[s]?\:\/\//g) ? "" : "//"}${t}" target="${i}" ${a}>${s}</a>`;
        });
      }
      static parseDomain(t) {
        const e = (t = StringUtils.cleanProtocol(t)).indexOf("?"), i = t.indexOf("/");
        return ~e || ~i ? t.split(~i ? "/" : "?")[0] : t;
      }
      static cleanProtocol(t) {
        return t = StringUtils.replaceAll(t, "http://", ""), t = StringUtils.replaceAll(t, "https://", "");
      }
    }
    const t = __webpack_require__(912)();
    class UrlUtils {
      static getParameter(t) {
        return new URL(location.href).searchParams.get(t);
      }
      static getProtocol() {
        return location.protocol.substr(0, location.protocol.length - 1);
      }
      static getHostFromAddress(t) {
        if (UrlUtils.checkValidAddress(t)) return t.split(":")[0];
      }
      static getPortFromAddress(t) {
        if (UrlUtils.checkValidAddress(t)) return parseInt(t.split(":")[1], 10);
      }
      static checkValidAddress(t) {
        if (!t.includes(":")) throw new Error("Address is invalid");
        return true;
      }
      static changeLastNumerallInPort(t, e) {
        return parseInt(t.toString().replace(/.$/, e.toString()), 10);
      }
      static downloadFile(t) {
        const e = document.createElement("a");
        e.href = t, e.target = "_blank", e.click();
      }
      static getCorrectlyPath(t, e) {
        return "/" === t[t.length - 1] && (t = t.slice(0, -1)), "/" !== e[0] && (e = "/" + e), t + e;
      }
      static getCorrectlyFileNamePath(t, e) {
        "/" === t[t.length - 1] && (t = t.slice(0, -1));
        let i = t;
        return t.length, i += `/${e}`, i;
      }
      static getResourceUrl(t, e, i, n = location.host) {
        if (!t) return;
        let r = t;
        return false === UrlUtils.isExistsProtocol(r) && ("/" === r[0] || false === r.includes(e) && (r = e + "/" + r), r = `//${n}${r}`, false === StringUtils.isExistsAnyExtension(r) && (r += `.${i}`)), r;
      }
      static isExistsProtocol(t) {
        return void 0 !== t && (t.includes("http://") || t.includes("https://") || t.includes("//"));
      }
      static isExistsLink(t) {
        return !!t.match(UrlUtils.LINK_REGEX);
      }
      static checkReferer(t) {
        return window.location !== window.parent.location && document.referrer.includes(t);
      }
      static getPathName() {
        return location.pathname.replace(/\/$/, "");
      }
      static pushHistory(t, e = true) {
        const i = new URL(location.href);
        i.pathname = t, e || (i.search = ""), window.history.pushState({}, "", i.href);
      }
      static shareLink(e) {
        return t.transform(e.toLowerCase()).replace(UrlUtils.REGEX.SPECIAL_CHARS, "").replace(UrlUtils.REGEX.ILLEGAL_CHARS, "").replace(UrlUtils.REGEX.SPACES, "-").replace(UrlUtils.REGEX.AMPERSAND, "-and-").replace(UrlUtils.REGEX.ANYTHING_NOT_LETTER, "").replace(UrlUtils.REGEX.DUPLICATED_DASHES, "-").replace(UrlUtils.REGEX.BORDER_DASHES, "");
      }
    }
    UrlUtils.LINK_REGEX = /((?:(http|https|Http|Https|rtsp|Rtsp):\/\/(?:(?:[a-zA-Z0-9\$\-\_\.\+\!\*\'\(\)\,\;\?\&\=]|(?:\%[a-fA-F0-9]{2})){1,64}(?:\:(?:[a-zA-Z0-9\$\-\_\.\+\!\*\'\(\)\,\;\?\&\=]|(?:\%[a-fA-F0-9]{2})){1,25})?\@)?)?((?:(?:[a-zA-Z0-9][a-zA-Z0-9\-]{0,64}\.)+(?:(?:aero|arpa|asia|a[cdefgilmnoqrstuwxz])|(?:biz|b[abdefghijmnorstvwyz])|(?:cat|com|coop|c[acdfghiklmnoruvxyz])|d[ejkmoz]|(?:edu|e[cegrstu])|f[ijkmor]|(?:gov|g[abdefghilmnpqrstuwy])|h[kmnrtu]|(?:info|int|i[delmnoqrst])|(?:jobs|j[emop])|k[eghimnrwyz]|l[abcikrstuvy]|(?:mil|mobi|museum|m[acdghklmnopqrstuvwxyz])|(?:name|net|n[acefgilopruz])|(?:org|om)|(?:pro|p[aefghklmnrstwy])|qa|r[eouw]|s[abcdeghijklmnortuvyz]|(?:tel|travel|t[cdfghjklmnoprtvwz])|u[agkmsyz]|v[aceginu]|w[fs]|y[etu]|z[amw]))|(?:(?:25[0-5]|2[0-4][0-9]|[0-1][0-9]{2}|[1-9][0-9]|[1-9])\.(?:25[0-5]|2[0-4][0-9]|[0-1][0-9]{2}|[1-9][0-9]|[1-9]|0)\.(?:25[0-5]|2[0-4][0-9]|[0-1][0-9]{2}|[1-9][0-9]|[1-9]|0)\.(?:25[0-5]|2[0-4][0-9]|[0-1][0-9]{2}|[1-9][0-9]|[0-9])))(?:\:\d{1,5})?)(\/(?:(?:[a-zA-Z0-9\;\/\?\:\@\&\=\#\~\-\.\+\!\*\'\(\)\,\_])|(?:\%[a-fA-F0-9]{2}))*)?(?:\b|$)/gi, UrlUtils.REGEX = {SPECIAL_CHARS: /§.|[!@#$%^&*().+\-\[\]=\\\/:;,?`~_|<>{}]/g, SPACES: /\s+/g, AMPERSAND: /&/g, ANYTHING_NOT_LETTER: /[^a-zA-Z0-9\-]/g, ILLEGAL_CHARS: /[\u0300-\u036f]/g, DUPLICATED_DASHES: /-+/g, BORDER_DASHES: /^-|-$/g};
    class Logger {
      static getArgsFromParams(t, e) {
        const i = [];
        for (let n = 0; n < t.length; n++) {
          const r = t[n];
          if ("string" == typeof r) {
            const t = Logger.parseHtmlToArgs(r, e);
            i[0] ? i[0] += " " + t.shift() : i[0] = t.shift(), i.push(...t);
          } else i.push(r);
        }
        return i;
      }
      static parseHtmlToArgs(t, e) {
        if (0 === t.length) return [t];
        if (0 === e.length) throw new Error("defaultStyle parameter can't be empty");
        const i = [""], n = [], r = [];
        let o = false, s = "", a = false;
        for (let l = 0; l < t.length; l++) {
          const c = t[l];
          if ("<" === c && (o = true, "/" === t[l + 1] && (a = true), a || (0 === r.length && i[i.length - 1].length ? (n.push(e), i.push("")) : r.length && i[i.length - 1].length && this.insertStylesFromHtmlTags(r, i, n, e))), o ? s += c : i[i.length - 1] += c, ">" === c) {
            if (a) {
              this.insertStylesFromHtmlTags(r, i, n, e);
              const t = s.replace("/", ""), o = r.indexOf(t);
              ~o && r.splice(o, 1);
            } else r.push(s);
            s = "", o = false, a = false;
          }
        }
        for ("" === i[i.length - 1] && i.length > 1 && i.pop(); i.length > n.length;) n.push(e);
        const l = n[n.length - 1];
        return e.length && 0 === r.length && l && false === l.includes(e) && n.push(e), 0 === i[i.length - 1].length && i.length > 1 && i.splice(i.length - 1, 1), !~"".indexOf("%c") && n.length > 0 && (i[0] = `%c${""}`), n.unshift(i.join("%c")), n;
      }
      static insertStylesFromHtmlTags(t, e, i, n) {
        const r = [n];
        for (let e = 0; e < t.length; e++) {
          const i = Logger.htmlStyles[t[e]];
          i && r.push(i.join(";"));
        }
        r.length && e[e.length - 1].length && (i.push(r.join(";")), e.push(""));
      }
      static log(...t) {
        Logger.styled(Logger.styles.log.join(";"), ...t);
      }
      static info(...t) {
        Logger.styled(Logger.styles.info.join(";"), ...t);
      }
      static warn(...t) {
        Logger.styled(Logger.styles.warn.join(";"), ...t);
      }
      static error(...t) {
        Logger.styled(Logger.styles.error.join(";"), ...t);
      }
      static debug(...t) {
        null !== UrlUtils.getParameter("dev") && Logger.log(...t);
      }
      static styled(t, ...e) {
        console.log.call(console, ...Logger.getArgsFromParams(e, t));
      }
      static logTime(...t) {
        t.unshift(`[${DateUtils.getTime()}] `), console.log.call(console, ...t);
      }
    }
    function e(t, e) {
      if (!Object.prototype.hasOwnProperty.call(t, e)) throw new TypeError("attempted to use private field on non-instance");
      return t;
    }
    Logger.commonStyles = ["color: initial"], Logger.styles = {log: [`${Logger.commonStyles.join(";")}`], dir: [`${Logger.commonStyles.join(";")}`], info: ["background-color: rgba(0, 0, 255, .1)", `${Logger.commonStyles.join(";")}`], warn: ["background-color: rgba(255, 255, 0, .2)", `${Logger.commonStyles.join(";")}`], error: ["background-color: rgba(255, 0, 0, .2)", `${Logger.commonStyles.join(";")}`]}, Logger.htmlStyles = {"<b>": ["font-weight: bold"], "<i>": ["font-style: italic"], "<s>": ["text-decoration: line-through"], "<u>": ["text-decoration: underline"]};
    var i = 0;
    function r() {
      return (r = Object.assign || function (t) {
        for (var e = 1; e < arguments.length; e++) {
          var i = arguments[e];
          for (var n in i) Object.prototype.hasOwnProperty.call(i, n) && (t[n] = i[n]);
        }
        return t;
      }).apply(this, arguments);
    }
    const o = 100, s = 301, a = 302, l = 303, c = 304, h = 306, u = 307, p = 1e3, m = 1001, d = 1002, _ = 1003, y = 1004, g = 1005, x = 1006, v = 1008, b = 1009, w = 1012, S = 1014, M = 1015, A = 1016, C = 1020, T = 1022, E = 1023, L = 1026, D = 1027, R = 2300, B = 2301, P = 2302, I = 2400, V = 2401, F = 2402, k = 2500, N = 3e3, G = 3001, U = 3007, z = 3002, O = 7680, H = 35044, W = 35048, J = "300 es";
    class EventDispatcher {
      addEventListener(t, e) {
        void 0 === this._listeners && (this._listeners = {});
        const i = this._listeners;
        void 0 === i[t] && (i[t] = []), -1 === i[t].indexOf(e) && i[t].push(e);
      }
      hasEventListener(t, e) {
        if (void 0 === this._listeners) return false;
        const i = this._listeners;
        return void 0 !== i[t] && -1 !== i[t].indexOf(e);
      }
      removeEventListener(t, e) {
        if (void 0 === this._listeners) return;
        const i = this._listeners[t];
        if (void 0 !== i) {
          const t = i.indexOf(e);
          -1 !== t && i.splice(t, 1);
        }
      }
      dispatchEvent(t) {
        if (void 0 === this._listeners) return;
        const e = this._listeners[t.type];
        if (void 0 !== e) {
          t.target = this;
          const i = e.slice(0);
          for (let e = 0, n = i.length; e < n; e++) i[e].call(this, t);
          t.target = null;
        }
      }
    }
    const X = [];
    for (let t = 0; t < 256; t++) X[t] = (t < 16 ? "0" : "") + t.toString(16);
    const q = Math.PI / 180, Y = 180 / Math.PI;
    function Z() {
      const t = 4294967295 * Math.random() | 0, e = 4294967295 * Math.random() | 0, i = 4294967295 * Math.random() | 0, n = 4294967295 * Math.random() | 0;
      return (X[255 & t] + X[t >> 8 & 255] + X[t >> 16 & 255] + X[t >> 24 & 255] + "-" + X[255 & e] + X[e >> 8 & 255] + "-" + X[e >> 16 & 15 | 64] + X[e >> 24 & 255] + "-" + X[63 & i | 128] + X[i >> 8 & 255] + "-" + X[i >> 16 & 255] + X[i >> 24 & 255] + X[255 & n] + X[n >> 8 & 255] + X[n >> 16 & 255] + X[n >> 24 & 255]).toUpperCase();
    }
    class Vector2 {
      constructor(t = 0, e = 0) {
        this.x = t, this.y = e;
      }
      get width() {
        return this.x;
      }
      set width (t) {
        this.x = t;
      }
      get height() {
        return this.y;
      }
      set height (t) {
        this.y = t;
      }
      set(t, e) {
        return this.x = t, this.y = e, this;
      }
      setScalar(t) {
        return this.x = t, this.y = t, this;
      }
      setX(t) {
        return this.x = t, this;
      }
      setY(t) {
        return this.y = t, this;
      }
      setComponent(t, e) {
        switch (t) {
          case 0:
            this.x = e;
            break;
          case 1:
            this.y = e;
            break;
          default:
            throw new Error("index is out of range: " + t);
        }
        return this;
      }
      getComponent(t) {
        switch (t) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          default:
            throw new Error("index is out of range: " + t);
        }
      }
      clone() {
        return new this.constructor(this.x, this.y);
      }
      copy(t) {
        return this.x = t.x, this.y = t.y, this;
      }
      add(t, e) {
        return void 0 !== e ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this);
      }
      addScalar(t) {
        return this.x += t, this.y += t, this;
      }
      addVectors(t, e) {
        return this.x = t.x + e.x, this.y = t.y + e.y, this;
      }
      addScaledVector(t, e) {
        return this.x += t.x * e, this.y += t.y * e, this;
      }
      sub(t, e) {
        return void 0 !== e ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this);
      }
      subScalar(t) {
        return this.x -= t, this.y -= t, this;
      }
      subVectors(t, e) {
        return this.x = t.x - e.x, this.y = t.y - e.y, this;
      }
      multiply(t) {
        return this.x *= t.x, this.y *= t.y, this;
      }
      multiplyScalar(t) {
        return this.x *= t, this.y *= t, this;
      }
      divide(t) {
        return this.x /= t.x, this.y /= t.y, this;
      }
      divideScalar(t) {
        return this.multiplyScalar(1 / t);
      }
      applyMatrix3(t) {
        const e = this.x, i = this.y, n = t.elements;
        return this.x = n[0] * e + n[3] * i + n[6], this.y = n[1] * e + n[4] * i + n[7], this;
      }
      min(t) {
        return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this;
      }
      max(t) {
        return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this;
      }
      clamp(t, e) {
        return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this;
      }
      clampScalar(t, e) {
        return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this;
      }
      clampLength(t, e) {
        const i = this.length();
        return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)));
      }
      floor() {
        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
      }
      ceil() {
        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
      }
      round() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
      }
      roundToZero() {
        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this;
      }
      negate() {
        return this.x = -this.x, this.y = -this.y, this;
      }
      dot(t) {
        return this.x * t.x + this.y * t.y;
      }
      cross(t) {
        return this.x * t.y - this.y * t.x;
      }
      lengthSq() {
        return this.x * this.x + this.y * this.y;
      }
      length() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      }
      manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y);
      }
      normalize() {
        return this.divideScalar(this.length() || 1);
      }
      angle() {
        return Math.atan2(-this.y, -this.x) + Math.PI;
      }
      distanceTo(t) {
        return Math.sqrt(this.distanceToSquared(t));
      }
      distanceToSquared(t) {
        const e = this.x - t.x, i = this.y - t.y;
        return e * e + i * i;
      }
      manhattanDistanceTo(t) {
        return Math.abs(this.x - t.x) + Math.abs(this.y - t.y);
      }
      setLength(t) {
        return this.normalize().multiplyScalar(t);
      }
      lerp(t, e) {
        return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this;
      }
      lerpVectors(t, e, i) {
        return this.x = t.x + (e.x - t.x) * i, this.y = t.y + (e.y - t.y) * i, this;
      }
      equals(t) {
        return t.x === this.x && t.y === this.y;
      }
      fromArray(t, e = 0) {
        return this.x = t[e], this.y = t[e + 1], this;
      }
      toArray(t = [], e = 0) {
        return t[e] = this.x, t[e + 1] = this.y, t;
      }
      fromBufferAttribute(t, e, i) {
        return void 0 !== i && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this;
      }
      rotateAround(t, e) {
        const i = Math.cos(e), n = Math.sin(e), r = this.x - t.x, o = this.y - t.y;
        return this.x = r * i - o * n + t.x, this.y = r * n + o * i + t.y, this;
      }
      random() {
        return this.x = Math.random(), this.y = Math.random(), this;
      }
    }
    Vector2.prototype.isVector2 = true;
    class Matrix3 {
      constructor() {
        this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.");
      }
      set(t, e, i, n, r, o, s, a, l) {
        const c = this.elements;
        return c[0] = t, c[1] = n, c[2] = s, c[3] = e, c[4] = r, c[5] = a, c[6] = i, c[7] = o, c[8] = l, this;
      }
      identity() {
        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
      }
      copy(t) {
        const e = this.elements, i = t.elements;
        return e[0] = i[0], e[1] = i[1], e[2] = i[2], e[3] = i[3], e[4] = i[4], e[5] = i[5], e[6] = i[6], e[7] = i[7], e[8] = i[8], this;
      }
      extractBasis(t, e, i) {
        return t.setFromMatrix3Column(this, 0), e.setFromMatrix3Column(this, 1), i.setFromMatrix3Column(this, 2), this;
      }
      setFromMatrix4(t) {
        const e = t.elements;
        return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this;
      }
      multiply(t) {
        return this.multiplyMatrices(this, t);
      }
      premultiply(t) {
        return this.multiplyMatrices(t, this);
      }
      multiplyMatrices(t, e) {
        const i = t.elements, n = e.elements, r = this.elements, o = i[0], s = i[3], a = i[6], l = i[1], c = i[4], h = i[7], u = i[2], p = i[5], m = i[8], d = n[0], _ = n[3], y = n[6], g = n[1], x = n[4], v = n[7], b = n[2], w = n[5], S = n[8];
        return r[0] = o * d + s * g + a * b, r[3] = o * _ + s * x + a * w, r[6] = o * y + s * v + a * S, r[1] = l * d + c * g + h * b, r[4] = l * _ + c * x + h * w, r[7] = l * y + c * v + h * S, r[2] = u * d + p * g + m * b, r[5] = u * _ + p * x + m * w, r[8] = u * y + p * v + m * S, this;
      }
      multiplyScalar(t) {
        const e = this.elements;
        return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this;
      }
      determinant() {
        const t = this.elements, e = t[0], i = t[1], n = t[2], r = t[3], o = t[4], s = t[5], a = t[6], l = t[7], c = t[8];
        return e * o * c - e * s * l - i * r * c + i * s * a + n * r * l - n * o * a;
      }
      invert() {
        const t = this.elements, e = t[0], i = t[1], n = t[2], r = t[3], o = t[4], s = t[5], a = t[6], l = t[7], c = t[8], h = c * o - s * l, u = s * a - c * r, p = l * r - o * a, m = e * h + i * u + n * p;
        if (0 === m) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        const d = 1 / m;
        return t[0] = h * d, t[1] = (n * l - c * i) * d, t[2] = (s * i - n * o) * d, t[3] = u * d, t[4] = (c * e - n * a) * d, t[5] = (n * r - s * e) * d, t[6] = p * d, t[7] = (i * a - l * e) * d, t[8] = (o * e - i * r) * d, this;
      }
      transpose() {
        let t;
        const e = this.elements;
        return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this;
      }
      getNormalMatrix(t) {
        return this.setFromMatrix4(t).invert().transpose();
      }
      transposeIntoArray(t) {
        const e = this.elements;
        return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this;
      }
      setUvTransform(t, e, i, n, r, o, s) {
        const a = Math.cos(r), l = Math.sin(r);
        return this.set(i * a, i * l, -i * (a * o + l * s) + o + t, -n * l, n * a, -n * (-l * o + a * s) + s + e, 0, 0, 1), this;
      }
      scale(t, e) {
        const i = this.elements;
        return i[0] *= t, i[3] *= t, i[6] *= t, i[1] *= e, i[4] *= e, i[7] *= e, this;
      }
      rotate(t) {
        const e = Math.cos(t), i = Math.sin(t), n = this.elements, r = n[0], o = n[3], s = n[6], a = n[1], l = n[4], c = n[7];
        return n[0] = e * r + i * a, n[3] = e * o + i * l, n[6] = e * s + i * c, n[1] = -i * r + e * a, n[4] = -i * o + e * l, n[7] = -i * s + e * c, this;
      }
      translate(t, e) {
        const i = this.elements;
        return i[0] += t * i[2], i[3] += t * i[5], i[6] += t * i[8], i[1] += e * i[2], i[4] += e * i[5], i[7] += e * i[8], this;
      }
      equals(t) {
        const e = this.elements, i = t.elements;
        for (let t = 0; t < 9; t++) if (e[t] !== i[t]) return false;
        return true;
      }
      fromArray(t, e = 0) {
        for (let i = 0; i < 9; i++) this.elements[i] = t[i + e];
        return this;
      }
      toArray(t = [], e = 0) {
        const i = this.elements;
        return t[e] = i[0], t[e + 1] = i[1], t[e + 2] = i[2], t[e + 3] = i[3], t[e + 4] = i[4], t[e + 5] = i[5], t[e + 6] = i[6], t[e + 7] = i[7], t[e + 8] = i[8], t;
      }
      clone() {
        return (new this.constructor).fromArray(this.elements);
      }
    }
    let it;
    Matrix3.prototype.isMatrix3 = true;
    class ImageUtils {
      static getDataURL(t) {
        if (/^data:/i.test(t.src)) return t.src;
        if ("undefined" == typeof HTMLCanvasElement) return t.src;
        let e;
        if (t instanceof HTMLCanvasElement) e = t; else {
          void 0 === it && (it = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), it.width = t.width, it.height = t.height;
          const i = it.getContext("2d");
          t instanceof ImageData ? i.putImageData(t, 0, 0) : i.drawImage(t, 0, 0, t.width, t.height), e = it;
        }
        return e.width > 2048 || e.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", t), e.toDataURL("image/jpeg", 0.6)) : e.toDataURL("image/png");
      }
    }
    let nt = 0;
    class Texture extends EventDispatcher {
      constructor(t = Texture.DEFAULT_IMAGE, e = Texture.DEFAULT_MAPPING, i = 1001, n = 1001, r = 1006, o = 1008, s = 1023, a = 1009, l = 1, c = 3e3) {
        super(), Object.defineProperty(this, "id", {value: nt++}), this.uuid = Z(), this.name = "", this.image = t, this.mipmaps = [], this.mapping = e, this.wrapS = i, this.wrapT = n, this.magFilter = r, this.minFilter = o, this.anisotropy = l, this.format = s, this.internalFormat = null, this.type = a, this.offset = new Vector2(0, 0), this.repeat = new Vector2(1, 1), this.center = new Vector2(0, 0), this.rotation = 0, this.matrixAutoUpdate = true, this.matrix = new Matrix3, this.generateMipmaps = true, this.premultiplyAlpha = false, this.flipY = true, this.unpackAlignment = 4, this.encoding = c, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = false;
      }
      updateMatrix() {
        this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
      }
      clone() {
        return (new this.constructor).copy(this);
      }
      copy(t) {
        return this.name = t.name, this.image = t.image, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.internalFormat = t.internalFormat, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.encoding = t.encoding, this;
      }
      toJSON(t) {
        const e = void 0 === t || "string" == typeof t;
        if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid];
        const i = {metadata: {version: 4.5, type: "Texture", generator: "Texture.toJSON"}, uuid: this.uuid, name: this.name, mapping: this.mapping, repeat: [this.repeat.x, this.repeat.y], offset: [this.offset.x, this.offset.y], center: [this.center.x, this.center.y], rotation: this.rotation, wrap: [this.wrapS, this.wrapT], format: this.format, type: this.type, encoding: this.encoding, minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY, premultiplyAlpha: this.premultiplyAlpha, unpackAlignment: this.unpackAlignment};
        if (void 0 !== this.image) {
          const n = this.image;
          if (void 0 === n.uuid && (n.uuid = Z()), !e && void 0 === t.images[n.uuid]) {
            let e;
            if (Array.isArray(n)) {
              e = [];
              for (let t = 0, i = n.length; t < i; t++) n[t].isDataTexture ? e.push(rt(n[t].image)) : e.push(rt(n[t]));
            } else e = rt(n);
            t.images[n.uuid] = {uuid: n.uuid, url: e};
          }
          i.image = n.uuid;
        }
        return e || (t.textures[this.uuid] = i), i;
      }
      dispose() {
        this.dispatchEvent({type: "dispose"});
      }
      transformUv(t) {
        if (300 !== this.mapping) return t;
        if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1) switch (this.wrapS) {
          case p:
            t.x = t.x - Math.floor(t.x);
            break;
          case m:
            t.x = t.x < 0 ? 0 : 1;
            break;
          case d:
            1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x);
        }
        if (t.y < 0 || t.y > 1) switch (this.wrapT) {
          case p:
            t.y = t.y - Math.floor(t.y);
            break;
          case m:
            t.y = t.y < 0 ? 0 : 1;
            break;
          case d:
            1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y);
        }
        return this.flipY && (t.y = 1 - t.y), t;
      }
      set needsUpdate (t) {
        true === t && this.version++;
      }
    }
    function rt(t) {
      return "undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap ? ImageUtils.getDataURL(t) : t.data ? {data: Array.prototype.slice.call(t.data), width: t.width, height: t.height, type: t.data.constructor.name} : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
    }
    Texture.DEFAULT_IMAGE = void 0, Texture.DEFAULT_MAPPING = 300, Texture.prototype.isTexture = true;
    class Vector4 {
      constructor(t = 0, e = 0, i = 0, n = 1) {
        this.x = t, this.y = e, this.z = i, this.w = n;
      }
      get width() {
        return this.z;
      }
      set width (t) {
        this.z = t;
      }
      get height() {
        return this.w;
      }
      set height (t) {
        this.w = t;
      }
      set(t, e, i, n) {
        return this.x = t, this.y = e, this.z = i, this.w = n, this;
      }
      setScalar(t) {
        return this.x = t, this.y = t, this.z = t, this.w = t, this;
      }
      setX(t) {
        return this.x = t, this;
      }
      setY(t) {
        return this.y = t, this;
      }
      setZ(t) {
        return this.z = t, this;
      }
      setW(t) {
        return this.w = t, this;
      }
      setComponent(t, e) {
        switch (t) {
          case 0:
            this.x = e;
            break;
          case 1:
            this.y = e;
            break;
          case 2:
            this.z = e;
            break;
          case 3:
            this.w = e;
            break;
          default:
            throw new Error("index is out of range: " + t);
        }
        return this;
      }
      getComponent(t) {
        switch (t) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          case 2:
            return this.z;
          case 3:
            return this.w;
          default:
            throw new Error("index is out of range: " + t);
        }
      }
      clone() {
        return new this.constructor(this.x, this.y, this.z, this.w);
      }
      copy(t) {
        return this.x = t.x, this.y = t.y, this.z = t.z, this.w = void 0 !== t.w ? t.w : 1, this;
      }
      add(t, e) {
        return void 0 !== e ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this);
      }
      addScalar(t) {
        return this.x += t, this.y += t, this.z += t, this.w += t, this;
      }
      addVectors(t, e) {
        return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this;
      }
      addScaledVector(t, e) {
        return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this;
      }
      sub(t, e) {
        return void 0 !== e ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this);
      }
      subScalar(t) {
        return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this;
      }
      subVectors(t, e) {
        return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this;
      }
      multiply(t) {
        return this.x *= t.x, this.y *= t.y, this.z *= t.z, this.w *= t.w, this;
      }
      multiplyScalar(t) {
        return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this;
      }
      applyMatrix4(t) {
        const e = this.x, i = this.y, n = this.z, r = this.w, o = t.elements;
        return this.x = o[0] * e + o[4] * i + o[8] * n + o[12] * r, this.y = o[1] * e + o[5] * i + o[9] * n + o[13] * r, this.z = o[2] * e + o[6] * i + o[10] * n + o[14] * r, this.w = o[3] * e + o[7] * i + o[11] * n + o[15] * r, this;
      }
      divideScalar(t) {
        return this.multiplyScalar(1 / t);
      }
      setAxisAngleFromQuaternion(t) {
        this.w = 2 * Math.acos(t.w);
        const e = Math.sqrt(1 - t.w * t.w);
        return e < 0.0001 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this;
      }
      setAxisAngleFromRotationMatrix(t) {
        let e, i, n, r;
        const o = 0.01, s = 0.1, a = t.elements, l = a[0], c = a[4], h = a[8], u = a[1], p = a[5], m = a[9], d = a[2], _ = a[6], y = a[10];
        if (Math.abs(c - u) < o && Math.abs(h - d) < o && Math.abs(m - _) < o) {
          if (Math.abs(c + u) < s && Math.abs(h + d) < s && Math.abs(m + _) < s && Math.abs(l + p + y - 3) < s) return this.set(1, 0, 0, 0), this;
          e = Math.PI;
          const t = (l + 1) / 2, a = (p + 1) / 2, g = (y + 1) / 2, x = (c + u) / 4, v = (h + d) / 4, b = (m + _) / 4;
          return t > a && t > g ? t < o ? (i = 0, n = 0.707106781, r = 0.707106781) : (i = Math.sqrt(t), n = x / i, r = v / i) : a > g ? a < o ? (i = 0.707106781, n = 0, r = 0.707106781) : (n = Math.sqrt(a), i = x / n, r = b / n) : g < o ? (i = 0.707106781, n = 0.707106781, r = 0) : (r = Math.sqrt(g), i = v / r, n = b / r), this.set(i, n, r, e), this;
        }
        let g = Math.sqrt((_ - m) * (_ - m) + (h - d) * (h - d) + (u - c) * (u - c));
        return Math.abs(g) < 0.001 && (g = 1), this.x = (_ - m) / g, this.y = (h - d) / g, this.z = (u - c) / g, this.w = Math.acos((l + p + y - 1) / 2), this;
      }
      min(t) {
        return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this;
      }
      max(t) {
        return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this;
      }
      clamp(t, e) {
        return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this;
      }
      clampScalar(t, e) {
        return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this.w = Math.max(t, Math.min(e, this.w)), this;
      }
      clampLength(t, e) {
        const i = this.length();
        return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)));
      }
      floor() {
        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
      }
      ceil() {
        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
      }
      round() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
      }
      roundToZero() {
        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this;
      }
      negate() {
        return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
      }
      dot(t) {
        return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w;
      }
      lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
      }
      length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
      }
      manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
      }
      normalize() {
        return this.divideScalar(this.length() || 1);
      }
      setLength(t) {
        return this.normalize().multiplyScalar(t);
      }
      lerp(t, e) {
        return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this;
      }
      lerpVectors(t, e, i) {
        return this.x = t.x + (e.x - t.x) * i, this.y = t.y + (e.y - t.y) * i, this.z = t.z + (e.z - t.z) * i, this.w = t.w + (e.w - t.w) * i, this;
      }
      equals(t) {
        return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w;
      }
      fromArray(t, e = 0) {
        return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this;
      }
      toArray(t = [], e = 0) {
        return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t;
      }
      fromBufferAttribute(t, e, i) {
        return void 0 !== i && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this;
      }
      random() {
        return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
      }
    }
    Vector4.prototype.isVector4 = true;
    class WebGLRenderTarget extends EventDispatcher {
      constructor(t, e, i = {}) {
        super(), this.width = t, this.height = e, this.depth = 1, this.scissor = new Vector4(0, 0, t, e), this.scissorTest = false, this.viewport = new Vector4(0, 0, t, e), this.texture = new Texture(void 0, i.mapping, i.wrapS, i.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i.encoding), this.texture.isRenderTargetTexture = true, this.texture.image = {width: t, height: e, depth: 1}, this.texture.generateMipmaps = void 0 !== i.generateMipmaps && i.generateMipmaps, this.texture.internalFormat = void 0 !== i.internalFormat ? i.internalFormat : null, this.texture.minFilter = void 0 !== i.minFilter ? i.minFilter : x, this.depthBuffer = void 0 === i.depthBuffer || i.depthBuffer, this.stencilBuffer = void 0 !== i.stencilBuffer && i.stencilBuffer, this.depthTexture = void 0 !== i.depthTexture ? i.depthTexture : null;
      }
      setTexture(t) {
        t.image = {width: this.width, height: this.height, depth: this.depth}, this.texture = t;
      }
      setSize(t, e, i = 1) {
        this.width === t && this.height === e && this.depth === i || (this.width = t, this.height = e, this.depth = i, this.texture.image.width = t, this.texture.image.height = e, this.texture.image.depth = i, this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e);
      }
      clone() {
        return (new this.constructor).copy(this);
      }
      copy(t) {
        return this.width = t.width, this.height = t.height, this.depth = t.depth, this.viewport.copy(t.viewport), this.texture = t.texture.clone(), this.texture.image = r({}, this.texture.image), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t.depthTexture, this;
      }
      dispose() {
        this.dispatchEvent({type: "dispose"});
      }
    }
    WebGLRenderTarget.prototype.isWebGLRenderTarget = true;
    (class WebGLMultipleRenderTargets extends WebGLRenderTarget {
      constructor(t, e, i) {
        super(t, e);
        const n = this.texture;
        this.texture = [];
        for (let t = 0; t < i; t++) this.texture[t] = n.clone();
      }
      setSize(t, e, i = 1) {
        if (this.width !== t || this.height !== e || this.depth !== i) {
          this.width = t, this.height = e, this.depth = i;
          for (let n = 0, r = this.texture.length; n < r; n++) this.texture[n].image.width = t, this.texture[n].image.height = e, this.texture[n].image.depth = i;
          this.dispose();
        }
        return this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e), this;
      }
      copy(t) {
        this.dispose(), this.width = t.width, this.height = t.height, this.depth = t.depth, this.viewport.set(0, 0, this.width, this.height), this.scissor.set(0, 0, this.width, this.height), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t.depthTexture, this.texture.length = 0;
        for (let e = 0, i = t.texture.length; e < i; e++) this.texture[e] = t.texture[e].clone();
        return this;
      }
    }.prototype.isWebGLMultipleRenderTargets = true);
    class WebGLMultisampleRenderTarget extends WebGLRenderTarget {
      constructor(t, e, i) {
        super(t, e, i), this.samples = 4;
      }
      copy(t) {
        return super.copy.call(this, t), this.samples = t.samples, this;
      }
    }
    WebGLMultisampleRenderTarget.prototype.isWebGLMultisampleRenderTarget = true;
    class Quaternion {
      constructor(t = 0, e = 0, i = 0, n = 1) {
        this._x = t, this._y = e, this._z = i, this._w = n;
      }
      static slerp(t, e, i, n) {
        return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."), i.slerpQuaternions(t, e, n);
      }
      static slerpFlat(t, e, i, n, r, o, s) {
        let a = i[n + 0], l = i[n + 1], c = i[n + 2], h = i[n + 3];
        const u = r[o + 0], p = r[o + 1], m = r[o + 2], d = r[o + 3];
        if (0 === s) return t[e + 0] = a, t[e + 1] = l, t[e + 2] = c, void (t[e + 3] = h);
        if (1 === s) return t[e + 0] = u, t[e + 1] = p, t[e + 2] = m, void (t[e + 3] = d);
        if (h !== d || a !== u || l !== p || c !== m) {
          let t = 1 - s;
          const e = a * u + l * p + c * m + h * d, i = e >= 0 ? 1 : -1, n = 1 - e * e;
          if (n > Number.EPSILON) {
            const r = Math.sqrt(n), o = Math.atan2(r, e * i);
            t = Math.sin(t * o) / r, s = Math.sin(s * o) / r;
          }
          const r = s * i;
          if (a = a * t + u * r, l = l * t + p * r, c = c * t + m * r, h = h * t + d * r, t === 1 - s) {
            const t = 1 / Math.sqrt(a * a + l * l + c * c + h * h);
            a *= t, l *= t, c *= t, h *= t;
          }
        }
        t[e] = a, t[e + 1] = l, t[e + 2] = c, t[e + 3] = h;
      }
      static multiplyQuaternionsFlat(t, e, i, n, r, o) {
        const s = i[n], a = i[n + 1], l = i[n + 2], c = i[n + 3], h = r[o], u = r[o + 1], p = r[o + 2], m = r[o + 3];
        return t[e] = s * m + c * h + a * p - l * u, t[e + 1] = a * m + c * u + l * h - s * p, t[e + 2] = l * m + c * p + s * u - a * h, t[e + 3] = c * m - s * h - a * u - l * p, t;
      }
      get x() {
        return this._x;
      }
      set x (t) {
        this._x = t, this._onChangeCallback();
      }
      get y() {
        return this._y;
      }
      set y (t) {
        this._y = t, this._onChangeCallback();
      }
      get z() {
        return this._z;
      }
      set z (t) {
        this._z = t, this._onChangeCallback();
      }
      get w() {
        return this._w;
      }
      set w (t) {
        this._w = t, this._onChangeCallback();
      }
      set(t, e, i, n) {
        return this._x = t, this._y = e, this._z = i, this._w = n, this._onChangeCallback(), this;
      }
      clone() {
        return new this.constructor(this._x, this._y, this._z, this._w);
      }
      copy(t) {
        return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this._onChangeCallback(), this;
      }
      setFromEuler(t, e) {
        if (!t || !t.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
        const i = t._x, n = t._y, r = t._z, o = t._order, s = Math.cos, a = Math.sin, l = s(i / 2), c = s(n / 2), h = s(r / 2), u = a(i / 2), p = a(n / 2), m = a(r / 2);
        switch (o) {
          case "XYZ":
            this._x = u * c * h + l * p * m, this._y = l * p * h - u * c * m, this._z = l * c * m + u * p * h, this._w = l * c * h - u * p * m;
            break;
          case "YXZ":
            this._x = u * c * h + l * p * m, this._y = l * p * h - u * c * m, this._z = l * c * m - u * p * h, this._w = l * c * h + u * p * m;
            break;
          case "ZXY":
            this._x = u * c * h - l * p * m, this._y = l * p * h + u * c * m, this._z = l * c * m + u * p * h, this._w = l * c * h - u * p * m;
            break;
          case "ZYX":
            this._x = u * c * h - l * p * m, this._y = l * p * h + u * c * m, this._z = l * c * m - u * p * h, this._w = l * c * h + u * p * m;
            break;
          case "YZX":
            this._x = u * c * h + l * p * m, this._y = l * p * h + u * c * m, this._z = l * c * m - u * p * h, this._w = l * c * h - u * p * m;
            break;
          case "XZY":
            this._x = u * c * h - l * p * m, this._y = l * p * h - u * c * m, this._z = l * c * m + u * p * h, this._w = l * c * h + u * p * m;
            break;
          default:
            console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o);
        }
        return false !== e && this._onChangeCallback(), this;
      }
      setFromAxisAngle(t, e) {
        const i = e / 2, n = Math.sin(i);
        return this._x = t.x * n, this._y = t.y * n, this._z = t.z * n, this._w = Math.cos(i), this._onChangeCallback(), this;
      }
      setFromRotationMatrix(t) {
        const e = t.elements, i = e[0], n = e[4], r = e[8], o = e[1], s = e[5], a = e[9], l = e[2], c = e[6], h = e[10], u = i + s + h;
        if (u > 0) {
          const t = 0.5 / Math.sqrt(u + 1);
          this._w = 0.25 / t, this._x = (c - a) * t, this._y = (r - l) * t, this._z = (o - n) * t;
        } else if (i > s && i > h) {
          const t = 2 * Math.sqrt(1 + i - s - h);
          this._w = (c - a) / t, this._x = 0.25 * t, this._y = (n + o) / t, this._z = (r + l) / t;
        } else if (s > h) {
          const t = 2 * Math.sqrt(1 + s - i - h);
          this._w = (r - l) / t, this._x = (n + o) / t, this._y = 0.25 * t, this._z = (a + c) / t;
        } else {
          const t = 2 * Math.sqrt(1 + h - i - s);
          this._w = (o - n) / t, this._x = (r + l) / t, this._y = (a + c) / t, this._z = 0.25 * t;
        }
        return this._onChangeCallback(), this;
      }
      setFromUnitVectors(t, e) {
        let i = t.dot(e) + 1;
        return i < Number.EPSILON ? (i = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0, this._w = i) : (this._x = 0, this._y = -t.z, this._z = t.y, this._w = i)) : (this._x = t.y * e.z - t.z * e.y, this._y = t.z * e.x - t.x * e.z, this._z = t.x * e.y - t.y * e.x, this._w = i), this.normalize();
      }
      angleTo(t) {
        return 2 * Math.acos(Math.abs(Math.max(-1, Math.min(1, this.dot(t)))));
      }
      rotateTowards(t, e) {
        const i = this.angleTo(t);
        if (0 === i) return this;
        const n = Math.min(1, e / i);
        return this.slerp(t, n), this;
      }
      identity() {
        return this.set(0, 0, 0, 1);
      }
      invert() {
        return this.conjugate();
      }
      conjugate() {
        return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
      }
      dot(t) {
        return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w;
      }
      lengthSq() {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
      }
      length() {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
      }
      normalize() {
        let t = this.length();
        return 0 === t ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this._onChangeCallback(), this;
      }
      multiply(t, e) {
        return void 0 !== e ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(t, e)) : this.multiplyQuaternions(this, t);
      }
      premultiply(t) {
        return this.multiplyQuaternions(t, this);
      }
      multiplyQuaternions(t, e) {
        const i = t._x, n = t._y, r = t._z, o = t._w, s = e._x, a = e._y, l = e._z, c = e._w;
        return this._x = i * c + o * s + n * l - r * a, this._y = n * c + o * a + r * s - i * l, this._z = r * c + o * l + i * a - n * s, this._w = o * c - i * s - n * a - r * l, this._onChangeCallback(), this;
      }
      slerp(t, e) {
        if (0 === e) return this;
        if (1 === e) return this.copy(t);
        const i = this._x, n = this._y, r = this._z, o = this._w;
        let s = o * t._w + i * t._x + n * t._y + r * t._z;
        if (s < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, s = -s) : this.copy(t), s >= 1) return this._w = o, this._x = i, this._y = n, this._z = r, this;
        const a = 1 - s * s;
        if (a <= Number.EPSILON) {
          const t = 1 - e;
          return this._w = t * o + e * this._w, this._x = t * i + e * this._x, this._y = t * n + e * this._y, this._z = t * r + e * this._z, this.normalize(), this._onChangeCallback(), this;
        }
        const l = Math.sqrt(a), c = Math.atan2(l, s), h = Math.sin((1 - e) * c) / l, u = Math.sin(e * c) / l;
        return this._w = o * h + this._w * u, this._x = i * h + this._x * u, this._y = n * h + this._y * u, this._z = r * h + this._z * u, this._onChangeCallback(), this;
      }
      slerpQuaternions(t, e, i) {
        this.copy(t).slerp(e, i);
      }
      equals(t) {
        return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w;
      }
      fromArray(t, e = 0) {
        return this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this._onChangeCallback(), this;
      }
      toArray(t = [], e = 0) {
        return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t;
      }
      fromBufferAttribute(t, e) {
        return this._x = t.getX(e), this._y = t.getY(e), this._z = t.getZ(e), this._w = t.getW(e), this;
      }
      _onChange(t) {
        return this._onChangeCallback = t, this;
      }
      _onChangeCallback() {}
    }
    Quaternion.prototype.isQuaternion = true;
    class three_module_Vector3 {
      constructor(t = 0, e = 0, i = 0) {
        this.x = t, this.y = e, this.z = i;
      }
      set(t, e, i) {
        return void 0 === i && (i = this.z), this.x = t, this.y = e, this.z = i, this;
      }
      setScalar(t) {
        return this.x = t, this.y = t, this.z = t, this;
      }
      setX(t) {
        return this.x = t, this;
      }
      setY(t) {
        return this.y = t, this;
      }
      setZ(t) {
        return this.z = t, this;
      }
      setComponent(t, e) {
        switch (t) {
          case 0:
            this.x = e;
            break;
          case 1:
            this.y = e;
            break;
          case 2:
            this.z = e;
            break;
          default:
            throw new Error("index is out of range: " + t);
        }
        return this;
      }
      getComponent(t) {
        switch (t) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          case 2:
            return this.z;
          default:
            throw new Error("index is out of range: " + t);
        }
      }
      clone() {
        return new this.constructor(this.x, this.y, this.z);
      }
      copy(t) {
        return this.x = t.x, this.y = t.y, this.z = t.z, this;
      }
      add(t, e) {
        return void 0 !== e ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this);
      }
      addScalar(t) {
        return this.x += t, this.y += t, this.z += t, this;
      }
      addVectors(t, e) {
        return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this;
      }
      addScaledVector(t, e) {
        return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this;
      }
      sub(t, e) {
        return void 0 !== e ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this);
      }
      subScalar(t) {
        return this.x -= t, this.y -= t, this.z -= t, this;
      }
      subVectors(t, e) {
        return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this;
      }
      multiply(t, e) {
        return void 0 !== e ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(t, e)) : (this.x *= t.x, this.y *= t.y, this.z *= t.z, this);
      }
      multiplyScalar(t) {
        return this.x *= t, this.y *= t, this.z *= t, this;
      }
      multiplyVectors(t, e) {
        return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this;
      }
      applyEuler(t) {
        return t && t.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(st.setFromEuler(t));
      }
      applyAxisAngle(t, e) {
        return this.applyQuaternion(st.setFromAxisAngle(t, e));
      }
      applyMatrix3(t) {
        const e = this.x, i = this.y, n = this.z, r = t.elements;
        return this.x = r[0] * e + r[3] * i + r[6] * n, this.y = r[1] * e + r[4] * i + r[7] * n, this.z = r[2] * e + r[5] * i + r[8] * n, this;
      }
      applyNormalMatrix(t) {
        return this.applyMatrix3(t).normalize();
      }
      applyMatrix4(t) {
        const e = this.x, i = this.y, n = this.z, r = t.elements, o = 1 / (r[3] * e + r[7] * i + r[11] * n + r[15]);
        return this.x = (r[0] * e + r[4] * i + r[8] * n + r[12]) * o, this.y = (r[1] * e + r[5] * i + r[9] * n + r[13]) * o, this.z = (r[2] * e + r[6] * i + r[10] * n + r[14]) * o, this;
      }
      applyQuaternion(t) {
        const e = this.x, i = this.y, n = this.z, r = t.x, o = t.y, s = t.z, a = t.w, l = a * e + o * n - s * i, c = a * i + s * e - r * n, h = a * n + r * i - o * e, u = -r * e - o * i - s * n;
        return this.x = l * a + u * -r + c * -s - h * -o, this.y = c * a + u * -o + h * -r - l * -s, this.z = h * a + u * -s + l * -o - c * -r, this;
      }
      project(t) {
        return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix);
      }
      unproject(t) {
        return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld);
      }
      transformDirection(t) {
        const e = this.x, i = this.y, n = this.z, r = t.elements;
        return this.x = r[0] * e + r[4] * i + r[8] * n, this.y = r[1] * e + r[5] * i + r[9] * n, this.z = r[2] * e + r[6] * i + r[10] * n, this.normalize();
      }
      divide(t) {
        return this.x /= t.x, this.y /= t.y, this.z /= t.z, this;
      }
      divideScalar(t) {
        return this.multiplyScalar(1 / t);
      }
      min(t) {
        return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this;
      }
      max(t) {
        return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this;
      }
      clamp(t, e) {
        return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this;
      }
      clampScalar(t, e) {
        return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this;
      }
      clampLength(t, e) {
        const i = this.length();
        return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)));
      }
      floor() {
        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
      }
      ceil() {
        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
      }
      round() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
      }
      roundToZero() {
        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this;
      }
      negate() {
        return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
      }
      dot(t) {
        return this.x * t.x + this.y * t.y + this.z * t.z;
      }
      lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z;
      }
      length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
      }
      manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
      }
      normalize() {
        return this.divideScalar(this.length() || 1);
      }
      setLength(t) {
        return this.normalize().multiplyScalar(t);
      }
      lerp(t, e) {
        return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this;
      }
      lerpVectors(t, e, i) {
        return this.x = t.x + (e.x - t.x) * i, this.y = t.y + (e.y - t.y) * i, this.z = t.z + (e.z - t.z) * i, this;
      }
      cross(t, e) {
        return void 0 !== e ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(t, e)) : this.crossVectors(this, t);
      }
      crossVectors(t, e) {
        const i = t.x, n = t.y, r = t.z, o = e.x, s = e.y, a = e.z;
        return this.x = n * a - r * s, this.y = r * o - i * a, this.z = i * s - n * o, this;
      }
      projectOnVector(t) {
        const e = t.lengthSq();
        if (0 === e) return this.set(0, 0, 0);
        const i = t.dot(this) / e;
        return this.copy(t).multiplyScalar(i);
      }
      projectOnPlane(t) {
        return ot.copy(this).projectOnVector(t), this.sub(ot);
      }
      reflect(t) {
        return this.sub(ot.copy(t).multiplyScalar(2 * this.dot(t)));
      }
      angleTo(t) {
        const e = Math.sqrt(this.lengthSq() * t.lengthSq());
        if (0 === e) return Math.PI / 2;
        const i = this.dot(t) / e;
        return Math.acos(Math.max(-1, Math.min(1, i)));
      }
      distanceTo(t) {
        return Math.sqrt(this.distanceToSquared(t));
      }
      distanceToSquared(t) {
        const e = this.x - t.x, i = this.y - t.y, n = this.z - t.z;
        return e * e + i * i + n * n;
      }
      manhattanDistanceTo(t) {
        return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z);
      }
      setFromSpherical(t) {
        return this.setFromSphericalCoords(t.radius, t.phi, t.theta);
      }
      setFromSphericalCoords(t, e, i) {
        const n = Math.sin(e) * t;
        return this.x = n * Math.sin(i), this.y = Math.cos(e) * t, this.z = n * Math.cos(i), this;
      }
      setFromCylindrical(t) {
        return this.setFromCylindricalCoords(t.radius, t.theta, t.y);
      }
      setFromCylindricalCoords(t, e, i) {
        return this.x = t * Math.sin(e), this.y = i, this.z = t * Math.cos(e), this;
      }
      setFromMatrixPosition(t) {
        const e = t.elements;
        return this.x = e[12], this.y = e[13], this.z = e[14], this;
      }
      setFromMatrixScale(t) {
        const e = this.setFromMatrixColumn(t, 0).length(), i = this.setFromMatrixColumn(t, 1).length(), n = this.setFromMatrixColumn(t, 2).length();
        return this.x = e, this.y = i, this.z = n, this;
      }
      setFromMatrixColumn(t, e) {
        return this.fromArray(t.elements, 4 * e);
      }
      setFromMatrix3Column(t, e) {
        return this.fromArray(t.elements, 3 * e);
      }
      equals(t) {
        return t.x === this.x && t.y === this.y && t.z === this.z;
      }
      fromArray(t, e = 0) {
        return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this;
      }
      toArray(t = [], e = 0) {
        return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t;
      }
      fromBufferAttribute(t, e, i) {
        return void 0 !== i && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this;
      }
      random() {
        return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
      }
    }
    three_module_Vector3.prototype.isVector3 = true;
    const ot = new three_module_Vector3, st = new Quaternion;
    class Box3 {
      constructor(t = new three_module_Vector3(Infinity, Infinity, Infinity), e = new three_module_Vector3(-Infinity, -Infinity, -Infinity)) {
        this.min = t, this.max = e;
      }
      set(t, e) {
        return this.min.copy(t), this.max.copy(e), this;
      }
      setFromArray(t) {
        let e = Infinity, i = Infinity, n = Infinity, r = -Infinity, o = -Infinity, s = -Infinity;
        for (let a = 0, l = t.length; a < l; a += 3) {
          const l = t[a], c = t[a + 1], h = t[a + 2];
          l < e && (e = l), c < i && (i = c), h < n && (n = h), l > r && (r = l), c > o && (o = c), h > s && (s = h);
        }
        return this.min.set(e, i, n), this.max.set(r, o, s), this;
      }
      setFromBufferAttribute(t) {
        let e = Infinity, i = Infinity, n = Infinity, r = -Infinity, o = -Infinity, s = -Infinity;
        for (let a = 0, l = t.count; a < l; a++) {
          const l = t.getX(a), c = t.getY(a), h = t.getZ(a);
          l < e && (e = l), c < i && (i = c), h < n && (n = h), l > r && (r = l), c > o && (o = c), h > s && (s = h);
        }
        return this.min.set(e, i, n), this.max.set(r, o, s), this;
      }
      setFromPoints(t) {
        this.makeEmpty();
        for (let e = 0, i = t.length; e < i; e++) this.expandByPoint(t[e]);
        return this;
      }
      setFromCenterAndSize(t, e) {
        const i = lt.copy(e).multiplyScalar(0.5);
        return this.min.copy(t).sub(i), this.max.copy(t).add(i), this;
      }
      setFromObject(t) {
        return this.makeEmpty(), this.expandByObject(t);
      }
      clone() {
        return (new this.constructor).copy(this);
      }
      copy(t) {
        return this.min.copy(t.min), this.max.copy(t.max), this;
      }
      makeEmpty() {
        return this.min.x = this.min.y = this.min.z = Infinity, this.max.x = this.max.y = this.max.z = -Infinity, this;
      }
      isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
      }
      getCenter(t) {
        return this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(0.5);
      }
      getSize(t) {
        return this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min);
      }
      expandByPoint(t) {
        return this.min.min(t), this.max.max(t), this;
      }
      expandByVector(t) {
        return this.min.sub(t), this.max.add(t), this;
      }
      expandByScalar(t) {
        return this.min.addScalar(-t), this.max.addScalar(t), this;
      }
      expandByObject(t) {
        t.updateWorldMatrix(false, false);
        const e = t.geometry;
        void 0 !== e && (null === e.boundingBox && e.computeBoundingBox(), ct.copy(e.boundingBox), ct.applyMatrix4(t.matrixWorld), this.union(ct));
        const i = t.children;
        for (let t = 0, e = i.length; t < e; t++) this.expandByObject(i[t]);
        return this;
      }
      containsPoint(t) {
        return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z);
      }
      containsBox(t) {
        return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z;
      }
      getParameter(t, e) {
        return e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z));
      }
      intersectsBox(t) {
        return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z);
      }
      intersectsSphere(t) {
        return this.clampPoint(t.center, lt), lt.distanceToSquared(t.center) <= t.radius * t.radius;
      }
      intersectsPlane(t) {
        let e, i;
        return t.normal.x > 0 ? (e = t.normal.x * this.min.x, i = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, i = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, i += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, i += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, i += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, i += t.normal.z * this.min.z), e <= -t.constant && i >= -t.constant;
      }
      intersectsTriangle(t) {
        if (this.isEmpty()) return false;
        this.getCenter(_t), yt.subVectors(this.max, _t), ht.subVectors(t.a, _t), ut.subVectors(t.b, _t), pt.subVectors(t.c, _t), mt.subVectors(ut, ht), dt.subVectors(pt, ut), ft.subVectors(ht, pt);
        let e = [0, -mt.z, mt.y, 0, -dt.z, dt.y, 0, -ft.z, ft.y, mt.z, 0, -mt.x, dt.z, 0, -dt.x, ft.z, 0, -ft.x, -mt.y, mt.x, 0, -dt.y, dt.x, 0, -ft.y, ft.x, 0];
        return !!vt(e, ht, ut, pt, yt) && (e = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!vt(e, ht, ut, pt, yt) && (gt.crossVectors(mt, dt), e = [gt.x, gt.y, gt.z], vt(e, ht, ut, pt, yt)));
      }
      clampPoint(t, e) {
        return e.copy(t).clamp(this.min, this.max);
      }
      distanceToPoint(t) {
        return lt.copy(t).clamp(this.min, this.max).sub(t).length();
      }
      getBoundingSphere(t) {
        return this.getCenter(t.center), t.radius = 0.5 * this.getSize(lt).length(), t;
      }
      intersect(t) {
        return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this;
      }
      union(t) {
        return this.min.min(t.min), this.max.max(t.max), this;
      }
      applyMatrix4(t) {
        return this.isEmpty() || (at[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), at[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), at[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), at[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), at[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), at[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), at[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), at[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(at)), this;
      }
      translate(t) {
        return this.min.add(t), this.max.add(t), this;
      }
      equals(t) {
        return t.min.equals(this.min) && t.max.equals(this.max);
      }
    }
    Box3.prototype.isBox3 = true;
    const at = [new three_module_Vector3, new three_module_Vector3, new three_module_Vector3, new three_module_Vector3, new three_module_Vector3, new three_module_Vector3, new three_module_Vector3, new three_module_Vector3], lt = new three_module_Vector3, ct = new Box3, ht = new three_module_Vector3, ut = new three_module_Vector3, pt = new three_module_Vector3, mt = new three_module_Vector3, dt = new three_module_Vector3, ft = new three_module_Vector3, _t = new three_module_Vector3, yt = new three_module_Vector3, gt = new three_module_Vector3, xt = new three_module_Vector3;
    function vt(t, e, i, n, r) {
      for (let o = 0, s = t.length - 3; o <= s; o += 3) {
        xt.fromArray(t, o);
        const s = r.x * Math.abs(xt.x) + r.y * Math.abs(xt.y) + r.z * Math.abs(xt.z), a = e.dot(xt), l = i.dot(xt), c = n.dot(xt);
        if (Math.max(-Math.max(a, l, c), Math.min(a, l, c)) > s) return false;
      }
      return true;
    }
    const bt = new Box3, wt = new three_module_Vector3, St = new three_module_Vector3, Mt = new three_module_Vector3;
    class Sphere {
      constructor(t = new three_module_Vector3, e = -1) {
        this.center = t, this.radius = e;
      }
      set(t, e) {
        return this.center.copy(t), this.radius = e, this;
      }
      setFromPoints(t, e) {
        const i = this.center;
        void 0 !== e ? i.copy(e) : bt.setFromPoints(t).getCenter(i);
        let n = 0;
        for (let e = 0, r = t.length; e < r; e++) n = Math.max(n, i.distanceToSquared(t[e]));
        return this.radius = Math.sqrt(n), this;
      }
      copy(t) {
        return this.center.copy(t.center), this.radius = t.radius, this;
      }
      isEmpty() {
        return this.radius < 0;
      }
      makeEmpty() {
        return this.center.set(0, 0, 0), this.radius = -1, this;
      }
      containsPoint(t) {
        return t.distanceToSquared(this.center) <= this.radius * this.radius;
      }
      distanceToPoint(t) {
        return t.distanceTo(this.center) - this.radius;
      }
      intersectsSphere(t) {
        const e = this.radius + t.radius;
        return t.center.distanceToSquared(this.center) <= e * e;
      }
      intersectsBox(t) {
        return t.intersectsSphere(this);
      }
      intersectsPlane(t) {
        return Math.abs(t.distanceToPoint(this.center)) <= this.radius;
      }
      clampPoint(t, e) {
        const i = this.center.distanceToSquared(t);
        return e.copy(t), i > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e;
      }
      getBoundingBox(t) {
        return this.isEmpty() ? (t.makeEmpty(), t) : (t.set(this.center, this.center), t.expandByScalar(this.radius), t);
      }
      applyMatrix4(t) {
        return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this;
      }
      translate(t) {
        return this.center.add(t), this;
      }
      expandByPoint(t) {
        Mt.subVectors(t, this.center);
        const e = Mt.lengthSq();
        if (e > this.radius * this.radius) {
          const t = Math.sqrt(e), i = 0.5 * (t - this.radius);
          this.center.add(Mt.multiplyScalar(i / t)), this.radius += i;
        }
        return this;
      }
      union(t) {
        return St.subVectors(t.center, this.center).normalize().multiplyScalar(t.radius), this.expandByPoint(wt.copy(t.center).add(St)), this.expandByPoint(wt.copy(t.center).sub(St)), this;
      }
      equals(t) {
        return t.center.equals(this.center) && t.radius === this.radius;
      }
      clone() {
        return (new this.constructor).copy(this);
      }
    }
    const At = new three_module_Vector3, Ct = new three_module_Vector3, Tt = new three_module_Vector3, Et = new three_module_Vector3, Lt = new three_module_Vector3, Dt = new three_module_Vector3, Rt = new three_module_Vector3;
    class Ray {
      constructor(t = new three_module_Vector3, e = new three_module_Vector3(0, 0, -1)) {
        this.origin = t, this.direction = e;
      }
      set(t, e) {
        return this.origin.copy(t), this.direction.copy(e), this;
      }
      copy(t) {
        return this.origin.copy(t.origin), this.direction.copy(t.direction), this;
      }
      at(t, e) {
        return e.copy(this.direction).multiplyScalar(t).add(this.origin);
      }
      lookAt(t) {
        return this.direction.copy(t).sub(this.origin).normalize(), this;
      }
      recast(t) {
        return this.origin.copy(this.at(t, At)), this;
      }
      closestPointToPoint(t, e) {
        e.subVectors(t, this.origin);
        const i = e.dot(this.direction);
        return i < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(i).add(this.origin);
      }
      distanceToPoint(t) {
        return Math.sqrt(this.distanceSqToPoint(t));
      }
      distanceSqToPoint(t) {
        const e = At.subVectors(t, this.origin).dot(this.direction);
        return e < 0 ? this.origin.distanceToSquared(t) : (At.copy(this.direction).multiplyScalar(e).add(this.origin), At.distanceToSquared(t));
      }
      distanceSqToSegment(t, e, i, n) {
        Ct.copy(t).add(e).multiplyScalar(0.5), Tt.copy(e).sub(t).normalize(), Et.copy(this.origin).sub(Ct);
        const r = 0.5 * t.distanceTo(e), o = -this.direction.dot(Tt), s = Et.dot(this.direction), a = -Et.dot(Tt), l = Et.lengthSq(), c = Math.abs(1 - o * o);
        let h, u, p, m;
        if (c > 0) if (h = o * a - s, u = o * s - a, m = r * c, h >= 0) if (u >= -m) if (u <= m) {
          const t = 1 / c;
          h *= t, u *= t, p = h * (h + o * u + 2 * s) + u * (o * h + u + 2 * a) + l;
        } else u = r, h = Math.max(0, -(o * u + s)), p = -h * h + u * (u + 2 * a) + l; else u = -r, h = Math.max(0, -(o * u + s)), p = -h * h + u * (u + 2 * a) + l; else u <= -m ? (h = Math.max(0, -(-o * r + s)), u = h > 0 ? -r : Math.min(Math.max(-r, -a), r), p = -h * h + u * (u + 2 * a) + l) : u <= m ? (h = 0, u = Math.min(Math.max(-r, -a), r), p = u * (u + 2 * a) + l) : (h = Math.max(0, -(o * r + s)), u = h > 0 ? r : Math.min(Math.max(-r, -a), r), p = -h * h + u * (u + 2 * a) + l); else u = o > 0 ? -r : r, h = Math.max(0, -(o * u + s)), p = -h * h + u * (u + 2 * a) + l;
        return i && i.copy(this.direction).multiplyScalar(h).add(this.origin), n && n.copy(Tt).multiplyScalar(u).add(Ct), p;
      }
      intersectSphere(t, e) {
        At.subVectors(t.center, this.origin);
        const i = At.dot(this.direction), n = At.dot(At) - i * i, r = t.radius * t.radius;
        if (n > r) return null;
        const o = Math.sqrt(r - n), s = i - o, a = i + o;
        return s < 0 && a < 0 ? null : s < 0 ? this.at(a, e) : this.at(s, e);
      }
      intersectsSphere(t) {
        return this.distanceSqToPoint(t.center) <= t.radius * t.radius;
      }
      distanceToPlane(t) {
        const e = t.normal.dot(this.direction);
        if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
        const i = -(this.origin.dot(t.normal) + t.constant) / e;
        return i >= 0 ? i : null;
      }
      intersectPlane(t, e) {
        const i = this.distanceToPlane(t);
        return null === i ? null : this.at(i, e);
      }
      intersectsPlane(t) {
        const e = t.distanceToPoint(this.origin);
        if (0 === e) return true;
        return t.normal.dot(this.direction) * e < 0;
      }
      intersectBox(t, e) {
        let i, n, r, o, s, a;
        const l = 1 / this.direction.x, c = 1 / this.direction.y, h = 1 / this.direction.z, u = this.origin;
        return l >= 0 ? (i = (t.min.x - u.x) * l, n = (t.max.x - u.x) * l) : (i = (t.max.x - u.x) * l, n = (t.min.x - u.x) * l), c >= 0 ? (r = (t.min.y - u.y) * c, o = (t.max.y - u.y) * c) : (r = (t.max.y - u.y) * c, o = (t.min.y - u.y) * c), i > o || r > n ? null : ((r > i || i != i) && (i = r), (o < n || n != n) && (n = o), h >= 0 ? (s = (t.min.z - u.z) * h, a = (t.max.z - u.z) * h) : (s = (t.max.z - u.z) * h, a = (t.min.z - u.z) * h), i > a || s > n ? null : ((s > i || i != i) && (i = s), (a < n || n != n) && (n = a), n < 0 ? null : this.at(i >= 0 ? i : n, e)));
      }
      intersectsBox(t) {
        return null !== this.intersectBox(t, At);
      }
      intersectTriangle(t, e, i, n, r) {
        Lt.subVectors(e, t), Dt.subVectors(i, t), Rt.crossVectors(Lt, Dt);
        let o, s = this.direction.dot(Rt);
        if (s > 0) {
          if (n) return null;
          o = 1;
        } else {
          if (!(s < 0)) return null;
          o = -1, s = -s;
        }
        Et.subVectors(this.origin, t);
        const a = o * this.direction.dot(Dt.crossVectors(Et, Dt));
        if (a < 0) return null;
        const l = o * this.direction.dot(Lt.cross(Et));
        if (l < 0) return null;
        if (a + l > s) return null;
        const c = -o * Et.dot(Rt);
        return c < 0 ? null : this.at(c / s, r);
      }
      applyMatrix4(t) {
        return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this;
      }
      equals(t) {
        return t.origin.equals(this.origin) && t.direction.equals(this.direction);
      }
      clone() {
        return (new this.constructor).copy(this);
      }
    }
    class Matrix4 {
      constructor() {
        this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
      }
      set(t, e, i, n, r, o, s, a, l, c, h, u, p, m, d, _) {
        const y = this.elements;
        return y[0] = t, y[4] = e, y[8] = i, y[12] = n, y[1] = r, y[5] = o, y[9] = s, y[13] = a, y[2] = l, y[6] = c, y[10] = h, y[14] = u, y[3] = p, y[7] = m, y[11] = d, y[15] = _, this;
      }
      identity() {
        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
      }
      clone() {
        return (new Matrix4).fromArray(this.elements);
      }
      copy(t) {
        const e = this.elements, i = t.elements;
        return e[0] = i[0], e[1] = i[1], e[2] = i[2], e[3] = i[3], e[4] = i[4], e[5] = i[5], e[6] = i[6], e[7] = i[7], e[8] = i[8], e[9] = i[9], e[10] = i[10], e[11] = i[11], e[12] = i[12], e[13] = i[13], e[14] = i[14], e[15] = i[15], this;
      }
      copyPosition(t) {
        const e = this.elements, i = t.elements;
        return e[12] = i[12], e[13] = i[13], e[14] = i[14], this;
      }
      setFromMatrix3(t) {
        const e = t.elements;
        return this.set(e[0], e[3], e[6], 0, e[1], e[4], e[7], 0, e[2], e[5], e[8], 0, 0, 0, 0, 1), this;
      }
      extractBasis(t, e, i) {
        return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this;
      }
      makeBasis(t, e, i) {
        return this.set(t.x, e.x, i.x, 0, t.y, e.y, i.y, 0, t.z, e.z, i.z, 0, 0, 0, 0, 1), this;
      }
      extractRotation(t) {
        const e = this.elements, i = t.elements, n = 1 / Bt.setFromMatrixColumn(t, 0).length(), r = 1 / Bt.setFromMatrixColumn(t, 1).length(), o = 1 / Bt.setFromMatrixColumn(t, 2).length();
        return e[0] = i[0] * n, e[1] = i[1] * n, e[2] = i[2] * n, e[3] = 0, e[4] = i[4] * r, e[5] = i[5] * r, e[6] = i[6] * r, e[7] = 0, e[8] = i[8] * o, e[9] = i[9] * o, e[10] = i[10] * o, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this;
      }
      makeRotationFromEuler(t) {
        t && t.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
        const e = this.elements, i = t.x, n = t.y, r = t.z, o = Math.cos(i), s = Math.sin(i), a = Math.cos(n), l = Math.sin(n), c = Math.cos(r), h = Math.sin(r);
        if ("XYZ" === t.order) {
          const t = o * c, i = o * h, n = s * c, r = s * h;
          e[0] = a * c, e[4] = -a * h, e[8] = l, e[1] = i + n * l, e[5] = t - r * l, e[9] = -s * a, e[2] = r - t * l, e[6] = n + i * l, e[10] = o * a;
        } else if ("YXZ" === t.order) {
          const t = a * c, i = a * h, n = l * c, r = l * h;
          e[0] = t + r * s, e[4] = n * s - i, e[8] = o * l, e[1] = o * h, e[5] = o * c, e[9] = -s, e[2] = i * s - n, e[6] = r + t * s, e[10] = o * a;
        } else if ("ZXY" === t.order) {
          const t = a * c, i = a * h, n = l * c, r = l * h;
          e[0] = t - r * s, e[4] = -o * h, e[8] = n + i * s, e[1] = i + n * s, e[5] = o * c, e[9] = r - t * s, e[2] = -o * l, e[6] = s, e[10] = o * a;
        } else if ("ZYX" === t.order) {
          const t = o * c, i = o * h, n = s * c, r = s * h;
          e[0] = a * c, e[4] = n * l - i, e[8] = t * l + r, e[1] = a * h, e[5] = r * l + t, e[9] = i * l - n, e[2] = -l, e[6] = s * a, e[10] = o * a;
        } else if ("YZX" === t.order) {
          const t = o * a, i = o * l, n = s * a, r = s * l;
          e[0] = a * c, e[4] = r - t * h, e[8] = n * h + i, e[1] = h, e[5] = o * c, e[9] = -s * c, e[2] = -l * c, e[6] = i * h + n, e[10] = t - r * h;
        } else if ("XZY" === t.order) {
          const t = o * a, i = o * l, n = s * a, r = s * l;
          e[0] = a * c, e[4] = -h, e[8] = l * c, e[1] = t * h + r, e[5] = o * c, e[9] = i * h - n, e[2] = n * h - i, e[6] = s * c, e[10] = r * h + t;
        }
        return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this;
      }
      makeRotationFromQuaternion(t) {
        return this.compose(It, t, Vt);
      }
      lookAt(t, e, i) {
        const n = this.elements;
        return Nt.subVectors(t, e), 0 === Nt.lengthSq() && (Nt.z = 1), Nt.normalize(), Ft.crossVectors(i, Nt), 0 === Ft.lengthSq() && (1 === Math.abs(i.z) ? Nt.x += 0.0001 : Nt.z += 0.0001, Nt.normalize(), Ft.crossVectors(i, Nt)), Ft.normalize(), kt.crossVectors(Nt, Ft), n[0] = Ft.x, n[4] = kt.x, n[8] = Nt.x, n[1] = Ft.y, n[5] = kt.y, n[9] = Nt.y, n[2] = Ft.z, n[6] = kt.z, n[10] = Nt.z, this;
      }
      multiply(t, e) {
        return void 0 !== e ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t);
      }
      premultiply(t) {
        return this.multiplyMatrices(t, this);
      }
      multiplyMatrices(t, e) {
        const i = t.elements, n = e.elements, r = this.elements, o = i[0], s = i[4], a = i[8], l = i[12], c = i[1], h = i[5], u = i[9], p = i[13], m = i[2], d = i[6], _ = i[10], y = i[14], g = i[3], x = i[7], v = i[11], b = i[15], w = n[0], S = n[4], M = n[8], A = n[12], C = n[1], T = n[5], E = n[9], L = n[13], D = n[2], R = n[6], B = n[10], P = n[14], I = n[3], V = n[7], F = n[11], k = n[15];
        return r[0] = o * w + s * C + a * D + l * I, r[4] = o * S + s * T + a * R + l * V, r[8] = o * M + s * E + a * B + l * F, r[12] = o * A + s * L + a * P + l * k, r[1] = c * w + h * C + u * D + p * I, r[5] = c * S + h * T + u * R + p * V, r[9] = c * M + h * E + u * B + p * F, r[13] = c * A + h * L + u * P + p * k, r[2] = m * w + d * C + _ * D + y * I, r[6] = m * S + d * T + _ * R + y * V, r[10] = m * M + d * E + _ * B + y * F, r[14] = m * A + d * L + _ * P + y * k, r[3] = g * w + x * C + v * D + b * I, r[7] = g * S + x * T + v * R + b * V, r[11] = g * M + x * E + v * B + b * F, r[15] = g * A + x * L + v * P + b * k, this;
      }
      multiplyScalar(t) {
        const e = this.elements;
        return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this;
      }
      determinant() {
        const t = this.elements, e = t[0], i = t[4], n = t[8], r = t[12], o = t[1], s = t[5], a = t[9], l = t[13], c = t[2], h = t[6], u = t[10], p = t[14];
        return t[3] * (+r * a * h - n * l * h - r * s * u + i * l * u + n * s * p - i * a * p) + t[7] * (+e * a * p - e * l * u + r * o * u - n * o * p + n * l * c - r * a * c) + t[11] * (+e * l * h - e * s * p - r * o * h + i * o * p + r * s * c - i * l * c) + t[15] * (-n * s * c - e * a * h + e * s * u + n * o * h - i * o * u + i * a * c);
      }
      transpose() {
        const t = this.elements;
        let e;
        return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this;
      }
      setPosition(t, e, i) {
        const n = this.elements;
        return t.isVector3 ? (n[12] = t.x, n[13] = t.y, n[14] = t.z) : (n[12] = t, n[13] = e, n[14] = i), this;
      }
      invert() {
        const t = this.elements, e = t[0], i = t[1], n = t[2], r = t[3], o = t[4], s = t[5], a = t[6], l = t[7], c = t[8], h = t[9], u = t[10], p = t[11], m = t[12], d = t[13], _ = t[14], y = t[15], g = h * _ * l - d * u * l + d * a * p - s * _ * p - h * a * y + s * u * y, x = m * u * l - c * _ * l - m * a * p + o * _ * p + c * a * y - o * u * y, v = c * d * l - m * h * l + m * s * p - o * d * p - c * s * y + o * h * y, b = m * h * a - c * d * a - m * s * u + o * d * u + c * s * _ - o * h * _, w = e * g + i * x + n * v + r * b;
        if (0 === w) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        const S = 1 / w;
        return t[0] = g * S, t[1] = (d * u * r - h * _ * r - d * n * p + i * _ * p + h * n * y - i * u * y) * S, t[2] = (s * _ * r - d * a * r + d * n * l - i * _ * l - s * n * y + i * a * y) * S, t[3] = (h * a * r - s * u * r - h * n * l + i * u * l + s * n * p - i * a * p) * S, t[4] = x * S, t[5] = (c * _ * r - m * u * r + m * n * p - e * _ * p - c * n * y + e * u * y) * S, t[6] = (m * a * r - o * _ * r - m * n * l + e * _ * l + o * n * y - e * a * y) * S, t[7] = (o * u * r - c * a * r + c * n * l - e * u * l - o * n * p + e * a * p) * S, t[8] = v * S, t[9] = (m * h * r - c * d * r - m * i * p + e * d * p + c * i * y - e * h * y) * S, t[10] = (o * d * r - m * s * r + m * i * l - e * d * l - o * i * y + e * s * y) * S, t[11] = (c * s * r - o * h * r - c * i * l + e * h * l + o * i * p - e * s * p) * S, t[12] = b * S, t[13] = (c * d * n - m * h * n + m * i * u - e * d * u - c * i * _ + e * h * _) * S, t[14] = (m * s * n - o * d * n - m * i * a + e * d * a + o * i * _ - e * s * _) * S, t[15] = (o * h * n - c * s * n + c * i * a - e * h * a - o * i * u + e * s * u) * S, this;
      }
      scale(t) {
        const e = this.elements, i = t.x, n = t.y, r = t.z;
        return e[0] *= i, e[4] *= n, e[8] *= r, e[1] *= i, e[5] *= n, e[9] *= r, e[2] *= i, e[6] *= n, e[10] *= r, e[3] *= i, e[7] *= n, e[11] *= r, this;
      }
      getMaxScaleOnAxis() {
        const t = this.elements, e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2], i = t[4] * t[4] + t[5] * t[5] + t[6] * t[6], n = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
        return Math.sqrt(Math.max(e, i, n));
      }
      makeTranslation(t, e, i) {
        return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, i, 0, 0, 0, 1), this;
      }
      makeRotationX(t) {
        const e = Math.cos(t), i = Math.sin(t);
        return this.set(1, 0, 0, 0, 0, e, -i, 0, 0, i, e, 0, 0, 0, 0, 1), this;
      }
      makeRotationY(t) {
        const e = Math.cos(t), i = Math.sin(t);
        return this.set(e, 0, i, 0, 0, 1, 0, 0, -i, 0, e, 0, 0, 0, 0, 1), this;
      }
      makeRotationZ(t) {
        const e = Math.cos(t), i = Math.sin(t);
        return this.set(e, -i, 0, 0, i, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
      }
      makeRotationAxis(t, e) {
        const i = Math.cos(e), n = Math.sin(e), r = 1 - i, o = t.x, s = t.y, a = t.z, l = r * o, c = r * s;
        return this.set(l * o + i, l * s - n * a, l * a + n * s, 0, l * s + n * a, c * s + i, c * a - n * o, 0, l * a - n * s, c * a + n * o, r * a * a + i, 0, 0, 0, 0, 1), this;
      }
      makeScale(t, e, i) {
        return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this;
      }
      makeShear(t, e, i, n, r, o) {
        return this.set(1, i, r, 0, t, 1, o, 0, e, n, 1, 0, 0, 0, 0, 1), this;
      }
      compose(t, e, i) {
        const n = this.elements, r = e._x, o = e._y, s = e._z, a = e._w, l = r + r, c = o + o, h = s + s, u = r * l, p = r * c, m = r * h, d = o * c, _ = o * h, y = s * h, g = a * l, x = a * c, v = a * h, b = i.x, w = i.y, S = i.z;
        return n[0] = (1 - (d + y)) * b, n[1] = (p + v) * b, n[2] = (m - x) * b, n[3] = 0, n[4] = (p - v) * w, n[5] = (1 - (u + y)) * w, n[6] = (_ + g) * w, n[7] = 0, n[8] = (m + x) * S, n[9] = (_ - g) * S, n[10] = (1 - (u + d)) * S, n[11] = 0, n[12] = t.x, n[13] = t.y, n[14] = t.z, n[15] = 1, this;
      }
      decompose(t, e, i) {
        const n = this.elements;
        let r = Bt.set(n[0], n[1], n[2]).length();
        const o = Bt.set(n[4], n[5], n[6]).length(), s = Bt.set(n[8], n[9], n[10]).length();
        this.determinant() < 0 && (r = -r), t.x = n[12], t.y = n[13], t.z = n[14], Pt.copy(this);
        const a = 1 / r, l = 1 / o, c = 1 / s;
        return Pt.elements[0] *= a, Pt.elements[1] *= a, Pt.elements[2] *= a, Pt.elements[4] *= l, Pt.elements[5] *= l, Pt.elements[6] *= l, Pt.elements[8] *= c, Pt.elements[9] *= c, Pt.elements[10] *= c, e.setFromRotationMatrix(Pt), i.x = r, i.y = o, i.z = s, this;
      }
      makePerspective(t, e, i, n, r, o) {
        void 0 === o && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
        const s = this.elements, a = 2 * r / (e - t), l = 2 * r / (i - n), c = (e + t) / (e - t), h = (i + n) / (i - n), u = -(o + r) / (o - r), p = -2 * o * r / (o - r);
        return s[0] = a, s[4] = 0, s[8] = c, s[12] = 0, s[1] = 0, s[5] = l, s[9] = h, s[13] = 0, s[2] = 0, s[6] = 0, s[10] = u, s[14] = p, s[3] = 0, s[7] = 0, s[11] = -1, s[15] = 0, this;
      }
      makeOrthographic(t, e, i, n, r, o) {
        const s = this.elements, a = 1 / (e - t), l = 1 / (i - n), c = 1 / (o - r), h = (e + t) * a, u = (i + n) * l, p = (o + r) * c;
        return s[0] = 2 * a, s[4] = 0, s[8] = 0, s[12] = -h, s[1] = 0, s[5] = 2 * l, s[9] = 0, s[13] = -u, s[2] = 0, s[6] = 0, s[10] = -2 * c, s[14] = -p, s[3] = 0, s[7] = 0, s[11] = 0, s[15] = 1, this;
      }
      equals(t) {
        const e = this.elements, i = t.elements;
        for (let t = 0; t < 16; t++) if (e[t] !== i[t]) return false;
        return true;
      }
      fromArray(t, e = 0) {
        for (let i = 0; i < 16; i++) this.elements[i] = t[i + e];
        return this;
      }
      toArray(t = [], e = 0) {
        const i = this.elements;
        return t[e] = i[0], t[e + 1] = i[1], t[e + 2] = i[2], t[e + 3] = i[3], t[e + 4] = i[4], t[e + 5] = i[5], t[e + 6] = i[6], t[e + 7] = i[7], t[e + 8] = i[8], t[e + 9] = i[9], t[e + 10] = i[10], t[e + 11] = i[11], t[e + 12] = i[12], t[e + 13] = i[13], t[e + 14] = i[14], t[e + 15] = i[15], t;
      }
    }
    Matrix4.prototype.isMatrix4 = true;
    const Bt = new three_module_Vector3, Pt = new Matrix4, It = new three_module_Vector3(0, 0, 0), Vt = new three_module_Vector3(1, 1, 1), Ft = new three_module_Vector3, kt = new three_module_Vector3, Nt = new three_module_Vector3, Gt = new Matrix4, Ut = new Quaternion;
    class Euler {
      constructor(t = 0, e = 0, i = 0, n = Euler.DefaultOrder) {
        this._x = t, this._y = e, this._z = i, this._order = n;
      }
      get x() {
        return this._x;
      }
      set x (t) {
        this._x = t, this._onChangeCallback();
      }
      get y() {
        return this._y;
      }
      set y (t) {
        this._y = t, this._onChangeCallback();
      }
      get z() {
        return this._z;
      }
      set z (t) {
        this._z = t, this._onChangeCallback();
      }
      get order() {
        return this._order;
      }
      set order (t) {
        this._order = t, this._onChangeCallback();
      }
      set(t, e, i, n = this._order) {
        return this._x = t, this._y = e, this._z = i, this._order = n, this._onChangeCallback(), this;
      }
      clone() {
        return new this.constructor(this._x, this._y, this._z, this._order);
      }
      copy(t) {
        return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this._onChangeCallback(), this;
      }
      setFromRotationMatrix(t, e = this._order, i = true) {
        const n = t.elements, r = n[0], o = n[4], s = n[8], a = n[1], l = n[5], c = n[9], h = n[2], u = n[6], p = n[10];
        switch (e) {
          case "XYZ":
            this._y = Math.asin(Math.max(-1, Math.min(1, s))), Math.abs(s) < 0.9999999 ? (this._x = Math.atan2(-c, p), this._z = Math.atan2(-o, r)) : (this._x = Math.atan2(u, l), this._z = 0);
            break;
          case "YXZ":
            this._x = Math.asin(-Math.max(-1, Math.min(1, c))), Math.abs(c) < 0.9999999 ? (this._y = Math.atan2(s, p), this._z = Math.atan2(a, l)) : (this._y = Math.atan2(-h, r), this._z = 0);
            break;
          case "ZXY":
            this._x = Math.asin(Math.max(-1, Math.min(1, u))), Math.abs(u) < 0.9999999 ? (this._y = Math.atan2(-h, p), this._z = Math.atan2(-o, l)) : (this._y = 0, this._z = Math.atan2(a, r));
            break;
          case "ZYX":
            this._y = Math.asin(-Math.max(-1, Math.min(1, h))), Math.abs(h) < 0.9999999 ? (this._x = Math.atan2(u, p), this._z = Math.atan2(a, r)) : (this._x = 0, this._z = Math.atan2(-o, l));
            break;
          case "YZX":
            this._z = Math.asin(Math.max(-1, Math.min(1, a))), Math.abs(a) < 0.9999999 ? (this._x = Math.atan2(-c, l), this._y = Math.atan2(-h, r)) : (this._x = 0, this._y = Math.atan2(s, p));
            break;
          case "XZY":
            this._z = Math.asin(-Math.max(-1, Math.min(1, o))), Math.abs(o) < 0.9999999 ? (this._x = Math.atan2(u, l), this._y = Math.atan2(s, r)) : (this._x = Math.atan2(-c, p), this._y = 0);
            break;
          default:
            console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e);
        }
        return this._order = e, true === i && this._onChangeCallback(), this;
      }
      setFromQuaternion(t, e, i) {
        return Gt.makeRotationFromQuaternion(t), this.setFromRotationMatrix(Gt, e, i);
      }
      setFromVector3(t, e = this._order) {
        return this.set(t.x, t.y, t.z, e);
      }
      reorder(t) {
        return Ut.setFromEuler(this), this.setFromQuaternion(Ut, t);
      }
      equals(t) {
        return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order;
      }
      fromArray(t) {
        return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (this._order = t[3]), this._onChangeCallback(), this;
      }
      toArray(t = [], e = 0) {
        return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t;
      }
      toVector3(t) {
        return t ? t.set(this._x, this._y, this._z) : new three_module_Vector3(this._x, this._y, this._z);
      }
      _onChange(t) {
        return this._onChangeCallback = t, this;
      }
      _onChangeCallback() {}
    }
    Euler.prototype.isEuler = true, Euler.DefaultOrder = "XYZ", Euler.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
    class Layers {
      constructor() {
        this.mask = 1;
      }
      set(t) {
        this.mask = 1 << t | 0;
      }
      enable(t) {
        this.mask |= 1 << t | 0;
      }
      enableAll() {
        this.mask = -1;
      }
      toggle(t) {
        this.mask ^= 1 << t | 0;
      }
      disable(t) {
        this.mask &= ~(1 << t | 0);
      }
      disableAll() {
        this.mask = 0;
      }
      test(t) {
        return 0 != (this.mask & t.mask);
      }
    }
    let zt = 0;
    const Ot = new three_module_Vector3, Ht = new Quaternion, Wt = new Matrix4, Jt = new three_module_Vector3, jt = new three_module_Vector3, Xt = new three_module_Vector3, qt = new Quaternion, Yt = new three_module_Vector3(1, 0, 0), Zt = new three_module_Vector3(0, 1, 0), Kt = new three_module_Vector3(0, 0, 1), $t = {type: "added"}, Qt = {type: "removed"};
    class Object3D extends EventDispatcher {
      constructor() {
        super(), Object.defineProperty(this, "id", {value: zt++}), this.uuid = Z(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Object3D.DefaultUp.clone();
        const t = new three_module_Vector3, e = new Euler, i = new Quaternion, n = new three_module_Vector3(1, 1, 1);
        e._onChange(function () {
          i.setFromEuler(e, false);
        }), i._onChange(function () {
          e.setFromQuaternion(i, void 0, false);
        }), Object.defineProperties(this, {position: {configurable: true, enumerable: true, value: t}, rotation: {configurable: true, enumerable: true, value: e}, quaternion: {configurable: true, enumerable: true, value: i}, scale: {configurable: true, enumerable: true, value: n}, modelViewMatrix: {value: new Matrix4}, normalMatrix: {value: new Matrix3}}), this.matrix = new Matrix4, this.matrixWorld = new Matrix4, this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = false, this.layers = new Layers, this.visible = true, this.castShadow = false, this.receiveShadow = false, this.frustumCulled = true, this.renderOrder = 0, this.animations = [], this.userData = {};
      }
      onBeforeRender() {}
      onAfterRender() {}
      applyMatrix4(t) {
        this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale);
      }
      applyQuaternion(t) {
        return this.quaternion.premultiply(t), this;
      }
      setRotationFromAxisAngle(t, e) {
        this.quaternion.setFromAxisAngle(t, e);
      }
      setRotationFromEuler(t) {
        this.quaternion.setFromEuler(t, true);
      }
      setRotationFromMatrix(t) {
        this.quaternion.setFromRotationMatrix(t);
      }
      setRotationFromQuaternion(t) {
        this.quaternion.copy(t);
      }
      rotateOnAxis(t, e) {
        return Ht.setFromAxisAngle(t, e), this.quaternion.multiply(Ht), this;
      }
      rotateOnWorldAxis(t, e) {
        return Ht.setFromAxisAngle(t, e), this.quaternion.premultiply(Ht), this;
      }
      rotateX(t) {
        return this.rotateOnAxis(Yt, t);
      }
      rotateY(t) {
        return this.rotateOnAxis(Zt, t);
      }
      rotateZ(t) {
        return this.rotateOnAxis(Kt, t);
      }
      translateOnAxis(t, e) {
        return Ot.copy(t).applyQuaternion(this.quaternion), this.position.add(Ot.multiplyScalar(e)), this;
      }
      translateX(t) {
        return this.translateOnAxis(Yt, t);
      }
      translateY(t) {
        return this.translateOnAxis(Zt, t);
      }
      translateZ(t) {
        return this.translateOnAxis(Kt, t);
      }
      localToWorld(t) {
        return t.applyMatrix4(this.matrixWorld);
      }
      worldToLocal(t) {
        return t.applyMatrix4(Wt.copy(this.matrixWorld).invert());
      }
      lookAt(t, e, i) {
        t.isVector3 ? Jt.copy(t) : Jt.set(t, e, i);
        const n = this.parent;
        this.updateWorldMatrix(true, false), jt.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Wt.lookAt(jt, Jt, this.up) : Wt.lookAt(Jt, jt, this.up), this.quaternion.setFromRotationMatrix(Wt), n && (Wt.extractRotation(n.matrixWorld), Ht.setFromRotationMatrix(Wt), this.quaternion.premultiply(Ht.invert()));
      }
      add(t) {
        if (arguments.length > 1) {
          for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
          return this;
        }
        return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (null !== t.parent && t.parent.remove(t), t.parent = this, this.children.push(t), t.dispatchEvent($t)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this);
      }
      remove(t) {
        if (arguments.length > 1) {
          for (let t = 0; t < arguments.length; t++) this.remove(arguments[t]);
          return this;
        }
        const e = this.children.indexOf(t);
        return -1 !== e && (t.parent = null, this.children.splice(e, 1), t.dispatchEvent(Qt)), this;
      }
      removeFromParent() {
        const t = this.parent;
        return null !== t && t.remove(this), this;
      }
      clear() {
        for (let t = 0; t < this.children.length; t++) {
          const e = this.children[t];
          e.parent = null, e.dispatchEvent(Qt);
        }
        return this.children.length = 0, this;
      }
      attach(t) {
        return this.updateWorldMatrix(true, false), Wt.copy(this.matrixWorld).invert(), null !== t.parent && (t.parent.updateWorldMatrix(true, false), Wt.multiply(t.parent.matrixWorld)), t.applyMatrix4(Wt), this.add(t), t.updateWorldMatrix(false, true), this;
      }
      getObjectById(t) {
        return this.getObjectByProperty("id", t);
      }
      getObjectByName(t) {
        return this.getObjectByProperty("name", t);
      }
      getObjectByProperty(t, e) {
        if (this[t] === e) return this;
        for (let i = 0, n = this.children.length; i < n; i++) {
          const n = this.children[i].getObjectByProperty(t, e);
          if (void 0 !== n) return n;
        }
      }
      getWorldPosition(t) {
        return this.updateWorldMatrix(true, false), t.setFromMatrixPosition(this.matrixWorld);
      }
      getWorldQuaternion(t) {
        return this.updateWorldMatrix(true, false), this.matrixWorld.decompose(jt, t, Xt), t;
      }
      getWorldScale(t) {
        return this.updateWorldMatrix(true, false), this.matrixWorld.decompose(jt, qt, t), t;
      }
      getWorldDirection(t) {
        this.updateWorldMatrix(true, false);
        const e = this.matrixWorld.elements;
        return t.set(e[8], e[9], e[10]).normalize();
      }
      raycast() {}
      traverse(t) {
        t(this);
        const e = this.children;
        for (let i = 0, n = e.length; i < n; i++) e[i].traverse(t);
      }
      traverseVisible(t) {
        if (false === this.visible) return;
        t(this);
        const e = this.children;
        for (let i = 0, n = e.length; i < n; i++) e[i].traverseVisible(t);
      }
      traverseAncestors(t) {
        const e = this.parent;
        null !== e && (t(e), e.traverseAncestors(t));
      }
      updateMatrix() {
        this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = true;
      }
      updateMatrixWorld(t) {
        this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = false, t = true);
        const e = this.children;
        for (let i = 0, n = e.length; i < n; i++) e[i].updateMatrixWorld(t);
      }
      updateWorldMatrix(t, e) {
        const i = this.parent;
        if (true === t && null !== i && i.updateWorldMatrix(true, false), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), true === e) {
          const t = this.children;
          for (let e = 0, i = t.length; e < i; e++) t[e].updateWorldMatrix(false, true);
        }
      }
      toJSON(t) {
        const e = void 0 === t || "string" == typeof t, i = {};
        e && (t = {geometries: {}, materials: {}, textures: {}, images: {}, shapes: {}, skeletons: {}, animations: {}}, i.metadata = {version: 4.5, type: "Object", generator: "Object3D.toJSON"});
        const n = {};
        if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), true === this.castShadow && (n.castShadow = true), true === this.receiveShadow && (n.receiveShadow = true), false === this.visible && (n.visible = false), false === this.frustumCulled && (n.frustumCulled = false), 0 !== this.renderOrder && (n.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), n.layers = this.layers.mask, n.matrix = this.matrix.toArray(), false === this.matrixAutoUpdate && (n.matrixAutoUpdate = false), this.isInstancedMesh && (n.type = "InstancedMesh", n.count = this.count, n.instanceMatrix = this.instanceMatrix.toJSON(), null !== this.instanceColor && (n.instanceColor = this.instanceColor.toJSON())), this.isScene) this.background && (this.background.isColor ? n.background = this.background.toJSON() : this.background.isTexture && (n.background = this.background.toJSON(t).uuid)), this.environment && this.environment.isTexture && (n.environment = this.environment.toJSON(t).uuid); else if (this.isMesh || this.isLine || this.isPoints) {
          n.geometry = (void 0 === t.geometries[this.geometry.uuid] && (t.geometries[this.geometry.uuid] = this.geometry.toJSON(t)), this.geometry.uuid);
          const e = this.geometry.parameters;
          if (void 0 !== e && void 0 !== e.shapes) {
            const i = e.shapes;
            if (Array.isArray(i)) for (let e = 0, n = i.length; e < n; e++) {
              const n = i[e];
              void 0 === t.shapes[n.uuid] && (t.shapes[n.uuid] = n.toJSON(t)), n.uuid;
            } else void 0 === t.shapes[i.uuid] && (t.shapes[i.uuid] = i.toJSON(t)), i.uuid;
          }
        }
        if (this.isSkinnedMesh && (n.bindMode = this.bindMode, n.bindMatrix = this.bindMatrix.toArray(), void 0 !== this.skeleton && (void 0 === t.skeletons[this.skeleton.uuid] && (t.skeletons[this.skeleton.uuid] = this.skeleton.toJSON(t)), this.skeleton.uuid, n.skeleton = this.skeleton.uuid)), void 0 !== this.material) if (Array.isArray(this.material)) {
          const e = [];
          for (let i = 0, n = this.material.length; i < n; i++) e.push((void 0 === t.materials[this.material[i].uuid] && (t.materials[this.material[i].uuid] = this.material[i].toJSON(t)), this.material[i].uuid));
          n.material = e;
        } else n.material = (void 0 === t.materials[this.material.uuid] && (t.materials[this.material.uuid] = this.material.toJSON(t)), this.material.uuid);
        if (this.children.length > 0) {
          n.children = [];
          for (let e = 0; e < this.children.length; e++) n.children.push(this.children[e].toJSON(t).object);
        }
        if (this.animations.length > 0) {
          n.animations = [];
          for (let e = 0; e < this.animations.length; e++) {
            const i = this.animations[e];
            n.animations.push((void 0 === t.animations[i.uuid] && (t.animations[i.uuid] = i.toJSON(t)), i.uuid));
          }
        }
        if (e) {
          const e = o(t.geometries), n = o(t.materials), r = o(t.textures), s = o(t.images), a = o(t.shapes), l = o(t.skeletons), c = o(t.animations);
          e.length > 0 && (i.geometries = e), n.length > 0 && (i.materials = n), r.length > 0 && (i.textures = r), s.length > 0 && (i.images = s), a.length > 0 && (i.shapes = a), l.length > 0 && (i.skeletons = l), c.length > 0 && (i.animations = c);
        }
        return i.object = n, i;
        function o(t) {
          const e = [];
          for (const i in t) {
            const n = t[i];
            delete n.metadata, e.push(n);
          }
          return e;
        }
      }
      clone(t) {
        return (new this.constructor).copy(this, t);
      }
      copy(t, e = true) {
        if (this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.rotation.order = t.rotation.order, this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.userData = JSON.parse(JSON.stringify(t.userData)), true === e) for (let e = 0; e < t.children.length; e++) {
          const i = t.children[e];
          this.add(i.clone());
        }
        return this;
      }
    }
    Object3D.DefaultUp = new three_module_Vector3(0, 1, 0), Object3D.DefaultMatrixAutoUpdate = true, Object3D.prototype.isObject3D = true;
    const te = new three_module_Vector3, ee = new three_module_Vector3, ie = new three_module_Vector3, ne = new three_module_Vector3, re = new three_module_Vector3, oe = new three_module_Vector3, se = new three_module_Vector3, ae = new three_module_Vector3, le = new three_module_Vector3, ce = new three_module_Vector3;
    class Triangle {
      constructor(t = new three_module_Vector3, e = new three_module_Vector3, i = new three_module_Vector3) {
        this.a = t, this.b = e, this.c = i;
      }
      static getNormal(t, e, i, n) {
        n.subVectors(i, e), te.subVectors(t, e), n.cross(te);
        const r = n.lengthSq();
        return r > 0 ? n.multiplyScalar(1 / Math.sqrt(r)) : n.set(0, 0, 0);
      }
      static getBarycoord(t, e, i, n, r) {
        te.subVectors(n, e), ee.subVectors(i, e), ie.subVectors(t, e);
        const o = te.dot(te), s = te.dot(ee), a = te.dot(ie), l = ee.dot(ee), c = ee.dot(ie), h = o * l - s * s;
        if (0 === h) return r.set(-2, -1, -1);
        const u = 1 / h, p = (l * a - s * c) * u, m = (o * c - s * a) * u;
        return r.set(1 - p - m, m, p);
      }
      static containsPoint(t, e, i, n) {
        return this.getBarycoord(t, e, i, n, ne), ne.x >= 0 && ne.y >= 0 && ne.x + ne.y <= 1;
      }
      static getUV(t, e, i, n, r, o, s, a) {
        return this.getBarycoord(t, e, i, n, ne), a.set(0, 0), a.addScaledVector(r, ne.x), a.addScaledVector(o, ne.y), a.addScaledVector(s, ne.z), a;
      }
      static isFrontFacing(t, e, i, n) {
        return te.subVectors(i, e), ee.subVectors(t, e), te.cross(ee).dot(n) < 0;
      }
      set(t, e, i) {
        return this.a.copy(t), this.b.copy(e), this.c.copy(i), this;
      }
      setFromPointsAndIndices(t, e, i, n) {
        return this.a.copy(t[e]), this.b.copy(t[i]), this.c.copy(t[n]), this;
      }
      clone() {
        return (new this.constructor).copy(this);
      }
      copy(t) {
        return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this;
      }
      getArea() {
        return te.subVectors(this.c, this.b), ee.subVectors(this.a, this.b), 0.5 * te.cross(ee).length();
      }
      getMidpoint(t) {
        return t.addVectors(this.a, this.b).add(this.c).multiplyScalar(0.3333333333333333);
      }
      getNormal(t) {
        return Triangle.getNormal(this.a, this.b, this.c, t);
      }
      getPlane(t) {
        return t.setFromCoplanarPoints(this.a, this.b, this.c);
      }
      getBarycoord(t, e) {
        return Triangle.getBarycoord(t, this.a, this.b, this.c, e);
      }
      getUV(t, e, i, n, r) {
        return Triangle.getUV(t, this.a, this.b, this.c, e, i, n, r);
      }
      containsPoint(t) {
        return Triangle.containsPoint(t, this.a, this.b, this.c);
      }
      isFrontFacing(t) {
        return Triangle.isFrontFacing(this.a, this.b, this.c, t);
      }
      intersectsBox(t) {
        return t.intersectsTriangle(this);
      }
      closestPointToPoint(t, e) {
        const i = this.a, n = this.b, r = this.c;
        let o, s;
        re.subVectors(n, i), oe.subVectors(r, i), ae.subVectors(t, i);
        const a = re.dot(ae), l = oe.dot(ae);
        if (a <= 0 && l <= 0) return e.copy(i);
        le.subVectors(t, n);
        const c = re.dot(le), h = oe.dot(le);
        if (c >= 0 && h <= c) return e.copy(n);
        const u = a * h - c * l;
        if (u <= 0 && a >= 0 && c <= 0) return o = a / (a - c), e.copy(i).addScaledVector(re, o);
        ce.subVectors(t, r);
        const p = re.dot(ce), m = oe.dot(ce);
        if (m >= 0 && p <= m) return e.copy(r);
        const d = p * l - a * m;
        if (d <= 0 && l >= 0 && m <= 0) return s = l / (l - m), e.copy(i).addScaledVector(oe, s);
        const _ = c * m - p * h;
        if (_ <= 0 && h - c >= 0 && p - m >= 0) return se.subVectors(r, n), s = (h - c) / (h - c + (p - m)), e.copy(n).addScaledVector(se, s);
        const y = 1 / (_ + d + u);
        return o = d * y, s = u * y, e.copy(i).addScaledVector(re, o).addScaledVector(oe, s);
      }
      equals(t) {
        return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c);
      }
    }
    let he = 0;
    var ue = "__private_" + i++ + "_" + "alphaTest";
    class Material extends EventDispatcher {
      constructor() {
        super(), Object.defineProperty(this, ue, {writable: true, value: 0}), Object.defineProperty(this, "id", {value: he++}), this.uuid = Z(), this.name = "", this.type = "Material", this.fog = true, this.blending = 1, this.side = 0, this.vertexColors = false, this.opacity = 1, this.format = E, this.transparent = false, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = o, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = 3, this.depthTest = true, this.depthWrite = true, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = O, this.stencilZFail = O, this.stencilZPass = O, this.stencilWrite = false, this.clippingPlanes = null, this.clipIntersection = false, this.clipShadows = false, this.shadowSide = null, this.colorWrite = true, this.precision = null, this.polygonOffset = false, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = false, this.alphaToCoverage = false, this.premultipliedAlpha = false, this.visible = true, this.toneMapped = true, this.userData = {}, this.version = 0;
      }
      get alphaTest() {
        return e(this, ue)[ue];
      }
      set alphaTest (t) {
        e(this, ue)[ue] > 0 != t > 0 && this.version++, e(this, ue)[ue] = t;
      }
      onBuild() {}
      onBeforeCompile() {}
      customProgramCacheKey() {
        return this.onBeforeCompile.toString();
      }
      setValues(t) {
        if (void 0 !== t) for (const e in t) {
          const i = t[e];
          if (void 0 === i) {
            console.warn("THREE.Material: '" + e + "' parameter is undefined.");
            continue;
          }
          if ("shading" === e) {
            console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === i;
            continue;
          }
          const n = this[e];
          void 0 !== n ? n && n.isColor ? n.set(i) : n && n.isVector3 && i && i.isVector3 ? n.copy(i) : this[e] = i : console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material.");
        }
      }
      toJSON(t) {
        const e = void 0 === t || "string" == typeof t;
        e && (t = {textures: {}, images: {}});
        const i = {metadata: {version: 4.5, type: "Material", generator: "Material.toJSON"}};
        function n(t) {
          const e = [];
          for (const i in t) {
            const n = t[i];
            delete n.metadata, e.push(n);
          }
          return e;
        }
        if (i.uuid = this.uuid, i.type = this.type, "" !== this.name && (i.name = this.name), this.color && this.color.isColor && (i.color = this.color.getHex()), void 0 !== this.roughness && (i.roughness = this.roughness), void 0 !== this.metalness && (i.metalness = this.metalness), this.sheenTint && this.sheenTint.isColor && (i.sheenTint = this.sheenTint.getHex()), this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (i.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (i.specular = this.specular.getHex()), void 0 !== this.specularIntensity && (i.specularIntensity = this.specularIntensity), this.specularTint && this.specularTint.isColor && (i.specularTint = this.specularTint.getHex()), void 0 !== this.shininess && (i.shininess = this.shininess), void 0 !== this.clearcoat && (i.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (i.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (i.clearcoatMap = this.clearcoatMap.toJSON(t).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid, i.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (i.map = this.map.toJSON(t).uuid), this.matcap && this.matcap.isTexture && (i.matcap = this.matcap.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(t).uuid, i.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (i.aoMap = this.aoMap.toJSON(t).uuid, i.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(t).uuid, i.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(t).uuid, i.normalMapType = this.normalMapType, i.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(t).uuid, i.displacementScale = this.displacementScale, i.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(t).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (i.specularIntensityMap = this.specularIntensityMap.toJSON(t).uuid), this.specularTintMap && this.specularTintMap.isTexture && (i.specularTintMap = this.specularTintMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(t).uuid, void 0 !== this.combine && (i.combine = this.combine)), void 0 !== this.envMapIntensity && (i.envMapIntensity = this.envMapIntensity), void 0 !== this.reflectivity && (i.reflectivity = this.reflectivity), void 0 !== this.refractionRatio && (i.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(t).uuid), void 0 !== this.transmission && (i.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (i.transmissionMap = this.transmissionMap.toJSON(t).uuid), void 0 !== this.thickness && (i.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (i.thicknessMap = this.thicknessMap.toJSON(t).uuid), void 0 !== this.attenuationDistance && (i.attenuationDistance = this.attenuationDistance), void 0 !== this.attenuationTint && (i.attenuationTint = this.attenuationTint.getHex()), void 0 !== this.size && (i.size = this.size), null !== this.shadowSide && (i.shadowSide = this.shadowSide), void 0 !== this.sizeAttenuation && (i.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (i.blending = this.blending), 0 !== this.side && (i.side = this.side), this.vertexColors && (i.vertexColors = true), this.opacity < 1 && (i.opacity = this.opacity), this.format !== E && (i.format = this.format), true === this.transparent && (i.transparent = this.transparent), i.depthFunc = this.depthFunc, i.depthTest = this.depthTest, i.depthWrite = this.depthWrite, i.colorWrite = this.colorWrite, i.stencilWrite = this.stencilWrite, i.stencilWriteMask = this.stencilWriteMask, i.stencilFunc = this.stencilFunc, i.stencilRef = this.stencilRef, i.stencilFuncMask = this.stencilFuncMask, i.stencilFail = this.stencilFail, i.stencilZFail = this.stencilZFail, i.stencilZPass = this.stencilZPass, this.rotation && 0 !== this.rotation && (i.rotation = this.rotation), true === this.polygonOffset && (i.polygonOffset = true), 0 !== this.polygonOffsetFactor && (i.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (i.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && 1 !== this.linewidth && (i.linewidth = this.linewidth), void 0 !== this.dashSize && (i.dashSize = this.dashSize), void 0 !== this.gapSize && (i.gapSize = this.gapSize), void 0 !== this.scale && (i.scale = this.scale), true === this.dithering && (i.dithering = true), this.alphaTest > 0 && (i.alphaTest = this.alphaTest), true === this.alphaToCoverage && (i.alphaToCoverage = this.alphaToCoverage), true === this.premultipliedAlpha && (i.premultipliedAlpha = this.premultipliedAlpha), true === this.wireframe && (i.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (i.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (i.wireframeLinejoin = this.wireframeLinejoin), true === this.flatShading && (i.flatShading = this.flatShading), false === this.visible && (i.visible = false), false === this.toneMapped && (i.toneMapped = false), "{}" !== JSON.stringify(this.userData) && (i.userData = this.userData), e) {
          const e = "__private_" + i++ + "_" + t.textures, r = "__private_" + i++ + "_" + t.images;
          e.length > 0 && (i.textures = e), r.length > 0 && (i.images = r);
        }
        return i;
      }
      clone() {
        return (new this.constructor).copy(this);
      }
      copy(t) {
        this.name = t.name, this.fog = t.fog, this.blending = t.blending, this.side = t.side, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.format = t.format, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.stencilWriteMask = t.stencilWriteMask, this.stencilFunc = t.stencilFunc, this.stencilRef = t.stencilRef, this.stencilFuncMask = t.stencilFuncMask, this.stencilFail = t.stencilFail, this.stencilZFail = t.stencilZFail, this.stencilZPass = t.stencilZPass, this.stencilWrite = t.stencilWrite;
        const e = t.clippingPlanes;
        let i = null;
        if (null !== e) {
          const t = e.length;
          i = new Array(t);
          for (let n = 0; n !== t; ++n) i[n] = e[n].clone();
        }
        return this.clippingPlanes = i, this.clipIntersection = t.clipIntersection, this.clipShadows = t.clipShadows, this.shadowSide = t.shadowSide, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.alphaToCoverage = t.alphaToCoverage, this.premultipliedAlpha = t.premultipliedAlpha, this.visible = t.visible, this.toneMapped = t.toneMapped, this.userData = JSON.parse(JSON.stringify(t.userData)), this;
      }
      dispose() {
        this.dispatchEvent({type: "dispose"});
      }
      set needsUpdate (t) {
        true === t && this.version++;
      }
    }
    Material.prototype.isMaterial = true;
    const pe = {aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074}, me = {h: 0, s: 0, l: 0}, de = {h: 0, s: 0, l: 0};
    function _e(t) {
      return t < 0.04045 ? 0.0773993808 * t : Math.pow(0.9478672986 * t + 0.0521327014, 2.4);
    }
    function ye(t) {
      return t < 0.0031308 ? 12.92 * t : 1.055 * Math.pow(t, 0.41666) - 0.055;
    }
    class three_module_Color {
      constructor(t, e, i) {
        return void 0 === e && void 0 === i ? this.set(t) : this.setRGB(t, e, i);
      }
      set(t) {
        return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t), this;
      }
      setScalar(t) {
        return this.r = t, this.g = t, this.b = t, this;
      }
      setHex(t) {
        return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (255 & t) / 255, this;
      }
      setRGB(t, e, i) {
        return this.r = t, this.g = e, this.b = i, this;
      }
      setHSL(t, e, i) {
        if (t = (t % 1 + 1) % 1, e = Math.max(0, Math.min(1, e)), i = Math.max(0, Math.min(1, i)), 0 === e) this.r = this.g = this.b = i; else {
          const n = i <= 0.5 ? i * (1 + e) : i + e - i * e, r = 2 * i - n;
          this.r = (t + 0.3333333333333333 < 0 && (t + 0.3333333333333333 += 1), t + 0.3333333333333333 > 1 && (t + 0.3333333333333333 -= 1), t + 0.3333333333333333 < 0.16666666666666666 ? r + 6 * (n - r) * (t + 0.3333333333333333) : t + 0.3333333333333333 < 0.5 ? n : t + 0.3333333333333333 < 0.6666666666666666 ? r + 6 * (n - r) * (0.6666666666666666 - (t + 0.3333333333333333)) : r), this.g = (t < 0 && (t += 1), t > 1 && (t -= 1), t < 0.16666666666666666 ? r + 6 * (n - r) * t : t < 0.5 ? n : t < 0.6666666666666666 ? r + 6 * (n - r) * (0.6666666666666666 - t) : r), this.b = (t - 0.3333333333333333 < 0 && (t - 0.3333333333333333 += 1), t - 0.3333333333333333 > 1 && (t - 0.3333333333333333 -= 1), t - 0.3333333333333333 < 0.16666666666666666 ? r + 6 * (n - r) * (t - 0.3333333333333333) : t - 0.3333333333333333 < 0.5 ? n : t - 0.3333333333333333 < 0.6666666666666666 ? r + 6 * (n - r) * (0.6666666666666666 - (t - 0.3333333333333333)) : r);
        }
        return this;
      }
      setStyle(t) {
        function e(e) {
          void 0 !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.");
        }
        let i;
        if (i = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t)) {
          let t;
          const n = i[1], r = i[2];
          switch (n) {
            case "rgb":
            case "rgba":
              if (t = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r)) return this.r = Math.min(255, parseInt(t[1], 10)) / 255, this.g = Math.min(255, parseInt(t[2], 10)) / 255, this.b = Math.min(255, parseInt(t[3], 10)) / 255, e(t[4]), this;
              if (t = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r)) return this.r = Math.min(100, parseInt(t[1], 10)) / 100, this.g = Math.min(100, parseInt(t[2], 10)) / 100, this.b = Math.min(100, parseInt(t[3], 10)) / 100, e(t[4]), this;
              break;
            case "hsl":
            case "hsla":
              if (t = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r)) {
                const i = parseFloat(t[1]) / 360, n = parseInt(t[2], 10) / 100, r = parseInt(t[3], 10) / 100;
                return e(t[4]), this.setHSL(i, n, r);
              }
          }
        } else if (i = /^\#([A-Fa-f\d]+)$/.exec(t)) {
          const t = i[1], e = t.length;
          if (3 === e) return this.r = parseInt(t.charAt(0) + t.charAt(0), 16) / 255, this.g = parseInt(t.charAt(1) + t.charAt(1), 16) / 255, this.b = parseInt(t.charAt(2) + t.charAt(2), 16) / 255, this;
          if (6 === e) return this.r = parseInt(t.charAt(0) + t.charAt(1), 16) / 255, this.g = parseInt(t.charAt(2) + t.charAt(3), 16) / 255, this.b = parseInt(t.charAt(4) + t.charAt(5), 16) / 255, this;
        }
        return t && t.length > 0 ? this.setColorName(t) : this;
      }
      setColorName(t) {
        const e = pe[t.toLowerCase()];
        return void 0 !== e ? this.setHex(e) : console.warn("THREE.Color: Unknown color " + t), this;
      }
      clone() {
        return new this.constructor(this.r, this.g, this.b);
      }
      copy(t) {
        return this.r = t.r, this.g = t.g, this.b = t.b, this;
      }
      copyGammaToLinear(t, e = 2) {
        return this.r = Math.pow(t.r, e), this.g = Math.pow(t.g, e), this.b = Math.pow(t.b, e), this;
      }
      copyLinearToGamma(t, e = 2) {
        const i = e > 0 ? 1 / e : 1;
        return this.r = Math.pow(t.r, i), this.g = Math.pow(t.g, i), this.b = Math.pow(t.b, i), this;
      }
      convertGammaToLinear(t) {
        return this.copyGammaToLinear(this, t), this;
      }
      convertLinearToGamma(t) {
        return this.copyLinearToGamma(this, t), this;
      }
      copySRGBToLinear(t) {
        return this.r = _e(t.r), this.g = _e(t.g), this.b = _e(t.b), this;
      }
      copyLinearToSRGB(t) {
        return this.r = ye(t.r), this.g = ye(t.g), this.b = ye(t.b), this;
      }
      convertSRGBToLinear() {
        return this.copySRGBToLinear(this), this;
      }
      convertLinearToSRGB() {
        return this.copyLinearToSRGB(this), this;
      }
      getHex() {
        return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0;
      }
      getHexString() {
        return ("000000" + this.getHex().toString(16)).slice(-6);
      }
      getHSL(t) {
        const e = this.r, i = this.g, n = this.b, r = Math.max(e, i, n), o = Math.min(e, i, n);
        let s, a;
        const l = (o + r) / 2;
        if (o === r) s = 0, a = 0; else {
          const t = r - o;
          switch (a = l <= 0.5 ? t / (r + o) : t / (2 - r - o), r) {
            case e:
              s = (i - n) / t + (i < n ? 6 : 0);
              break;
            case i:
              s = (n - e) / t + 2;
              break;
            case n:
              s = (e - i) / t + 4;
          }
          s /= 6;
        }
        return t.h = s, t.s = a, t.l = l, t;
      }
      getStyle() {
        return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")";
      }
      offsetHSL(t, e, i) {
        return this.getHSL(me), me.h += t, me.s += e, me.l += i, this.setHSL(me.h, me.s, me.l), this;
      }
      add(t) {
        return this.r += t.r, this.g += t.g, this.b += t.b, this;
      }
      addColors(t, e) {
        return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this;
      }
      addScalar(t) {
        return this.r += t, this.g += t, this.b += t, this;
      }
      sub(t) {
        return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this;
      }
      multiply(t) {
        return this.r *= t.r, this.g *= t.g, this.b *= t.b, this;
      }
      multiplyScalar(t) {
        return this.r *= t, this.g *= t, this.b *= t, this;
      }
      lerp(t, e) {
        return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this;
      }
      lerpColors(t, e, i) {
        return this.r = t.r + (e.r - t.r) * i, this.g = t.g + (e.g - t.g) * i, this.b = t.b + (e.b - t.b) * i, this;
      }
      lerpHSL(t, e) {
        this.getHSL(me), t.getHSL(de);
        const i = (1 - e) * me.h + e * de.h, n = (1 - e) * me.s + e * de.s, r = (1 - e) * me.l + e * de.l;
        return this.setHSL(i, n, r), this;
      }
      equals(t) {
        return t.r === this.r && t.g === this.g && t.b === this.b;
      }
      fromArray(t, e = 0) {
        return this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this;
      }
      toArray(t = [], e = 0) {
        return t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t;
      }
      fromBufferAttribute(t, e) {
        return this.r = t.getX(e), this.g = t.getY(e), this.b = t.getZ(e), true === t.normalized && (this.r /= 255, this.g /= 255, this.b /= 255), this;
      }
      toJSON() {
        return this.getHex();
      }
    }
    three_module_Color.NAMES = pe, three_module_Color.prototype.isColor = true, three_module_Color.prototype.r = 1, three_module_Color.prototype.g = 1, three_module_Color.prototype.b = 1;
    class MeshBasicMaterial extends Material {
      constructor(t) {
        super(), this.type = "MeshBasicMaterial", this.color = new three_module_Color(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(t);
      }
      copy(t) {
        return super.copy(t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this;
      }
    }
    MeshBasicMaterial.prototype.isMeshBasicMaterial = true;
    const ge = new three_module_Vector3, xe = new Vector2;
    class BufferAttribute {
      constructor(t, e, i) {
        if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.name = "", this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e : 0, this.normalized = true === i, this.usage = H, this.updateRange = {offset: 0, count: -1}, this.version = 0;
      }
      onUploadCallback() {}
      set needsUpdate (t) {
        true === t && this.version++;
      }
      setUsage(t) {
        return this.usage = t, this;
      }
      copy(t) {
        return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.usage = t.usage, this;
      }
      copyAt(t, e, i) {
        t *= this.itemSize, i *= e.itemSize;
        for (let n = 0, r = this.itemSize; n < r; n++) this.array[t + n] = e.array[i + n];
        return this;
      }
      copyArray(t) {
        return this.array.set(t), this;
      }
      copyColorsArray(t) {
        const e = this.array;
        let i = 0;
        for (let n = 0, r = t.length; n < r; n++) {
          let r = t[n];
          void 0 === r && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", n), r = new three_module_Color), e[i++] = r.r, e[i++] = r.g, e[i++] = r.b;
        }
        return this;
      }
      copyVector2sArray(t) {
        const e = this.array;
        let i = 0;
        for (let n = 0, r = t.length; n < r; n++) {
          let r = t[n];
          void 0 === r && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", n), r = new Vector2), e[i++] = r.x, e[i++] = r.y;
        }
        return this;
      }
      copyVector3sArray(t) {
        const e = this.array;
        let i = 0;
        for (let n = 0, r = t.length; n < r; n++) {
          let r = t[n];
          void 0 === r && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", n), r = new three_module_Vector3), e[i++] = r.x, e[i++] = r.y, e[i++] = r.z;
        }
        return this;
      }
      copyVector4sArray(t) {
        const e = this.array;
        let i = 0;
        for (let n = 0, r = t.length; n < r; n++) {
          let r = t[n];
          void 0 === r && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", n), r = new Vector4), e[i++] = r.x, e[i++] = r.y, e[i++] = r.z, e[i++] = r.w;
        }
        return this;
      }
      applyMatrix3(t) {
        if (2 === this.itemSize) for (let e = 0, i = this.count; e < i; e++) xe.fromBufferAttribute(this, e), xe.applyMatrix3(t), this.setXY(e, xe.x, xe.y); else if (3 === this.itemSize) for (let e = 0, i = this.count; e < i; e++) ge.fromBufferAttribute(this, e), ge.applyMatrix3(t), this.setXYZ(e, ge.x, ge.y, ge.z);
        return this;
      }
      applyMatrix4(t) {
        for (let e = 0, i = this.count; e < i; e++) ge.x = this.getX(e), ge.y = this.getY(e), ge.z = this.getZ(e), ge.applyMatrix4(t), this.setXYZ(e, ge.x, ge.y, ge.z);
        return this;
      }
      applyNormalMatrix(t) {
        for (let e = 0, i = this.count; e < i; e++) ge.x = this.getX(e), ge.y = this.getY(e), ge.z = this.getZ(e), ge.applyNormalMatrix(t), this.setXYZ(e, ge.x, ge.y, ge.z);
        return this;
      }
      transformDirection(t) {
        for (let e = 0, i = this.count; e < i; e++) ge.x = this.getX(e), ge.y = this.getY(e), ge.z = this.getZ(e), ge.transformDirection(t), this.setXYZ(e, ge.x, ge.y, ge.z);
        return this;
      }
      set(t, e = 0) {
        return this.array.set(t, e), this;
      }
      getX(t) {
        return this.array[t * this.itemSize];
      }
      setX(t, e) {
        return this.array[t * this.itemSize] = e, this;
      }
      getY(t) {
        return this.array[t * this.itemSize + 1];
      }
      setY(t, e) {
        return this.array[t * this.itemSize + 1] = e, this;
      }
      getZ(t) {
        return this.array[t * this.itemSize + 2];
      }
      setZ(t, e) {
        return this.array[t * this.itemSize + 2] = e, this;
      }
      getW(t) {
        return this.array[t * this.itemSize + 3];
      }
      setW(t, e) {
        return this.array[t * this.itemSize + 3] = e, this;
      }
      setXY(t, e, i) {
        return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this;
      }
      setXYZ(t, e, i, n) {
        return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this.array[t + 2] = n, this;
      }
      setXYZW(t, e, i, n, r) {
        return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this.array[t + 2] = n, this.array[t + 3] = r, this;
      }
      onUpload(t) {
        return this.onUploadCallback = t, this;
      }
      clone() {
        return new this.constructor(this.array, this.itemSize).copy(this);
      }
      toJSON() {
        const t = {itemSize: this.itemSize, type: this.array.constructor.name, array: Array.prototype.slice.call(this.array), normalized: this.normalized};
        return "" !== this.name && (t.name = this.name), this.usage !== H && (t.usage = this.usage), 0 === this.updateRange.offset && -1 === this.updateRange.count || (t.updateRange = this.updateRange), t;
      }
    }
    BufferAttribute.prototype.isBufferAttribute = true;
    class Uint16BufferAttribute extends BufferAttribute {
      constructor(t, e, i) {
        super(new Uint16Array(t), e, i);
      }
    }
    class Uint32BufferAttribute extends BufferAttribute {
      constructor(t, e, i) {
        super(new Uint32Array(t), e, i);
      }
    }
    (class Float16BufferAttribute extends BufferAttribute {
      constructor(t, e, i) {
        super(new Uint16Array(t), e, i);
      }
    }.prototype.isFloat16BufferAttribute = true);
    class Float32BufferAttribute extends BufferAttribute {
      constructor(t, e, i) {
        super(new Float32Array(t), e, i);
      }
    }
    function ve(t) {
      if (0 === t.length) return -Infinity;
      let e = t[0];
      for (let i = 1, n = t.length; i < n; ++i) t[i] > e && (e = t[i]);
      return e;
    }
    Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array;
    let be = 0;
    const we = new Matrix4, Se = new Object3D, Me = new three_module_Vector3, Ae = new Box3, Ce = new Box3, Te = new three_module_Vector3;
    class BufferGeometry extends EventDispatcher {
      constructor() {
        super(), Object.defineProperty(this, "id", {value: be++}), this.uuid = Z(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = false, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {start: 0, count: Infinity}, this.userData = {};
      }
      getIndex() {
        return this.index;
      }
      setIndex(t) {
        return Array.isArray(t) ? this.index = new (ve(t) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(t, 1) : this.index = t, this;
      }
      getAttribute(t) {
        return this.attributes[t];
      }
      setAttribute(t, e) {
        return this.attributes[t] = e, this;
      }
      deleteAttribute(t) {
        return delete this.attributes[t], this;
      }
      hasAttribute(t) {
        return void 0 !== this.attributes[t];
      }
      addGroup(t, e, i = 0) {
        this.groups.push({start: t, count: e, materialIndex: i});
      }
      clearGroups() {
        this.groups = [];
      }
      setDrawRange(t, e) {
        this.drawRange.start = t, this.drawRange.count = e;
      }
      applyMatrix4(t) {
        const e = this.attributes.position;
        void 0 !== e && (e.applyMatrix4(t), e.needsUpdate = true);
        const i = this.attributes.normal;
        if (void 0 !== i) {
          const e = (new Matrix3).getNormalMatrix(t);
          i.applyNormalMatrix(e), i.needsUpdate = true;
        }
        const n = this.attributes.tangent;
        return void 0 !== n && (n.transformDirection(t), n.needsUpdate = true), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this;
      }
      applyQuaternion(t) {
        return we.makeRotationFromQuaternion(t), this.applyMatrix4(we), this;
      }
      rotateX(t) {
        return we.makeRotationX(t), this.applyMatrix4(we), this;
      }
      rotateY(t) {
        return we.makeRotationY(t), this.applyMatrix4(we), this;
      }
      rotateZ(t) {
        return we.makeRotationZ(t), this.applyMatrix4(we), this;
      }
      translate(t, e, i) {
        return we.makeTranslation(t, e, i), this.applyMatrix4(we), this;
      }
      scale(t, e, i) {
        return we.makeScale(t, e, i), this.applyMatrix4(we), this;
      }
      lookAt(t) {
        return Se.lookAt(t), Se.updateMatrix(), this.applyMatrix4(Se.matrix), this;
      }
      center() {
        return this.computeBoundingBox(), this.boundingBox.getCenter(Me).negate(), this.translate(Me.x, Me.y, Me.z), this;
      }
      setFromPoints(t) {
        const e = [];
        for (let i = 0, n = t.length; i < n; i++) {
          const n = t[i];
          e.push(n.x, n.y, n.z || 0);
        }
        return this.setAttribute("position", new Float32BufferAttribute(e, 3)), this;
      }
      computeBoundingBox() {
        null === this.boundingBox && (this.boundingBox = new Box3);
        const t = this.attributes.position, e = this.morphAttributes.position;
        if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingBox.set(new three_module_Vector3(-Infinity, -Infinity, -Infinity), new three_module_Vector3(Infinity, Infinity, Infinity));
        if (void 0 !== t) {
          if (this.boundingBox.setFromBufferAttribute(t), e) for (let t = 0, i = e.length; t < i; t++) {
            const i = e[t];
            Ae.setFromBufferAttribute(i), this.morphTargetsRelative ? (Te.addVectors(this.boundingBox.min, Ae.min), this.boundingBox.expandByPoint(Te), Te.addVectors(this.boundingBox.max, Ae.max), this.boundingBox.expandByPoint(Te)) : (this.boundingBox.expandByPoint(Ae.min), this.boundingBox.expandByPoint(Ae.max));
          }
        } else this.boundingBox.makeEmpty();
        (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
      }
      computeBoundingSphere() {
        null === this.boundingSphere && (this.boundingSphere = new Sphere);
        const t = this.attributes.position, e = this.morphAttributes.position;
        if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingSphere.set(new three_module_Vector3, Infinity);
        if (t) {
          const i = this.boundingSphere.center;
          if (Ae.setFromBufferAttribute(t), e) for (let t = 0, i = e.length; t < i; t++) {
            const i = e[t];
            Ce.setFromBufferAttribute(i), this.morphTargetsRelative ? (Te.addVectors(Ae.min, Ce.min), Ae.expandByPoint(Te), Te.addVectors(Ae.max, Ce.max), Ae.expandByPoint(Te)) : (Ae.expandByPoint(Ce.min), Ae.expandByPoint(Ce.max));
          }
          Ae.getCenter(i);
          let n = 0;
          for (let e = 0, r = t.count; e < r; e++) Te.fromBufferAttribute(t, e), n = Math.max(n, i.distanceToSquared(Te));
          if (e) for (let r = 0, o = e.length; r < o; r++) {
            const o = e[r], s = this.morphTargetsRelative;
            for (let e = 0, r = o.count; e < r; e++) Te.fromBufferAttribute(o, e), s && (Me.fromBufferAttribute(t, e), Te.add(Me)), n = Math.max(n, i.distanceToSquared(Te));
          }
          this.boundingSphere.radius = Math.sqrt(n), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
        }
      }
      computeTangents() {
        const t = this.index, e = this.attributes;
        if (null === t || void 0 === e.position || void 0 === e.normal || void 0 === e.uv) return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
        const i = t.array, n = e.position.array, r = e.normal.array, o = e.uv.array, s = n.length / 3;
        void 0 === e.tangent && this.setAttribute("tangent", new BufferAttribute(new Float32Array(4 * s), 4));
        const a = e.tangent.array, l = [], c = [];
        for (let t = 0; t < s; t++) l[t] = new three_module_Vector3, c[t] = new three_module_Vector3;
        const h = new three_module_Vector3, u = new three_module_Vector3, p = new three_module_Vector3, m = new Vector2, d = new Vector2, _ = new Vector2, y = new three_module_Vector3, g = new three_module_Vector3;
        function x(t, e, i) {
          h.fromArray(n, 3 * t), u.fromArray(n, 3 * e), p.fromArray(n, 3 * i), m.fromArray(o, 2 * t), d.fromArray(o, 2 * e), _.fromArray(o, 2 * i), u.sub(h), p.sub(h), d.sub(m), _.sub(m);
          const r = 1 / (d.x * _.y - _.x * d.y);
          isFinite(r) && (y.copy(u).multiplyScalar(_.y).addScaledVector(p, -d.y).multiplyScalar(r), g.copy(p).multiplyScalar(d.x).addScaledVector(u, -_.x).multiplyScalar(r), l[t].add(y), l[e].add(y), l[i].add(y), c[t].add(g), c[e].add(g), c[i].add(g));
        }
        let v = this.groups;
        0 === v.length && (v = [{start: 0, count: i.length}]);
        for (let t = 0, e = v.length; t < e; ++t) {
          const e = v[t], n = e.start;
          for (let r = n + e.count; t < r; t += 3) x(i[t + 0], i[t + 1], i[t + 2]);
        }
        const b = new three_module_Vector3, w = new three_module_Vector3, S = new three_module_Vector3, M = new three_module_Vector3;
        function A(t) {
          S.fromArray(r, 3 * t), M.copy(S);
          const e = l[t];
          b.copy(e), b.sub(S.multiplyScalar(S.dot(e))).normalize(), w.crossVectors(M, e);
          const i = w.dot(c[t]) < 0 ? -1 : 1;
          a[4 * t] = b.x, a[4 * t + 1] = b.y, a[4 * t + 2] = b.z, a[4 * t + 3] = i;
        }
        for (let t = 0, e = v.length; t < e; ++t) {
          const e = v[t], n = e.start;
          for (let r = n + e.count; t < r; t += 3) A(i[t + 0]), A(i[t + 1]), A(i[t + 2]);
        }
      }
      computeVertexNormals() {
        const t = this.index, e = this.getAttribute("position");
        if (void 0 !== e) {
          let i = this.getAttribute("normal");
          if (void 0 === i) i = new BufferAttribute(new Float32Array(3 * e.count), 3), this.setAttribute("normal", i); else for (let t = 0, e = i.count; t < e; t++) i.setXYZ(t, 0, 0, 0);
          const n = new three_module_Vector3, r = new three_module_Vector3, o = new three_module_Vector3, s = new three_module_Vector3, a = new three_module_Vector3, l = new three_module_Vector3, c = new three_module_Vector3, h = new three_module_Vector3;
          if (t) for (let u = 0, p = t.count; u < p; u += 3) {
            const p = t.getX(u + 0), m = t.getX(u + 1), d = t.getX(u + 2);
            n.fromBufferAttribute(e, p), r.fromBufferAttribute(e, m), o.fromBufferAttribute(e, d), c.subVectors(o, r), h.subVectors(n, r), c.cross(h), s.fromBufferAttribute(i, p), a.fromBufferAttribute(i, m), l.fromBufferAttribute(i, d), s.add(c), a.add(c), l.add(c), i.setXYZ(p, s.x, s.y, s.z), i.setXYZ(m, a.x, a.y, a.z), i.setXYZ(d, l.x, l.y, l.z);
          } else for (let t = 0, s = e.count; t < s; t += 3) n.fromBufferAttribute(e, t + 0), r.fromBufferAttribute(e, t + 1), o.fromBufferAttribute(e, t + 2), c.subVectors(o, r), h.subVectors(n, r), c.cross(h), i.setXYZ(t + 0, c.x, c.y, c.z), i.setXYZ(t + 1, c.x, c.y, c.z), i.setXYZ(t + 2, c.x, c.y, c.z);
          this.normalizeNormals(), i.needsUpdate = true;
        }
      }
      merge(t, e) {
        if (!t || !t.isBufferGeometry) return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t);
        void 0 === e && (e = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
        const i = this.attributes;
        for (const n in i) {
          if (void 0 === t.attributes[n]) continue;
          const r = i[n].array, o = t.attributes[n], s = o.array, a = o.itemSize * e, l = Math.min(s.length, r.length - a);
          for (let t = 0, e = a; t < l; t++, e++) r[e] = s[t];
        }
        return this;
      }
      normalizeNormals() {
        const t = this.attributes.normal;
        for (let e = 0, i = t.count; e < i; e++) Te.fromBufferAttribute(t, e), Te.normalize(), t.setXYZ(e, Te.x, Te.y, Te.z);
      }
      toNonIndexed() {
        function t(t, e) {
          const i = t.array, n = t.itemSize, r = t.normalized, o = new i.constructor(e.length * n);
          let s = 0, a = 0;
          for (let r = 0, l = e.length; r < l; r++) {
            s = t.isInterleavedBufferAttribute ? e[r] * t.data.stride + t.offset : e[r] * n;
            for (let t = 0; t < n; t++) o[a++] = i[s++];
          }
          return new BufferAttribute(o, n, r);
        }
        if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
        const e = new BufferGeometry, i = this.index.array, n = this.attributes;
        for (const r in n) {
          const o = t(n[r], i);
          e.setAttribute(r, o);
        }
        const r = this.morphAttributes;
        for (const n in r) {
          const o = [], s = r[n];
          for (let e = 0, n = s.length; e < n; e++) {
            const n = t(s[e], i);
            o.push(n);
          }
          e.morphAttributes[n] = o;
        }
        e.morphTargetsRelative = this.morphTargetsRelative;
        const o = this.groups;
        for (let t = 0, i = o.length; t < i; t++) {
          const i = o[t];
          e.addGroup(i.start, i.count, i.materialIndex);
        }
        return e;
      }
      toJSON() {
        const t = {metadata: {version: 4.5, type: "BufferGeometry", generator: "BufferGeometry.toJSON"}};
        if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), Object.keys(this.userData).length > 0 && (t.userData = this.userData), void 0 !== this.parameters) {
          const e = this.parameters;
          for (const i in e) void 0 !== e[i] && (t[i] = e[i]);
          return t;
        }
        t.data = {attributes: {}};
        const e = this.index;
        null !== e && (t.data.index = {type: e.array.constructor.name, array: Array.prototype.slice.call(e.array)});
        const i = this.attributes;
        for (const e in i) {
          const n = i[e];
          t.data.attributes[e] = n.toJSON(t.data);
        }
        const n = {};
        let r = false;
        for (const e in this.morphAttributes) {
          const i = this.morphAttributes[e], o = [];
          for (let e = 0, n = i.length; e < n; e++) {
            const n = i[e];
            o.push(n.toJSON(t.data));
          }
          o.length > 0 && (n[e] = o, r = true);
        }
        r && (t.data.morphAttributes = n, t.data.morphTargetsRelative = this.morphTargetsRelative);
        const o = this.groups;
        o.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(o)));
        const s = this.boundingSphere;
        return null !== s && (t.data.boundingSphere = {center: s.center.toArray(), radius: s.radius}), t;
      }
      clone() {
        return (new BufferGeometry).copy(this);
      }
      copy(t) {
        this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
        const e = {};
        this.name = t.name;
        const i = t.index;
        null !== i && this.setIndex(i.clone(e));
        const n = t.attributes;
        for (const t in n) {
          const i = n[t];
          this.setAttribute(t, i.clone(e));
        }
        const r = t.morphAttributes;
        for (const t in r) {
          const i = [], n = r[t];
          for (let t = 0, r = n.length; t < r; t++) i.push(n[t].clone(e));
          this.morphAttributes[t] = i;
        }
        this.morphTargetsRelative = t.morphTargetsRelative;
        const o = t.groups;
        for (let t = 0, e = o.length; t < e; t++) {
          const e = o[t];
          this.addGroup(e.start, e.count, e.materialIndex);
        }
        const s = t.boundingBox;
        null !== s && (this.boundingBox = s.clone());
        const a = t.boundingSphere;
        return null !== a && (this.boundingSphere = a.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, this;
      }
      dispose() {
        this.dispatchEvent({type: "dispose"});
      }
    }
    BufferGeometry.prototype.isBufferGeometry = true;
    const Ee = new Matrix4, Le = new Ray, De = new Sphere, Re = new three_module_Vector3, Be = new three_module_Vector3, Pe = new three_module_Vector3, Ie = new three_module_Vector3, Ve = new three_module_Vector3, Fe = new three_module_Vector3, ke = new three_module_Vector3, Ne = new three_module_Vector3, Ge = new three_module_Vector3, Ue = new Vector2, ze = new Vector2, Oe = new Vector2, He = new three_module_Vector3, We = new three_module_Vector3;
    class Mesh extends Object3D {
      constructor(t = new BufferGeometry, e = new MeshBasicMaterial) {
        super(), this.type = "Mesh", this.geometry = t, this.material = e, this.updateMorphTargets();
      }
      copy(t) {
        return super.copy(t), void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this.material = t.material, this.geometry = t.geometry, this;
      }
      updateMorphTargets() {
        const t = this.geometry;
        if (t.isBufferGeometry) {
          const e = t.morphAttributes, i = Object.keys(e);
          if (i.length > 0) {
            const t = e[i[0]];
            if (void 0 !== t) {
              this.morphTargetInfluences = [], this.morphTargetDictionary = {};
              for (let e = 0, i = t.length; e < i; e++) {
                const i = t[e].name || String(e);
                this.morphTargetInfluences.push(0), this.morphTargetDictionary[i] = e;
              }
            }
          }
        } else {
          const e = t.morphTargets;
          void 0 !== e && e.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
        }
      }
      raycast(t, e) {
        const i = this.geometry, n = this.material, r = this.matrixWorld;
        if (void 0 === n) return;
        if (null === i.boundingSphere && i.computeBoundingSphere(), De.copy(i.boundingSphere), De.applyMatrix4(r), false === t.ray.intersectsSphere(De)) return;
        if (Ee.copy(r).invert(), Le.copy(t.ray).applyMatrix4(Ee), null !== i.boundingBox && false === Le.intersectsBox(i.boundingBox)) return;
        let o;
        if (i.isBufferGeometry) {
          const r = i.index, s = i.attributes.position, a = i.morphAttributes.position, l = i.morphTargetsRelative, c = i.attributes.uv, h = i.attributes.uv2, u = i.groups, p = i.drawRange;
          if (null !== r) if (Array.isArray(n)) for (let i = 0, m = u.length; i < m; i++) {
            const m = u[i], d = n[m.materialIndex];
            for (let i = Math.max(m.start, p.start), n = Math.min(m.start + m.count, p.start + p.count); i < n; i += 3) {
              const n = r.getX(i), u = r.getX(i + 1), p = r.getX(i + 2);
              o = Je(this, d, t, Le, s, a, l, c, h, n, u, p), o && (o.faceIndex = Math.floor(i / 3), o.face.materialIndex = m.materialIndex, e.push(o));
            }
          } else {
            for (let i = Math.max(0, p.start), u = Math.min(r.count, p.start + p.count); i < u; i += 3) {
              const u = r.getX(i), p = r.getX(i + 1), m = r.getX(i + 2);
              o = Je(this, n, t, Le, s, a, l, c, h, u, p, m), o && (o.faceIndex = Math.floor(i / 3), e.push(o));
            }
          } else if (void 0 !== s) if (Array.isArray(n)) for (let i = 0, r = u.length; i < r; i++) {
            const r = u[i], m = n[r.materialIndex];
            for (let i = Math.max(r.start, p.start), n = Math.min(r.start + r.count, p.start + p.count); i < n; i += 3) {
              o = Je(this, m, t, Le, s, a, l, c, h, i, i + 1, i + 2), o && (o.faceIndex = Math.floor(i / 3), o.face.materialIndex = r.materialIndex, e.push(o));
            }
          } else {
            for (let i = Math.max(0, p.start), r = Math.min(s.count, p.start + p.count); i < r; i += 3) {
              o = Je(this, n, t, Le, s, a, l, c, h, i, i + 1, i + 2), o && (o.faceIndex = Math.floor(i / 3), e.push(o));
            }
          }
        } else i.isGeometry && console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
    }
    function Je(t, e, i, n, r, o, s, a, l, c, h, u) {
      Re.fromBufferAttribute(r, c), Be.fromBufferAttribute(r, h), Pe.fromBufferAttribute(r, u);
      const p = t.morphTargetInfluences;
      if (o && p) {
        ke.set(0, 0, 0), Ne.set(0, 0, 0), Ge.set(0, 0, 0);
        for (let t = 0, e = o.length; t < e; t++) {
          const e = p[t], i = o[t];
          0 !== e && (Ie.fromBufferAttribute(i, c), Ve.fromBufferAttribute(i, h), Fe.fromBufferAttribute(i, u), s ? (ke.addScaledVector(Ie, e), Ne.addScaledVector(Ve, e), Ge.addScaledVector(Fe, e)) : (ke.addScaledVector(Ie.sub(Re), e), Ne.addScaledVector(Ve.sub(Be), e), Ge.addScaledVector(Fe.sub(Pe), e)));
        }
        Re.add(ke), Be.add(Ne), Pe.add(Ge);
      }
      t.isSkinnedMesh && (t.boneTransform(c, Re), t.boneTransform(h, Be), t.boneTransform(u, Pe));
      const m = function (t, e, i, n, r, o, s, a) {
        let l;
        if (l = 1 === e.side ? n.intersectTriangle(s, o, r, true, a) : n.intersectTriangle(r, o, s, 2 !== e.side, a), null === l) return null;
        We.copy(a), We.applyMatrix4(t.matrixWorld);
        const c = i.ray.origin.distanceTo(We);
        return c < i.near || c > i.far ? null : {distance: c, point: We.clone(), object: t};
      }(t, e, i, n, Re, Be, Pe, He);
      if (m) {
        a && (Ue.fromBufferAttribute(a, c), ze.fromBufferAttribute(a, h), Oe.fromBufferAttribute(a, u), m.uv = Triangle.getUV(He, Re, Be, Pe, Ue, ze, Oe, new Vector2)), l && (Ue.fromBufferAttribute(l, c), ze.fromBufferAttribute(l, h), Oe.fromBufferAttribute(l, u), m.uv2 = Triangle.getUV(He, Re, Be, Pe, Ue, ze, Oe, new Vector2));
        const t = {a: c, b: h, c: u, normal: new three_module_Vector3, materialIndex: 0};
        Triangle.getNormal(Re, Be, Pe, t.normal), m.face = t;
      }
      return m;
    }
    Mesh.prototype.isMesh = true;
    class BoxGeometry extends BufferGeometry {
      constructor(t = 1, e = 1, i = 1, n = 1, r = 1, o = 1) {
        super(), this.type = "BoxGeometry", this.parameters = {width: t, height: e, depth: i, widthSegments: n, heightSegments: r, depthSegments: o};
        const s = this;
        n = Math.floor(n), r = Math.floor(r), o = Math.floor(o);
        const a = [], l = [], c = [], h = [];
        let u = 0, p = 0;
        function m(t, e, i, n, r, o, m, d, _, y, g) {
          const x = o / _, v = m / y, b = o / 2, w = m / 2, S = d / 2, M = _ + 1, A = y + 1;
          let C = 0, T = 0;
          const E = new three_module_Vector3;
          for (let o = 0; o < A; o++) {
            const s = o * v - w;
            for (let a = 0; a < M; a++) {
              const u = a * x - b;
              E[t] = u * n, E[e] = s * r, E[i] = S, l.push(E.x, E.y, E.z), E[t] = 0, E[e] = 0, E[i] = d > 0 ? 1 : -1, c.push(E.x, E.y, E.z), h.push(a / _), h.push(1 - o / y), C += 1;
            }
          }
          for (let t = 0; t < y; t++) for (let e = 0; e < _; e++) {
            const i = u + e + M * t, n = u + e + M * (t + 1), r = u + (e + 1) + M * (t + 1), o = u + (e + 1) + M * t;
            a.push(i, n, o), a.push(n, r, o), T += 6;
          }
          s.addGroup(p, T, g), p += T, u += C;
        }
        m("z", "y", "x", -1, -1, i, e, t, o, r, 0), m("z", "y", "x", 1, -1, i, e, -t, o, r, 1), m("x", "z", "y", 1, 1, t, i, e, n, o, 2), m("x", "z", "y", 1, -1, t, i, -e, n, o, 3), m("x", "y", "z", 1, -1, t, e, i, n, r, 4), m("x", "y", "z", -1, -1, t, e, -i, n, r, 5), this.setIndex(a), this.setAttribute("position", new Float32BufferAttribute(l, 3)), this.setAttribute("normal", new Float32BufferAttribute(c, 3)), this.setAttribute("uv", new Float32BufferAttribute(h, 2));
      }
      static fromJSON(t) {
        return new BoxGeometry(t.width, t.height, t.depth, t.widthSegments, t.heightSegments, t.depthSegments);
      }
    }
    function je(t) {
      const e = {};
      for (const i in t) {
        e[i] = {};
        for (const n in t[i]) {
          const r = t[i][n];
          r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? e[i][n] = r.clone() : Array.isArray(r) ? e[i][n] = r.slice() : e[i][n] = r;
        }
      }
      return e;
    }
    function Xe(t) {
      const e = {};
      for (let i = 0; i < t.length; i++) {
        const n = je(t[i]);
        for (const t in n) e[t] = n[t];
      }
      return e;
    }
    const qe = {clone: je, merge: Xe};
    class ShaderMaterial extends Material {
      constructor(t) {
        super(), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = false, this.wireframeLinewidth = 1, this.fog = false, this.lights = false, this.clipping = false, this.extensions = {derivatives: false, fragDepth: false, drawBuffers: false, shaderTextureLOD: false}, this.defaultAttributeValues = {color: [1, 1, 1], uv: [0, 0], uv2: [0, 0]}, this.index0AttributeName = void 0, this.uniformsNeedUpdate = false, this.glslVersion = null, void 0 !== t && (void 0 !== t.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(t));
      }
      copy(t) {
        return super.copy(t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = je(t.uniforms), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.lights = t.lights, this.clipping = t.clipping, this.extensions = Object.assign({}, t.extensions), this.glslVersion = t.glslVersion, this;
      }
      toJSON(t) {
        const e = super.toJSON(t);
        e.glslVersion = this.glslVersion, e.uniforms = {};
        for (const i in this.uniforms) {
          const n = this.uniforms[i].value;
          n && n.isTexture ? e.uniforms[i] = {type: "t", value: n.toJSON(t).uuid} : n && n.isColor ? e.uniforms[i] = {type: "c", value: n.getHex()} : n && n.isVector2 ? e.uniforms[i] = {type: "v2", value: n.toArray()} : n && n.isVector3 ? e.uniforms[i] = {type: "v3", value: n.toArray()} : n && n.isVector4 ? e.uniforms[i] = {type: "v4", value: n.toArray()} : n && n.isMatrix3 ? e.uniforms[i] = {type: "m3", value: n.toArray()} : n && n.isMatrix4 ? e.uniforms[i] = {type: "m4", value: n.toArray()} : e.uniforms[i] = {value: n};
        }
        Object.keys(this.defines).length > 0 && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader;
        const i = {};
        for (const t in this.extensions) true === this.extensions[t] && (i[t] = true);
        return Object.keys(i).length > 0 && (e.extensions = i), e;
      }
    }
    ShaderMaterial.prototype.isShaderMaterial = true;
    class Camera extends Object3D {
      constructor() {
        super(), this.type = "Camera", this.matrixWorldInverse = new Matrix4, this.projectionMatrix = new Matrix4, this.projectionMatrixInverse = new Matrix4;
      }
      copy(t, e) {
        return super.copy(t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this;
      }
      getWorldDirection(t) {
        this.updateWorldMatrix(true, false);
        const e = this.matrixWorld.elements;
        return t.set(-e[8], -e[9], -e[10]).normalize();
      }
      updateMatrixWorld(t) {
        super.updateMatrixWorld(t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
      }
      updateWorldMatrix(t, e) {
        super.updateWorldMatrix(t, e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
      }
      clone() {
        return (new this.constructor).copy(this);
      }
    }
    Camera.prototype.isCamera = true;
    class PerspectiveCamera extends Camera {
      constructor(t = 50, e = 1, i = 0.1, n = 2e3) {
        super(), this.type = "PerspectiveCamera", this.fov = t, this.zoom = 1, this.near = i, this.far = n, this.focus = 10, this.aspect = e, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
      }
      copy(t, e) {
        return super.copy(t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = null === t.view ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this;
      }
      setFocalLength(t) {
        const e = 0.5 * this.getFilmHeight() / t;
        this.fov = 2 * Y * Math.atan(e), this.updateProjectionMatrix();
      }
      getFocalLength() {
        const t = Math.tan(0.5 * q * this.fov);
        return 0.5 * this.getFilmHeight() / t;
      }
      getEffectiveFOV() {
        return 2 * Y * Math.atan(Math.tan(0.5 * q * this.fov) / this.zoom);
      }
      getFilmWidth() {
        return this.filmGauge * Math.min(this.aspect, 1);
      }
      getFilmHeight() {
        return this.filmGauge / Math.max(this.aspect, 1);
      }
      setViewOffset(t, e, i, n, r, o) {
        this.aspect = t / e, null === this.view && (this.view = {enabled: true, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1}), this.view.enabled = true, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = i, this.view.offsetY = n, this.view.width = r, this.view.height = o, this.updateProjectionMatrix();
      }
      clearViewOffset() {
        null !== this.view && (this.view.enabled = false), this.updateProjectionMatrix();
      }
      updateProjectionMatrix() {
        const t = this.near;
        let e = t * Math.tan(0.5 * q * this.fov) / this.zoom, i = 2 * e, n = this.aspect * i, r = -0.5 * n;
        const o = this.view;
        if (null !== this.view && this.view.enabled) {
          const t = o.fullWidth, s = o.fullHeight;
          r += o.offsetX * n / t, e -= o.offsetY * i / s, n *= o.width / t, i *= o.height / s;
        }
        const s = this.filmOffset;
        0 !== s && (r += t * s / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + n, e, e - i, t, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
      }
      toJSON(t) {
        const e = super.toJSON(t);
        return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, null !== this.view && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e;
      }
    }
    PerspectiveCamera.prototype.isPerspectiveCamera = true;
    const Ye = 90;
    class CubeCamera extends Object3D {
      constructor(t, e, i) {
        if (super(), this.type = "CubeCamera", true !== i.isWebGLCubeRenderTarget) return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
        this.renderTarget = i;
        const n = new PerspectiveCamera(Ye, 1, t, e);
        n.layers = this.layers, n.up.set(0, -1, 0), n.lookAt(new three_module_Vector3(1, 0, 0)), this.add(n);
        const r = new PerspectiveCamera(Ye, 1, t, e);
        r.layers = this.layers, r.up.set(0, -1, 0), r.lookAt(new three_module_Vector3(-1, 0, 0)), this.add(r);
        const o = new PerspectiveCamera(Ye, 1, t, e);
        o.layers = this.layers, o.up.set(0, 0, 1), o.lookAt(new three_module_Vector3(0, 1, 0)), this.add(o);
        const s = new PerspectiveCamera(Ye, 1, t, e);
        s.layers = this.layers, s.up.set(0, 0, -1), s.lookAt(new three_module_Vector3(0, -1, 0)), this.add(s);
        const a = new PerspectiveCamera(Ye, 1, t, e);
        a.layers = this.layers, a.up.set(0, -1, 0), a.lookAt(new three_module_Vector3(0, 0, 1)), this.add(a);
        const l = new PerspectiveCamera(Ye, 1, t, e);
        l.layers = this.layers, l.up.set(0, -1, 0), l.lookAt(new three_module_Vector3(0, 0, -1)), this.add(l);
      }
      update(t, e) {
        null === this.parent && this.updateMatrixWorld();
        const i = this.renderTarget, [n, r, o, s, a, l] = this.children, c = t.xr.enabled, h = t.getRenderTarget();
        t.xr.enabled = false;
        const u = i.texture.generateMipmaps;
        i.texture.generateMipmaps = false, t.setRenderTarget(i, 0), t.render(e, n), t.setRenderTarget(i, 1), t.render(e, r), t.setRenderTarget(i, 2), t.render(e, o), t.setRenderTarget(i, 3), t.render(e, s), t.setRenderTarget(i, 4), t.render(e, a), i.texture.generateMipmaps = u, t.setRenderTarget(i, 5), t.render(e, l), t.setRenderTarget(h), t.xr.enabled = c;
      }
    }
    class CubeTexture extends Texture {
      constructor(t, e, i, n, r, o, a, l, c, h) {
        super(t = void 0 !== t ? t : [], e = void 0 !== e ? e : s, i, n, r, o, a = void 0 !== a ? a : T, l, c, h), this.flipY = false;
      }
      get images() {
        return this.image;
      }
      set images (t) {
        this.image = t;
      }
    }
    CubeTexture.prototype.isCubeTexture = true;
    class WebGLCubeRenderTarget extends WebGLRenderTarget {
      constructor(t, e, i) {
        Number.isInteger(e) && (console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"), e = i), super(t, t, e), e = e || {}, this.texture = new CubeTexture(void 0, e.mapping, e.wrapS, e.wrapT, e.magFilter, e.minFilter, e.format, e.type, e.anisotropy, e.encoding), this.texture.isRenderTargetTexture = true, this.texture.generateMipmaps = void 0 !== e.generateMipmaps && e.generateMipmaps, this.texture.minFilter = void 0 !== e.minFilter ? e.minFilter : x, this.texture._needsFlipEnvMap = false;
      }
      fromEquirectangularTexture(t, e) {
        this.texture.type = e.type, this.texture.format = E, this.texture.encoding = e.encoding, this.texture.generateMipmaps = e.generateMipmaps, this.texture.minFilter = e.minFilter, this.texture.magFilter = e.magFilter;
        const i = {uniforms: {tEquirect: {value: null}}, vertexShader: "\n\n				varying vec3 vWorldDirection;\n\n				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n				}\n\n				void main() {\n\n					vWorldDirection = transformDirection( position, modelMatrix );\n\n					#include <begin_vertex>\n					#include <project_vertex>\n\n				}\n			", fragmentShader: "\n\n				uniform sampler2D tEquirect;\n\n				varying vec3 vWorldDirection;\n\n				#include <common>\n\n				void main() {\n\n					vec3 direction = normalize( vWorldDirection );\n\n					vec2 sampleUV = equirectUv( direction );\n\n					gl_FragColor = texture2D( tEquirect, sampleUV );\n\n				}\n			"}, n = new BoxGeometry(5, 5, 5), r = new ShaderMaterial({name: "CubemapFromEquirect", uniforms: je(i.uniforms), vertexShader: i.vertexShader, fragmentShader: i.fragmentShader, side: 1, blending: 0});
        r.uniforms.tEquirect.value = e;
        const o = new Mesh(n, r), s = e.minFilter;
        e.minFilter === v && (e.minFilter = x);
        return new CubeCamera(1, 10, this).update(t, o), e.minFilter = s, o.geometry.dispose(), o.material.dispose(), this;
      }
      clear(t, e, i, n) {
        const r = t.getRenderTarget();
        for (let r = 0; r < 6; r++) t.setRenderTarget(this, r), t.clear(e, i, n);
        t.setRenderTarget(r);
      }
    }
    WebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = true;
    const Ze = new three_module_Vector3, Ke = new three_module_Vector3, $e = new Matrix3;
    class Plane {
      constructor(t = new three_module_Vector3(1, 0, 0), e = 0) {
        this.normal = t, this.constant = e;
      }
      set(t, e) {
        return this.normal.copy(t), this.constant = e, this;
      }
      setComponents(t, e, i, n) {
        return this.normal.set(t, e, i), this.constant = n, this;
      }
      setFromNormalAndCoplanarPoint(t, e) {
        return this.normal.copy(t), this.constant = -e.dot(this.normal), this;
      }
      setFromCoplanarPoints(t, e, i) {
        const n = Ze.subVectors(i, e).cross(Ke.subVectors(t, e)).normalize();
        return this.setFromNormalAndCoplanarPoint(n, t), this;
      }
      copy(t) {
        return this.normal.copy(t.normal), this.constant = t.constant, this;
      }
      normalize() {
        const t = 1 / this.normal.length();
        return this.normal.multiplyScalar(t), this.constant *= t, this;
      }
      negate() {
        return this.constant *= -1, this.normal.negate(), this;
      }
      distanceToPoint(t) {
        return this.normal.dot(t) + this.constant;
      }
      distanceToSphere(t) {
        return this.distanceToPoint(t.center) - t.radius;
      }
      projectPoint(t, e) {
        return e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t);
      }
      intersectLine(t, e) {
        const i = t.delta(Ze), n = this.normal.dot(i);
        if (0 === n) return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : null;
        const r = -(t.start.dot(this.normal) + this.constant) / n;
        return r < 0 || r > 1 ? null : e.copy(i).multiplyScalar(r).add(t.start);
      }
      intersectsLine(t) {
        const e = this.distanceToPoint(t.start), i = this.distanceToPoint(t.end);
        return e < 0 && i > 0 || i < 0 && e > 0;
      }
      intersectsBox(t) {
        return t.intersectsPlane(this);
      }
      intersectsSphere(t) {
        return t.intersectsPlane(this);
      }
      coplanarPoint(t) {
        return t.copy(this.normal).multiplyScalar(-this.constant);
      }
      applyMatrix4(t, e) {
        const i = e || $e.getNormalMatrix(t), n = this.coplanarPoint(Ze).applyMatrix4(t), r = this.normal.applyMatrix3(i).normalize();
        return this.constant = -n.dot(r), this;
      }
      translate(t) {
        return this.constant -= t.dot(this.normal), this;
      }
      equals(t) {
        return t.normal.equals(this.normal) && t.constant === this.constant;
      }
      clone() {
        return (new this.constructor).copy(this);
      }
    }
    Plane.prototype.isPlane = true;
    const Qe = new Sphere, ti = new three_module_Vector3;
    class Frustum {
      constructor(t = new Plane, e = new Plane, i = new Plane, n = new Plane, r = new Plane, o = new Plane) {
        this.planes = [t, e, i, n, r, o];
      }
      set(t, e, i, n, r, o) {
        const s = this.planes;
        return s[0].copy(t), s[1].copy(e), s[2].copy(i), s[3].copy(n), s[4].copy(r), s[5].copy(o), this;
      }
      copy(t) {
        const e = this.planes;
        for (let i = 0; i < 6; i++) e[i].copy(t.planes[i]);
        return this;
      }
      setFromProjectionMatrix(t) {
        const e = this.planes, i = t.elements, n = i[0], r = i[1], o = i[2], s = i[3], a = i[4], l = i[5], c = i[6], h = i[7], u = i[8], p = i[9], m = i[10], d = i[11], _ = i[12], y = i[13], g = i[14], x = i[15];
        return e[0].setComponents(s - n, h - a, d - u, x - _).normalize(), e[1].setComponents(s + n, h + a, d + u, x + _).normalize(), e[2].setComponents(s + r, h + l, d + p, x + y).normalize(), e[3].setComponents(s - r, h - l, d - p, x - y).normalize(), e[4].setComponents(s - o, h - c, d - m, x - g).normalize(), e[5].setComponents(s + o, h + c, d + m, x + g).normalize(), this;
      }
      intersectsObject(t) {
        const e = t.geometry;
        return null === e.boundingSphere && e.computeBoundingSphere(), Qe.copy(e.boundingSphere).applyMatrix4(t.matrixWorld), this.intersectsSphere(Qe);
      }
      intersectsSprite(t) {
        return Qe.center.set(0, 0, 0), Qe.radius = 0.7071067811865476, Qe.applyMatrix4(t.matrixWorld), this.intersectsSphere(Qe);
      }
      intersectsSphere(t) {
        const e = this.planes, i = t.center, n = -t.radius;
        for (let t = 0; t < 6; t++) {
          if (e[t].distanceToPoint(i) < n) return false;
        }
        return true;
      }
      intersectsBox(t) {
        const e = this.planes;
        for (let i = 0; i < 6; i++) {
          const n = e[i];
          if (ti.x = n.normal.x > 0 ? t.max.x : t.min.x, ti.y = n.normal.y > 0 ? t.max.y : t.min.y, ti.z = n.normal.z > 0 ? t.max.z : t.min.z, n.distanceToPoint(ti) < 0) return false;
        }
        return true;
      }
      containsPoint(t) {
        const e = this.planes;
        for (let i = 0; i < 6; i++) if (e[i].distanceToPoint(t) < 0) return false;
        return true;
      }
      clone() {
        return (new this.constructor).copy(this);
      }
    }
    function ei() {
      let t = null, e = false, i = null, n = null;
      function r(e, o) {
        i(e, o), n = t.requestAnimationFrame(r);
      }
      return {start: function () {
        true !== e && null !== i && (n = t.requestAnimationFrame(r), e = true);
      }, stop: function () {
        t.cancelAnimationFrame(n), e = false;
      }, setAnimationLoop: function (t) {
        i = t;
      }, setContext: function (e) {
        t = e;
      }};
    }
    function ii(t, e) {
      const i = e.isWebGL2, n = new WeakMap;
      return {get: function (t) {
        return t.isInterleavedBufferAttribute && (t = t.data), n.get(t);
      }, remove: function (e) {
        e.isInterleavedBufferAttribute && (e = e.data);
        const i = n.get(e);
        i && (t.deleteBuffer(i.buffer), n.delete(e));
      }, update: function (e, r) {
        if (e.isGLBufferAttribute) {
          const t = n.get(e);
          return void ((!t || t.version < e.version) && n.set(e, {buffer: e.buffer, type: e.type, bytesPerElement: e.elementSize, version: e.version}));
        }
        e.isInterleavedBufferAttribute && (e = e.data);
        const o = n.get(e);
        void 0 === o ? n.set(e, function (e, n) {
          const r = e.array, o = e.usage, s = t.createBuffer();
          t.bindBuffer(n, s), t.bufferData(n, r, o), e.onUploadCallback();
          let a = 5126;
          return r instanceof Float32Array ? a = 5126 : r instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : r instanceof Uint16Array ? e.isFloat16BufferAttribute ? i ? a = 5131 : console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.") : a = 5123 : r instanceof Int16Array ? a = 5122 : r instanceof Uint32Array ? a = 5125 : r instanceof Int32Array ? a = 5124 : r instanceof Int8Array ? a = 5120 : (r instanceof Uint8Array || r instanceof Uint8ClampedArray) && (a = 5121), {buffer: s, type: a, bytesPerElement: r.BYTES_PER_ELEMENT, version: e.version};
        }(e, r)) : o.version < e.version && (!function (e, n, r) {
          const o = n.array, s = n.updateRange;
          t.bindBuffer(r, e), -1 === s.count ? t.bufferSubData(r, 0, o) : (i ? t.bufferSubData(r, s.offset * o.BYTES_PER_ELEMENT, o, s.offset, s.count) : t.bufferSubData(r, s.offset * o.BYTES_PER_ELEMENT, o.subarray(s.offset, s.offset + s.count)), s.count = -1);
        }(o.buffer, e, r), o.version = e.version);
      }};
    }
    class PlaneGeometry extends BufferGeometry {
      constructor(t = 1, e = 1, i = 1, n = 1) {
        super(), this.type = "PlaneGeometry", this.parameters = {width: t, height: e, widthSegments: i, heightSegments: n};
        const r = t / 2, o = e / 2, s = Math.floor(i), a = Math.floor(n), l = s + 1, c = a + 1, h = t / s, u = e / a, p = [], m = [], d = [], _ = [];
        for (let t = 0; t < c; t++) {
          const e = t * u - o;
          for (let i = 0; i < l; i++) {
            const n = i * h - r;
            m.push(n, -e, 0), d.push(0, 0, 1), _.push(i / s), _.push(1 - t / a);
          }
        }
        for (let t = 0; t < a; t++) for (let e = 0; e < s; e++) {
          const i = e + l * t, n = e + l * (t + 1), r = e + 1 + l * (t + 1), o = e + 1 + l * t;
          p.push(i, n, o), p.push(n, r, o);
        }
        this.setIndex(p), this.setAttribute("position", new Float32BufferAttribute(m, 3)), this.setAttribute("normal", new Float32BufferAttribute(d, 3)), this.setAttribute("uv", new Float32BufferAttribute(_, 2));
      }
      static fromJSON(t) {
        return new PlaneGeometry(t.width, t.height, t.widthSegments, t.heightSegments);
      }
    }
    const ni = {alphamap_fragment: "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif", alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif", alphatest_fragment: "#ifdef USE_ALPHATEST\n	if ( diffuseColor.a < alphaTest ) discard;\n#endif", alphatest_pars_fragment: "#ifdef USE_ALPHATEST\n	uniform float alphaTest;\n#endif", aomap_fragment: "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n	#endif\n#endif", aomap_pars_fragment: "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif", begin_vertex: "vec3 transformed = vec3( position );", beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif", bsdfs: "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( incidentLight.direction + viewDir );\n	float dotNL = saturate( dot( normal, incidentLight.direction ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( f0, f90, dotVH );\n	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n	float D = D_GGX( alpha, dotNH );\n	return F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n	float dotNH = saturate( dot( geometry.normal, halfDir ) );\n	float dotVH = saturate( dot( geometry.viewDir, halfDir ) );\n	vec3 F = F_Schlick( specularColor, 1.0, dotVH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float NoH ) {\n	float invAlpha = 1.0 / roughness;\n	float cos2h = NoH * NoH;\n	float sin2h = max( 1.0 - cos2h, 0.0078125 );\n	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float NoV, float NoL ) {\n	return saturate( 1.0 / ( 4.0 * ( NoL + NoV - NoL * NoV ) ) );\n}\nvec3 BRDF_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n	vec3 N = geometry.normal;\n	vec3 V = geometry.viewDir;\n	vec3 H = normalize( V + L );\n	float dotNH = saturate( dot( N, H ) );\n	return specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif", bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 ) * faceDirection;\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif", clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n		plane = clippingPlanes[ i ];\n		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n	}\n	#pragma unroll_loop_end\n	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n		bool clipped = true;\n		#pragma unroll_loop_start\n		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n		}\n		#pragma unroll_loop_end\n		if ( clipped ) discard;\n	#endif\n#endif", clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif", clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n#endif", clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n	vClipPosition = - mvPosition.xyz;\n#endif", color_fragment: "#if defined( USE_COLOR_ALPHA )\n	diffuseColor *= vColor;\n#elif defined( USE_COLOR )\n	diffuseColor.rgb *= vColor;\n#endif", color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR )\n	varying vec3 vColor;\n#endif", color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	varying vec3 vColor;\n#endif", color_vertex: "#if defined( USE_COLOR_ALPHA )\n	vColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	vColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n	vColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n	vColor.xyz *= instanceColor.xyz;\n#endif", common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\nstruct GeometricContext {\n	vec3 position;\n	vec3 normal;\n	vec3 viewDir;\n#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n	return dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n	return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	return vec2( u, v );\n}", cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n	#define cubeUV_maxMipLevel 8.0\n	#define cubeUV_minMipLevel 4.0\n	#define cubeUV_maxTileSize 256.0\n	#define cubeUV_minTileSize 16.0\n	float getFace( vec3 direction ) {\n		vec3 absDirection = abs( direction );\n		float face = - 1.0;\n		if ( absDirection.x > absDirection.z ) {\n			if ( absDirection.x > absDirection.y )\n				face = direction.x > 0.0 ? 0.0 : 3.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		} else {\n			if ( absDirection.z > absDirection.y )\n				face = direction.z > 0.0 ? 2.0 : 5.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		}\n		return face;\n	}\n	vec2 getUV( vec3 direction, float face ) {\n		vec2 uv;\n		if ( face == 0.0 ) {\n			uv = vec2( direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 1.0 ) {\n			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n		} else if ( face == 2.0 ) {\n			uv = vec2( - direction.x, direction.y ) / abs( direction.z );\n		} else if ( face == 3.0 ) {\n			uv = vec2( - direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 4.0 ) {\n			uv = vec2( - direction.x, direction.z ) / abs( direction.y );\n		} else {\n			uv = vec2( direction.x, direction.y ) / abs( direction.z );\n		}\n		return 0.5 * ( uv + 1.0 );\n	}\n	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n		float face = getFace( direction );\n		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n		mipInt = max( mipInt, cubeUV_minMipLevel );\n		float faceSize = exp2( mipInt );\n		float texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n		vec2 f = fract( uv );\n		uv += 0.5 - f;\n		if ( face > 2.0 ) {\n			uv.y += faceSize;\n			face -= 3.0;\n		}\n		uv.x += face * faceSize;\n		if ( mipInt < cubeUV_maxMipLevel ) {\n			uv.y += 2.0 * cubeUV_maxTileSize;\n		}\n		uv.y += filterInt * 2.0 * cubeUV_minTileSize;\n		uv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n		uv *= texelSize;\n		vec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.x += texelSize;\n		vec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.y += texelSize;\n		vec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.x -= texelSize;\n		vec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		vec3 tm = mix( tl, tr, f.x );\n		vec3 bm = mix( bl, br, f.x );\n		return mix( tm, bm, f.y );\n	}\n	#define r0 1.0\n	#define v0 0.339\n	#define m0 - 2.0\n	#define r1 0.8\n	#define v1 0.276\n	#define m1 - 1.0\n	#define r4 0.4\n	#define v4 0.046\n	#define m4 2.0\n	#define r5 0.305\n	#define v5 0.016\n	#define m5 3.0\n	#define r6 0.21\n	#define v6 0.0038\n	#define m6 4.0\n	float roughnessToMip( float roughness ) {\n		float mip = 0.0;\n		if ( roughness >= r1 ) {\n			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n		} else if ( roughness >= r4 ) {\n			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n		} else if ( roughness >= r5 ) {\n			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n		} else if ( roughness >= r6 ) {\n			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n		} else {\n			mip = - 2.0 * log2( 1.16 * roughness );		}\n		return mip;\n	}\n	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n		float mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n		float mipF = fract( mip );\n		float mipInt = floor( mip );\n		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n		if ( mipF == 0.0 ) {\n			return vec4( color0, 1.0 );\n		} else {\n			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n			return vec4( mix( color0, color1, mipF ), 1.0 );\n		}\n	}\n#endif", defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n	mat3 m = mat3( instanceMatrix );\n	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n	transformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif", displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif", displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif", emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif", emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif", encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );", encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n	return value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n	float maxComponent = max( max( value.r, value.g ), value.b );\n	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.r, max( value.g, value.b ) );\n	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n	M = ceil( M * 255.0 ) / 255.0;\n	return vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.r, max( value.g, value.b ) );\n	float D = max( maxRange / maxRGB, 1.0 );\n	D = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n	vec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n	vec4 vResult;\n	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n	vResult.w = fract( Le );\n	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n	return vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n	float Le = value.z * 255.0 + value.w;\n	vec3 Xp_Y_XYZp;\n	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n	vec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n	return vec4( max( vRGB, 0.0 ), 1.0 );\n}", envmap_fragment: "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToFrag;\n		if ( isOrthographic ) {\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n		envColor = envMapTexelToLinear( envColor );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif", envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	uniform int maxMipLevel;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	\n#endif", envmap_pars_fragment: "#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif", envmap_pars_vertex: "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif", envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n	#ifdef ENVMAP_MODE_REFRACTION\n		uniform float refractionRatio;\n	#endif\n	vec3 getIBLIrradiance( const in GeometricContext geometry ) {\n		#if defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n			return PI * envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n		#if defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 reflectVec;\n			#ifdef ENVMAP_MODE_REFLECTION\n				reflectVec = reflect( - viewDir, normal );\n				reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n			#else\n				reflectVec = refract( - viewDir, normal, refractionRatio );\n			#endif\n			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n			return envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n#endif", envmap_vertex: "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex;\n		if ( isOrthographic ) {\n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif", fog_vertex: "#ifdef USE_FOG\n	vFogDepth = - mvPosition.z;\n#endif", fog_pars_vertex: "#ifdef USE_FOG\n	varying float vFogDepth;\n#endif", fog_fragment: "#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif", fog_pars_fragment: "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float vFogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif", gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n	uniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n	#ifdef USE_GRADIENTMAP\n		return texture2D( gradientMap, coord ).rgb;\n	#else\n		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n	#endif\n}", lightmap_fragment: "#ifdef USE_LIGHTMAP\n	vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n	vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		lightMapIrradiance *= PI;\n	#endif\n	reflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif", lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif", lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n	vLightBack = vec3( 0.0 );\n	vIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		getPointLightInfo( pointLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		getSpotLightInfo( spotLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		#ifdef DOUBLE_SIDED\n			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif", lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n	vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	return irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n	#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n		if ( cutoffDistance > 0.0 ) {\n			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n		}\n		return distanceFalloff;\n	#else\n		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n		}\n		return 1.0;\n	#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n	return smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n		light.color = directionalLight.color;\n		light.direction = directionalLight.direction;\n		light.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n		vec3 lVector = pointLight.position - geometry.position;\n		light.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		light.color = pointLight.color;\n		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n		light.visible = ( light.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n		vec3 lVector = spotLight.position - geometry.position;\n		light.direction = normalize( lVector );\n		float angleCos = dot( light.direction, spotLight.direction );\n		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n		if ( spotAttenuation > 0.0 ) {\n			float lightDistance = length( lVector );\n			light.color = spotLight.color * spotAttenuation;\n			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n			light.visible = ( light.color != vec3( 0.0 ) );\n		} else {\n			light.color = vec3( 0.0 );\n			light.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n		float dotNL = dot( geometry.normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		return irradiance;\n	}\n#endif", lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;", lights_toon_pars_fragment: "varying vec3 vViewPosition;\nstruct ToonMaterial {\n	vec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )	(0)", lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;", lights_phong_pars_fragment: "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n	vec3 diffuseColor;\n	vec3 specularColor;\n	float specularShininess;\n	float specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )	(0)", lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n	#ifdef SPECULAR\n		float specularIntensityFactor = specularIntensity;\n		vec3 specularTintFactor = specularTint;\n		#ifdef USE_SPECULARINTENSITYMAP\n			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n		#endif\n		#ifdef USE_SPECULARTINTMAP\n			specularTintFactor *= specularTintMapTexelToLinear( texture2D( specularTintMap, vUv ) ).rgb;\n		#endif\n		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n	#else\n		float specularIntensityFactor = 1.0;\n		vec3 specularTintFactor = vec3( 1.0 );\n		material.specularF90 = 1.0;\n	#endif\n	material.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularTintFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n	material.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n	material.clearcoat = clearcoat;\n	material.clearcoatRoughness = clearcoatRoughness;\n	material.clearcoatF0 = vec3( 0.04 );\n	material.clearcoatF90 = 1.0;\n	#ifdef USE_CLEARCOATMAP\n		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n	#endif\n	#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n	#endif\n	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n	material.sheenTint = sheenTint;\n#endif", lights_physical_pars_fragment: "struct PhysicalMaterial {\n	vec3 diffuseColor;\n	float roughness;\n	vec3 specularColor;\n	float specularF90;\n	#ifdef USE_CLEARCOAT\n		float clearcoat;\n		float clearcoatRoughness;\n		vec3 clearcoatF0;\n		float clearcoatF90;\n	#endif\n	#ifdef USE_SHEEN\n		vec3 sheenTint;\n	#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n	return fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	return specularColor * fab.x + specularF90 * fab.y;\n}\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	vec3 FssEss = specularColor * fab.x + specularF90 * fab.y;\n	float Ess = fab.x + fab.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometry.normal;\n		vec3 viewDir = geometry.viewDir;\n		vec3 position = geometry.position;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.roughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifdef USE_CLEARCOAT\n		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = dotNLcc * directLight.color;\n		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		reflectedLight.directSpecular += irradiance * BRDF_Sheen( material.roughness, directLight.direction, geometry, material.sheenTint );\n	#else\n		reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n	#endif\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef USE_CLEARCOAT\n		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n	reflectedLight.indirectSpecular += radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}", lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n	geometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointLightInfo( pointLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		pointLightShadow = pointLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotLightInfo( spotLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		spotLightShadow = spotLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalLightInfo( directionalLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directionalLightShadow = directionalLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	irradiance += getLightProbeIrradiance( lightProbe, geometry );\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif", lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			lightMapIrradiance *= PI;\n		#endif\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n		iblIrradiance += getIBLIrradiance( geometry );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n	#ifdef USE_CLEARCOAT\n		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n	#endif\n#endif", lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif", logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif", logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif", logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n		varying float vIsPerspective;\n	#else\n		uniform float logDepthBufFC;\n	#endif\n#endif", logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n	#else\n		if ( isPerspectiveMatrix( projectionMatrix ) ) {\n			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n			gl_Position.z *= gl_Position.w;\n		}\n	#endif\n#endif", map_fragment: "#ifdef USE_MAP\n	vec4 texelColor = texture2D( map, vUv );\n	texelColor = mapTexelToLinear( texelColor );\n	diffuseColor *= texelColor;\n#endif", map_pars_fragment: "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif", map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n	vec4 mapTexel = texture2D( map, uv );\n	diffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif", map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	uniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif", metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vUv );\n	metalnessFactor *= texelMetalness.b;\n#endif", metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif", morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n	objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n	objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n	objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif", morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n	uniform float morphTargetBaseInfluence;\n	#ifndef USE_MORPHNORMALS\n		uniform float morphTargetInfluences[ 8 ];\n	#else\n		uniform float morphTargetInfluences[ 4 ];\n	#endif\n#endif", morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	transformed += morphTarget0 * morphTargetInfluences[ 0 ];\n	transformed += morphTarget1 * morphTargetInfluences[ 1 ];\n	transformed += morphTarget2 * morphTargetInfluences[ 2 ];\n	transformed += morphTarget3 * morphTargetInfluences[ 3 ];\n	#ifndef USE_MORPHNORMALS\n		transformed += morphTarget4 * morphTargetInfluences[ 4 ];\n		transformed += morphTarget5 * morphTargetInfluences[ 5 ];\n		transformed += morphTarget6 * morphTargetInfluences[ 6 ];\n		transformed += morphTarget7 * morphTargetInfluences[ 7 ];\n	#endif\n#endif", normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	#ifdef USE_TANGENT\n		vec3 tangent = normalize( vTangent );\n		vec3 bitangent = normalize( vBitangent );\n		#ifdef DOUBLE_SIDED\n			tangent = tangent * faceDirection;\n			bitangent = bitangent * faceDirection;\n		#endif\n		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n			mat3 vTBN = mat3( tangent, bitangent, normal );\n		#endif\n	#endif\n#endif\nvec3 geometryNormal = normal;", normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n	#ifdef USE_TANGENT\n		normal = normalize( vTBN * mapN );\n	#else\n		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n	#endif\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif", normal_pars_fragment: "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif", normal_pars_vertex: "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif", normal_vertex: "#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif", normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n		vec3 N = surf_norm;\n		vec3 q1perp = cross( q1, N );\n		vec3 q0perp = cross( N, q0 );\n		vec3 T = q1perp * st0.x + q0perp * st1.x;\n		vec3 B = q1perp * st0.y + q0perp * st1.y;\n		float det = max( dot( T, T ), dot( B, B ) );\n		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n	}\n#endif", clearcoat_normal_fragment_begin: "#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal = geometryNormal;\n#endif", clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n	#ifdef USE_TANGENT\n		clearcoatNormal = normalize( vTBN * clearcoatMapN );\n	#else\n		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n	#endif\n#endif", clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n	uniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif", output_fragment: "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );", packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n	vec4 r = vec4( fract( v * PackFactors ), v );\n	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n	return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}", premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif", project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n	mvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;", dithering_fragment: "#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif", dithering_pars_fragment: "#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif", roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vUv );\n	roughnessFactor *= texelRoughness.g;\n#endif", roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif", shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n	}\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n		float occlusion = 1.0;\n		vec2 distribution = texture2DDistribution( shadow, uv );\n		float hard_shadow = step( compare , distribution.x );\n		if (hard_shadow != 1.0 ) {\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n		}\n		return occlusion;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n		bool frustumTest = all( frustumTestVec );\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx = texelSize.x;\n			float dy = texelSize.y;\n			vec2 uv = shadowCoord.xy;\n			vec2 f = fract( uv * shadowMapSize + 0.5 );\n			uv -= f * texelSize;\n			shadow = (\n				texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n						  f.x ),\n					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n						  f.x ),\n					 f.y )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_VSM )\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return shadow;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n		vec3 lightToPosition = shadowCoord.xyz;\n		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;\n		vec3 bd3D = normalize( lightToPosition );\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif", shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif", shadowmap_vertex: "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		vec4 shadowWorldPosition;\n	#endif\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n#endif", shadowmask_pars_fragment: "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLightShadows[ i ];\n		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#endif\n	return shadow;\n}", skinbase_vertex: "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif", skinning_pars_vertex: "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	#ifdef BONE_TEXTURE\n		uniform highp sampler2D boneTexture;\n		uniform int boneTextureSize;\n		mat4 getBoneMatrix( const in float i ) {\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureSize ) );\n			float y = floor( j / float( boneTextureSize ) );\n			float dx = 1.0 / float( boneTextureSize );\n			float dy = 1.0 / float( boneTextureSize );\n			y = dy * ( y + 0.5 );\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n			mat4 bone = mat4( v1, v2, v3, v4 );\n			return bone;\n		}\n	#else\n		uniform mat4 boneMatrices[ MAX_BONES ];\n		mat4 getBoneMatrix( const in float i ) {\n			mat4 bone = boneMatrices[ int(i) ];\n			return bone;\n		}\n	#endif\n#endif", skinning_vertex: "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif", skinnormal_vertex: "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif", specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif", specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif", tonemapping_fragment: "#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif", tonemapping_pars_fragment: "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n	return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n	return a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	const mat3 ACESInputMat = mat3(\n		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),\n		vec3( 0.04823, 0.01566, 0.83777 )\n	);\n	const mat3 ACESOutputMat = mat3(\n		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),\n		vec3( -0.07367, -0.00605,  1.07602 )\n	);\n	color *= toneMappingExposure / 0.6;\n	color = ACESInputMat * color;\n	color = RRTAndODTFit( color );\n	color = ACESOutputMat * color;\n	return saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }", transmission_fragment: "#ifdef USE_TRANSMISSION\n	float transmissionAlpha = 1.0;\n	float transmissionFactor = transmission;\n	float thicknessFactor = thickness;\n	#ifdef USE_TRANSMISSIONMAP\n		transmissionFactor *= texture2D( transmissionMap, vUv ).r;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		thicknessFactor *= texture2D( thicknessMap, vUv ).g;\n	#endif\n	vec3 pos = vWorldPosition;\n	vec3 v = normalize( cameraPosition - pos );\n	vec3 n = inverseTransformDirection( normal, viewMatrix );\n	vec4 transmission = getIBLVolumeRefraction(\n		n, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n		attenuationTint, attenuationDistance );\n	totalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n	transmissionAlpha = transmission.a;\n#endif", transmission_pars_fragment: "#ifdef USE_TRANSMISSION\n	uniform float transmission;\n	uniform float thickness;\n	uniform float attenuationDistance;\n	uniform vec3 attenuationTint;\n	#ifdef USE_TRANSMISSIONMAP\n		uniform sampler2D transmissionMap;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		uniform sampler2D thicknessMap;\n	#endif\n	uniform vec2 transmissionSamplerSize;\n	uniform sampler2D transmissionSamplerMap;\n	uniform mat4 modelMatrix;\n	uniform mat4 projectionMatrix;\n	varying vec3 vWorldPosition;\n	vec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {\n		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n		vec3 modelScale;\n		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n		return normalize( refractionVector ) * thickness * modelScale;\n	}\n	float applyIorToRoughness( float roughness, float ior ) {\n		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n	}\n	vec4 getTransmissionSample( vec2 fragCoord, float roughness, float ior ) {\n		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n		#ifdef TEXTURE_LOD_EXT\n			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n		#else\n			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n		#endif\n	}\n	vec3 applyVolumeAttenuation( vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance ) {\n		if ( attenuationDistance == 0.0 ) {\n			return radiance;\n		} else {\n			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;\n		}\n	}\n	vec4 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 diffuseColor, vec3 specularColor, float specularF90,\n		vec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,\n		vec3 attenuationColor, float attenuationDistance ) {\n		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n		vec3 refractedRayExit = position + transmissionRay;\n		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n		vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n		refractionCoords += 1.0;\n		refractionCoords /= 2.0;\n		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n	}\n#endif", uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n	varying vec2 vUv;\n#endif", uv_pars_vertex: "#ifdef USE_UV\n	#ifdef UVS_VERTEX_ONLY\n		vec2 vUv;\n	#else\n		varying vec2 vUv;\n	#endif\n	uniform mat3 uvTransform;\n#endif", uv_vertex: "#ifdef USE_UV\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif", uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	varying vec2 vUv2;\n#endif", uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n	uniform mat3 uv2Transform;\n#endif", uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif", worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n	vec4 worldPosition = vec4( transformed, 1.0 );\n	#ifdef USE_INSTANCING\n		worldPosition = instanceMatrix * worldPosition;\n	#endif\n	worldPosition = modelMatrix * worldPosition;\n#endif", background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n	vec4 texColor = texture2D( t2D, vUv );\n	gl_FragColor = mapTexelToLinear( texColor );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}", background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}", cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n	vec3 vReflect = vWorldDirection;\n	#include <envmap_fragment>\n	gl_FragColor = envColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}", cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}", depth_frag: "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <logdepthbuf_fragment>\n	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( fragCoordZ );\n	#endif\n}", depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vHighPrecisionZW = gl_Position.zw;\n}", distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}", distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}", equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV = equirectUv( direction );\n	vec4 texColor = texture2D( tEquirect, sampleUV );\n	gl_FragColor = mapTexelToLinear( texColor );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}", equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}", linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}", linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vLineDistance = scale * lineDistance;\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}", meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinbase_vertex>\n		#include <skinnormal_vertex>\n		#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}", meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <emissivemap_fragment>\n	#ifdef DOUBLE_SIDED\n		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n	#else\n		reflectedLight.indirectDiffuse += vIndirectFront;\n	#endif\n	#include <lightmap_fragment>\n	reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n	#ifdef DOUBLE_SIDED\n		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n	#else\n		reflectedLight.directDiffuse = vLightFront;\n	#endif\n	reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <lights_lambert_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}", meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n		matcapColor = matcapTexelToLinear( matcapColor );\n	#else\n		vec4 matcapColor = vec4( 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}", meshnormal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}", meshnormal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}", meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}", meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n	#define IOR\n	#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n	uniform float ior;\n#endif\n#ifdef SPECULAR\n	uniform float specularIntensity;\n	uniform vec3 specularTint;\n	#ifdef USE_SPECULARINTENSITYMAP\n		uniform sampler2D specularIntensityMap;\n	#endif\n	#ifdef USE_SPECULARTINTMAP\n		uniform sampler2D specularTintMap;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheenTint;\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n	#include <transmission_fragment>\n	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n	#ifdef USE_CLEARCOAT\n		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n		outgoingLight = outgoingLight * ( 1.0 - clearcoat * Fcc ) + clearcoatSpecular * clearcoat;\n	#endif\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n	varying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n	vWorldPosition = worldPosition.xyz;\n#endif\n}", meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}", points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}", points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}", shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}", shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <begin_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}", sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}", sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n	vec2 scale;\n	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}"}, ri = {common: {diffuse: {value: new three_module_Color(16777215)}, opacity: {value: 1}, map: {value: null}, uvTransform: {value: new Matrix3}, uv2Transform: {value: new Matrix3}, alphaMap: {value: null}, alphaTest: {value: 0}}, specularmap: {specularMap: {value: null}}, envmap: {envMap: {value: null}, flipEnvMap: {value: -1}, reflectivity: {value: 1}, ior: {value: 1.5}, refractionRatio: {value: 0.98}, maxMipLevel: {value: 0}}, aomap: {aoMap: {value: null}, aoMapIntensity: {value: 1}}, lightmap: {lightMap: {value: null}, lightMapIntensity: {value: 1}}, emissivemap: {emissiveMap: {value: null}}, bumpmap: {bumpMap: {value: null}, bumpScale: {value: 1}}, normalmap: {normalMap: {value: null}, normalScale: {value: new Vector2(1, 1)}}, displacementmap: {displacementMap: {value: null}, displacementScale: {value: 1}, displacementBias: {value: 0}}, roughnessmap: {roughnessMap: {value: null}}, metalnessmap: {metalnessMap: {value: null}}, gradientmap: {gradientMap: {value: null}}, fog: {fogDensity: {value: 0.00025}, fogNear: {value: 1}, fogFar: {value: 2e3}, fogColor: {value: new three_module_Color(16777215)}}, lights: {ambientLightColor: {value: []}, lightProbe: {value: []}, directionalLights: {value: [], properties: {direction: {}, color: {}}}, directionalLightShadows: {value: [], properties: {shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {}}}, directionalShadowMap: {value: []}, directionalShadowMatrix: {value: []}, spotLights: {value: [], properties: {color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {}}}, spotLightShadows: {value: [], properties: {shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {}}}, spotShadowMap: {value: []}, spotShadowMatrix: {value: []}, pointLights: {value: [], properties: {color: {}, position: {}, decay: {}, distance: {}}}, pointLightShadows: {value: [], properties: {shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {}, shadowCameraNear: {}, shadowCameraFar: {}}}, pointShadowMap: {value: []}, pointShadowMatrix: {value: []}, hemisphereLights: {value: [], properties: {direction: {}, skyColor: {}, groundColor: {}}}, rectAreaLights: {value: [], properties: {color: {}, position: {}, width: {}, height: {}}}, ltc_1: {value: null}, ltc_2: {value: null}}, points: {diffuse: {value: new three_module_Color(16777215)}, opacity: {value: 1}, size: {value: 1}, scale: {value: 1}, map: {value: null}, alphaMap: {value: null}, alphaTest: {value: 0}, uvTransform: {value: new Matrix3}}, sprite: {diffuse: {value: new three_module_Color(16777215)}, opacity: {value: 1}, center: {value: new Vector2(0.5, 0.5)}, rotation: {value: 0}, map: {value: null}, alphaMap: {value: null}, alphaTest: {value: 0}, uvTransform: {value: new Matrix3}}}, oi = {basic: {uniforms: Xe([ri.common, ri.specularmap, ri.envmap, ri.aomap, ri.lightmap, ri.fog]), vertexShader: ni.meshbasic_vert, fragmentShader: ni.meshbasic_frag}, lambert: {uniforms: Xe([ri.common, ri.specularmap, ri.envmap, ri.aomap, ri.lightmap, ri.emissivemap, ri.fog, ri.lights, {emissive: {value: new three_module_Color(0)}}]), vertexShader: ni.meshlambert_vert, fragmentShader: ni.meshlambert_frag}, phong: {uniforms: Xe([ri.common, ri.specularmap, ri.envmap, ri.aomap, ri.lightmap, ri.emissivemap, ri.bumpmap, ri.normalmap, ri.displacementmap, ri.fog, ri.lights, {emissive: {value: new three_module_Color(0)}, specular: {value: new three_module_Color(1118481)}, shininess: {value: 30}}]), vertexShader: ni.meshphong_vert, fragmentShader: ni.meshphong_frag}, standard: {uniforms: Xe([ri.common, ri.envmap, ri.aomap, ri.lightmap, ri.emissivemap, ri.bumpmap, ri.normalmap, ri.displacementmap, ri.roughnessmap, ri.metalnessmap, ri.fog, ri.lights, {emissive: {value: new three_module_Color(0)}, roughness: {value: 1}, metalness: {value: 0}, envMapIntensity: {value: 1}}]), vertexShader: ni.meshphysical_vert, fragmentShader: ni.meshphysical_frag}, toon: {uniforms: Xe([ri.common, ri.aomap, ri.lightmap, ri.emissivemap, ri.bumpmap, ri.normalmap, ri.displacementmap, ri.gradientmap, ri.fog, ri.lights, {emissive: {value: new three_module_Color(0)}}]), vertexShader: ni.meshtoon_vert, fragmentShader: ni.meshtoon_frag}, matcap: {uniforms: Xe([ri.common, ri.bumpmap, ri.normalmap, ri.displacementmap, ri.fog, {matcap: {value: null}}]), vertexShader: ni.meshmatcap_vert, fragmentShader: ni.meshmatcap_frag}, points: {uniforms: Xe([ri.points, ri.fog]), vertexShader: ni.points_vert, fragmentShader: ni.points_frag}, dashed: {uniforms: Xe([ri.common, ri.fog, {scale: {value: 1}, dashSize: {value: 1}, totalSize: {value: 2}}]), vertexShader: ni.linedashed_vert, fragmentShader: ni.linedashed_frag}, depth: {uniforms: Xe([ri.common, ri.displacementmap]), vertexShader: ni.depth_vert, fragmentShader: ni.depth_frag}, normal: {uniforms: Xe([ri.common, ri.bumpmap, ri.normalmap, ri.displacementmap, {opacity: {value: 1}}]), vertexShader: ni.meshnormal_vert, fragmentShader: ni.meshnormal_frag}, sprite: {uniforms: Xe([ri.sprite, ri.fog]), vertexShader: ni.sprite_vert, fragmentShader: ni.sprite_frag}, background: {uniforms: {uvTransform: {value: new Matrix3}, t2D: {value: null}}, vertexShader: ni.background_vert, fragmentShader: ni.background_frag}, cube: {uniforms: Xe([ri.envmap, {opacity: {value: 1}}]), vertexShader: ni.cube_vert, fragmentShader: ni.cube_frag}, equirect: {uniforms: {tEquirect: {value: null}}, vertexShader: ni.equirect_vert, fragmentShader: ni.equirect_frag}, distanceRGBA: {uniforms: Xe([ri.common, ri.displacementmap, {referencePosition: {value: new three_module_Vector3}, nearDistance: {value: 1}, farDistance: {value: 1e3}}]), vertexShader: ni.distanceRGBA_vert, fragmentShader: ni.distanceRGBA_frag}, shadow: {uniforms: Xe([ri.lights, ri.fog, {color: {value: new three_module_Color(0)}, opacity: {value: 1}}]), vertexShader: ni.shadow_vert, fragmentShader: ni.shadow_frag}};
    function si(t, e, i, n, r) {
      const o = new three_module_Color(0);
      let s, a, l = 0, c = null, u = 0, p = null;
      function m(t, e) {
        i.buffers.color.setClear(t.r, t.g, t.b, e, r);
      }
      return {getClearColor: function () {
        return o;
      }, setClearColor: function (t, e = 1) {
        o.set(t), l = e, m(o, l);
      }, getClearAlpha: function () {
        return l;
      }, setClearAlpha: function (t) {
        l = t, m(o, l);
      }, render: function (i, r) {
        let d = false, _ = true === r.isScene ? r.background : null;
        _ && _.isTexture && (_ = e.get(_));
        const y = t.xr, g = y.getSession && y.getSession();
        g && "additive" === g.environmentBlendMode && (_ = null), null === _ ? m(o, l) : _ && _.isColor && (m(_, 1), d = true), (t.autoClear || d) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), _ && (_.isCubeTexture || _.mapping === h) ? (void 0 === a && (a = new Mesh(new BoxGeometry(1, 1, 1), new ShaderMaterial({name: "BackgroundCubeMaterial", uniforms: je(oi.cube.uniforms), vertexShader: oi.cube.vertexShader, fragmentShader: oi.cube.fragmentShader, side: 1, depthTest: false, depthWrite: false, fog: false})), a.geometry.deleteAttribute("normal"), a.geometry.deleteAttribute("uv"), a.onBeforeRender = function (t, e, i) {
          this.matrixWorld.copyPosition(i.matrixWorld);
        }, Object.defineProperty(a.material, "envMap", {get: function () {
          return this.uniforms.envMap.value;
        }}), n.update(a)), a.material.uniforms.envMap.value = _, a.material.uniforms.flipEnvMap.value = _.isCubeTexture && false === _.isRenderTargetTexture ? -1 : 1, c === _ && u === _.version && p === t.toneMapping || (a.material.needsUpdate = true, c = _, u = _.version, p = t.toneMapping), i.unshift(a, a.geometry, a.material, 0, 0, null)) : _ && _.isTexture && (void 0 === s && (s = new Mesh(new PlaneGeometry(2, 2), new ShaderMaterial({name: "BackgroundMaterial", uniforms: je(oi.background.uniforms), vertexShader: oi.background.vertexShader, fragmentShader: oi.background.fragmentShader, side: 0, depthTest: false, depthWrite: false, fog: false})), s.geometry.deleteAttribute("normal"), Object.defineProperty(s.material, "map", {get: function () {
          return this.uniforms.t2D.value;
        }}), n.update(s)), s.material.uniforms.t2D.value = _, true === _.matrixAutoUpdate && _.updateMatrix(), s.material.uniforms.uvTransform.value.copy(_.matrix), c === _ && u === _.version && p === t.toneMapping || (s.material.needsUpdate = true, c = _, u = _.version, p = t.toneMapping), i.unshift(s, s.geometry, s.material, 0, 0, null));
      }};
    }
    function ai(t, e, i, n) {
      const r = t.getParameter(34921), o = n.isWebGL2 ? null : e.get("OES_vertex_array_object"), s = n.isWebGL2 || null !== o, a = {}, l = p(null);
      let c = l;
      function h(e) {
        return n.isWebGL2 ? t.bindVertexArray(e) : o.bindVertexArrayOES(e);
      }
      function u(e) {
        return n.isWebGL2 ? t.deleteVertexArray(e) : o.deleteVertexArrayOES(e);
      }
      function p(t) {
        const e = [], i = [], n = [];
        for (let t = 0; t < r; t++) e[t] = 0, i[t] = 0, n[t] = 0;
        return {geometry: null, program: null, wireframe: false, newAttributes: e, enabledAttributes: i, attributeDivisors: n, object: t, attributes: {}, index: null};
      }
      function m() {
        const t = c.newAttributes;
        for (let e = 0, i = t.length; e < i; e++) t[e] = 0;
      }
      function d(t) {
        _(t, 0);
      }
      function _(i, r) {
        const o = c.newAttributes, s = c.enabledAttributes, a = c.attributeDivisors;
        if (o[i] = 1, 0 === s[i] && (t.enableVertexAttribArray(i), s[i] = 1), a[i] !== r) {
          (n.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[n.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](i, r), a[i] = r;
        }
      }
      function y() {
        const e = c.newAttributes, i = c.enabledAttributes;
        for (let n = 0, r = i.length; n < r; n++) i[n] !== e[n] && (t.disableVertexAttribArray(n), i[n] = 0);
      }
      function g(e, i, r, o, s, a) {
        true !== n.isWebGL2 || 5124 !== r && 5125 !== r ? t.vertexAttribPointer(e, i, r, o, s, a) : t.vertexAttribIPointer(e, i, r, s, a);
      }
      function x() {
        v(), c !== l && (c = l, h(c.object));
      }
      function v() {
        l.geometry = null, l.program = null, l.wireframe = false;
      }
      return {setup: function (r, l, u, x, v) {
        let b = false;
        if (s) {
          const e = function (e, i, r) {
            const s = true === r.wireframe;
            let l = a[e.id];
            void 0 === l && (l = {}, a[e.id] = l);
            let c = l[i.id];
            void 0 === c && (c = {}, l[i.id] = c);
            let h = c[s];
            void 0 === h && (h = p(n.isWebGL2 ? t.createVertexArray() : o.createVertexArrayOES()), c[s] = h);
            return h;
          }(x, u, l);
          c !== e && (c = e, h(c.object)), b = function (t, e) {
            const i = c.attributes, n = t.attributes;
            let r = 0;
            for (const t in n) {
              const e = i[t], o = n[t];
              if (void 0 === e) return true;
              if (e.attribute !== o) return true;
              if (e.data !== o.data) return true;
              r++;
            }
            return c.attributesNum !== r || c.index !== e;
          }(x, v), b && function (t, e) {
            const i = {}, n = t.attributes;
            let r = 0;
            for (const t in n) {
              const e = n[t], o = {};
              o.attribute = e, e.data && (o.data = e.data), i[t] = o, r++;
            }
            c.attributes = i, c.attributesNum = r, c.index = e;
          }(x, v);
        } else {
          const t = true === l.wireframe;
          c.geometry === x.id && c.program === u.id && c.wireframe === t || (c.geometry = x.id, c.program = u.id, c.wireframe = t, b = true);
        }
        true === r.isInstancedMesh && (b = true), null !== v && i.update(v, 34963), b && (!function (r, o, s, a) {
          if (false === n.isWebGL2 && (r.isInstancedMesh || a.isInstancedBufferGeometry) && null === e.get("ANGLE_instanced_arrays")) return;
          m();
          const l = a.attributes, c = s.getAttributes(), h = o.defaultAttributeValues;
          for (const e in c) {
            const n = c[e];
            if (n.location >= 0) {
              let o = l[e];
              if (void 0 === o && ("instanceMatrix" === e && r.instanceMatrix && (o = r.instanceMatrix), "instanceColor" === e && r.instanceColor && (o = r.instanceColor)), void 0 !== o) {
                const e = o.normalized, s = o.itemSize, l = i.get(o);
                if (void 0 === l) continue;
                const c = l.buffer, h = l.type, u = l.bytesPerElement;
                if (o.isInterleavedBufferAttribute) {
                  const i = o.data, l = i.stride, p = o.offset;
                  if (i && i.isInstancedInterleavedBuffer) {
                    for (let t = 0; t < n.locationSize; t++) _(n.location + t, i.meshPerAttribute);
                    true !== r.isInstancedMesh && void 0 === a._maxInstanceCount && (a._maxInstanceCount = i.meshPerAttribute * i.count);
                  } else for (let t = 0; t < n.locationSize; t++) d(n.location + t);
                  t.bindBuffer(34962, c);
                  for (let t = 0; t < n.locationSize; t++) g(n.location + t, s / n.locationSize, h, e, l * u, (p + s / n.locationSize * t) * u);
                } else {
                  if (o.isInstancedBufferAttribute) {
                    for (let t = 0; t < n.locationSize; t++) _(n.location + t, o.meshPerAttribute);
                    true !== r.isInstancedMesh && void 0 === a._maxInstanceCount && (a._maxInstanceCount = o.meshPerAttribute * o.count);
                  } else for (let t = 0; t < n.locationSize; t++) d(n.location + t);
                  t.bindBuffer(34962, c);
                  for (let t = 0; t < n.locationSize; t++) g(n.location + t, s / n.locationSize, h, e, s * u, s / n.locationSize * t * u);
                }
              } else if (void 0 !== h) {
                const i = h[e];
                if (void 0 !== i) switch (i.length) {
                  case 2:
                    t.vertexAttrib2fv(n.location, i);
                    break;
                  case 3:
                    t.vertexAttrib3fv(n.location, i);
                    break;
                  case 4:
                    t.vertexAttrib4fv(n.location, i);
                    break;
                  default:
                    t.vertexAttrib1fv(n.location, i);
                }
              }
            }
          }
          y();
        }(r, l, u, x), null !== v && t.bindBuffer(34963, i.get(v).buffer));
      }, reset: x, resetDefaultState: v, dispose: function () {
        x();
        for (const t in a) {
          const e = a[t];
          for (const t in e) {
            const i = e[t];
            for (const t in i) u(i[t].object), delete i[t];
            delete e[t];
          }
          delete a[t];
        }
      }, releaseStatesOfGeometry: function (t) {
        if (void 0 === a[t.id]) return;
        const e = a[t.id];
        for (const t in e) {
          const i = e[t];
          for (const t in i) u(i[t].object), delete i[t];
          delete e[t];
        }
        delete a[t.id];
      }, releaseStatesOfProgram: function (t) {
        for (const e in a) {
          const i = a[e];
          if (void 0 === i[t.id]) continue;
          const n = i[t.id];
          for (const t in n) u(n[t].object), delete n[t];
          delete i[t.id];
        }
      }, initAttributes: m, enableAttribute: d, disableUnusedAttributes: y};
    }
    function li(t, e, i, n) {
      const r = n.isWebGL2;
      let o;
      this.setMode = function (t) {
        o = t;
      }, this.render = function (e, n) {
        t.drawArrays(o, e, n), i.update(n, o, 1);
      }, this.renderInstances = function (n, s, a) {
        if (0 === a) return;
        let l, c;
        if (r) l = t, c = "drawArraysInstanced"; else if (l = e.get("ANGLE_instanced_arrays"), c = "drawArraysInstancedANGLE", null === l) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
        l[c](o, n, s, a), i.update(s, o, a);
      };
    }
    function ci(t, e, i) {
      let n;
      function r(e) {
        if ("highp" === e) {
          if (t.getShaderPrecisionFormat(35633, 36338).precision > 0 && t.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp";
          e = "mediump";
        }
        return "mediump" === e && t.getShaderPrecisionFormat(35633, 36337).precision > 0 && t.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp";
      }
      const o = "undefined" != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && t instanceof WebGL2ComputeRenderingContext;
      let s = void 0 !== i.precision ? i.precision : "highp";
      const a = r(s);
      a !== s && (console.warn("THREE.WebGLRenderer:", s, "not supported, using", a, "instead."), s = a);
      const l = o || e.has("WEBGL_draw_buffers"), c = true === i.logarithmicDepthBuffer, h = t.getParameter(34930), u = t.getParameter(35660), p = t.getParameter(3379), m = t.getParameter(34076), d = t.getParameter(34921), _ = t.getParameter(36347), y = t.getParameter(36348), g = t.getParameter(36349), x = u > 0, v = o || e.has("OES_texture_float");
      return {isWebGL2: o, drawBuffers: l, getMaxAnisotropy: function () {
        if (void 0 !== n) return n;
        if (true === e.has("EXT_texture_filter_anisotropic")) {
          const i = e.get("EXT_texture_filter_anisotropic");
          n = t.getParameter(i.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
        } else n = 0;
        return n;
      }, getMaxPrecision: r, precision: s, logarithmicDepthBuffer: c, maxTextures: h, maxVertexTextures: u, maxTextureSize: p, maxCubemapSize: m, maxAttributes: d, maxVertexUniforms: _, maxVaryings: y, maxFragmentUniforms: g, vertexTextures: x, floatFragmentTextures: v, floatVertexTextures: x && v, maxSamples: o ? t.getParameter(36183) : 0};
    }
    function hi(t) {
      const e = this;
      let i = null, n = 0, r = false, o = false;
      const s = new Plane, a = new Matrix3, l = {value: null, needsUpdate: false};
      function c() {
        l.value !== i && (l.value = i, l.needsUpdate = n > 0), e.numPlanes = n, e.numIntersection = 0;
      }
      function h(t, i, n, r) {
        const o = null !== t ? t.length : 0;
        let c = null;
        if (0 !== o) {
          if (c = l.value, true !== r || null === c) {
            const e = n + 4 * o, r = i.matrixWorldInverse;
            a.getNormalMatrix(r), (null === c || c.length < e) && (c = new Float32Array(e));
            for (let e = 0; e !== o; ++e, i += 4) s.copy(t[e]).applyMatrix4(r, a), s.normal.toArray(c, i), c[i + 3] = s.constant;
          }
          l.value = c, l.needsUpdate = true;
        }
        return e.numPlanes = o, e.numIntersection = 0, c;
      }
      this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function (t, e, o) {
        const s = 0 !== t.length || e || 0 !== n || r;
        return r = e, i = h(t, o, 0), n = t.length, s;
      }, this.beginShadows = function () {
        o = true, h(null);
      }, this.endShadows = function () {
        o = false, c();
      }, this.setState = function (e, s, a) {
        const u = e.clippingPlanes, p = e.clipIntersection, m = e.clipShadows, d = t.get(e);
        if (!r || null === u || 0 === u.length || o && !m) o ? h(null) : c(); else {
          const t = o ? 0 : n, e = 4 * t;
          let r = d.clippingState || null;
          l.value = r, r = h(u, s, e, a);
          for (let t = 0; t !== e; ++t) r[t] = i[t];
          d.clippingState = r, this.numIntersection = p ? this.numPlanes : 0, this.numPlanes += t;
        }
      };
    }
    function ui(t) {
      let e = new WeakMap;
      function n(t) {
        const i = t.target;
        i.removeEventListener("dispose", n);
        const r = e.get(i);
        void 0 !== r && (e.delete(i), r.dispose());
      }
      return {get: function (r) {
        if (r && r.isTexture && false === r.isRenderTargetTexture) {
          const o = r.mapping;
          if (o === l || o === c) {
            if (e.has(r)) {
              return r.mapping === l ? e.get(r).texture.mapping = s : r.mapping === c && (e.get(r).texture.mapping = a), e.get(r).texture;
            }
            {
              const o = r.image;
              if (o && o.height > 0) {
                const s = t.getRenderTarget(), a = new WebGLCubeRenderTarget(o.height / 2);
                return a.fromEquirectangularTexture(t, r), e.set(r, a), t.setRenderTarget(s), r.addEventListener("dispose", n), (r.mapping === l ? a.texture.mapping = s : r.mapping === c && (a.texture.mapping = a), a.texture);
              }
              return null;
            }
          }
        }
        return r;
      }, dispose: function () {
        e = new WeakMap;
      }};
    }
    oi.physical = {uniforms: Xe([oi.standard.uniforms, {clearcoat: {value: 0}, clearcoatMap: {value: null}, clearcoatRoughness: {value: 0}, clearcoatRoughnessMap: {value: null}, clearcoatNormalScale: {value: new Vector2(1, 1)}, clearcoatNormalMap: {value: null}, sheenTint: {value: new three_module_Color(0)}, transmission: {value: 0}, transmissionMap: {value: null}, transmissionSamplerSize: {value: new Vector2}, transmissionSamplerMap: {value: null}, thickness: {value: 0}, thicknessMap: {value: null}, attenuationDistance: {value: 0}, attenuationTint: {value: new three_module_Color(0)}, specularIntensity: {value: 0}, specularIntensityMap: {value: null}, specularTint: {value: new three_module_Color(1, 1, 1)}, specularTintMap: {value: null}}]), vertexShader: ni.meshphysical_vert, fragmentShader: ni.meshphysical_frag};
    class OrthographicCamera extends Camera {
      constructor(t = -1, e = 1, i = 1, n = -1, r = 0.1, o = 2e3) {
        super(), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = t, this.right = e, this.top = i, this.bottom = n, this.near = r, this.far = o, this.updateProjectionMatrix();
      }
      copy(t, e) {
        return super.copy(t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = null === t.view ? null : Object.assign({}, t.view), this;
      }
      setViewOffset(t, e, i, n, r, o) {
        null === this.view && (this.view = {enabled: true, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1}), this.view.enabled = true, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = i, this.view.offsetY = n, this.view.width = r, this.view.height = o, this.updateProjectionMatrix();
      }
      clearViewOffset() {
        null !== this.view && (this.view.enabled = false), this.updateProjectionMatrix();
      }
      updateProjectionMatrix() {
        const t = (this.right - this.left) / (2 * this.zoom), e = (this.top - this.bottom) / (2 * this.zoom), i = (this.right + this.left) / 2, n = (this.top + this.bottom) / 2;
        let r = i - t, o = i + t, s = n + e, a = n - e;
        if (null !== this.view && this.view.enabled) {
          const t = (this.right - this.left) / this.view.fullWidth / this.zoom, e = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
          r += t * this.view.offsetX, o = r + t * this.view.width, s -= e * this.view.offsetY, a = s - e * this.view.height;
        }
        this.projectionMatrix.makeOrthographic(r, o, s, a, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
      }
      toJSON(t) {
        const e = super.toJSON(t);
        return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, null !== this.view && (e.object.view = Object.assign({}, this.view)), e;
      }
    }
    OrthographicCamera.prototype.isOrthographicCamera = true;
    class RawShaderMaterial extends ShaderMaterial {
      constructor(t) {
        super(t), this.type = "RawShaderMaterial";
      }
    }
    RawShaderMaterial.prototype.isRawShaderMaterial = true;
    const pi = Math.pow(2, 8), mi = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582], di = 5 + mi.length, fi = 20, _i = {[N]: 0, [G]: 1, [z]: 2, 3004: 3, 3005: 4, 3006: 5, [U]: 6}, yi = new OrthographicCamera, {_lodPlanes: gi, _sizeLods: xi, _sigmas: vi} = Ti(), bi = new three_module_Color;
    let wi = null;
    const Si = (1 + Math.sqrt(5)) / 2, Mi = 1 / Si, Ai = [new three_module_Vector3(1, 1, 1), new three_module_Vector3(-1, 1, 1), new three_module_Vector3(1, 1, -1), new three_module_Vector3(-1, 1, -1), new three_module_Vector3(0, Si, Mi), new three_module_Vector3(0, Si, -Mi), new three_module_Vector3(Mi, 0, Si), new three_module_Vector3(-Mi, 0, Si), new three_module_Vector3(Si, Mi, 0), new three_module_Vector3(-Si, Mi, 0)];
    class PMREMGenerator {
      constructor(t) {
        this._renderer = t, this._pingPongRenderTarget = null, this._blurMaterial = function (t) {
          const e = new Float32Array(t), i = new three_module_Vector3(0, 1, 0);
          return new RawShaderMaterial({name: "SphericalGaussianBlur", defines: {n: t}, uniforms: {envMap: {value: null}, samples: {value: 1}, weights: {value: e}, latitudinal: {value: false}, dTheta: {value: 0}, mipInt: {value: 0}, poleAxis: {value: i}, inputEncoding: {value: _i[3e3]}, outputEncoding: {value: _i[3e3]}}, vertexShader: "\n\n		precision mediump float;\n		precision mediump int;\n\n		attribute vec3 position;\n		attribute vec2 uv;\n		attribute float faceIndex;\n\n		varying vec3 vOutputDirection;\n\n		// RH coordinate system; PMREM face-indexing convention\n		vec3 getDirection( vec2 uv, float face ) {\n\n			uv = 2.0 * uv - 1.0;\n\n			vec3 direction = vec3( uv, 1.0 );\n\n			if ( face == 0.0 ) {\n\n				direction = direction.zyx; // ( 1, v, u ) pos x\n\n			} else if ( face == 1.0 ) {\n\n				direction = direction.xzy;\n				direction.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n			} else if ( face == 2.0 ) {\n\n				direction.x *= -1.0; // ( -u, v, 1 ) pos z\n\n			} else if ( face == 3.0 ) {\n\n				direction = direction.zyx;\n				direction.xz *= -1.0; // ( -1, v, -u ) neg x\n\n			} else if ( face == 4.0 ) {\n\n				direction = direction.xzy;\n				direction.xy *= -1.0; // ( -u, -1, v ) neg y\n\n			} else if ( face == 5.0 ) {\n\n				direction.z *= -1.0; // ( u, v, -1 ) neg z\n\n			}\n\n			return direction;\n\n		}\n\n		void main() {\n\n			vOutputDirection = getDirection( uv, faceIndex );\n			gl_Position = vec4( position, 1.0 );\n\n		}\n	", fragmentShader: `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t${"\n\n		uniform int inputEncoding;\n		uniform int outputEncoding;\n\n		#include <encodings_pars_fragment>\n\n		vec4 inputTexelToLinear( vec4 value ) {\n\n			if ( inputEncoding == 0 ) {\n\n				return value;\n\n			} else if ( inputEncoding == 1 ) {\n\n				return sRGBToLinear( value );\n\n			} else if ( inputEncoding == 2 ) {\n\n				return RGBEToLinear( value );\n\n			} else if ( inputEncoding == 3 ) {\n\n				return RGBMToLinear( value, 7.0 );\n\n			} else if ( inputEncoding == 4 ) {\n\n				return RGBMToLinear( value, 16.0 );\n\n			} else if ( inputEncoding == 5 ) {\n\n				return RGBDToLinear( value, 256.0 );\n\n			} else {\n\n				return GammaToLinear( value, 2.2 );\n\n			}\n\n		}\n\n		vec4 linearToOutputTexel( vec4 value ) {\n\n			if ( outputEncoding == 0 ) {\n\n				return value;\n\n			} else if ( outputEncoding == 1 ) {\n\n				return LinearTosRGB( value );\n\n			} else if ( outputEncoding == 2 ) {\n\n				return LinearToRGBE( value );\n\n			} else if ( outputEncoding == 3 ) {\n\n				return LinearToRGBM( value, 7.0 );\n\n			} else if ( outputEncoding == 4 ) {\n\n				return LinearToRGBM( value, 16.0 );\n\n			} else if ( outputEncoding == 5 ) {\n\n				return LinearToRGBD( value, 256.0 );\n\n			} else {\n\n				return LinearToGamma( value, 2.2 );\n\n			}\n\n		}\n\n		vec4 envMapTexelToLinear( vec4 color ) {\n\n			return inputTexelToLinear( color );\n\n		}\n	"}\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`, blending: 0, depthTest: false, depthWrite: false});
        }(fi), this._equirectShader = null, this._cubemapShader = null, this._compileMaterial(this._blurMaterial);
      }
      fromScene(t, e = 0, i = 0.1, n = 100) {
        wi = this._renderer.getRenderTarget();
        const r = this._allocateTargets();
        return this._sceneToCubeUV(t, i, n, r), e > 0 && this._blur(r, 0, 0, e), this._applyPMREM(r), this._cleanup(r), r;
      }
      fromEquirectangular(t) {
        return this._fromTexture(t);
      }
      fromCubemap(t) {
        return this._fromTexture(t);
      }
      compileCubemapShader() {
        null === this._cubemapShader && (this._cubemapShader = Ri(), this._compileMaterial(this._cubemapShader));
      }
      compileEquirectangularShader() {
        null === this._equirectShader && (this._equirectShader = Di(), this._compileMaterial(this._equirectShader));
      }
      dispose() {
        this._blurMaterial.dispose(), null !== this._cubemapShader && this._cubemapShader.dispose(), null !== this._equirectShader && this._equirectShader.dispose();
        for (let t = 0; t < gi.length; t++) gi[t].dispose();
      }
      _cleanup(t) {
        this._pingPongRenderTarget.dispose(), this._renderer.setRenderTarget(wi), t.scissorTest = false, Li(t, 0, 0, t.width, t.height);
      }
      _fromTexture(t) {
        wi = this._renderer.getRenderTarget();
        const e = this._allocateTargets(t);
        return this._textureToCubeUV(t, e), this._applyPMREM(e), this._cleanup(e), e;
      }
      _allocateTargets(t) {
        const e = {magFilter: _, minFilter: _, generateMipmaps: false, type: b, format: 1023, encoding: void 0 !== t && t.type === b && (t.encoding === N || t.encoding === G || t.encoding === U) ? t.encoding : z, depthBuffer: false}, i = Ei(e);
        return i.depthBuffer = !t, this._pingPongRenderTarget = Ei(e), i;
      }
      _compileMaterial(t) {
        const e = new Mesh(gi[0], t);
        this._renderer.compile(e, yi);
      }
      _sceneToCubeUV(t, e, i, n) {
        const r = new PerspectiveCamera(90, 1, e, i), o = [1, -1, 1, 1, 1, 1], s = [1, 1, 1, -1, -1, -1], a = this._renderer, l = a.autoClear, c = a.outputEncoding, h = a.toneMapping;
        a.getClearColor(bi), a.toneMapping = 0, a.outputEncoding = N, a.autoClear = false;
        const u = new MeshBasicMaterial({name: "PMREM.Background", side: 1, depthWrite: false, depthTest: false}), p = new Mesh(new BoxGeometry, u);
        let m = false;
        const d = t.background;
        d ? d.isColor && (u.color.copy(d), t.background = null, m = true) : (u.color.copy(bi), m = true);
        for (let e = 0; e < 6; e++) {
          const i = e % 3;
          0 == i ? (r.up.set(0, o[e], 0), r.lookAt(s[e], 0, 0)) : 1 == i ? (r.up.set(0, 0, o[e]), r.lookAt(0, s[e], 0)) : (r.up.set(0, o[e], 0), r.lookAt(0, 0, s[e])), Li(n, i * pi, e > 2 ? pi : 0, pi, pi), a.setRenderTarget(n), m && a.render(p, r), a.render(t, r);
        }
        p.geometry.dispose(), p.material.dispose(), a.toneMapping = h, a.outputEncoding = c, a.autoClear = l, t.background = d;
      }
      _textureToCubeUV(t, e) {
        const i = this._renderer;
        t.isCubeTexture ? null == this._cubemapShader && (this._cubemapShader = Ri()) : null == this._equirectShader && (this._equirectShader = Di());
        const n = t.isCubeTexture ? this._cubemapShader : this._equirectShader, r = new Mesh(gi[0], n), o = n.uniforms;
        o.envMap.value = t, t.isCubeTexture || o.texelSize.value.set(1 / t.image.width, 1 / t.image.height), o.inputEncoding.value = _i[t.encoding], o.outputEncoding.value = _i[e.texture.encoding], Li(e, 0, 0, 3 * pi, 2 * pi), i.setRenderTarget(e), i.render(r, yi);
      }
      _applyPMREM(t) {
        const e = this._renderer, i = e.autoClear;
        e.autoClear = false;
        for (let e = 1; e < di; e++) {
          const i = Math.sqrt(vi[e] * vi[e] - vi[e - 1] * vi[e - 1]), n = Ai[(e - 1) % Ai.length];
          this._blur(t, e - 1, e, i, n);
        }
        e.autoClear = i;
      }
      _blur(t, e, i, n, r) {
        const o = this._pingPongRenderTarget;
        this._halfBlur(t, o, e, i, n, "latitudinal", r), this._halfBlur(o, t, i, i, n, "longitudinal", r);
      }
      _halfBlur(t, e, i, n, r, o, s) {
        const a = this._renderer, l = this._blurMaterial;
        "latitudinal" !== o && "longitudinal" !== o && console.error("blur direction must be either latitudinal or longitudinal!");
        const c = new Mesh(gi[n], l), h = l.uniforms, u = xi[i] - 1, p = isFinite(r) ? Math.PI / (2 * u) : 2 * Math.PI / 39, m = r / p, d = isFinite(r) ? 1 + Math.floor(3 * m) : fi;
        d > fi && console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${d} samples when the maximum is set to 20`);
        const _ = [];
        let y = 0;
        for (let t = 0; t < fi; ++t) {
          const e = t / m, i = Math.exp(-e * e / 2);
          _.push(i), 0 == t ? y += i : t < d && (y += 2 * i);
        }
        for (let t = 0; t < _.length; t++) _[t] = _[t] / y;
        h.envMap.value = t.texture, h.samples.value = d, h.weights.value = _, h.latitudinal.value = "latitudinal" === o, s && (h.poleAxis.value = s), h.dTheta.value = p, h.mipInt.value = 8 - i, h.inputEncoding.value = _i[t.texture.encoding], h.outputEncoding.value = _i[t.texture.encoding];
        const g = xi[n];
        Li(e, 3 * Math.max(0, pi - 2 * g), (0 === n ? 0 : 2 * pi) + 2 * g * (n > 4 ? n - 8 + 4 : 0), 3 * g, 2 * g), a.setRenderTarget(e), a.render(c, yi);
      }
    }
    function Ti() {
      const t = [], e = [], i = [];
      let n = 8;
      for (let r = 0; r < di; r++) {
        const o = Math.pow(2, n);
        e.push(o);
        let s = 1 / o;
        r > 4 ? s = mi[r - 8 + 4 - 1] : 0 == r && (s = 0), i.push(s);
        const a = 1 / (o - 1), l = -a / 2, c = 1 + a / 2, h = [l, l, c, l, c, c, l, l, c, c, l, c], u = 6, p = 6, m = 3, d = 2, _ = 1, y = new Float32Array(m * p * u), g = new Float32Array(d * p * u), x = new Float32Array(_ * p * u);
        for (let t = 0; t < u; t++) {
          const e = t % 3 * 2 / 3 - 1, i = t > 2 ? 0 : -1, n = [e, i, 0, e + 0.6666666666666666, i, 0, e + 0.6666666666666666, i + 1, 0, e, i, 0, e + 0.6666666666666666, i + 1, 0, e, i + 1, 0];
          y.set(n, m * p * t), g.set(h, d * p * t);
          const r = [t, t, t, t, t, t];
          x.set(r, _ * p * t);
        }
        const v = new BufferGeometry;
        v.setAttribute("position", new BufferAttribute(y, m)), v.setAttribute("uv", new BufferAttribute(g, d)), v.setAttribute("faceIndex", new BufferAttribute(x, _)), t.push(v), n > 4 && n--;
      }
      return {_lodPlanes: t, _sizeLods: e, _sigmas: i};
    }
    function Ei(t) {
      const e = new WebGLRenderTarget(3 * pi, 3 * pi, t);
      return e.texture.mapping = h, e.texture.name = "PMREM.cubeUv", e.scissorTest = true, e;
    }
    function Li(t, e, i, n, r) {
      t.viewport.set(e, i, n, r), t.scissor.set(e, i, n, r);
    }
    function Di() {
      const t = new Vector2(1, 1);
      return new RawShaderMaterial({name: "EquirectangularToCubeUV", uniforms: {envMap: {value: null}, texelSize: {value: t}, inputEncoding: {value: _i[3e3]}, outputEncoding: {value: _i[3e3]}}, vertexShader: "\n\n		precision mediump float;\n		precision mediump int;\n\n		attribute vec3 position;\n		attribute vec2 uv;\n		attribute float faceIndex;\n\n		varying vec3 vOutputDirection;\n\n		// RH coordinate system; PMREM face-indexing convention\n		vec3 getDirection( vec2 uv, float face ) {\n\n			uv = 2.0 * uv - 1.0;\n\n			vec3 direction = vec3( uv, 1.0 );\n\n			if ( face == 0.0 ) {\n\n				direction = direction.zyx; // ( 1, v, u ) pos x\n\n			} else if ( face == 1.0 ) {\n\n				direction = direction.xzy;\n				direction.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n			} else if ( face == 2.0 ) {\n\n				direction.x *= -1.0; // ( -u, v, 1 ) pos z\n\n			} else if ( face == 3.0 ) {\n\n				direction = direction.zyx;\n				direction.xz *= -1.0; // ( -1, v, -u ) neg x\n\n			} else if ( face == 4.0 ) {\n\n				direction = direction.xzy;\n				direction.xy *= -1.0; // ( -u, -1, v ) neg y\n\n			} else if ( face == 5.0 ) {\n\n				direction.z *= -1.0; // ( u, v, -1 ) neg z\n\n			}\n\n			return direction;\n\n		}\n\n		void main() {\n\n			vOutputDirection = getDirection( uv, faceIndex );\n			gl_Position = vec4( position, 1.0 );\n\n		}\n	", fragmentShader: `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t${"\n\n		uniform int inputEncoding;\n		uniform int outputEncoding;\n\n		#include <encodings_pars_fragment>\n\n		vec4 inputTexelToLinear( vec4 value ) {\n\n			if ( inputEncoding == 0 ) {\n\n				return value;\n\n			} else if ( inputEncoding == 1 ) {\n\n				return sRGBToLinear( value );\n\n			} else if ( inputEncoding == 2 ) {\n\n				return RGBEToLinear( value );\n\n			} else if ( inputEncoding == 3 ) {\n\n				return RGBMToLinear( value, 7.0 );\n\n			} else if ( inputEncoding == 4 ) {\n\n				return RGBMToLinear( value, 16.0 );\n\n			} else if ( inputEncoding == 5 ) {\n\n				return RGBDToLinear( value, 256.0 );\n\n			} else {\n\n				return GammaToLinear( value, 2.2 );\n\n			}\n\n		}\n\n		vec4 linearToOutputTexel( vec4 value ) {\n\n			if ( outputEncoding == 0 ) {\n\n				return value;\n\n			} else if ( outputEncoding == 1 ) {\n\n				return LinearTosRGB( value );\n\n			} else if ( outputEncoding == 2 ) {\n\n				return LinearToRGBE( value );\n\n			} else if ( outputEncoding == 3 ) {\n\n				return LinearToRGBM( value, 7.0 );\n\n			} else if ( outputEncoding == 4 ) {\n\n				return LinearToRGBM( value, 16.0 );\n\n			} else if ( outputEncoding == 5 ) {\n\n				return LinearToRGBD( value, 256.0 );\n\n			} else {\n\n				return LinearToGamma( value, 2.2 );\n\n			}\n\n		}\n\n		vec4 envMapTexelToLinear( vec4 color ) {\n\n			return inputTexelToLinear( color );\n\n		}\n	"}\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`, blending: 0, depthTest: false, depthWrite: false});
    }
    function Ri() {
      return new RawShaderMaterial({name: "CubemapToCubeUV", uniforms: {envMap: {value: null}, inputEncoding: {value: _i[3e3]}, outputEncoding: {value: _i[3e3]}}, vertexShader: "\n\n		precision mediump float;\n		precision mediump int;\n\n		attribute vec3 position;\n		attribute vec2 uv;\n		attribute float faceIndex;\n\n		varying vec3 vOutputDirection;\n\n		// RH coordinate system; PMREM face-indexing convention\n		vec3 getDirection( vec2 uv, float face ) {\n\n			uv = 2.0 * uv - 1.0;\n\n			vec3 direction = vec3( uv, 1.0 );\n\n			if ( face == 0.0 ) {\n\n				direction = direction.zyx; // ( 1, v, u ) pos x\n\n			} else if ( face == 1.0 ) {\n\n				direction = direction.xzy;\n				direction.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n			} else if ( face == 2.0 ) {\n\n				direction.x *= -1.0; // ( -u, v, 1 ) pos z\n\n			} else if ( face == 3.0 ) {\n\n				direction = direction.zyx;\n				direction.xz *= -1.0; // ( -1, v, -u ) neg x\n\n			} else if ( face == 4.0 ) {\n\n				direction = direction.xzy;\n				direction.xy *= -1.0; // ( -u, -1, v ) neg y\n\n			} else if ( face == 5.0 ) {\n\n				direction.z *= -1.0; // ( u, v, -1 ) neg z\n\n			}\n\n			return direction;\n\n		}\n\n		void main() {\n\n			vOutputDirection = getDirection( uv, faceIndex );\n			gl_Position = vec4( position, 1.0 );\n\n		}\n	", fragmentShader: `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\t${"\n\n		uniform int inputEncoding;\n		uniform int outputEncoding;\n\n		#include <encodings_pars_fragment>\n\n		vec4 inputTexelToLinear( vec4 value ) {\n\n			if ( inputEncoding == 0 ) {\n\n				return value;\n\n			} else if ( inputEncoding == 1 ) {\n\n				return sRGBToLinear( value );\n\n			} else if ( inputEncoding == 2 ) {\n\n				return RGBEToLinear( value );\n\n			} else if ( inputEncoding == 3 ) {\n\n				return RGBMToLinear( value, 7.0 );\n\n			} else if ( inputEncoding == 4 ) {\n\n				return RGBMToLinear( value, 16.0 );\n\n			} else if ( inputEncoding == 5 ) {\n\n				return RGBDToLinear( value, 256.0 );\n\n			} else {\n\n				return GammaToLinear( value, 2.2 );\n\n			}\n\n		}\n\n		vec4 linearToOutputTexel( vec4 value ) {\n\n			if ( outputEncoding == 0 ) {\n\n				return value;\n\n			} else if ( outputEncoding == 1 ) {\n\n				return LinearTosRGB( value );\n\n			} else if ( outputEncoding == 2 ) {\n\n				return LinearToRGBE( value );\n\n			} else if ( outputEncoding == 3 ) {\n\n				return LinearToRGBM( value, 7.0 );\n\n			} else if ( outputEncoding == 4 ) {\n\n				return LinearToRGBM( value, 16.0 );\n\n			} else if ( outputEncoding == 5 ) {\n\n				return LinearToRGBD( value, 256.0 );\n\n			} else {\n\n				return LinearToGamma( value, 2.2 );\n\n			}\n\n		}\n\n		vec4 envMapTexelToLinear( vec4 color ) {\n\n			return inputTexelToLinear( color );\n\n		}\n	"}\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`, blending: 0, depthTest: false, depthWrite: false});
    }
    function Ii(t) {
      let e = new WeakMap, i = null;
      function n(t) {
        const i = t.target;
        i.removeEventListener("dispose", n);
        const r = e.get(i);
        void 0 !== r && (e.delete(i), r.dispose());
      }
      return {get: function (r) {
        if (r && r.isTexture && false === r.isRenderTargetTexture) {
          const o = r.mapping, h = o === l || o === c, u = o === s || o === a;
          if (h || u) {
            if (e.has(r)) return e.get(r).texture;
            {
              const o = r.image;
              if (h && o && o.height > 0 || u && o && function (t) {
                let e = 0;
                const i = 6;
                for (let n = 0; n < i; n++) void 0 !== t[n] && e++;
                return e === i;
              }(o)) {
                const o = t.getRenderTarget();
                null === i && (i = new PMREMGenerator(t));
                const s = h ? i.fromEquirectangular(r) : i.fromCubemap(r);
                return e.set(r, s), t.setRenderTarget(o), r.addEventListener("dispose", n), s.texture;
              }
              return null;
            }
          }
        }
        return r;
      }, dispose: function () {
        e = new WeakMap, null !== i && (i.dispose(), i = null);
      }};
    }
    function Vi(t) {
      const e = {};
      function i(i) {
        if (void 0 !== e[i]) return e[i];
        let n;
        switch (i) {
          case "WEBGL_depth_texture":
            n = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture");
            break;
          case "EXT_texture_filter_anisotropic":
            n = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
            break;
          case "WEBGL_compressed_texture_s3tc":
            n = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
            break;
          case "WEBGL_compressed_texture_pvrtc":
            n = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
            break;
          default:
            n = t.getExtension(i);
        }
        return e[i] = n, n;
      }
      return {has: function (t) {
        return null !== i(t);
      }, init: function (t) {
        t.isWebGL2 ? i("EXT_color_buffer_float") : (i("WEBGL_depth_texture"), i("OES_texture_float"), i("OES_texture_half_float"), i("OES_texture_half_float_linear"), i("OES_standard_derivatives"), i("OES_element_index_uint"), i("OES_vertex_array_object"), i("ANGLE_instanced_arrays")), i("OES_texture_float_linear"), i("EXT_color_buffer_half_float");
      }, get: function (t) {
        const e = i(t);
        return null === e && console.warn("THREE.WebGLRenderer: " + t + " extension not supported."), e;
      }};
    }
    function Fi(t, e, i, n) {
      const r = {}, o = new WeakMap;
      function s(t) {
        const a = t.target;
        null !== a.index && e.remove(a.index);
        for (const t in a.attributes) e.remove(a.attributes[t]);
        a.removeEventListener("dispose", s), delete r[a.id];
        const l = o.get(a);
        l && (e.remove(l), o.delete(a)), n.releaseStatesOfGeometry(a), true === a.isInstancedBufferGeometry && delete a._maxInstanceCount, i.memory.geometries--;
      }
      function a(t) {
        const i = [], n = t.index, r = t.attributes.position;
        let s = 0;
        if (null !== n) {
          const t = n.array;
          s = n.version;
          for (let e = 0, n = t.length; e < n; e += 3) {
            const n = t[e + 0], r = t[e + 1], o = t[e + 2];
            i.push(n, r, r, o, o, n);
          }
        } else {
          const t = r.array;
          s = r.version;
          for (let e = 0, n = t.length / 3 - 1; e < n; e += 3) {
            const t = e + 0, n = e + 1, r = e + 2;
            i.push(t, n, n, r, r, t);
          }
        }
        const a = new (ve(i) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(i, 1);
        a.version = s;
        const l = o.get(t);
        l && e.remove(l), o.set(t, a);
      }
      return {get: function (t, e) {
        return true === r[e.id] || (e.addEventListener("dispose", s), r[e.id] = true, i.memory.geometries++), e;
      }, update: function (t) {
        const i = t.attributes;
        for (const t in i) e.update(i[t], 34962);
        const n = t.morphAttributes;
        for (const t in n) {
          const i = n[t];
          for (let t = 0, n = i.length; t < n; t++) e.update(i[t], 34962);
        }
      }, getWireframeAttribute: function (t) {
        const e = o.get(t);
        if (e) {
          const i = t.index;
          null !== i && e.version < i.version && a(t);
        } else a(t);
        return o.get(t);
      }};
    }
    function ki(t, e, i, n) {
      const r = n.isWebGL2;
      let o, s, a;
      this.setMode = function (t) {
        o = t;
      }, this.setIndex = function (t) {
        s = t.type, a = t.bytesPerElement;
      }, this.render = function (e, n) {
        t.drawElements(o, n, s, e * a), i.update(n, o, 1);
      }, this.renderInstances = function (n, l, c) {
        if (0 === c) return;
        let h, u;
        if (r) h = t, u = "drawElementsInstanced"; else if (h = e.get("ANGLE_instanced_arrays"), u = "drawElementsInstancedANGLE", null === h) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
        h[u](o, l, s, n * a, c), i.update(l, o, c);
      };
    }
    function Ni(t) {
      const e = {frame: 0, calls: 0, triangles: 0, points: 0, lines: 0};
      return {memory: {geometries: 0, textures: 0}, render: e, programs: null, autoReset: true, reset: function () {
        e.frame++, e.calls = 0, e.triangles = 0, e.points = 0, e.lines = 0;
      }, update: function (t, i, n) {
        switch (e.calls++, i) {
          case 4:
            e.triangles += n * (t / 3);
            break;
          case 1:
            e.lines += n * (t / 2);
            break;
          case 3:
            e.lines += n * (t - 1);
            break;
          case 2:
            e.lines += n * t;
            break;
          case 0:
            e.points += n * t;
            break;
          default:
            console.error("THREE.WebGLInfo: Unknown draw mode:", i);
        }
      }};
    }
    function zi(t) {
      const e = {}, i = new Float32Array(8), n = [];
      for (let t = 0; t < 8; t++) n[t] = [t, 0];
      return {update: function (r, o, s, a) {
        const l = r.morphTargetInfluences, c = void 0 === l ? 0 : l.length;
        let h = e[o.id];
        if (void 0 === h || h.length !== c) {
          h = [];
          for (let t = 0; t < c; t++) h[t] = [t, 0];
          e[o.id] = h;
        }
        for (let t = 0; t < c; t++) {
          const e = h[t];
          e[0] = t, e[1] = l[t];
        }
        h.sort(Ui);
        for (let t = 0; t < 8; t++) t < c && h[t][1] ? (n[t][0] = h[t][0], n[t][1] = h[t][1]) : (n[t][0] = Number.MAX_SAFE_INTEGER, n[t][1] = 0);
        n.sort(Gi);
        const u = o.morphAttributes.position, p = o.morphAttributes.normal;
        let m = 0;
        for (let t = 0; t < 8; t++) {
          const e = n[t], r = e[0], s = e[1];
          r !== Number.MAX_SAFE_INTEGER && s ? (u && o.getAttribute("morphTarget" + t) !== u[r] && o.setAttribute("morphTarget" + t, u[r]), p && o.getAttribute("morphNormal" + t) !== p[r] && o.setAttribute("morphNormal" + t, p[r]), i[t] = s, m += s) : (u && true === o.hasAttribute("morphTarget" + t) && o.deleteAttribute("morphTarget" + t), p && true === o.hasAttribute("morphNormal" + t) && o.deleteAttribute("morphNormal" + t), i[t] = 0);
        }
        const d = o.morphTargetsRelative ? 1 : 1 - m;
        a.getUniforms().setValue(t, "morphTargetBaseInfluence", d), a.getUniforms().setValue(t, "morphTargetInfluences", i);
      }};
    }
    function Oi(t, e, i, n) {
      let r = new WeakMap;
      function o(t) {
        const e = t.target;
        e.removeEventListener("dispose", o), i.remove(e.instanceMatrix), null !== e.instanceColor && i.remove(e.instanceColor);
      }
      return {update: function (t) {
        const s = n.render.frame, a = t.geometry, l = e.get(t, a);
        return r.get(l) !== s && (e.update(l), r.set(l, s)), t.isInstancedMesh && (false === t.hasEventListener("dispose", o) && t.addEventListener("dispose", o), i.update(t.instanceMatrix, 34962), null !== t.instanceColor && i.update(t.instanceColor, 34962)), l;
      }, dispose: function () {
        r = new WeakMap;
      }};
    }
    class DataTexture2DArray extends Texture {
      constructor(t = null, e = 1, i = 1, n = 1) {
        super(null), this.image = {data: t, width: e, height: i, depth: n}, this.magFilter = _, this.minFilter = _, this.wrapR = m, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1, this.needsUpdate = true;
      }
    }
    DataTexture2DArray.prototype.isDataTexture2DArray = true;
    class DataTexture3D extends Texture {
      constructor(t = null, e = 1, i = 1, n = 1) {
        super(null), this.image = {data: t, width: e, height: i, depth: n}, this.magFilter = _, this.minFilter = _, this.wrapR = m, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1, this.needsUpdate = true;
      }
    }
    DataTexture3D.prototype.isDataTexture3D = true;
    const Hi = new Texture, Wi = new DataTexture2DArray, Ji = new DataTexture3D, ji = new CubeTexture, Xi = [], qi = [], Yi = new Float32Array(16), Zi = new Float32Array(9), Ki = new Float32Array(4);
    function $i(t, e, i) {
      const n = t[0];
      if (n <= 0 || n > 0) return t;
      const r = e * i;
      let o = Xi[r];
      if (void 0 === o && (o = new Float32Array(r), Xi[r] = o), 0 !== e) {
        n.toArray(o, 0);
        for (let n = 1, r = 0; n !== e; ++n) r += i, t[n].toArray(o, r);
      }
      return o;
    }
    function Qi(t, e) {
      if (t.length !== e.length) return false;
      for (let i = 0, n = t.length; i < n; i++) if (t[i] !== e[i]) return false;
      return true;
    }
    function tn(t, e) {
      for (let i = 0, n = e.length; i < n; i++) t[i] = e[i];
    }
    function en(t, e) {
      let i = qi[e];
      void 0 === i && (i = new Int32Array(e), qi[e] = i);
      for (let n = 0; n !== e; ++n) i[n] = t.allocateTextureUnit();
      return i;
    }
    function nn(t, e) {
      const i = this.cache;
      i[0] !== e && (t.uniform1f(this.addr, e), i[0] = e);
    }
    function rn(t, e) {
      const i = this.cache;
      if (void 0 !== e.x) i[0] === e.x && i[1] === e.y || (t.uniform2f(this.addr, e.x, e.y), i[0] = e.x, i[1] = e.y); else {
        if (Qi(i, e)) return;
        t.uniform2fv(this.addr, e), tn(i, e);
      }
    }
    function on(t, e) {
      const i = this.cache;
      if (void 0 !== e.x) i[0] === e.x && i[1] === e.y && i[2] === e.z || (t.uniform3f(this.addr, e.x, e.y, e.z), i[0] = e.x, i[1] = e.y, i[2] = e.z); else if (void 0 !== e.r) i[0] === e.r && i[1] === e.g && i[2] === e.b || (t.uniform3f(this.addr, e.r, e.g, e.b), i[0] = e.r, i[1] = e.g, i[2] = e.b); else {
        if (Qi(i, e)) return;
        t.uniform3fv(this.addr, e), tn(i, e);
      }
    }
    function sn(t, e) {
      const i = this.cache;
      if (void 0 !== e.x) i[0] === e.x && i[1] === e.y && i[2] === e.z && i[3] === e.w || (t.uniform4f(this.addr, e.x, e.y, e.z, e.w), i[0] = e.x, i[1] = e.y, i[2] = e.z, i[3] = e.w); else {
        if (Qi(i, e)) return;
        t.uniform4fv(this.addr, e), tn(i, e);
      }
    }
    function an(t, e) {
      const i = this.cache, n = e.elements;
      if (void 0 === n) {
        if (Qi(i, e)) return;
        t.uniformMatrix2fv(this.addr, false, e), tn(i, e);
      } else {
        if (Qi(i, n)) return;
        Ki.set(n), t.uniformMatrix2fv(this.addr, false, Ki), tn(i, n);
      }
    }
    function ln(t, e) {
      const i = this.cache, n = e.elements;
      if (void 0 === n) {
        if (Qi(i, e)) return;
        t.uniformMatrix3fv(this.addr, false, e), tn(i, e);
      } else {
        if (Qi(i, n)) return;
        Zi.set(n), t.uniformMatrix3fv(this.addr, false, Zi), tn(i, n);
      }
    }
    function cn(t, e) {
      const i = this.cache, n = e.elements;
      if (void 0 === n) {
        if (Qi(i, e)) return;
        t.uniformMatrix4fv(this.addr, false, e), tn(i, e);
      } else {
        if (Qi(i, n)) return;
        Yi.set(n), t.uniformMatrix4fv(this.addr, false, Yi), tn(i, n);
      }
    }
    function hn(t, e) {
      const i = this.cache;
      i[0] !== e && (t.uniform1i(this.addr, e), i[0] = e);
    }
    function un(t, e) {
      const i = this.cache;
      Qi(i, e) || (t.uniform2iv(this.addr, e), tn(i, e));
    }
    function pn(t, e) {
      const i = this.cache;
      Qi(i, e) || (t.uniform3iv(this.addr, e), tn(i, e));
    }
    function mn(t, e) {
      const i = this.cache;
      Qi(i, e) || (t.uniform4iv(this.addr, e), tn(i, e));
    }
    function dn(t, e) {
      const i = this.cache;
      i[0] !== e && (t.uniform1ui(this.addr, e), i[0] = e);
    }
    function fn(t, e) {
      const i = this.cache;
      Qi(i, e) || (t.uniform2uiv(this.addr, e), tn(i, e));
    }
    function _n(t, e) {
      const i = this.cache;
      Qi(i, e) || (t.uniform3uiv(this.addr, e), tn(i, e));
    }
    function yn(t, e) {
      const i = this.cache;
      Qi(i, e) || (t.uniform4uiv(this.addr, e), tn(i, e));
    }
    function gn(t, e, i) {
      const n = this.cache, r = i.allocateTextureUnit();
      n[0] !== r && (t.uniform1i(this.addr, r), n[0] = r), i.safeSetTexture2D(e || Hi, r);
    }
    function xn(t, e, i) {
      const n = this.cache, r = i.allocateTextureUnit();
      n[0] !== r && (t.uniform1i(this.addr, r), n[0] = r), i.setTexture3D(e || Ji, r);
    }
    function vn(t, e, i) {
      const n = this.cache, r = i.allocateTextureUnit();
      n[0] !== r && (t.uniform1i(this.addr, r), n[0] = r), i.safeSetTextureCube(e || ji, r);
    }
    function bn(t, e, i) {
      const n = this.cache, r = i.allocateTextureUnit();
      n[0] !== r && (t.uniform1i(this.addr, r), n[0] = r), i.setTexture2DArray(e || Wi, r);
    }
    function wn(t, e) {
      t.uniform1fv(this.addr, e);
    }
    function Sn(t, e) {
      const i = $i(e, this.size, 2);
      t.uniform2fv(this.addr, i);
    }
    function Mn(t, e) {
      const i = $i(e, this.size, 3);
      t.uniform3fv(this.addr, i);
    }
    function An(t, e) {
      const i = $i(e, this.size, 4);
      t.uniform4fv(this.addr, i);
    }
    function Cn(t, e) {
      const i = $i(e, this.size, 4);
      t.uniformMatrix2fv(this.addr, false, i);
    }
    function Tn(t, e) {
      const i = $i(e, this.size, 9);
      t.uniformMatrix3fv(this.addr, false, i);
    }
    function En(t, e) {
      const i = $i(e, this.size, 16);
      t.uniformMatrix4fv(this.addr, false, i);
    }
    function Ln(t, e) {
      t.uniform1iv(this.addr, e);
    }
    function Dn(t, e) {
      t.uniform2iv(this.addr, e);
    }
    function Rn(t, e) {
      t.uniform3iv(this.addr, e);
    }
    function Bn(t, e) {
      t.uniform4iv(this.addr, e);
    }
    function Pn(t, e) {
      t.uniform1uiv(this.addr, e);
    }
    function In(t, e) {
      t.uniform2uiv(this.addr, e);
    }
    function Vn(t, e) {
      t.uniform3uiv(this.addr, e);
    }
    function Fn(t, e) {
      t.uniform4uiv(this.addr, e);
    }
    function kn(t, e, i) {
      const n = e.length, r = en(i, n);
      t.uniform1iv(this.addr, r);
      for (let t = 0; t !== n; ++t) i.safeSetTexture2D(e[t] || Hi, r[t]);
    }
    function Nn(t, e, i) {
      const n = e.length, r = en(i, n);
      t.uniform1iv(this.addr, r);
      for (let t = 0; t !== n; ++t) i.safeSetTextureCube(e[t] || ji, r[t]);
    }
    function Gn(t, e, i) {
      this.id = t, this.addr = i, this.cache = [], this.setValue = function (t) {
        switch (t) {
          case 5126:
            return nn;
          case 35664:
            return rn;
          case 35665:
            return on;
          case 35666:
            return sn;
          case 35674:
            return an;
          case 35675:
            return ln;
          case 35676:
            return cn;
          case 5124:
          case 35670:
            return hn;
          case 35667:
          case 35671:
            return un;
          case 35668:
          case 35672:
            return pn;
          case 35669:
          case 35673:
            return mn;
          case 5125:
            return dn;
          case 36294:
            return fn;
          case 36295:
            return _n;
          case 36296:
            return yn;
          case 35678:
          case 36198:
          case 36298:
          case 36306:
          case 35682:
            return gn;
          case 35679:
          case 36299:
          case 36307:
            return xn;
          case 35680:
          case 36300:
          case 36308:
          case 36293:
            return vn;
          case 36289:
          case 36303:
          case 36311:
          case 36292:
            return bn;
        }
      }(e.type);
    }
    function Un(t, e, i) {
      this.id = t, this.addr = i, this.cache = [], this.size = e.size, this.setValue = function (t) {
        switch (t) {
          case 5126:
            return wn;
          case 35664:
            return Sn;
          case 35665:
            return Mn;
          case 35666:
            return An;
          case 35674:
            return Cn;
          case 35675:
            return Tn;
          case 35676:
            return En;
          case 5124:
          case 35670:
            return Ln;
          case 35667:
          case 35671:
            return Dn;
          case 35668:
          case 35672:
            return Rn;
          case 35669:
          case 35673:
            return Bn;
          case 5125:
            return Pn;
          case 36294:
            return In;
          case 36295:
            return Vn;
          case 36296:
            return Fn;
          case 35678:
          case 36198:
          case 36298:
          case 36306:
          case 35682:
            return kn;
          case 35680:
          case 36300:
          case 36308:
          case 36293:
            return Nn;
        }
      }(e.type);
    }
    function zn(t) {
      this.id = t, this.seq = [], this.map = {};
    }
    Un.prototype.updateCache = function (t) {
      const e = this.cache;
      t instanceof Float32Array && e.length !== t.length && (this.cache = new Float32Array(t.length)), tn(e, t);
    }, zn.prototype.setValue = function (t, e, i) {
      const n = this.seq;
      for (let r = 0, o = n.length; r !== o; ++r) {
        const o = n[r];
        o.setValue(t, e[o.id], i);
      }
    };
    const On = /(\w+)(\])?(\[|\.)?/g;
    function Hn(t, e) {
      t.seq.push(e), t.map[e.id] = e;
    }
    function Wn(t, e, i) {
      const n = t.name, r = n.length;
      for (On.lastIndex = 0;;) {
        const o = On.exec(n), s = On.lastIndex;
        let a = o[1];
        const l = "]" === o[2], c = o[3];
        if (l && (a |= 0), void 0 === c || "[" === c && s + 2 === r) {
          Hn(i, void 0 === c ? new Gn(a, t, e) : new Un(a, t, e));
          break;
        }
        {
          let t = i.map[a];
          void 0 === t && (t = new zn(a), Hn(i, t)), i = t;
        }
      }
    }
    function Jn(t, e) {
      this.seq = [], this.map = {};
      const i = t.getProgramParameter(e, 35718);
      for (let n = 0; n < i; ++n) {
        const i = t.getActiveUniform(e, n);
        Wn(i, t.getUniformLocation(e, i.name), this);
      }
    }
    function jn(t, e, i) {
      const n = t.createShader(e);
      return t.shaderSource(n, i), t.compileShader(n), n;
    }
    Jn.prototype.setValue = function (t, e, i, n) {
      const r = this.map[e];
      void 0 !== r && r.setValue(t, i, n);
    }, Jn.prototype.setOptional = function (t, e, i) {
      const n = e[i];
      void 0 !== n && this.setValue(t, i, n);
    }, Jn.upload = function (t, e, i, n) {
      for (let r = 0, o = e.length; r !== o; ++r) {
        const o = e[r], s = i[o.id];
        false !== s.needsUpdate && o.setValue(t, s.value, n);
      }
    }, Jn.seqWithValue = function (t, e) {
      const i = [];
      for (let n = 0, r = t.length; n !== r; ++n) {
        const r = t[n];
        r.id in e && i.push(r);
      }
      return i;
    };
    let Xn = 0;
    function qn(t) {
      switch (t) {
        case N:
          return ["Linear", "( value )"];
        case G:
          return ["sRGB", "( value )"];
        case z:
          return ["RGBE", "( value )"];
        case 3004:
          return ["RGBM", "( value, 7.0 )"];
        case 3005:
          return ["RGBM", "( value, 16.0 )"];
        case 3006:
          return ["RGBD", "( value, 256.0 )"];
        case U:
          return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
        case 3003:
          return ["LogLuv", "( value )"];
        default:
          return console.warn("THREE.WebGLProgram: Unsupported encoding:", t), ["Linear", "( value )"];
      }
    }
    function Yn(t, e, i) {
      const n = t.getShaderParameter(e, 35713), r = t.getShaderInfoLog(e).trim();
      return n && "" === r ? "" : i.toUpperCase() + "\n\n" + r + "\n\n" + function (t) {
        const e = t.split("\n");
        for (let t = 0; t < e.length; t++) e[t] = t + 1 + ": " + e[t];
        return e.join("\n");
      }(t.getShaderSource(e));
    }
    function Zn(t, e) {
      const i = qn(e);
      return "vec4 " + t + "( vec4 value ) { return " + i[0] + "ToLinear" + i[1] + "; }";
    }
    function Kn(t, e) {
      const i = qn(e);
      return "vec4 " + t + "( vec4 value ) { return LinearTo" + i[0] + i[1] + "; }";
    }
    function $n(t, e) {
      let i;
      switch (e) {
        case 1:
          i = "Linear";
          break;
        case 2:
          i = "Reinhard";
          break;
        case 3:
          i = "OptimizedCineon";
          break;
        case 4:
          i = "ACESFilmic";
          break;
        case 5:
          i = "Custom";
          break;
        default:
          console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), i = "Linear";
      }
      return "vec3 " + t + "( vec3 color ) { return " + i + "ToneMapping( color ); }";
    }
    const ir = /^[ \t]*#include +<([\w\d./]+)>/gm;
    function rr(t, e) {
      const i = ni[e];
      if (void 0 === i) throw new Error("Can not resolve #include <" + e + ">");
      return i.replace(ir, rr);
    }
    const or = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g, sr = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
    function cr(t, e, i, n) {
      let r = "";
      for (let t = parseInt(e); t < parseInt(i); t++) r += n.replace(/\[\s*i\s*\]/g, "[ " + t + " ]").replace(/UNROLLED_LOOP_INDEX/g, t);
      return r;
    }
    function hr(t) {
      let e = "precision " + t.precision + " float;\nprecision " + t.precision + " int;";
      return "highp" === t.precision ? e += "\n#define HIGH_PRECISION" : "mediump" === t.precision ? e += "\n#define MEDIUM_PRECISION" : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"), e;
    }
    function ur(t, e, i, n) {
      const r = t.getContext(), o = i.defines;
      let l = i.vertexShader, c = i.fragmentShader;
      const p = function (t) {
        let e = "SHADOWMAP_TYPE_BASIC";
        return 1 === t.shadowMapType ? e = "SHADOWMAP_TYPE_PCF" : 2 === t.shadowMapType ? e = "SHADOWMAP_TYPE_PCF_SOFT" : 3 === t.shadowMapType && (e = "SHADOWMAP_TYPE_VSM"), e;
      }(i), m = function (t) {
        let e = "ENVMAP_TYPE_CUBE";
        if (t.envMap) switch (t.envMapMode) {
          case s:
          case a:
            e = "ENVMAP_TYPE_CUBE";
            break;
          case h:
          case u:
            e = "ENVMAP_TYPE_CUBE_UV";
        }
        return e;
      }(i), d = function (t) {
        let e = "ENVMAP_MODE_REFLECTION";
        if (t.envMap) switch (t.envMapMode) {
          case a:
          case u:
            e = "ENVMAP_MODE_REFRACTION";
        }
        return e;
      }(i), _ = function (t) {
        let e = "ENVMAP_BLENDING_NONE";
        if (t.envMap) switch (t.combine) {
          case 0:
            e = "ENVMAP_BLENDING_MULTIPLY";
            break;
          case 1:
            e = "ENVMAP_BLENDING_MIX";
            break;
          case 2:
            e = "ENVMAP_BLENDING_ADD";
        }
        return e;
      }(i), y = t.gammaFactor > 0 ? t.gammaFactor : 1, g = i.isWebGL2 ? "" : function (t) {
        return [t.extensionDerivatives || t.envMapCubeUV || t.bumpMap || t.tangentSpaceNormalMap || t.clearcoatNormalMap || t.flatShading || "physical" === t.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (t.extensionFragDepth || t.logarithmicDepthBuffer) && t.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", t.extensionDrawBuffers && t.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (t.extensionShaderTextureLOD || t.envMap || t.transmission) && t.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Qn).join("\n");
      }(i), x = function (t) {
        const e = [];
        for (const i in t) {
          const n = t[i];
          false !== n && e.push("#define " + i + " " + n);
        }
        return e.join("\n");
      }(o), v = r.createProgram();
      let b, w, S = i.glslVersion ? "#version " + i.glslVersion + "\n" : "";
      i.isRawShaderMaterial ? (b = [x].filter(Qn).join("\n"), b.length > 0 && (b += "\n"), w = [g, x].filter(Qn).join("\n"), w.length > 0 && (w += "\n")) : (b = [hr(i), "#define SHADER_NAME " + i.shaderName, x, i.instancing ? "#define USE_INSTANCING" : "", i.instancingColor ? "#define USE_INSTANCING_COLOR" : "", i.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + y, "#define MAX_BONES " + i.maxBones, i.useFog && i.fog ? "#define USE_FOG" : "", i.useFog && i.fogExp2 ? "#define FOG_EXP2" : "", i.map ? "#define USE_MAP" : "", i.envMap ? "#define USE_ENVMAP" : "", i.envMap ? "#define " + d : "", i.lightMap ? "#define USE_LIGHTMAP" : "", i.aoMap ? "#define USE_AOMAP" : "", i.emissiveMap ? "#define USE_EMISSIVEMAP" : "", i.bumpMap ? "#define USE_BUMPMAP" : "", i.normalMap ? "#define USE_NORMALMAP" : "", i.normalMap && i.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", i.normalMap && i.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", i.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", i.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", i.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", i.displacementMap && i.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", i.specularMap ? "#define USE_SPECULARMAP" : "", i.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", i.specularTintMap ? "#define USE_SPECULARTINTMAP" : "", i.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", i.metalnessMap ? "#define USE_METALNESSMAP" : "", i.alphaMap ? "#define USE_ALPHAMAP" : "", i.transmission ? "#define USE_TRANSMISSION" : "", i.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", i.thicknessMap ? "#define USE_THICKNESSMAP" : "", i.vertexTangents ? "#define USE_TANGENT" : "", i.vertexColors ? "#define USE_COLOR" : "", i.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", i.vertexUvs ? "#define USE_UV" : "", i.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", i.flatShading ? "#define FLAT_SHADED" : "", i.skinning ? "#define USE_SKINNING" : "", i.useVertexTexture ? "#define BONE_TEXTURE" : "", i.morphTargets ? "#define USE_MORPHTARGETS" : "", i.morphNormals && false === i.flatShading ? "#define USE_MORPHNORMALS" : "", i.doubleSided ? "#define DOUBLE_SIDED" : "", i.flipSided ? "#define FLIP_SIDED" : "", i.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", i.shadowMapEnabled ? "#define " + p : "", i.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", i.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", i.logarithmicDepthBuffer && i.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "	attribute vec3 morphTarget0;", "	attribute vec3 morphTarget1;", "	attribute vec3 morphTarget2;", "	attribute vec3 morphTarget3;", "	#ifdef USE_MORPHNORMALS", "		attribute vec3 morphNormal0;", "		attribute vec3 morphNormal1;", "		attribute vec3 morphNormal2;", "		attribute vec3 morphNormal3;", "	#else", "		attribute vec3 morphTarget4;", "		attribute vec3 morphTarget5;", "		attribute vec3 morphTarget6;", "		attribute vec3 morphTarget7;", "	#endif", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", "\n"].filter(Qn).join("\n"), w = [g, hr(i), "#define SHADER_NAME " + i.shaderName, x, "#define GAMMA_FACTOR " + y, i.useFog && i.fog ? "#define USE_FOG" : "", i.useFog && i.fogExp2 ? "#define FOG_EXP2" : "", i.map ? "#define USE_MAP" : "", i.matcap ? "#define USE_MATCAP" : "", i.envMap ? "#define USE_ENVMAP" : "", i.envMap ? "#define " + m : "", i.envMap ? "#define " + d : "", i.envMap ? "#define " + _ : "", i.lightMap ? "#define USE_LIGHTMAP" : "", i.aoMap ? "#define USE_AOMAP" : "", i.emissiveMap ? "#define USE_EMISSIVEMAP" : "", i.bumpMap ? "#define USE_BUMPMAP" : "", i.normalMap ? "#define USE_NORMALMAP" : "", i.normalMap && i.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", i.normalMap && i.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", i.clearcoat ? "#define USE_CLEARCOAT" : "", i.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", i.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", i.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", i.specularMap ? "#define USE_SPECULARMAP" : "", i.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", i.specularTintMap ? "#define USE_SPECULARTINTMAP" : "", i.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", i.metalnessMap ? "#define USE_METALNESSMAP" : "", i.alphaMap ? "#define USE_ALPHAMAP" : "", i.alphaTest ? "#define USE_ALPHATEST" : "", i.sheenTint ? "#define USE_SHEEN" : "", i.transmission ? "#define USE_TRANSMISSION" : "", i.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", i.thicknessMap ? "#define USE_THICKNESSMAP" : "", i.vertexTangents ? "#define USE_TANGENT" : "", i.vertexColors || i.instancingColor ? "#define USE_COLOR" : "", i.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", i.vertexUvs ? "#define USE_UV" : "", i.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", i.gradientMap ? "#define USE_GRADIENTMAP" : "", i.flatShading ? "#define FLAT_SHADED" : "", i.doubleSided ? "#define DOUBLE_SIDED" : "", i.flipSided ? "#define FLIP_SIDED" : "", i.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", i.shadowMapEnabled ? "#define " + p : "", i.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", i.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", i.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", i.logarithmicDepthBuffer && i.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (i.extensionShaderTextureLOD || i.envMap) && i.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", 0 !== i.toneMapping ? "#define TONE_MAPPING" : "", 0 !== i.toneMapping ? ni.tonemapping_pars_fragment : "", 0 !== i.toneMapping ? $n("toneMapping", i.toneMapping) : "", i.dithering ? "#define DITHERING" : "", i.format === T ? "#define OPAQUE" : "", ni.encodings_pars_fragment, i.map ? Zn("mapTexelToLinear", i.mapEncoding) : "", i.matcap ? Zn("matcapTexelToLinear", i.matcapEncoding) : "", i.envMap ? Zn("envMapTexelToLinear", i.envMapEncoding) : "", i.emissiveMap ? Zn("emissiveMapTexelToLinear", i.emissiveMapEncoding) : "", i.specularTintMap ? Zn("specularTintMapTexelToLinear", i.specularTintMapEncoding) : "", i.lightMap ? Zn("lightMapTexelToLinear", i.lightMapEncoding) : "", Kn("linearToOutputTexel", i.outputEncoding), i.depthPacking ? "#define DEPTH_PACKING " + i.depthPacking : "", "\n"].filter(Qn).join("\n")), l = l.replace(ir, rr), l = l.replace(/NUM_DIR_LIGHTS/g, i.numDirLights).replace(/NUM_SPOT_LIGHTS/g, i.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, i.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, i.numPointLights).replace(/NUM_HEMI_LIGHTS/g, i.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, i.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, i.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, i.numPointLightShadows), l = l.replace(/NUM_CLIPPING_PLANES/g, i.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, i.numClippingPlanes - i.numClipIntersection), c = c.replace(ir, rr), c = c.replace(/NUM_DIR_LIGHTS/g, i.numDirLights).replace(/NUM_SPOT_LIGHTS/g, i.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, i.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, i.numPointLights).replace(/NUM_HEMI_LIGHTS/g, i.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, i.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, i.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, i.numPointLightShadows), c = c.replace(/NUM_CLIPPING_PLANES/g, i.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, i.numClippingPlanes - i.numClipIntersection), l = l.replace(sr, cr).replace(or, lr), c = c.replace(sr, cr).replace(or, lr), i.isWebGL2 && true !== i.isRawShaderMaterial && (S = "#version 300 es\n", b = ["#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + b, w = ["#define varying in", i.glslVersion === J ? "" : "out highp vec4 pc_fragColor;", i.glslVersion === J ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + w);
      const M = S + w + c, A = jn(r, 35633, S + b + l), C = jn(r, 35632, M);
      if (r.attachShader(v, A), r.attachShader(v, C), void 0 !== i.index0AttributeName ? r.bindAttribLocation(v, 0, i.index0AttributeName) : true === i.morphTargets && r.bindAttribLocation(v, 0, "position"), r.linkProgram(v), t.debug.checkShaderErrors) {
        const t = r.getProgramInfoLog(v).trim(), e = r.getShaderInfoLog(A).trim(), i = r.getShaderInfoLog(C).trim();
        let n = true, o = true;
        if (false === r.getProgramParameter(v, 35714)) {
          n = false;
          const e = Yn(r, A, "vertex"), i = Yn(r, C, "fragment");
          console.error("THREE.WebGLProgram: Shader Error " + r.getError() + " - VALIDATE_STATUS " + r.getProgramParameter(v, 35715) + "\n\nProgram Info Log: " + t + "\n" + e + "\n" + i);
        } else "" !== t ? console.warn("THREE.WebGLProgram: Program Info Log:", t) : "" !== e && "" !== i || (o = false);
        o && (this.diagnostics = {runnable: n, programLog: t, vertexShader: {log: e, prefix: b}, fragmentShader: {log: i, prefix: w}});
      }
      let E, L;
      return r.deleteShader(A), r.deleteShader(C), this.getUniforms = function () {
        return void 0 === E && (E = new Jn(r, v)), E;
      }, this.getAttributes = function () {
        return void 0 === L && (L = function (t, e) {
          const i = {}, n = t.getProgramParameter(e, 35721);
          for (let r = 0; r < n; r++) {
            const n = t.getActiveAttrib(e, r), o = n.name;
            let s = 1;
            35674 === n.type && (s = 2), 35675 === n.type && (s = 3), 35676 === n.type && (s = 4), i[o] = {type: n.type, location: t.getAttribLocation(e, o), locationSize: s};
          }
          return i;
        }(r, v)), L;
      }, this.destroy = function () {
        n.releaseStatesOfProgram(this), r.deleteProgram(v), this.program = void 0;
      }, this.name = i.shaderName, this.id = Xn++, this.cacheKey = e, this.usedTimes = 1, this.program = v, this.vertexShader = A, this.fragmentShader = C, this;
    }
    function pr(t, e, i, n, r, o, s) {
      const a = [], l = r.isWebGL2, c = r.logarithmicDepthBuffer, p = r.floatVertexTextures, m = r.maxVertexUniforms, d = r.vertexTextures;
      let _ = r.precision;
      const y = {MeshDepthMaterial: "depth", MeshDistanceMaterial: "distanceRGBA", MeshNormalMaterial: "normal", MeshBasicMaterial: "basic", MeshLambertMaterial: "lambert", MeshPhongMaterial: "phong", MeshToonMaterial: "toon", MeshStandardMaterial: "physical", MeshPhysicalMaterial: "physical", MeshMatcapMaterial: "matcap", LineBasicMaterial: "basic", LineDashedMaterial: "dashed", PointsMaterial: "points", ShadowMaterial: "shadow", SpriteMaterial: "sprite"}, g = ["precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing", "instancingColor", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV", "lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoat", "clearcoatMap", "clearcoatRoughnessMap", "clearcoatNormalMap", "displacementMap", "specularMap", "specularIntensityMap", "specularTintMap", "specularTintMapEncoding", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "alphaTest", "combine", "vertexColors", "vertexAlphas", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "format", "sheenTint", "transmission", "transmissionMap", "thicknessMap"];
      function x(t) {
        let e;
        return t && t.isTexture ? e = t.encoding : t && t.isWebGLRenderTarget ? (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), e = t.texture.encoding) : e = N, e;
      }
      return {getParameters: function (o, a, g, v, b) {
        const w = v.fog, S = o.isMeshStandardMaterial ? v.environment : null, M = (o.isMeshStandardMaterial ? i : e).get(o.envMap || S), A = y[o.type], C = b.isSkinnedMesh ? function (t) {
          const e = t.skeleton.bones;
          if (p) return 1024;
          {
            const t = m, i = Math.floor((t - 20) / 4), n = Math.min(i, e.length);
            return n < e.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + e.length + " bones. This GPU supports " + n + "."), 0) : n;
          }
        }(b) : 0;
        let T, E;
        if (null !== o.precision && (_ = r.getMaxPrecision(o.precision), _ !== o.precision && console.warn("THREE.WebGLProgram.getParameters:", o.precision, "not supported, using", _, "instead.")), A) {
          const t = oi[A];
          T = t.vertexShader, E = t.fragmentShader;
        } else T = o.vertexShader, E = o.fragmentShader;
        const L = t.getRenderTarget(), D = o.alphaTest > 0, R = o.clearcoat > 0;
        return {isWebGL2: l, shaderID: A, shaderName: o.type, vertexShader: T, fragmentShader: E, defines: o.defines, isRawShaderMaterial: true === o.isRawShaderMaterial, glslVersion: o.glslVersion, precision: _, instancing: true === b.isInstancedMesh, instancingColor: true === b.isInstancedMesh && null !== b.instanceColor, supportsVertexTextures: d, outputEncoding: null !== L ? x(L.texture) : t.outputEncoding, map: !!o.map, mapEncoding: x(o.map), matcap: !!o.matcap, matcapEncoding: x(o.matcap), envMap: !!M, envMapMode: M && M.mapping, envMapEncoding: x(M), envMapCubeUV: !!M && (M.mapping === h || M.mapping === u), lightMap: !!o.lightMap, lightMapEncoding: x(o.lightMap), aoMap: !!o.aoMap, emissiveMap: !!o.emissiveMap, emissiveMapEncoding: x(o.emissiveMap), bumpMap: !!o.bumpMap, normalMap: !!o.normalMap, objectSpaceNormalMap: 1 === o.normalMapType, tangentSpaceNormalMap: 0 === o.normalMapType, clearcoat: R, clearcoatMap: R && !!o.clearcoatMap, clearcoatRoughnessMap: R && !!o.clearcoatRoughnessMap, clearcoatNormalMap: R && !!o.clearcoatNormalMap, displacementMap: !!o.displacementMap, roughnessMap: !!o.roughnessMap, metalnessMap: !!o.metalnessMap, specularMap: !!o.specularMap, specularIntensityMap: !!o.specularIntensityMap, specularTintMap: !!o.specularTintMap, specularTintMapEncoding: x(o.specularTintMap), alphaMap: !!o.alphaMap, alphaTest: D, gradientMap: !!o.gradientMap, sheenTint: !!o.sheenTint && (o.sheenTint.r > 0 || o.sheenTint.g > 0 || o.sheenTint.b > 0), transmission: o.transmission > 0, transmissionMap: !!o.transmissionMap, thicknessMap: !!o.thicknessMap, combine: o.combine, vertexTangents: !!o.normalMap && !!b.geometry && !!b.geometry.attributes.tangent, vertexColors: o.vertexColors, vertexAlphas: true === o.vertexColors && !!b.geometry && !!b.geometry.attributes.color && 4 === b.geometry.attributes.color.itemSize, vertexUvs: !!(o.map || o.bumpMap || o.normalMap || o.specularMap || o.alphaMap || o.emissiveMap || o.roughnessMap || o.metalnessMap || o.clearcoatMap || o.clearcoatRoughnessMap || o.clearcoatNormalMap || o.displacementMap || o.transmissionMap || o.thicknessMap || o.specularIntensityMap || o.specularTintMap), uvsVertexOnly: !(o.map || o.bumpMap || o.normalMap || o.specularMap || o.alphaMap || o.emissiveMap || o.roughnessMap || o.metalnessMap || o.clearcoatNormalMap || o.transmission > 0 || o.transmissionMap || o.thicknessMap || o.specularIntensityMap || o.specularTintMap || !o.displacementMap), fog: !!w, useFog: o.fog, fogExp2: w && w.isFogExp2, flatShading: !!o.flatShading, sizeAttenuation: o.sizeAttenuation, logarithmicDepthBuffer: c, skinning: true === b.isSkinnedMesh && C > 0, maxBones: C, useVertexTexture: p, morphTargets: !!b.geometry && !!b.geometry.morphAttributes.position, morphNormals: !!b.geometry && !!b.geometry.morphAttributes.normal, numDirLights: a.directional.length, numPointLights: a.point.length, numSpotLights: a.spot.length, numRectAreaLights: a.rectArea.length, numHemiLights: a.hemi.length, numDirLightShadows: a.directionalShadowMap.length, numPointLightShadows: a.pointShadowMap.length, numSpotLightShadows: a.spotShadowMap.length, numClippingPlanes: s.numPlanes, numClipIntersection: s.numIntersection, format: o.format, dithering: o.dithering, shadowMapEnabled: t.shadowMap.enabled && g.length > 0, shadowMapType: t.shadowMap.type, toneMapping: o.toneMapped ? t.toneMapping : 0, physicallyCorrectLights: t.physicallyCorrectLights, premultipliedAlpha: o.premultipliedAlpha, doubleSided: 2 === o.side, flipSided: 1 === o.side, depthPacking: void 0 !== o.depthPacking && o.depthPacking, index0AttributeName: o.index0AttributeName, extensionDerivatives: o.extensions && o.extensions.derivatives, extensionFragDepth: o.extensions && o.extensions.fragDepth, extensionDrawBuffers: o.extensions && o.extensions.drawBuffers, extensionShaderTextureLOD: o.extensions && o.extensions.shaderTextureLOD, rendererExtensionFragDepth: l || n.has("EXT_frag_depth"), rendererExtensionDrawBuffers: l || n.has("WEBGL_draw_buffers"), rendererExtensionShaderTextureLod: l || n.has("EXT_shader_texture_lod"), customProgramCacheKey: o.customProgramCacheKey()};
      }, getProgramCacheKey: function (e) {
        const i = [];
        if (e.shaderID ? i.push(e.shaderID) : (i.push(e.fragmentShader), i.push(e.vertexShader)), void 0 !== e.defines) for (const t in e.defines) i.push(t), i.push(e.defines[t]);
        if (false === e.isRawShaderMaterial) {
          for (let t = 0; t < g.length; t++) i.push(e[g[t]]);
          i.push(t.outputEncoding), i.push(t.gammaFactor);
        }
        return i.push(e.customProgramCacheKey), i.join();
      }, getUniforms: function (t) {
        const e = y[t.type];
        let i;
        if (e) {
          const t = oi[e];
          i = qe.clone(t.uniforms);
        } else i = t.uniforms;
        return i;
      }, acquireProgram: function (e, i) {
        let n;
        for (let t = 0, e = a.length; t < e; t++) {
          const e = a[t];
          if (e.cacheKey === i) {
            n = e, ++n.usedTimes;
            break;
          }
        }
        return void 0 === n && (n = new ur(t, i, e, o), a.push(n)), n;
      }, releaseProgram: function (t) {
        if (0 == --t.usedTimes) {
          const e = a.indexOf(t);
          a[e] = a[a.length - 1], a.pop(), t.destroy();
        }
      }, programs: a};
    }
    function mr() {
      let t = new WeakMap;
      return {get: function (e) {
        let i = t.get(e);
        return void 0 === i && (i = {}, t.set(e, i)), i;
      }, remove: function (e) {
        t.delete(e);
      }, update: function (e, i, n) {
        t.get(e)[i] = n;
      }, dispose: function () {
        t = new WeakMap;
      }};
    }
    function dr(t, e) {
      return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.program !== e.program ? t.program.id - e.program.id : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id;
    }
    function fr(t, e) {
      return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id;
    }
    function _r(t) {
      const e = [];
      let i = 0;
      const n = [], r = [], o = [], s = {id: -1};
      function a(n, r, o, a, l, c) {
        let h = e[i];
        const u = t.get(o);
        return void 0 === h ? (h = {id: n.id, object: n, geometry: r, material: o, program: u.program || s, groupOrder: a, renderOrder: n.renderOrder, z: l, group: c}, e[i] = h) : (h.id = n.id, h.object = n, h.geometry = r, h.material = o, h.program = u.program || s, h.groupOrder = a, h.renderOrder = n.renderOrder, h.z = l, h.group = c), i++, h;
      }
      return {opaque: n, transmissive: r, transparent: o, init: function () {
        i = 0, n.length = 0, r.length = 0, o.length = 0;
      }, push: function (t, e, i, s, l, c) {
        const h = a(t, e, i, s, l, c);
        i.transmission > 0 ? r.push(h) : true === i.transparent ? o.push(h) : n.push(h);
      }, unshift: function (t, e, i, s, l, c) {
        const h = a(t, e, i, s, l, c);
        i.transmission > 0 ? r.unshift(h) : true === i.transparent ? o.unshift(h) : n.unshift(h);
      }, finish: function () {
        for (let t = i, n = e.length; t < n; t++) {
          const i = e[t];
          if (null === i.id) break;
          i.id = null, i.object = null, i.geometry = null, i.material = null, i.program = null, i.group = null;
        }
      }, sort: function (t, e) {
        n.length > 1 && n.sort(t || dr), r.length > 1 && r.sort(e || fr), o.length > 1 && o.sort(e || fr);
      }};
    }
    function yr(t) {
      let e = new WeakMap;
      return {get: function (i, n) {
        let r;
        return false === e.has(i) ? (r = new _r(t), e.set(i, [r])) : n >= e.get(i).length ? (r = new _r(t), e.get(i).push(r)) : r = e.get(i)[n], r;
      }, dispose: function () {
        e = new WeakMap;
      }};
    }
    function gr() {
      const t = {};
      return {get: function (e) {
        if (void 0 !== t[e.id]) return t[e.id];
        let i;
        switch (e.type) {
          case "DirectionalLight":
            i = {direction: new three_module_Vector3, color: new three_module_Color};
            break;
          case "SpotLight":
            i = {position: new three_module_Vector3, direction: new three_module_Vector3, color: new three_module_Color, distance: 0, coneCos: 0, penumbraCos: 0, decay: 0};
            break;
          case "PointLight":
            i = {position: new three_module_Vector3, color: new three_module_Color, distance: 0, decay: 0};
            break;
          case "HemisphereLight":
            i = {direction: new three_module_Vector3, skyColor: new three_module_Color, groundColor: new three_module_Color};
            break;
          case "RectAreaLight":
            i = {color: new three_module_Color, position: new three_module_Vector3, halfWidth: new three_module_Vector3, halfHeight: new three_module_Vector3};
        }
        return t[e.id] = i, i;
      }};
    }
    let xr = 0;
    function br(t, e) {
      const i = new gr, n = function () {
        const t = {};
        return {get: function (e) {
          if (void 0 !== t[e.id]) return t[e.id];
          let i;
          switch (e.type) {
            case "DirectionalLight":
            case "SpotLight":
              i = {shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new Vector2};
              break;
            case "PointLight":
              i = {shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new Vector2, shadowCameraNear: 1, shadowCameraFar: 1e3};
          }
          return t[e.id] = i, i;
        }};
      }(), r = {version: 0, hash: {directionalLength: -1, pointLength: -1, spotLength: -1, rectAreaLength: -1, hemiLength: -1, numDirectionalShadows: -1, numPointShadows: -1, numSpotShadows: -1}, ambient: [0, 0, 0], probe: [], directional: [], directionalShadow: [], directionalShadowMap: [], directionalShadowMatrix: [], spot: [], spotShadow: [], spotShadowMap: [], spotShadowMatrix: [], rectArea: [], rectAreaLTC1: null, rectAreaLTC2: null, point: [], pointShadow: [], pointShadowMap: [], pointShadowMatrix: [], hemi: []};
      for (let t = 0; t < 9; t++) r.probe.push(new three_module_Vector3);
      const o = new three_module_Vector3, s = new Matrix4, a = new Matrix4;
      return {setup: function (o, s) {
        let a = 0, l = 0, c = 0;
        for (let t = 0; t < 9; t++) r.probe[t].set(0, 0, 0);
        let h = 0, u = 0, p = 0, m = 0, d = 0, _ = 0, y = 0, g = 0;
        o.sort(vr);
        const x = true !== s ? Math.PI : 1;
        for (let t = 0, e = o.length; t < e; t++) {
          const e = o[t], s = e.color, v = e.intensity, b = e.distance, w = e.shadow && e.shadow.map ? e.shadow.map.texture : null;
          if (e.isAmbientLight) a += s.r * v * x, l += s.g * v * x, c += s.b * v * x; else if (e.isLightProbe) for (let t = 0; t < 9; t++) r.probe[t].addScaledVector(e.sh.coefficients[t], v); else if (e.isDirectionalLight) {
            const t = i.get(e);
            if (t.color.copy(e.color).multiplyScalar(e.intensity * x), e.castShadow) {
              const t = e.shadow, i = n.get(e);
              i.shadowBias = t.bias, i.shadowNormalBias = t.normalBias, i.shadowRadius = t.radius, i.shadowMapSize = t.mapSize, r.directionalShadow[h] = i, r.directionalShadowMap[h] = w, r.directionalShadowMatrix[h] = e.shadow.matrix, _++;
            }
            r.directional[h] = t, h++;
          } else if (e.isSpotLight) {
            const t = i.get(e);
            if (t.position.setFromMatrixPosition(e.matrixWorld), t.color.copy(s).multiplyScalar(v * x), t.distance = b, t.coneCos = Math.cos(e.angle), t.penumbraCos = Math.cos(e.angle * (1 - e.penumbra)), t.decay = e.decay, e.castShadow) {
              const t = e.shadow, i = n.get(e);
              i.shadowBias = t.bias, i.shadowNormalBias = t.normalBias, i.shadowRadius = t.radius, i.shadowMapSize = t.mapSize, r.spotShadow[p] = i, r.spotShadowMap[p] = w, r.spotShadowMatrix[p] = e.shadow.matrix, g++;
            }
            r.spot[p] = t, p++;
          } else if (e.isRectAreaLight) {
            const t = i.get(e);
            t.color.copy(s).multiplyScalar(v), t.halfWidth.set(0.5 * e.width, 0, 0), t.halfHeight.set(0, 0.5 * e.height, 0), r.rectArea[m] = t, m++;
          } else if (e.isPointLight) {
            const t = i.get(e);
            if (t.color.copy(e.color).multiplyScalar(e.intensity * x), t.distance = e.distance, t.decay = e.decay, e.castShadow) {
              const t = e.shadow, i = n.get(e);
              i.shadowBias = t.bias, i.shadowNormalBias = t.normalBias, i.shadowRadius = t.radius, i.shadowMapSize = t.mapSize, i.shadowCameraNear = t.camera.near, i.shadowCameraFar = t.camera.far, r.pointShadow[u] = i, r.pointShadowMap[u] = w, r.pointShadowMatrix[u] = e.shadow.matrix, y++;
            }
            r.point[u] = t, u++;
          } else if (e.isHemisphereLight) {
            const t = i.get(e);
            t.skyColor.copy(e.color).multiplyScalar(v * x), t.groundColor.copy(e.groundColor).multiplyScalar(v * x), r.hemi[d] = t, d++;
          }
        }
        m > 0 && (e.isWebGL2 || true === t.has("OES_texture_float_linear") ? (r.rectAreaLTC1 = ri.LTC_FLOAT_1, r.rectAreaLTC2 = ri.LTC_FLOAT_2) : true === t.has("OES_texture_half_float_linear") ? (r.rectAreaLTC1 = ri.LTC_HALF_1, r.rectAreaLTC2 = ri.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), r.ambient[0] = a, r.ambient[1] = l, r.ambient[2] = c;
        const v = r.hash;
        v.directionalLength === h && v.pointLength === u && v.spotLength === p && v.rectAreaLength === m && v.hemiLength === d && v.numDirectionalShadows === _ && v.numPointShadows === y && v.numSpotShadows === g || (r.directional.length = h, r.spot.length = p, r.rectArea.length = m, r.point.length = u, r.hemi.length = d, r.directionalShadow.length = _, r.directionalShadowMap.length = _, r.pointShadow.length = y, r.pointShadowMap.length = y, r.spotShadow.length = g, r.spotShadowMap.length = g, r.directionalShadowMatrix.length = _, r.pointShadowMatrix.length = y, r.spotShadowMatrix.length = g, v.directionalLength = h, v.pointLength = u, v.spotLength = p, v.rectAreaLength = m, v.hemiLength = d, v.numDirectionalShadows = _, v.numPointShadows = y, v.numSpotShadows = g, r.version = xr++);
      }, setupView: function (t, e) {
        let i = 0, n = 0, l = 0, c = 0, h = 0;
        const u = e.matrixWorldInverse;
        for (let e = 0, p = t.length; e < p; e++) {
          const p = t[e];
          if (p.isDirectionalLight) {
            const t = r.directional[i];
            t.direction.setFromMatrixPosition(p.matrixWorld), o.setFromMatrixPosition(p.target.matrixWorld), t.direction.sub(o), t.direction.transformDirection(u), i++;
          } else if (p.isSpotLight) {
            const t = r.spot[l];
            t.position.setFromMatrixPosition(p.matrixWorld), t.position.applyMatrix4(u), t.direction.setFromMatrixPosition(p.matrixWorld), o.setFromMatrixPosition(p.target.matrixWorld), t.direction.sub(o), t.direction.transformDirection(u), l++;
          } else if (p.isRectAreaLight) {
            const t = r.rectArea[c];
            t.position.setFromMatrixPosition(p.matrixWorld), t.position.applyMatrix4(u), a.identity(), s.copy(p.matrixWorld), s.premultiply(u), a.extractRotation(s), t.halfWidth.set(0.5 * p.width, 0, 0), t.halfHeight.set(0, 0.5 * p.height, 0), t.halfWidth.applyMatrix4(a), t.halfHeight.applyMatrix4(a), c++;
          } else if (p.isPointLight) {
            const t = r.point[n];
            t.position.setFromMatrixPosition(p.matrixWorld), t.position.applyMatrix4(u), n++;
          } else if (p.isHemisphereLight) {
            const t = r.hemi[h];
            t.direction.setFromMatrixPosition(p.matrixWorld), t.direction.transformDirection(u), t.direction.normalize(), h++;
          }
        }
      }, state: r};
    }
    function wr(t, e) {
      const i = new br(t, e), n = [], r = [];
      return {init: function () {
        n.length = 0, r.length = 0;
      }, state: {lightsArray: n, shadowsArray: r, lights: i}, setupLights: function (t) {
        i.setup(n, t);
      }, setupLightsView: function (t) {
        i.setupView(n, t);
      }, pushLight: function (t) {
        n.push(t);
      }, pushShadow: function (t) {
        r.push(t);
      }};
    }
    function Sr(t, e) {
      let i = new WeakMap;
      return {get: function (n, r = 0) {
        let o;
        return false === i.has(n) ? (o = new wr(t, e), i.set(n, [o])) : r >= i.get(n).length ? (o = new wr(t, e), i.get(n).push(o)) : o = i.get(n)[r], o;
      }, dispose: function () {
        i = new WeakMap;
      }};
    }
    class MeshDepthMaterial extends Material {
      constructor(t) {
        super(), this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = false, this.wireframeLinewidth = 1, this.fog = false, this.setValues(t);
      }
      copy(t) {
        return super.copy(t), this.depthPacking = t.depthPacking, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this;
      }
    }
    MeshDepthMaterial.prototype.isMeshDepthMaterial = true;
    class MeshDistanceMaterial extends Material {
      constructor(t) {
        super(), this.type = "MeshDistanceMaterial", this.referencePosition = new three_module_Vector3, this.nearDistance = 1, this.farDistance = 1e3, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = false, this.setValues(t);
      }
      copy(t) {
        return super.copy(t), this.referencePosition.copy(t.referencePosition), this.nearDistance = t.nearDistance, this.farDistance = t.farDistance, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this;
      }
    }
    MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;
    function Mr(t, e, i) {
      let n = new Frustum;
      const r = new Vector2, o = new Vector2, s = new Vector4, a = new MeshDepthMaterial({depthPacking: 3201}), l = new MeshDistanceMaterial, c = {}, h = i.maxTextureSize, u = {0: 1, 1: 0, 2: 2}, p = new ShaderMaterial({uniforms: {shadow_pass: {value: null}, resolution: {value: new Vector2}, radius: {value: 4}, samples: {value: 8}}, vertexShader: "void main() {\n	gl_Position = vec4( position, 1.0 );\n}", fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\nuniform float samples;\n#include <packing>\nvoid main() {\n	float mean = 0.0;\n	float squared_mean = 0.0;\n	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n	for ( float i = 0.0; i < samples; i ++ ) {\n		float uvOffset = uvStart + i * uvStride;\n		#ifdef HORIZONTAL_PASS\n			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n			mean += distribution.x;\n			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n		#else\n			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n			mean += depth;\n			squared_mean += depth * depth;\n		#endif\n	}\n	mean = mean / samples;\n	squared_mean = squared_mean / samples;\n	float std_dev = sqrt( squared_mean - mean * mean );\n	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"}), m = p.clone();
      m.defines.HORIZONTAL_PASS = 1;
      const d = new BufferGeometry;
      d.setAttribute("position", new BufferAttribute(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
      const y = new Mesh(d, p), g = this;
      function v(i, n) {
        const r = e.update(y);
        p.uniforms.shadow_pass.value = i.map.texture, p.uniforms.resolution.value = i.mapSize, p.uniforms.radius.value = i.radius, p.uniforms.samples.value = i.blurSamples, t.setRenderTarget(i.mapPass), t.clear(), t.renderBufferDirect(n, null, r, p, y, null), m.uniforms.shadow_pass.value = i.mapPass.texture, m.uniforms.resolution.value = i.mapSize, m.uniforms.radius.value = i.radius, m.uniforms.samples.value = i.blurSamples, t.setRenderTarget(i.map), t.clear(), t.renderBufferDirect(n, null, r, m, y, null);
      }
      function b(e, i, n, r, o, s, h) {
        let p = null;
        const m = true === r.isPointLight ? e.customDistanceMaterial : e.customDepthMaterial;
        if (p = void 0 !== m ? m : true === r.isPointLight ? l : a, t.localClippingEnabled && true === n.clipShadows && 0 !== n.clippingPlanes.length || n.displacementMap && 0 !== n.displacementScale || n.alphaMap && n.alphaTest > 0) {
          const t = p.uuid, e = n.uuid;
          let i = c[t];
          void 0 === i && (i = {}, c[t] = i);
          let r = i[e];
          void 0 === r && (r = p.clone(), i[e] = r), p = r;
        }
        return p.visible = n.visible, p.wireframe = n.wireframe, p.side = 3 === h ? null !== n.shadowSide ? n.shadowSide : n.side : null !== n.shadowSide ? n.shadowSide : u[n.side], p.alphaMap = n.alphaMap, p.alphaTest = n.alphaTest, p.clipShadows = n.clipShadows, p.clippingPlanes = n.clippingPlanes, p.clipIntersection = n.clipIntersection, p.displacementMap = n.displacementMap, p.displacementScale = n.displacementScale, p.displacementBias = n.displacementBias, p.wireframeLinewidth = n.wireframeLinewidth, p.linewidth = n.linewidth, true === r.isPointLight && true === p.isMeshDistanceMaterial && (p.referencePosition.setFromMatrixPosition(r.matrixWorld), p.nearDistance = o, p.farDistance = s), p;
      }
      function w(i, r, o, s, a) {
        if (false === i.visible) return;
        if (i.layers.test(r.layers) && (i.isMesh || i.isLine || i.isPoints) && (i.castShadow || i.receiveShadow && 3 === a) && (!i.frustumCulled || n.intersectsObject(i))) {
          i.modelViewMatrix.multiplyMatrices(o.matrixWorldInverse, i.matrixWorld);
          const n = e.update(i), r = i.material;
          if (Array.isArray(r)) {
            const e = n.groups;
            for (let l = 0, c = e.length; l < c; l++) {
              const c = e[l], h = r[c.materialIndex];
              if (h && h.visible) {
                const e = b(i, 0, h, s, o.near, o.far, a);
                t.renderBufferDirect(o, null, n, e, i, c);
              }
            }
          } else if (r.visible) {
            const e = b(i, 0, r, s, o.near, o.far, a);
            t.renderBufferDirect(o, null, n, e, i, null);
          }
        }
        const l = i.children;
        for (let t = 0, e = l.length; t < e; t++) w(l[t], r, o, s, a);
      }
      this.enabled = false, this.autoUpdate = true, this.needsUpdate = false, this.type = 1, this.render = function (e, i, a) {
        if (false === g.enabled) return;
        if (false === g.autoUpdate && false === g.needsUpdate) return;
        if (0 === e.length) return;
        const l = t.getRenderTarget(), c = t.getActiveCubeFace(), u = t.getActiveMipmapLevel(), p = t.state;
        p.setBlending(0), p.buffers.color.setClear(1, 1, 1, 1), p.buffers.depth.setTest(true), p.setScissorTest(false);
        for (let l = 0, c = e.length; l < c; l++) {
          const c = e[l], u = c.shadow;
          if (void 0 === u) {
            console.warn("THREE.WebGLShadowMap:", c, "has no shadow.");
            continue;
          }
          if (false === u.autoUpdate && false === u.needsUpdate) continue;
          r.copy(u.mapSize);
          const m = u.getFrameExtents();
          if (r.multiply(m), o.copy(u.mapSize), (r.x > h || r.y > h) && (r.x > h && (o.x = Math.floor(h / m.x), r.x = o.x * m.x, u.mapSize.x = o.x), r.y > h && (o.y = Math.floor(h / m.y), r.y = o.y * m.y, u.mapSize.y = o.y)), null === u.map && !u.isPointLightShadow && 3 === this.type) {
            const t = {minFilter: x, magFilter: x, format: E};
            u.map = new WebGLRenderTarget(r.x, r.y, t), u.map.texture.name = c.name + ".shadowMap", u.mapPass = new WebGLRenderTarget(r.x, r.y, t), u.camera.updateProjectionMatrix();
          }
          if (null === u.map) {
            const t = {minFilter: _, magFilter: _, format: E};
            u.map = new WebGLRenderTarget(r.x, r.y, t), u.map.texture.name = c.name + ".shadowMap", u.camera.updateProjectionMatrix();
          }
          t.setRenderTarget(u.map), t.clear();
          const d = u.getViewportCount();
          for (let t = 0; t < d; t++) {
            const e = u.getViewport(t);
            s.set(o.x * e.x, o.y * e.y, o.x * e.z, o.y * e.w), p.viewport(s), u.updateMatrices(c, t), n = u.getFrustum(), w(i, a, u.camera, c, this.type);
          }
          u.isPointLightShadow || 3 !== this.type || v(u, a), u.needsUpdate = false;
        }
        g.needsUpdate = false, t.setRenderTarget(l, c, u);
      };
    }
    function Ar(t, e, i) {
      const n = i.isWebGL2;
      const r = new function () {
        let e = false;
        const i = new Vector4;
        let n = null;
        const r = new Vector4(0, 0, 0, 0);
        return {setMask: function (i) {
          n === i || e || (t.colorMask(i, i, i, i), n = i);
        }, setLocked: function (t) {
          e = t;
        }, setClear: function (e, n, o, s, a) {
          true === a && (e *= s, n *= s, o *= s), i.set(e, n, o, s), false === r.equals(i) && (t.clearColor(e, n, o, s), r.copy(i));
        }, reset: function () {
          e = false, n = null, r.set(-1, 0, 0, 0);
        }};
      }, s = new function () {
        let e = false, i = null, n = null, r = null;
        return {setTest: function (t) {
          t ? G(2929) : U(2929);
        }, setMask: function (n) {
          i === n || e || (t.depthMask(n), i = n);
        }, setFunc: function (e) {
          if (n !== e) {
            if (e) switch (e) {
              case 0:
                t.depthFunc(512);
                break;
              case 1:
                t.depthFunc(519);
                break;
              case 2:
                t.depthFunc(513);
                break;
              case 3:
                t.depthFunc(515);
                break;
              case 4:
                t.depthFunc(514);
                break;
              case 5:
                t.depthFunc(518);
                break;
              case 6:
                t.depthFunc(516);
                break;
              case 7:
                t.depthFunc(517);
                break;
              default:
                t.depthFunc(515);
            } else t.depthFunc(515);
            n = e;
          }
        }, setLocked: function (t) {
          e = t;
        }, setClear: function (e) {
          r !== e && (t.clearDepth(e), r = e);
        }, reset: function () {
          e = false, i = null, n = null, r = null;
        }};
      }, a = new function () {
        let e = false, i = null, n = null, r = null, o = null, s = null, a = null, l = null, c = null;
        return {setTest: function (t) {
          e || (t ? G(2960) : U(2960));
        }, setMask: function (n) {
          i === n || e || (t.stencilMask(n), i = n);
        }, setFunc: function (e, i, s) {
          n === e && r === i && o === s || (t.stencilFunc(e, i, s), n = e, r = i, o = s);
        }, setOp: function (e, i, n) {
          s === e && a === i && l === n || (t.stencilOp(e, i, n), s = e, a = i, l = n);
        }, setLocked: function (t) {
          e = t;
        }, setClear: function (e) {
          c !== e && (t.clearStencil(e), c = e);
        }, reset: function () {
          e = false, i = null, n = null, r = null, o = null, s = null, a = null, l = null, c = null;
        }};
      };
      let l = {}, c = null, h = {}, u = null, p = false, m = null, d = null, _ = null, y = null, g = null, x = null, v = null, b = false, w = null, S = null, M = null, A = null, C = null;
      const T = t.getParameter(35661);
      let E = false, L = 0;
      const D = t.getParameter(7938);
      -1 !== D.indexOf("WebGL") ? (L = parseFloat(/^WebGL (\d)/.exec(D)[1]), E = L >= 1) : -1 !== D.indexOf("OpenGL ES") && (L = parseFloat(/^OpenGL ES (\d)/.exec(D)[1]), E = L >= 2);
      let R = null, B = {};
      const P = t.getParameter(3088), I = t.getParameter(2978), V = (new Vector4).fromArray(P), F = (new Vector4).fromArray(I);
      function k(e, i, n) {
        const r = new Uint8Array(4), o = t.createTexture();
        t.bindTexture(e, o), t.texParameteri(e, 10241, 9728), t.texParameteri(e, 10240, 9728);
        for (let e = 0; e < n; e++) t.texImage2D(i + e, 0, 6408, 1, 1, 0, 6408, 5121, r);
        return o;
      }
      const N = {};
      function G(e) {
        true !== l[e] && (t.enable(e), l[e] = true);
      }
      function U(e) {
        false !== l[e] && (t.disable(e), l[e] = false);
      }
      N[3553] = k(3553, 3553, 1), N[34067] = k(34067, 34069, 6), r.setClear(0, 0, 0, 1), s.setClear(1), a.setClear(0), G(2929), s.setFunc(3), W(false), J(1), G(2884), H(0);
      const z = {[o]: 32774, 101: 32778, 102: 32779};
      if (n) z[103] = 32775, z[104] = 32776; else {
        const t = e.get("EXT_blend_minmax");
        null !== t && (z[103] = t.MIN_EXT, z[104] = t.MAX_EXT);
      }
      const O = {200: 0, 201: 1, 202: 768, 204: 770, 210: 776, 208: 774, 206: 772, 203: 769, 205: 771, 209: 775, 207: 773};
      function H(e, i, n, r, s, a, l, c) {
        if (0 !== e) {
          if (false === p && (G(3042), p = true), 5 === e) s = s || i, a = a || n, l = l || r, i === d && s === g || (t.blendEquationSeparate(z[i], z[s]), d = i, g = s), n === _ && r === y && a === x && l === v || (t.blendFuncSeparate(O[n], O[r], O[a], O[l]), _ = n, y = r, x = a, v = l), m = e, b = null; else if (e !== m || c !== b) {
            if (d === o && g === o || (t.blendEquation(32774), d = o, g = o), c) switch (e) {
              case 1:
                t.blendFuncSeparate(1, 771, 1, 771);
                break;
              case 2:
                t.blendFunc(1, 1);
                break;
              case 3:
                t.blendFuncSeparate(0, 0, 769, 771);
                break;
              case 4:
                t.blendFuncSeparate(0, 768, 0, 770);
                break;
              default:
                console.error("THREE.WebGLState: Invalid blending: ", e);
            } else switch (e) {
              case 1:
                t.blendFuncSeparate(770, 771, 1, 771);
                break;
              case 2:
                t.blendFunc(770, 1);
                break;
              case 3:
                t.blendFunc(0, 769);
                break;
              case 4:
                t.blendFunc(0, 768);
                break;
              default:
                console.error("THREE.WebGLState: Invalid blending: ", e);
            }
            _ = null, y = null, x = null, v = null, m = e, b = c;
          }
        } else true === p && (U(3042), p = false);
      }
      function W(e) {
        w !== e && (e ? t.frontFace(2304) : t.frontFace(2305), w = e);
      }
      function J(e) {
        0 !== e ? (G(2884), e !== S && (1 === e ? t.cullFace(1029) : 2 === e ? t.cullFace(1028) : t.cullFace(1032))) : U(2884), S = e;
      }
      function X(e, i, n) {
        e ? (G(32823), A === i && C === n || (t.polygonOffset(i, n), A = i, C = n)) : U(32823);
      }
      function q(e) {
        void 0 === e && (e = 33984 + T - 1), R !== e && (t.activeTexture(e), R = e);
      }
      return {buffers: {color: r, depth: s, stencil: a}, enable: G, disable: U, bindFramebuffer: function (e, i) {
        return null === i && null !== c && (i = c), h[e] !== i && (t.bindFramebuffer(e, i), h[e] = i, n && (36009 === e && (h[36160] = i), 36160 === e && (h[36009] = i)), true);
      }, bindXRFramebuffer: function (e) {
        e !== c && (t.bindFramebuffer(36160, e), c = e);
      }, useProgram: function (e) {
        return u !== e && (t.useProgram(e), u = e, true);
      }, setBlending: H, setMaterial: function (t, e) {
        2 === t.side ? U(2884) : G(2884);
        let i = 1 === t.side;
        e && (i = !i), W(i), 1 === t.blending && false === t.transparent ? H(0) : H(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.premultipliedAlpha), s.setFunc(t.depthFunc), s.setTest(t.depthTest), s.setMask(t.depthWrite), r.setMask(t.colorWrite);
        const n = t.stencilWrite;
        a.setTest(n), n && (a.setMask(t.stencilWriteMask), a.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask), a.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)), X(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits), true === t.alphaToCoverage ? G(32926) : U(32926);
      }, setFlipSided: W, setCullFace: J, setLineWidth: function (e) {
        e !== M && (E && t.lineWidth(e), M = e);
      }, setPolygonOffset: X, setScissorTest: function (t) {
        t ? G(3089) : U(3089);
      }, activeTexture: q, bindTexture: function (e, i) {
        null === R && q();
        let n = B[R];
        void 0 === n && (n = {type: void 0, texture: void 0}, B[R] = n), n.type === e && n.texture === i || (t.bindTexture(e, i || N[e]), n.type = e, n.texture = i);
      }, unbindTexture: function () {
        const e = B[R];
        void 0 !== e && void 0 !== e.type && (t.bindTexture(e.type, null), e.type = void 0, e.texture = void 0);
      }, compressedTexImage2D: function () {
        try {
          t.compressedTexImage2D.apply(t, arguments);
        } catch (t) {
          console.error("THREE.WebGLState:", t);
        }
      }, texImage2D: function () {
        try {
          t.texImage2D.apply(t, arguments);
        } catch (t) {
          console.error("THREE.WebGLState:", t);
        }
      }, texImage3D: function () {
        try {
          t.texImage3D.apply(t, arguments);
        } catch (t) {
          console.error("THREE.WebGLState:", t);
        }
      }, scissor: function (e) {
        false === V.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), V.copy(e));
      }, viewport: function (e) {
        false === F.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), F.copy(e));
      }, reset: function () {
        t.disable(3042), t.disable(2884), t.disable(2929), t.disable(32823), t.disable(3089), t.disable(2960), t.disable(32926), t.blendEquation(32774), t.blendFunc(1, 0), t.blendFuncSeparate(1, 0, 1, 0), t.colorMask(true, true, true, true), t.clearColor(0, 0, 0, 0), t.depthMask(true), t.depthFunc(513), t.clearDepth(1), t.stencilMask(4294967295), t.stencilFunc(519, 0, 4294967295), t.stencilOp(7680, 7680, 7680), t.clearStencil(0), t.cullFace(1029), t.frontFace(2305), t.polygonOffset(0, 0), t.activeTexture(33984), t.bindFramebuffer(36160, null), true === n && (t.bindFramebuffer(36009, null), t.bindFramebuffer(36008, null)), t.useProgram(null), t.lineWidth(1), t.scissor(0, 0, t.canvas.width, t.canvas.height), t.viewport(0, 0, t.canvas.width, t.canvas.height), l = {}, R = null, B = {}, c = null, h = {}, u = null, p = false, m = null, d = null, _ = null, y = null, g = null, x = null, v = null, b = false, w = null, S = null, M = null, A = null, C = null, V.set(0, 0, t.canvas.width, t.canvas.height), F.set(0, 0, t.canvas.width, t.canvas.height), r.reset(), s.reset(), a.reset();
      }};
    }
    function Cr(t, e, i, n, r, o, s) {
      const a = r.isWebGL2, l = r.maxTextures, c = r.maxCubemapSize, h = r.maxTextureSize, u = r.maxSamples, b = new WeakMap;
      let R, B = false;
      try {
        B = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d");
      } catch (t) {}
      function P(t, e) {
        return B ? new OffscreenCanvas(t, e) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
      }
      function I(t, e, i, n) {
        let r = 1;
        if ((t.width > n || t.height > n) && (r = n / Math.max(t.width, t.height)), r < 1 || true === e) {
          if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap) {
            const n = e ? et : Math.floor, o = "__private_" + i++ + "_" + r * t.width, s = "__private_" + i++ + "_" + r * t.height;
            void 0 === R && (R = P(o, s));
            const a = i ? P(o, s) : R;
            a.width = o, a.height = s;
            return a.getContext("2d").drawImage(t, 0, 0, o, s), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + t.width + "x" + t.height + ") to (" + o + "x" + s + ")."), a;
          }
          return "data" in t && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + t.width + "x" + t.height + ")."), t;
        }
        return t;
      }
      function k(e, i, r, o, s = 1) {
        t.generateMipmap(e);
        n.get(i).__maxMipLevel = Math.log2(Math.max(r, o, s));
      }
      function N(i, n, r) {
        if (false === a) return n;
        if (null !== i) {
          if (void 0 !== t[i]) return t[i];
          console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + i + "'");
        }
        return 6403 === n && (5126 === r && (o = 33326), 5131 === r && (o = 33325), 5121 === r && (o = 33321)), 6407 === n && (5126 === r && (o = 34837), 5131 === r && (o = 34843), 5121 === r && (o = 32849)), 6408 === n && (5126 === r && (o = 34836), 5131 === r && (o = 34842), 5121 === r && (o = 32856)), 33325 !== o && 33326 !== o && 34842 !== o && 34836 !== o || e.get("EXT_color_buffer_float"), o;
      }
      function G(t) {
        return t === _ || t === y || t === g ? 9728 : 9729;
      }
      function U(e) {
        const i = e.target;
        i.removeEventListener("dispose", U), function (e) {
          const i = n.get(e);
          if (void 0 === i.__webglInit) return;
          t.deleteTexture(i.__webglTexture), n.remove(e);
        }(i), i.isVideoTexture && b.delete(i), s.memory.textures--;
      }
      function z(e) {
        const i = e.target;
        i.removeEventListener("dispose", z), function (e) {
          const i = e.texture, r = n.get(e), o = n.get(i);
          if (!e) return;
          void 0 !== o.__webglTexture && (t.deleteTexture(o.__webglTexture), s.memory.textures--);
          e.depthTexture && e.depthTexture.dispose();
          if (e.isWebGLCubeRenderTarget) for (let e = 0; e < 6; e++) t.deleteFramebuffer(r.__webglFramebuffer[e]), r.__webglDepthbuffer && t.deleteRenderbuffer(r.__webglDepthbuffer[e]); else t.deleteFramebuffer(r.__webglFramebuffer), r.__webglDepthbuffer && t.deleteRenderbuffer(r.__webglDepthbuffer), r.__webglMultisampledFramebuffer && t.deleteFramebuffer(r.__webglMultisampledFramebuffer), r.__webglColorRenderbuffer && t.deleteRenderbuffer(r.__webglColorRenderbuffer), r.__webglDepthRenderbuffer && t.deleteRenderbuffer(r.__webglDepthRenderbuffer);
          if (e.isWebGLMultipleRenderTargets) for (let e = 0, r = i.length; e < r; e++) {
            const r = n.get(i[e]);
            r.__webglTexture && (t.deleteTexture(r.__webglTexture), s.memory.textures--), n.remove(i[e]);
          }
          n.remove(i), n.remove(e);
        }(i);
      }
      let O = 0;
      function H(t, e) {
        const r = n.get(t);
        if (t.isVideoTexture && function (t) {
          const e = s.render.frame;
          b.get(t) !== e && (b.set(t, e), t.update());
        }(t), t.version > 0 && r.__version !== t.version) {
          const i = t.image;
          if (void 0 === i) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined"); else {
            if (false !== i.complete) return void Z(r, t, e);
            console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
          }
        }
        i.activeTexture(33984 + e), i.bindTexture(3553, r.__webglTexture);
      }
      function W(e, r) {
        const s = n.get(e);
        e.version > 0 && s.__version !== e.version ? function (e, n, r) {
          if (6 !== n.image.length) return;
          Y(e, n), i.activeTexture(33984 + r), i.bindTexture(34067, e.__webglTexture), t.pixelStorei(37440, n.flipY), t.pixelStorei(37441, n.premultiplyAlpha), t.pixelStorei(3317, n.unpackAlignment), t.pixelStorei(37443, 0);
          const s = n && (n.isCompressedTexture || n.image[0].isCompressedTexture), l = n.image[0] && n.image[0].isDataTexture, h = [];
          for (let t = 0; t < 6; t++) h[t] = s || l ? l ? n.image[t].image : n.image[t] : I(n.image[t], false, true, c);
          const u = h[0], p = 0 == (u.width & u.width - 1) && 0 !== u.width && (0 == (u.height & u.height - 1) && 0 !== u.height) || a, m = o.convert(n.format), d = o.convert(n.type), _ = N(n.internalFormat, m, d);
          let y;
          if (q(34067, n, p), s) {
            for (let t = 0; t < 6; t++) {
              y = h[t].mipmaps;
              for (let e = 0; e < y.length; e++) {
                const r = y[e];
                n.format !== E && n.format !== T ? null !== m ? i.compressedTexImage2D(34069 + t, e, _, r.width, r.height, 0, r.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : i.texImage2D(34069 + t, e, _, r.width, r.height, 0, m, d, r.data);
              }
            }
            e.__maxMipLevel = y.length - 1;
          } else {
            y = n.mipmaps;
            for (let t = 0; t < 6; t++) if (l) {
              i.texImage2D(34069 + t, 0, _, h[t].width, h[t].height, 0, m, d, h[t].data);
              for (let e = 0; e < y.length; e++) {
                const n = y[e].image[t].image;
                i.texImage2D(34069 + t, e + 1, _, n.width, n.height, 0, m, d, n.data);
              }
            } else {
              i.texImage2D(34069 + t, 0, _, m, d, h[t]);
              for (let e = 0; e < y.length; e++) {
                const n = y[e];
                i.texImage2D(34069 + t, e + 1, _, m, d, n.image[t]);
              }
            }
            e.__maxMipLevel = y.length;
          }
          n.generateMipmaps && p && n.minFilter !== _ && n.minFilter !== x && k(34067, n, u.width, u.height);
          e.__version = n.version, n.onUpdate && n.onUpdate(n);
        }(s, e, r) : (i.activeTexture(33984 + r), i.bindTexture(34067, s.__webglTexture));
      }
      const J = {[p]: 10497, [m]: 33071, [d]: 33648}, X = {[_]: 9728, [y]: 9984, [g]: 9986, [x]: 9729, 1007: 9985, [v]: 9987};
      function q(i, o, s) {
        if (s ? (t.texParameteri(i, 10242, J[o.wrapS]), t.texParameteri(i, 10243, J[o.wrapT]), 32879 !== i && 35866 !== i || t.texParameteri(i, 32882, J[o.wrapR]), t.texParameteri(i, 10240, X[o.magFilter]), t.texParameteri(i, 10241, X[o.minFilter])) : (t.texParameteri(i, 10242, 33071), t.texParameteri(i, 10243, 33071), 32879 !== i && 35866 !== i || t.texParameteri(i, 32882, 33071), o.wrapS === m && o.wrapT === m || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), t.texParameteri(i, 10240, G(o.magFilter)), t.texParameteri(i, 10241, G(o.minFilter)), o.minFilter !== _ && o.minFilter !== x && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), true === e.has("EXT_texture_filter_anisotropic")) {
          const s = e.get("EXT_texture_filter_anisotropic");
          if (o.type === M && false === e.has("OES_texture_float_linear")) return;
          if (false === a && o.type === A && false === e.has("OES_texture_half_float_linear")) return;
          (o.anisotropy > 1 || n.get(o).__currentAnisotropy) && (t.texParameterf(i, s.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(o.anisotropy, r.getMaxAnisotropy())), n.get(o).__currentAnisotropy = o.anisotropy);
        }
      }
      function Y(e, i) {
        void 0 === e.__webglInit && (e.__webglInit = true, i.addEventListener("dispose", U), e.__webglTexture = t.createTexture(), s.memory.textures++);
      }
      function Z(e, n, r) {
        let s = 3553;
        n.isDataTexture2DArray && (s = 35866), n.isDataTexture3D && (s = 32879), Y(e, n), i.activeTexture(33984 + r), i.bindTexture(s, e.__webglTexture), t.pixelStorei(37440, n.flipY), t.pixelStorei(37441, n.premultiplyAlpha), t.pixelStorei(3317, n.unpackAlignment), t.pixelStorei(37443, 0);
        const l = function (t) {
          return !a && (t.wrapS !== m || t.wrapT !== m || t.minFilter !== _ && t.minFilter !== x);
        }(n) && false === (0 == (n.image.width & n.image.width - 1) && 0 !== n.image.width && (0 == (n.image.height & n.image.height - 1) && 0 !== n.image.height)), c = I(n.image, l, false, h), u = 0 == (c.width & c.width - 1) && 0 !== c.width && (0 == (c.height & c.height - 1) && 0 !== c.height) || a, p = o.convert(n.format);
        let d, y = o.convert(n.type), g = N(n.internalFormat, p, y);
        q(s, n, u);
        const v = n.mipmaps;
        if (n.isDepthTexture) g = 6402, a ? g = n.type === M ? 36012 : n.type === S ? 33190 : n.type === C ? 35056 : 33189 : n.type === M && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), n.format === L && 6402 === g && n.type !== w && n.type !== S && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), n.type = w, y = o.convert(n.type)), n.format === D && 6402 === g && (g = 34041, n.type !== C && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), n.type = C, y = o.convert(n.type))), i.texImage2D(3553, 0, g, c.width, c.height, 0, p, y, null); else if (n.isDataTexture) if (v.length > 0 && u) {
          for (let t = 0, e = v.length; t < e; t++) d = v[t], i.texImage2D(3553, t, g, d.width, d.height, 0, p, y, d.data);
          n.generateMipmaps = false, e.__maxMipLevel = v.length - 1;
        } else i.texImage2D(3553, 0, g, c.width, c.height, 0, p, y, c.data), e.__maxMipLevel = 0; else if (n.isCompressedTexture) {
          for (let t = 0, e = v.length; t < e; t++) d = v[t], n.format !== E && n.format !== T ? null !== p ? i.compressedTexImage2D(3553, t, g, d.width, d.height, 0, d.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : i.texImage2D(3553, t, g, d.width, d.height, 0, p, y, d.data);
          e.__maxMipLevel = v.length - 1;
        } else if (n.isDataTexture2DArray) i.texImage3D(35866, 0, g, c.width, c.height, c.depth, 0, p, y, c.data), e.__maxMipLevel = 0; else if (n.isDataTexture3D) i.texImage3D(32879, 0, g, c.width, c.height, c.depth, 0, p, y, c.data), e.__maxMipLevel = 0; else if (v.length > 0 && u) {
          for (let t = 0, e = v.length; t < e; t++) d = v[t], i.texImage2D(3553, t, g, p, y, d);
          n.generateMipmaps = false, e.__maxMipLevel = v.length - 1;
        } else i.texImage2D(3553, 0, g, p, y, c), e.__maxMipLevel = 0;
        n.generateMipmaps && u && n.minFilter !== _ && n.minFilter !== x && k(s, n, c.width, c.height), e.__version = n.version, n.onUpdate && n.onUpdate(n);
      }
      function K(e, r, s, a, l) {
        const c = o.convert(s.format), h = o.convert(s.type), u = N(s.internalFormat, c, h);
        32879 === l || 35866 === l ? i.texImage3D(l, 0, u, r.width, r.height, r.depth, 0, c, h, null) : i.texImage2D(l, 0, u, r.width, r.height, 0, c, h, null), i.bindFramebuffer(36160, e), t.framebufferTexture2D(36160, a, l, n.get(s).__webglTexture, 0), i.bindFramebuffer(36160, null);
      }
      function $(e, i, n) {
        if (t.bindRenderbuffer(36161, e), i.depthBuffer && !i.stencilBuffer) {
          let r = 33189;
          if (n) {
            const e = i.depthTexture;
            e && e.isDepthTexture && (e.type === M ? r = 36012 : e.type === S && (r = 33190));
            const n = it(i);
            t.renderbufferStorageMultisample(36161, n, r, i.width, i.height);
          } else t.renderbufferStorage(36161, r, i.width, i.height);
          t.framebufferRenderbuffer(36160, 36096, 36161, e);
        } else if (i.depthBuffer && i.stencilBuffer) {
          if (n) {
            const e = it(i);
            t.renderbufferStorageMultisample(36161, e, 35056, i.width, i.height);
          } else t.renderbufferStorage(36161, 34041, i.width, i.height);
          t.framebufferRenderbuffer(36160, 33306, 36161, e);
        } else {
          const e = true === i.isWebGLMultipleRenderTargets ? i.texture[0] : i.texture, r = o.convert(e.format), s = o.convert(e.type), a = N(e.internalFormat, r, s);
          if (n) {
            const e = it(i);
            t.renderbufferStorageMultisample(36161, e, a, i.width, i.height);
          } else t.renderbufferStorage(36161, a, i.width, i.height);
        }
        t.bindRenderbuffer(36161, null);
      }
      function Q(e) {
        const r = n.get(e), o = true === e.isWebGLCubeRenderTarget;
        if (e.depthTexture) {
          if (o) throw new Error("target.depthTexture not supported in Cube render targets");
          !function (e, r) {
            if (r && r.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
            if (i.bindFramebuffer(36160, e), !r.depthTexture || !r.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
            n.get(r.depthTexture).__webglTexture && r.depthTexture.image.width === r.width && r.depthTexture.image.height === r.height || (r.depthTexture.image.width = r.width, r.depthTexture.image.height = r.height, r.depthTexture.needsUpdate = true), H(r.depthTexture, 0);
            const o = n.get(r.depthTexture).__webglTexture;
            if (r.depthTexture.format === L) t.framebufferTexture2D(36160, 36096, 3553, o, 0); else {
              if (r.depthTexture.format !== D) throw new Error("Unknown depthTexture format");
              t.framebufferTexture2D(36160, 33306, 3553, o, 0);
            }
          }(r.__webglFramebuffer, e);
        } else if (o) {
          r.__webglDepthbuffer = [];
          for (let n = 0; n < 6; n++) i.bindFramebuffer(36160, r.__webglFramebuffer[n]), r.__webglDepthbuffer[n] = t.createRenderbuffer(), (r.__webglDepthbuffer[n] % e + e) % e;
        } else i.bindFramebuffer(36160, r.__webglFramebuffer), r.__webglDepthbuffer = t.createRenderbuffer(), (r.__webglDepthbuffer % e + e) % e;
        i.bindFramebuffer(36160, null);
      }
      function it(t) {
        return a && t.isWebGLMultisampleRenderTarget ? Math.min(u, t.samples) : 0;
      }
      let nt = false, rt = false;
      this.allocateTextureUnit = function () {
        const t = O;
        return t >= l && console.warn("THREE.WebGLTextures: Trying to use " + t + " texture units while this GPU supports only " + l), O += 1, t;
      }, this.resetTextureUnits = function () {
        O = 0;
      }, this.setTexture2D = H, this.setTexture2DArray = function (t, e) {
        const r = n.get(t);
        t.version > 0 && r.__version !== t.version ? Z(r, t, e) : (i.activeTexture(33984 + e), i.bindTexture(35866, r.__webglTexture));
      }, this.setTexture3D = function (t, e) {
        const r = n.get(t);
        t.version > 0 && r.__version !== t.version ? Z(r, t, e) : (i.activeTexture(33984 + e), i.bindTexture(32879, r.__webglTexture));
      }, this.setTextureCube = W, this.setupRenderTarget = function (e) {
        const l = e.texture, c = n.get(e), h = n.get(l);
        e.addEventListener("dispose", z), true !== e.isWebGLMultipleRenderTargets && (h.__webglTexture = t.createTexture(), h.__version = l.version, s.memory.textures++);
        const u = true === e.isWebGLCubeRenderTarget, p = true === e.isWebGLMultipleRenderTargets, m = true === e.isWebGLMultisampleRenderTarget, d = l.isDataTexture3D || l.isDataTexture2DArray, _ = 0 == (e.width & e.width - 1) && 0 !== e.width && (0 == (e.height & e.height - 1) && 0 !== e.height) || a;
        if (!a || l.format !== T || l.type !== M && l.type !== A || (l.format = E, console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")), u) {
          c.__webglFramebuffer = [];
          for (let e = 0; e < 6; e++) c.__webglFramebuffer[e] = t.createFramebuffer();
        } else if (c.__webglFramebuffer = t.createFramebuffer(), p) if (r.drawBuffers) {
          const i = e.texture;
          for (let e = 0, r = i.length; e < r; e++) {
            const r = n.get(i[e]);
            void 0 === r.__webglTexture && (r.__webglTexture = t.createTexture(), s.memory.textures++);
          }
        } else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension."); else if (m) if (a) {
          c.__webglMultisampledFramebuffer = t.createFramebuffer(), c.__webglColorRenderbuffer = t.createRenderbuffer(), t.bindRenderbuffer(36161, c.__webglColorRenderbuffer);
          const n = o.convert(l.format), r = o.convert(l.type), s = N(l.internalFormat, n, r), a = it(e);
          t.renderbufferStorageMultisample(36161, a, s, e.width, e.height), i.bindFramebuffer(36160, c.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(36160, 36064, 36161, c.__webglColorRenderbuffer), t.bindRenderbuffer(36161, null), e.depthBuffer && (c.__webglDepthRenderbuffer = t.createRenderbuffer(), (c.__webglDepthRenderbuffer % e + e) % e), i.bindFramebuffer(36160, null);
        } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
        if (u) {
          i.bindTexture(34067, h.__webglTexture), q(34067, l, _);
          for (let t = 0; t < 6; t++) Math.max(e, Math.min(l, c.__webglFramebuffer[t]));
          l.generateMipmaps && _ && l.minFilter !== _ && l.minFilter !== x && k(34067, l, e.width, e.height), i.unbindTexture();
        } else if (p) {
          const t = e.texture;
          for (let r = 0, o = t.length; r < o; r++) {
            const o = t[r], s = n.get(o);
            i.bindTexture(3553, s.__webglTexture), q(3553, o, _), Math.max(e, Math.min(o, c.__webglFramebuffer)), o.generateMipmaps && _ && o.minFilter !== _ && o.minFilter !== x && k(3553, o, e.width, e.height);
          }
          i.unbindTexture();
        } else {
          let t = 3553;
          if (d) if (a) {
            t = l.isDataTexture3D ? 32879 : 35866;
          } else console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.");
          i.bindTexture(t, h.__webglTexture), q(t, l, _), Math.max(e, Math.min(l, c.__webglFramebuffer)), l.generateMipmaps && _ && l.minFilter !== _ && l.minFilter !== x && k(t, l, e.width, e.height, e.depth), i.unbindTexture();
        }
        e.depthBuffer && (1 - i) * e + i * e;
      }, this.updateRenderTargetMipmap = function (t) {
        const e = 0 == (t.width & t.width - 1) && 0 !== t.width && (0 == (t.height & t.height - 1) && 0 !== t.height) || a, r = true === t.isWebGLMultipleRenderTargets ? t.texture : [t.texture];
        for (let o = 0, s = r.length; o < s; o++) {
          const s = r[o];
          if (s.generateMipmaps && e && s.minFilter !== _ && s.minFilter !== x) {
            const e = t.isWebGLCubeRenderTarget ? 34067 : 3553, r = n.get(s).__webglTexture;
            i.bindTexture(e, r), k(e, s, t.width, t.height), i.unbindTexture();
          }
        }
      }, this.updateMultisampleRenderTarget = function (e) {
        if (e.isWebGLMultisampleRenderTarget) if (a) {
          const r = e.width, o = e.height;
          let s = 16384;
          e.depthBuffer && (s |= 256), e.stencilBuffer && (s |= 1024);
          const a = n.get(e);
          i.bindFramebuffer(36008, a.__webglMultisampledFramebuffer), i.bindFramebuffer(36009, a.__webglFramebuffer), t.blitFramebuffer(0, 0, r, o, 0, 0, r, o, s, 9728), i.bindFramebuffer(36008, null), i.bindFramebuffer(36009, a.__webglMultisampledFramebuffer);
        } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
      }, this.safeSetTexture2D = function (t, e) {
        t && t.isWebGLRenderTarget && (false === nt && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), nt = true), t = t.texture), H(t, e);
      }, this.safeSetTextureCube = function (t, e) {
        t && t.isWebGLCubeRenderTarget && (false === rt && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), rt = true), t = t.texture), W(t, e);
      };
    }
    function Tr(t, e, i) {
      const n = i.isWebGL2;
      return {convert: function (t) {
        let i;
        if (t === b) return 5121;
        if (1017 === t) return 32819;
        if (1018 === t) return 32820;
        if (1019 === t) return 33635;
        if (1010 === t) return 5120;
        if (1011 === t) return 5122;
        if (t === w) return 5123;
        if (1013 === t) return 5124;
        if (t === S) return 5125;
        if (t === M) return 5126;
        if (t === A) return n ? 5131 : (i = e.get("OES_texture_half_float"), null !== i ? i.HALF_FLOAT_OES : null);
        if (1021 === t) return 6406;
        if (t === T) return 6407;
        if (t === E) return 6408;
        if (1024 === t) return 6409;
        if (1025 === t) return 6410;
        if (t === L) return 6402;
        if (t === D) return 34041;
        if (1028 === t) return 6403;
        if (1029 === t) return 36244;
        if (1030 === t) return 33319;
        if (1031 === t) return 33320;
        if (1032 === t) return 36248;
        if (1033 === t) return 36249;
        if (33776 === t || 33777 === t || 33778 === t || 33779 === t) {
          if (i = e.get("WEBGL_compressed_texture_s3tc"), null === i) return null;
          if (33776 === t) return i.COMPRESSED_RGB_S3TC_DXT1_EXT;
          if (33777 === t) return i.COMPRESSED_RGBA_S3TC_DXT1_EXT;
          if (33778 === t) return i.COMPRESSED_RGBA_S3TC_DXT3_EXT;
          if (33779 === t) return i.COMPRESSED_RGBA_S3TC_DXT5_EXT;
        }
        if (35840 === t || 35841 === t || 35842 === t || 35843 === t) {
          if (i = e.get("WEBGL_compressed_texture_pvrtc"), null === i) return null;
          if (35840 === t) return i.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
          if (35841 === t) return i.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
          if (35842 === t) return i.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
          if (35843 === t) return i.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
        }
        if (36196 === t) return i = e.get("WEBGL_compressed_texture_etc1"), null !== i ? i.COMPRESSED_RGB_ETC1_WEBGL : null;
        if ((37492 === t || 37496 === t) && (i = e.get("WEBGL_compressed_texture_etc"), null !== i)) {
          if (37492 === t) return i.COMPRESSED_RGB8_ETC2;
          if (37496 === t) return i.COMPRESSED_RGBA8_ETC2_EAC;
        }
        return 37808 === t || 37809 === t || 37810 === t || 37811 === t || 37812 === t || 37813 === t || 37814 === t || 37815 === t || 37816 === t || 37817 === t || 37818 === t || 37819 === t || 37820 === t || 37821 === t || 37840 === t || 37841 === t || 37842 === t || 37843 === t || 37844 === t || 37845 === t || 37846 === t || 37847 === t || 37848 === t || 37849 === t || 37850 === t || 37851 === t || 37852 === t || 37853 === t ? (i = e.get("WEBGL_compressed_texture_astc"), null !== i ? t : null) : 36492 === t ? (i = e.get("EXT_texture_compression_bptc"), null !== i ? t : null) : t === C ? n ? 34042 : (i = e.get("WEBGL_depth_texture"), null !== i ? i.UNSIGNED_INT_24_8_WEBGL : null) : void 0;
      }};
    }
    class ArrayCamera extends PerspectiveCamera {
      constructor(t = []) {
        super(), this.cameras = t;
      }
    }
    ArrayCamera.prototype.isArrayCamera = true;
    class Group extends Object3D {
      constructor() {
        super(), this.type = "Group";
      }
    }
    Group.prototype.isGroup = true;
    const Er = {type: "move"};
    class WebXRController {
      constructor() {
        this._targetRay = null, this._grip = null, this._hand = null;
      }
      getHandSpace() {
        return null === this._hand && (this._hand = new Group, this._hand.matrixAutoUpdate = false, this._hand.visible = false, this._hand.joints = {}, this._hand.inputState = {pinching: false}), this._hand;
      }
      getTargetRaySpace() {
        return null === this._targetRay && (this._targetRay = new Group, this._targetRay.matrixAutoUpdate = false, this._targetRay.visible = false, this._targetRay.hasLinearVelocity = false, this._targetRay.linearVelocity = new three_module_Vector3, this._targetRay.hasAngularVelocity = false, this._targetRay.angularVelocity = new three_module_Vector3), this._targetRay;
      }
      getGripSpace() {
        return null === this._grip && (this._grip = new Group, this._grip.matrixAutoUpdate = false, this._grip.visible = false, this._grip.hasLinearVelocity = false, this._grip.linearVelocity = new three_module_Vector3, this._grip.hasAngularVelocity = false, this._grip.angularVelocity = new three_module_Vector3), this._grip;
      }
      dispatchEvent(t) {
        return null !== this._targetRay && this._targetRay.dispatchEvent(t), null !== this._grip && this._grip.dispatchEvent(t), null !== this._hand && this._hand.dispatchEvent(t), this;
      }
      disconnect(t) {
        return this.dispatchEvent({type: "disconnected", data: t}), null !== this._targetRay && (this._targetRay.visible = false), null !== this._grip && (this._grip.visible = false), null !== this._hand && (this._hand.visible = false), this;
      }
      update(t, e, i) {
        let n = null, r = null, o = null;
        const s = this._targetRay, a = this._grip, l = this._hand;
        if (t && "visible-blurred" !== e.session.visibilityState) if (null !== s && (n = e.getPose(t.targetRaySpace, i), null !== n && (s.matrix.fromArray(n.transform.matrix), s.matrix.decompose(s.position, s.rotation, s.scale), n.linearVelocity ? (s.hasLinearVelocity = true, s.linearVelocity.copy(n.linearVelocity)) : s.hasLinearVelocity = false, n.angularVelocity ? (s.hasAngularVelocity = true, s.angularVelocity.copy(n.angularVelocity)) : s.hasAngularVelocity = false, this.dispatchEvent(Er))), l && t.hand) {
          o = true;
          for (const n of t.hand.values()) {
            const t = e.getJointPose(n, i);
            if (void 0 === l.joints[n.jointName]) {
              const t = new Group;
              t.matrixAutoUpdate = false, t.visible = false, l.joints[n.jointName] = t, l.add(t);
            }
            const r = l.joints[n.jointName];
            null !== t && (r.matrix.fromArray(t.transform.matrix), r.matrix.decompose(r.position, r.rotation, r.scale), r.jointRadius = t.radius), r.visible = null !== t;
          }
          const n = l.joints["index-finger-tip"], r = l.joints["thumb-tip"], s = n.position.distanceTo(r.position), a = 0.02, c = 0.005;
          l.inputState.pinching && s > a + c ? (l.inputState.pinching = false, this.dispatchEvent({type: "pinchend", handedness: t.handedness, target: this})) : !l.inputState.pinching && s <= a - c && (l.inputState.pinching = true, this.dispatchEvent({type: "pinchstart", handedness: t.handedness, target: this}));
        } else null !== a && t.gripSpace && (r = e.getPose(t.gripSpace, i), null !== r && (a.matrix.fromArray(r.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), r.linearVelocity ? (a.hasLinearVelocity = true, a.linearVelocity.copy(r.linearVelocity)) : a.hasLinearVelocity = false, r.angularVelocity ? (a.hasAngularVelocity = true, a.angularVelocity.copy(r.angularVelocity)) : a.hasAngularVelocity = false));
        return null !== s && (s.visible = null !== n), null !== a && (a.visible = null !== r), null !== l && (l.visible = null !== o), this;
      }
    }
    class WebXRManager extends EventDispatcher {
      constructor(t, e) {
        super();
        const i = this, n = t.state;
        let r = null, o = 1, s = null, a = "local-floor", l = null, c = null, h = null, u = null, p = null, m = false, d = null, _ = null, y = null, g = null, x = null, v = null;
        const b = [], w = new Map, S = new PerspectiveCamera;
        S.layers.enable(1), S.viewport = new Vector4;
        const M = new PerspectiveCamera;
        M.layers.enable(2), M.viewport = new Vector4;
        const A = [S, M], C = new ArrayCamera;
        C.layers.enable(1), C.layers.enable(2);
        let T = null, E = null;
        function L(t) {
          const e = w.get(t.inputSource);
          e && e.dispatchEvent({type: t.type, data: t.inputSource});
        }
        function D() {
          w.forEach(function (t, e) {
            t.disconnect(e);
          }), w.clear(), T = null, E = null, n.bindXRFramebuffer(null), t.setRenderTarget(t.getRenderTarget()), h && e.deleteFramebuffer(h), d && e.deleteFramebuffer(d), _ && e.deleteRenderbuffer(_), y && e.deleteRenderbuffer(y), h = null, d = null, _ = null, y = null, p = null, u = null, c = null, r = null, F.stop(), i.isPresenting = false, i.dispatchEvent({type: "sessionend"});
        }
        function R(t) {
          const e = r.inputSources;
          for (let t = 0; t < b.length; t++) w.set(e[t], b[t]);
          for (let e = 0; e < t.removed.length; e++) {
            const i = t.removed[e], n = w.get(i);
            n && (n.dispatchEvent({type: "disconnected", data: i}), w.delete(i));
          }
          for (let e = 0; e < t.added.length; e++) {
            const i = t.added[e], n = w.get(i);
            n && n.dispatchEvent({type: "connected", data: i});
          }
        }
        this.cameraAutoUpdate = true, this.enabled = false, this.isPresenting = false, this.getController = function (t) {
          let e = b[t];
          return void 0 === e && (e = new WebXRController, b[t] = e), e.getTargetRaySpace();
        }, this.getControllerGrip = function (t) {
          let e = b[t];
          return void 0 === e && (e = new WebXRController, b[t] = e), e.getGripSpace();
        }, this.getHand = function (t) {
          let e = b[t];
          return void 0 === e && (e = new WebXRController, b[t] = e), e.getHandSpace();
        }, this.setFramebufferScaleFactor = function (t) {
          o = t, true === i.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
        }, this.setReferenceSpaceType = function (t) {
          a = t, true === i.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
        }, this.getReferenceSpace = function () {
          return s;
        }, this.getBaseLayer = function () {
          return null !== u ? u : p;
        }, this.getBinding = function () {
          return c;
        }, this.getFrame = function () {
          return g;
        }, this.getSession = function () {
          return r;
        }, this.setSession = async function (t) {
          if (r = t, null !== r) {
            r.addEventListener("select", L), r.addEventListener("selectstart", L), r.addEventListener("selectend", L), r.addEventListener("squeeze", L), r.addEventListener("squeezestart", L), r.addEventListener("squeezeend", L), r.addEventListener("end", D), r.addEventListener("inputsourceschange", R);
            const t = e.getContextAttributes();
            if (true !== t.xrCompatible && await e.makeXRCompatible(), void 0 === r.renderState.layers) {
              const i = {antialias: t.antialias, alpha: t.alpha, depth: t.depth, stencil: t.stencil, framebufferScaleFactor: o};
              p = new XRWebGLLayer(r, e, i), r.updateRenderState({baseLayer: p});
            } else if (e instanceof WebGLRenderingContext) {
              const i = {antialias: true, alpha: t.alpha, depth: t.depth, stencil: t.stencil, framebufferScaleFactor: o};
              p = new XRWebGLLayer(r, e, i), r.updateRenderState({layers: [p]});
            } else {
              m = t.antialias;
              let i = null;
              t.depth && (v = 256, t.stencil && (v |= 1024), x = t.stencil ? 33306 : 36096, i = t.stencil ? 35056 : 33190);
              const s = {colorFormat: t.alpha ? 32856 : 32849, depthFormat: i, scaleFactor: o};
              c = new XRWebGLBinding(r, e), u = c.createProjectionLayer(s), h = e.createFramebuffer(), r.updateRenderState({layers: [u]}), m && (d = e.createFramebuffer(), _ = e.createRenderbuffer(), e.bindRenderbuffer(36161, _), e.renderbufferStorageMultisample(36161, 4, 32856, u.textureWidth, u.textureHeight), n.bindFramebuffer(36160, d), e.framebufferRenderbuffer(36160, 36064, 36161, _), e.bindRenderbuffer(36161, null), null !== i && (y = e.createRenderbuffer(), e.bindRenderbuffer(36161, y), e.renderbufferStorageMultisample(36161, 4, i, u.textureWidth, u.textureHeight), e.framebufferRenderbuffer(36160, x, 36161, y), e.bindRenderbuffer(36161, null)), n.bindFramebuffer(36160, null));
            }
            s = await r.requestReferenceSpace(a), F.setContext(r), F.start(), i.isPresenting = true, i.dispatchEvent({type: "sessionstart"});
          }
        };
        const B = new three_module_Vector3, P = new three_module_Vector3;
        function I(t, e) {
          null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix), t.matrixWorldInverse.copy(t.matrixWorld).invert();
        }
        this.updateCamera = function (t) {
          if (null === r) return;
          C.near = M.near = S.near = t.near, C.far = M.far = S.far = t.far, T === C.near && E === C.far || (r.updateRenderState({depthNear: C.near, depthFar: C.far}), T = C.near, E = C.far);
          const e = t.parent, i = C.cameras;
          I(C, e);
          for (let t = 0; t < i.length; t++) I(i[t], e);
          C.matrixWorld.decompose(C.position, C.quaternion, C.scale), t.position.copy(C.position), t.quaternion.copy(C.quaternion), t.scale.copy(C.scale), t.matrix.copy(C.matrix), t.matrixWorld.copy(C.matrixWorld);
          const n = t.children;
          for (let t = 0, e = n.length; t < e; t++) n[t].updateMatrixWorld(true);
          2 === i.length ? function (t, e, i) {
            B.setFromMatrixPosition(e.matrixWorld), P.setFromMatrixPosition(i.matrixWorld);
            const n = B.distanceTo(P), r = e.projectionMatrix.elements, o = i.projectionMatrix.elements, s = r[14] / (r[10] - 1), a = r[14] / (r[10] + 1), l = (r[9] + 1) / r[5], c = (r[9] - 1) / r[5], h = (r[8] - 1) / r[0], u = (o[8] + 1) / o[0], p = s * h, m = s * u, d = n / (-h + u), _ = d * -h;
            e.matrixWorld.decompose(t.position, t.quaternion, t.scale), t.translateX(_), t.translateZ(d), t.matrixWorld.compose(t.position, t.quaternion, t.scale), t.matrixWorldInverse.copy(t.matrixWorld).invert();
            const y = s + d, g = a + d, x = p - _, v = m + (n - _), b = l * a / g * y, w = c * a / g * y;
            t.projectionMatrix.makePerspective(x, v, b, w, y, g);
          }(C, S, M) : C.projectionMatrix.copy(S.projectionMatrix);
        }, this.getCamera = function () {
          return C;
        }, this.getFoveation = function () {
          return null !== u ? u.fixedFoveation : null !== p ? p.fixedFoveation : void 0;
        }, this.setFoveation = function (t) {
          null !== u && (u.fixedFoveation = t), null !== p && void 0 !== p.fixedFoveation && (p.fixedFoveation = t);
        };
        let V = null;
        const F = new ei;
        F.setAnimationLoop(function (t, i) {
          if (l = i.getViewerPose(s), g = i, null !== l) {
            const t = l.views;
            null !== p && n.bindXRFramebuffer(p.framebuffer);
            let i = false;
            t.length !== C.cameras.length && (C.cameras.length = 0, i = true);
            for (let r = 0; r < t.length; r++) {
              const o = t[r];
              let s = null;
              if (null !== p) s = p.getViewport(o); else {
                const t = c.getViewSubImage(u, o);
                n.bindXRFramebuffer(h), void 0 !== t.depthStencilTexture && e.framebufferTexture2D(36160, x, 3553, t.depthStencilTexture, 0), e.framebufferTexture2D(36160, 36064, 3553, t.colorTexture, 0), s = t.viewport;
              }
              const a = A[r];
              a.matrix.fromArray(o.transform.matrix), a.projectionMatrix.fromArray(o.projectionMatrix), a.viewport.set(s.x, s.y, s.width, s.height), 0 === r && C.matrix.copy(a.matrix), true === i && C.cameras.push(a);
            }
            m && (n.bindXRFramebuffer(d), null !== v && e.clear(v));
          }
          const o = r.inputSources;
          for (let t = 0; t < b.length; t++) {
            const e = b[t], n = o[t];
            e.update(n, i, s);
          }
          if (V && V(t, i), m) {
            const t = u.textureWidth, i = u.textureHeight;
            n.bindFramebuffer(36008, d), n.bindFramebuffer(36009, h), e.invalidateFramebuffer(36008, [x]), e.invalidateFramebuffer(36009, [x]), e.blitFramebuffer(0, 0, t, i, 0, 0, t, i, 16384, 9728), e.invalidateFramebuffer(36008, [36064]), n.bindFramebuffer(36008, null), n.bindFramebuffer(36009, null), n.bindFramebuffer(36160, d);
          }
          g = null;
        }), this.setAnimationLoop = function (t) {
          V = t;
        }, this.dispose = function () {};
      }
    }
    function Lr(t) {
      function e(e, i) {
        e.opacity.value = i.opacity, i.color && e.diffuse.value.copy(i.color), i.emissive && e.emissive.value.copy(i.emissive).multiplyScalar(i.emissiveIntensity), i.map && (e.map.value = i.map), i.alphaMap && (e.alphaMap.value = i.alphaMap), i.specularMap && (e.specularMap.value = i.specularMap), i.alphaTest > 0 && (e.alphaTest.value = i.alphaTest);
        const n = t.get(i).envMap;
        if (n) {
          e.envMap.value = n, e.flipEnvMap.value = n.isCubeTexture && false === n.isRenderTargetTexture ? -1 : 1, e.reflectivity.value = i.reflectivity, e.ior.value = i.ior, e.refractionRatio.value = i.refractionRatio;
          const r = t.get(n).__maxMipLevel;
          void 0 !== r && (e.maxMipLevel.value = r);
        }
        let r, o;
        i.lightMap && (e.lightMap.value = i.lightMap, e.lightMapIntensity.value = i.lightMapIntensity), i.aoMap && (e.aoMap.value = i.aoMap, e.aoMapIntensity.value = i.aoMapIntensity), i.map ? r = i.map : i.specularMap ? r = i.specularMap : i.displacementMap ? r = i.displacementMap : i.normalMap ? r = i.normalMap : i.bumpMap ? r = i.bumpMap : i.roughnessMap ? r = i.roughnessMap : i.metalnessMap ? r = i.metalnessMap : i.alphaMap ? r = i.alphaMap : i.emissiveMap ? r = i.emissiveMap : i.clearcoatMap ? r = i.clearcoatMap : i.clearcoatNormalMap ? r = i.clearcoatNormalMap : i.clearcoatRoughnessMap ? r = i.clearcoatRoughnessMap : i.specularIntensityMap ? r = i.specularIntensityMap : i.specularTintMap ? r = i.specularTintMap : i.transmissionMap ? r = i.transmissionMap : i.thicknessMap && (r = i.thicknessMap), void 0 !== r && (r.isWebGLRenderTarget && (r = r.texture), true === r.matrixAutoUpdate && r.updateMatrix(), e.uvTransform.value.copy(r.matrix)), i.aoMap ? o = i.aoMap : i.lightMap && (o = i.lightMap), void 0 !== o && (o.isWebGLRenderTarget && (o = o.texture), true === o.matrixAutoUpdate && o.updateMatrix(), e.uv2Transform.value.copy(o.matrix));
      }
      function i(e, i) {
        e.roughness.value = i.roughness, e.metalness.value = i.metalness, i.roughnessMap && (e.roughnessMap.value = i.roughnessMap), i.metalnessMap && (e.metalnessMap.value = i.metalnessMap), i.emissiveMap && (e.emissiveMap.value = i.emissiveMap), i.bumpMap && (e.bumpMap.value = i.bumpMap, e.bumpScale.value = i.bumpScale, 1 === i.side && (e.bumpScale.value *= -1)), i.normalMap && (e.normalMap.value = i.normalMap, e.normalScale.value.copy(i.normalScale), 1 === i.side && e.normalScale.value.negate()), i.displacementMap && (e.displacementMap.value = i.displacementMap, e.displacementScale.value = i.displacementScale, e.displacementBias.value = i.displacementBias);
        t.get(i).envMap && (e.envMapIntensity.value = i.envMapIntensity);
      }
      return {refreshFogUniforms: function (t, e) {
        t.fogColor.value.copy(e.color), e.isFog ? (t.fogNear.value = e.near, t.fogFar.value = e.far) : e.isFogExp2 && (t.fogDensity.value = e.density);
      }, refreshMaterialUniforms: function (t, n, r, o, s) {
        n.isMeshBasicMaterial ? e(t, n) : n.isMeshLambertMaterial ? (e(t, n), function (t, e) {
          e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
        }(t, n)) : n.isMeshToonMaterial ? (e(t, n), function (t, e) {
          e.gradientMap && (t.gradientMap.value = e.gradientMap);
          e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
          e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1));
          e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate());
          e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias);
        }(t, n)) : n.isMeshPhongMaterial ? (e(t, n), function (t, e) {
          t.specular.value.copy(e.specular), t.shininess.value = Math.max(e.shininess, 0.0001), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
          e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1));
          e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate());
          e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias);
        }(t, n)) : n.isMeshStandardMaterial ? (e(t, n), n.isMeshPhysicalMaterial ? function (t, e, n) {
          i(t, e), t.ior.value = e.ior, e.sheenTint && t.sheenTint.value.copy(e.sheenTint);
          e.clearcoat > 0 && (t.clearcoat.value = e.clearcoat, t.clearcoatRoughness.value = e.clearcoatRoughness, e.clearcoatMap && (t.clearcoatMap.value = e.clearcoatMap), e.clearcoatRoughnessMap && (t.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap), e.clearcoatNormalMap && (t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale), t.clearcoatNormalMap.value = e.clearcoatNormalMap, 1 === e.side && t.clearcoatNormalScale.value.negate()));
          e.transmission > 0 && (t.transmission.value = e.transmission, t.transmissionSamplerMap.value = n.texture, t.transmissionSamplerSize.value.set(n.width, n.height), e.transmissionMap && (t.transmissionMap.value = e.transmissionMap), t.thickness.value = e.thickness, e.thicknessMap && (t.thicknessMap.value = e.thicknessMap), t.attenuationDistance.value = e.attenuationDistance, t.attenuationTint.value.copy(e.attenuationTint));
          t.specularIntensity.value = e.specularIntensity, t.specularTint.value.copy(e.specularTint), e.specularIntensityMap && (t.specularIntensityMap.value = e.specularIntensityMap);
          e.specularTintMap && (t.specularTintMap.value = e.specularTintMap);
        }(t, n, s) : i(t, n)) : n.isMeshMatcapMaterial ? (e(t, n), function (t, e) {
          e.matcap && (t.matcap.value = e.matcap);
          e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1));
          e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate());
          e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias);
        }(t, n)) : n.isMeshDepthMaterial ? (e(t, n), function (t, e) {
          e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias);
        }(t, n)) : n.isMeshDistanceMaterial ? (e(t, n), function (t, e) {
          e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias);
          t.referencePosition.value.copy(e.referencePosition), t.nearDistance.value = e.nearDistance, t.farDistance.value = e.farDistance;
        }(t, n)) : n.isMeshNormalMaterial ? (e(t, n), function (t, e) {
          e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1));
          e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate());
          e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias);
        }(t, n)) : n.isLineBasicMaterial ? (function (t, e) {
          t.diffuse.value.copy(e.color), t.opacity.value = e.opacity;
        }(t, n), n.isLineDashedMaterial && function (t, e) {
          t.dashSize.value = e.dashSize, t.totalSize.value = e.dashSize + e.gapSize, t.scale.value = e.scale;
        }(t, n)) : n.isPointsMaterial ? function (t, e, i, n) {
          t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.size.value = e.size * i, t.scale.value = 0.5 * n, e.map && (t.map.value = e.map);
          e.alphaMap && (t.alphaMap.value = e.alphaMap);
          e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest);
          let r;
          e.map ? r = e.map : e.alphaMap && (r = e.alphaMap);
          void 0 !== r && (true === r.matrixAutoUpdate && r.updateMatrix(), t.uvTransform.value.copy(r.matrix));
        }(t, n, r, o) : n.isSpriteMaterial ? function (t, e) {
          t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.rotation.value = e.rotation, e.map && (t.map.value = e.map);
          e.alphaMap && (t.alphaMap.value = e.alphaMap);
          e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest);
          let i;
          e.map ? i = e.map : e.alphaMap && (i = e.alphaMap);
          void 0 !== i && (true === i.matrixAutoUpdate && i.updateMatrix(), t.uvTransform.value.copy(i.matrix));
        }(t, n) : n.isShadowMaterial ? (t.color.value.copy(n.color), t.opacity.value = n.opacity) : n.isShaderMaterial && (n.uniformsNeedUpdate = false);
      }};
    }
    function Dr(t = {}) {
      const e = void 0 !== t.canvas ? t.canvas : function () {
        const t = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
        return t.style.display = "block", t;
      }(), i = void 0 !== t.context ? t.context : null, n = void 0 !== t.alpha && t.alpha, r = void 0 === t.depth || t.depth, o = void 0 === t.stencil || t.stencil, s = void 0 !== t.antialias && t.antialias, a = void 0 === t.premultipliedAlpha || t.premultipliedAlpha, l = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer, c = void 0 !== t.powerPreference ? t.powerPreference : "default", h = void 0 !== t.failIfMajorPerformanceCaveat && t.failIfMajorPerformanceCaveat;
      let u = null, p = null;
      const d = [], y = [];
      this.domElement = e, this.debug = {checkShaderErrors: true}, this.autoClear = true, this.autoClearColor = true, this.autoClearDepth = true, this.autoClearStencil = true, this.sortObjects = true, this.clippingPlanes = [], this.localClippingEnabled = false, this.gammaFactor = 2, this.outputEncoding = N, this.physicallyCorrectLights = false, this.toneMapping = 0, this.toneMappingExposure = 1;
      const g = this;
      let x = false, w = 0, S = 0, C = null, T = -1, L = null;
      const D = new Vector4, R = new Vector4;
      let B = null, P = e.width, I = e.height, V = 1, F = null, k = null;
      const G = new Vector4(0, 0, P, I), U = new Vector4(0, 0, P, I);
      let z = false;
      const O = [], H = new Frustum;
      let W = false, J = false, X = null;
      const q = new Matrix4, Y = new three_module_Vector3, Z = {background: null, fog: null, environment: null, overrideMaterial: null, isScene: true};
      function K() {
        return null === C ? V : 1;
      }
      let $, Q, tt, et, it, nt, rt, ot, st, at, lt, ct, ht, ut, pt, mt, dt, ft, _t, yt, gt, xt, vt, bt = i;
      function wt(t, i) {
        for (let n = 0; n < t.length; n++) {
          const r = t[n], o = e.getContext(r, i);
          if (null !== o) return o;
        }
        return null;
      }
      try {
        const t = {alpha: n, depth: r, stencil: o, antialias: s, premultipliedAlpha: a, preserveDrawingBuffer: l, powerPreference: c, failIfMajorPerformanceCaveat: h};
        if (e.addEventListener("webglcontextlost", At, false), e.addEventListener("webglcontextrestored", Ct, false), null === bt) {
          const e = ["webgl2", "webgl", "experimental-webgl"];
          if (true === g.isWebGL1Renderer && e.shift(), bt = wt(e, t), null === bt) throw wt(e) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
        }
        void 0 === bt.getShaderPrecisionFormat && (bt.getShaderPrecisionFormat = function () {
          return {rangeMin: 1, rangeMax: 1, precision: 1};
        });
      } catch (t) {
        throw console.error("THREE.WebGLRenderer: " + t.message), t;
      }
      function St() {
        $ = new Vi(bt), Q = new ci(bt, $, t), $.init(Q), xt = new Tr(bt, $, Q), tt = new Ar(bt, $, Q), O[0] = 1029, et = new Ni(bt), it = new mr, nt = new Cr(bt, $, tt, it, Q, xt, et), rt = new ui(g), ot = new Ii(g), st = new ii(bt, Q), vt = new ai(bt, $, st, Q), at = new Fi(bt, st, et, vt), lt = new Oi(bt, at, st, et), _t = new zi(bt), mt = new hi(it), ct = new pr(g, rt, ot, $, Q, vt, mt), ht = new Lr(it), ut = new yr(it), pt = new Sr($, Q), ft = new si(g, rt, tt, lt, a), dt = new Mr(g, lt, Q), yt = new li(bt, $, et, Q), gt = new ki(bt, $, et, Q), et.programs = ct.programs, g.capabilities = Q, g.extensions = $, g.properties = it, g.renderLists = ut, g.shadowMap = dt, g.state = tt, g.info = et;
      }
      St();
      const Mt = new WebXRManager(g, bt);
      function At(t) {
        t.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), x = true;
      }
      function Ct() {
        console.log("THREE.WebGLRenderer: Context Restored."), x = false;
        const t = et.autoReset, e = dt.enabled, i = dt.autoUpdate, n = dt.needsUpdate, r = dt.type;
        St(), et.autoReset = t, dt.enabled = e, dt.autoUpdate = i, dt.needsUpdate = n, dt.type = r;
      }
      function Tt(t) {
        const e = t.target;
        e.removeEventListener("dispose", Tt), function (t) {
          (function (t) {
            const e = it.get(t).programs;
            void 0 !== e && e.forEach(function (t) {
              ct.releaseProgram(t);
            });
          }(t), it.remove(t));
        }(e);
      }
      this.xr = Mt, this.getContext = function () {
        return bt;
      }, this.getContextAttributes = function () {
        return bt.getContextAttributes();
      }, this.forceContextLoss = function () {
        const t = $.get("WEBGL_lose_context");
        t && t.loseContext();
      }, this.forceContextRestore = function () {
        const t = $.get("WEBGL_lose_context");
        t && t.restoreContext();
      }, this.getPixelRatio = function () {
        return V;
      }, this.setPixelRatio = function (t) {
        void 0 !== t && (V = t, this.setSize(P, I, false));
      }, this.getSize = function (t) {
        return t.set(P, I);
      }, this.setSize = function (t, i, n) {
        Mt.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (P = t, I = i, e.width = Math.floor(t * V), e.height = Math.floor(i * V), false !== n && (e.style.width = t + "px", e.style.height = i + "px"), this.setViewport(0, 0, t, i));
      }, this.getDrawingBufferSize = function (t) {
        return t.set(P * V, I * V).floor();
      }, this.setDrawingBufferSize = function (t, i, n) {
        P = t, I = i, V = n, e.width = Math.floor(t * n), e.height = Math.floor(i * n), this.setViewport(0, 0, t, i);
      }, this.getCurrentViewport = function (t) {
        return t.copy(D);
      }, this.getViewport = function (t) {
        return t.copy(G);
      }, this.setViewport = function (t, e, i, n) {
        t.isVector4 ? G.set(t.x, t.y, t.z, t.w) : G.set(t, e, i, n), tt.viewport(D.copy(G).multiplyScalar(V).floor());
      }, this.getScissor = function (t) {
        return t.copy(U);
      }, this.setScissor = function (t, e, i, n) {
        t.isVector4 ? U.set(t.x, t.y, t.z, t.w) : U.set(t, e, i, n), tt.scissor(R.copy(U).multiplyScalar(V).floor());
      }, this.getScissorTest = function () {
        return z;
      }, this.setScissorTest = function (t) {
        tt.setScissorTest(z = t);
      }, this.setOpaqueSort = function (t) {
        F = t;
      }, this.setTransparentSort = function (t) {
        k = t;
      }, this.getClearColor = function (t) {
        return t.copy(ft.getClearColor());
      }, this.setClearColor = function () {
        ft.setClearColor.apply(ft, arguments);
      }, this.getClearAlpha = function () {
        return ft.getClearAlpha();
      }, this.setClearAlpha = function () {
        ft.setClearAlpha.apply(ft, arguments);
      }, this.clear = function (t, e, i) {
        let n = 0;
        (void 0 === t || t) && (n |= 16384), (void 0 === e || e) && (n |= 256), (void 0 === i || i) && (n |= 1024), bt.clear(n);
      }, this.clearColor = function () {
        this.clear(true, false, false);
      }, this.clearDepth = function () {
        this.clear(false, true, false);
      }, this.clearStencil = function () {
        this.clear(false, false, true);
      }, this.dispose = function () {
        e.removeEventListener("webglcontextlost", At, false), e.removeEventListener("webglcontextrestored", Ct, false), ut.dispose(), pt.dispose(), it.dispose(), rt.dispose(), ot.dispose(), lt.dispose(), vt.dispose(), Mt.dispose(), Mt.removeEventListener("sessionstart", Lt), Mt.removeEventListener("sessionend", Dt), X && (X.dispose(), X = null), Rt.stop();
      }, this.renderBufferImmediate = function (t, e) {
        vt.initAttributes();
        const i = it.get(t);
        t.hasPositions && !i.position && (i.position = bt.createBuffer()), t.hasNormals && !i.normal && (i.normal = bt.createBuffer()), t.hasUvs && !i.uv && (i.uv = bt.createBuffer()), t.hasColors && !i.color && (i.color = bt.createBuffer());
        const n = e.getAttributes();
        t.hasPositions && (bt.bindBuffer(34962, i.position), bt.bufferData(34962, t.positionArray, 35048), vt.enableAttribute(n.position.location), bt.vertexAttribPointer(n.position.location, 3, 5126, false, 0, 0)), t.hasNormals && (bt.bindBuffer(34962, i.normal), bt.bufferData(34962, t.normalArray, 35048), vt.enableAttribute(n.normal.location), bt.vertexAttribPointer(n.normal.location, 3, 5126, false, 0, 0)), t.hasUvs && (bt.bindBuffer(34962, i.uv), bt.bufferData(34962, t.uvArray, 35048), vt.enableAttribute(n.uv.location), bt.vertexAttribPointer(n.uv.location, 2, 5126, false, 0, 0)), t.hasColors && (bt.bindBuffer(34962, i.color), bt.bufferData(34962, t.colorArray, 35048), vt.enableAttribute(n.color.location), bt.vertexAttribPointer(n.color.location, 3, 5126, false, 0, 0)), vt.disableUnusedAttributes(), bt.drawArrays(4, 0, t.count), t.count = 0;
      }, this.renderBufferDirect = function (t, e, i, n, r, o) {
        null === e && (e = Z);
        const s = r.isMesh && r.matrixWorld.determinant() < 0, a = Nt(t, e, n, r);
        tt.setMaterial(n, s);
        let l = i.index;
        const c = i.attributes.position;
        if (null === l) {
          if (void 0 === c || 0 === c.count) return;
        } else if (0 === l.count) return;
        let h, u = 1;
        true === n.wireframe && (l = at.getWireframeAttribute(i), u = 2), void 0 === i.morphAttributes.position && void 0 === i.morphAttributes.normal || _t.update(r, i, n, a), vt.setup(r, n, a, i, l);
        let p = yt;
        null !== l && (h = st.get(l), p = gt, p.setIndex(h));
        const m = null !== l ? l.count : c.count, d = i.drawRange.start * u, _ = i.drawRange.count * u, y = null !== o ? o.start * u : 0, g = null !== o ? o.count * u : Infinity, x = Math.max(d, y), v = Math.min(m, d + _, y + g) - 1, b = Math.max(0, v - x + 1);
        if (0 !== b) {
          if (r.isMesh) true === n.wireframe ? (tt.setLineWidth(n.wireframeLinewidth * Math.max(e, Math.min(i, t))), p.setMode(1)) : p.setMode(4); else if (r.isLine) {
            let t = n.linewidth;
            void 0 === t && (t = 1), tt.setLineWidth(t * Math.max(e, Math.min(i, t))), r.isLineSegments ? p.setMode(1) : r.isLineLoop ? p.setMode(2) : p.setMode(3);
          } else r.isPoints ? p.setMode(0) : r.isSprite && p.setMode(4);
          if (r.isInstancedMesh) p.renderInstances(x, b, r.count); else if (i.isInstancedBufferGeometry) {
            const t = Math.min(i.instanceCount, i._maxInstanceCount);
            p.renderInstances(x, b, t);
          } else p.render(x, b);
        }
      }, this.compile = function (t, e) {
        p = pt.get(t), p.init(), y.push(p), t.traverseVisible(function (t) {
          t.isLight && t.layers.test(e.layers) && (p.pushLight(t), t.castShadow && p.pushShadow(t));
        }), p.setupLights(g.physicallyCorrectLights), t.traverse(function (e) {
          const i = e.material;
          if (i) if (Array.isArray(i)) for (let n = 0; n < i.length; n++) {
            Ft(i[n], t, e);
          } else Ft(i, t, e);
        }), y.pop(), p = null;
      };
      let Et = null;
      function Lt() {
        Rt.stop();
      }
      function Dt() {
        Rt.start();
      }
      const Rt = new ei;
      function Bt(t, e, i, n) {
        if (false === t.visible) return;
        if (t.layers.test(e.layers)) if (t.isGroup) i = t.renderOrder; else if (t.isLOD) true === t.autoUpdate && t.update(e); else if (t.isLight) p.pushLight(t), t.castShadow && p.pushShadow(t); else if (t.isSprite) {
          if (!t.frustumCulled || H.intersectsSprite(t)) {
            n && Y.setFromMatrixPosition(t.matrixWorld).applyMatrix4(q);
            const e = lt.update(t), r = t.material;
            r.visible && u.push(t, e, r, i, Y.z, null);
          }
        } else if (t.isImmediateRenderObject) n && Y.setFromMatrixPosition(t.matrixWorld).applyMatrix4(q), u.push(t, null, t.material, i, Y.z, null); else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.frame !== et.render.frame && (t.skeleton.update(), t.skeleton.frame = et.render.frame), !t.frustumCulled || H.intersectsObject(t))) {
          n && Y.setFromMatrixPosition(t.matrixWorld).applyMatrix4(q);
          const e = lt.update(t), r = t.material;
          if (Array.isArray(r)) {
            const n = e.groups;
            for (let o = 0, s = n.length; o < s; o++) {
              const s = n[o], a = r[s.materialIndex];
              a && a.visible && u.push(t, e, a, i, Y.z, s);
            }
          } else r.visible && u.push(t, e, r, i, Y.z, null);
        }
        const r = t.children;
        for (let t = 0, o = r.length; t < o; t++) Bt(r[t], e, i, n);
      }
      function Pt(t, e, i, n) {
        const r = t.opaque, o = t.transmissive, a = t.transparent;
        p.setupLightsView(i), o.length > 0 && function (t, e, i) {
          if (null === X) {
            const t = true === s && true === Q.isWebGL2;
            X = new (t ? WebGLMultisampleRenderTarget : WebGLRenderTarget)(1024, 1024, {generateMipmaps: true, type: null !== xt.convert(A) ? A : b, minFilter: v, magFilter: _, wrapS: m, wrapT: m});
          }
          const n = g.getRenderTarget();
          g.setRenderTarget(X), g.clear();
          const r = g.toneMapping;
          g.toneMapping = 0, It(t, e, i), g.toneMapping = r, nt.updateMultisampleRenderTarget(X), nt.updateRenderTargetMipmap(X), g.setRenderTarget(n);
        }(r, e, i), n && tt.viewport(D.copy(n)), r.length > 0 && It(r, e, i), o.length > 0 && It(o, e, i), a.length > 0 && It(a, e, i);
      }
      function It(t, e, i) {
        const n = true === e.isScene ? e.overrideMaterial : null;
        for (let r = 0, o = t.length; r < o; r++) {
          const o = t[r], s = o.object, a = o.geometry, l = null === n ? o.material : n, c = o.group;
          s.layers.test(i.layers) && Vt(s, e, i, a, l, c);
        }
      }
      function Vt(t, e, i, n, r, o) {
        if (t.onBeforeRender(g, e, i, n, r, o), t.modelViewMatrix.multiplyMatrices(i.matrixWorldInverse, t.matrixWorld), t.normalMatrix.getNormalMatrix(t.modelViewMatrix), t.isImmediateRenderObject) {
          const n = Nt(i, e, r, t);
          tt.setMaterial(r), vt.reset(), function (t, e) {
            t.render(function (t) {
              g.renderBufferImmediate(t, e);
            });
          }(t, n);
        } else true === r.transparent && 2 === r.side ? (r.side = 1, r.needsUpdate = true, g.renderBufferDirect(i, e, n, r, t, o), r.side = 0, r.needsUpdate = true, g.renderBufferDirect(i, e, n, r, t, o), r.side = 2) : g.renderBufferDirect(i, e, n, r, t, o);
        t.onAfterRender(g, e, i, n, r, o);
      }
      function Ft(t, e, i) {
        true !== e.isScene && (e = Z);
        const n = it.get(t), r = p.state.lights, o = p.state.shadowsArray, s = r.state.version, a = ct.getParameters(t, r.state, o, e, i), l = ct.getProgramCacheKey(a);
        let c = n.programs;
        n.environment = t.isMeshStandardMaterial ? e.environment : null, n.fog = e.fog, n.envMap = (t.isMeshStandardMaterial ? ot : rt).get(t.envMap || n.environment), void 0 === c && (t.addEventListener("dispose", Tt), c = new Map, n.programs = c);
        let h = c.get(l);
        if (void 0 !== h) {
          if (n.currentProgram === h && n.lightsStateVersion === s) return kt(t, a), h;
        } else a.uniforms = ct.getUniforms(t), t.onBuild(a, g), t.onBeforeCompile(a, g), h = ct.acquireProgram(a, l), c.set(l, h), n.uniforms = a.uniforms;
        const u = n.uniforms;
        (t.isShaderMaterial || t.isRawShaderMaterial) && true !== t.clipping || (u.clippingPlanes = mt.uniform), kt(t, a), n.needsLights = function (t) {
          return t.isMeshLambertMaterial || t.isMeshToonMaterial || t.isMeshPhongMaterial || t.isMeshStandardMaterial || t.isShadowMaterial || t.isShaderMaterial && true === t.lights;
        }(t), n.lightsStateVersion = s, n.needsLights && (u.ambientLightColor.value = r.state.ambient, u.lightProbe.value = r.state.probe, u.directionalLights.value = r.state.directional, u.directionalLightShadows.value = r.state.directionalShadow, u.spotLights.value = r.state.spot, u.spotLightShadows.value = r.state.spotShadow, u.rectAreaLights.value = r.state.rectArea, u.ltc_1.value = r.state.rectAreaLTC1, u.ltc_2.value = r.state.rectAreaLTC2, u.pointLights.value = r.state.point, u.pointLightShadows.value = r.state.pointShadow, u.hemisphereLights.value = r.state.hemi, u.directionalShadowMap.value = r.state.directionalShadowMap, u.directionalShadowMatrix.value = r.state.directionalShadowMatrix, u.spotShadowMap.value = r.state.spotShadowMap, u.spotShadowMatrix.value = r.state.spotShadowMatrix, u.pointShadowMap.value = r.state.pointShadowMap, u.pointShadowMatrix.value = r.state.pointShadowMatrix);
        const m = h.getUniforms(), d = Jn.seqWithValue(m.seq, u);
        return n.currentProgram = h, n.uniformsList = d, h;
      }
      function kt(t, e) {
        const i = it.get(t);
        i.outputEncoding = e.outputEncoding, i.instancing = e.instancing, i.skinning = e.skinning, i.morphTargets = e.morphTargets, i.morphNormals = e.morphNormals, i.numClippingPlanes = e.numClippingPlanes, i.numIntersection = e.numClipIntersection, i.vertexAlphas = e.vertexAlphas, i.vertexTangents = e.vertexTangents;
      }
      function Nt(t, e, i, n) {
        true !== e.isScene && (e = Z), nt.resetTextureUnits();
        const r = e.fog, o = i.isMeshStandardMaterial ? e.environment : null, s = null === C ? g.outputEncoding : C.texture.encoding, a = (i.isMeshStandardMaterial ? ot : rt).get(i.envMap || o), l = true === i.vertexColors && !!n.geometry && !!n.geometry.attributes.color && 4 === n.geometry.attributes.color.itemSize, c = !!n.geometry && !!n.geometry.attributes.tangent, h = !!n.geometry && !!n.geometry.morphAttributes.position, u = !!n.geometry && !!n.geometry.morphAttributes.normal, m = it.get(i), d = p.state.lights;
        if (true === W && (true === J || t !== L)) {
          const e = t === L && i.id === T;
          mt.setState(i, t, e);
        }
        let _ = false;
        i.version === m.__version ? m.needsLights && m.lightsStateVersion !== d.state.version || m.outputEncoding !== s || n.isInstancedMesh && false === m.instancing ? _ = true : n.isInstancedMesh || true !== m.instancing ? n.isSkinnedMesh && false === m.skinning ? _ = true : n.isSkinnedMesh || true !== m.skinning ? m.envMap !== a || i.fog && m.fog !== r ? _ = true : void 0 === m.numClippingPlanes || m.numClippingPlanes === mt.numPlanes && m.numIntersection === mt.numIntersection ? (m.vertexAlphas !== l || m.vertexTangents !== c || m.morphTargets !== h || m.morphNormals !== u) && (_ = true) : _ = true : _ = true : _ = true : (_ = true, m.__version = i.version);
        let y = m.currentProgram;
        true === _ && (y = Ft(i, e, n));
        let x = false, v = false, b = false;
        const w = y.getUniforms(), S = m.uniforms;
        if (tt.useProgram(y.program) && (x = true, v = true, b = true), i.id !== T && (T = i.id, v = true), x || L !== t) {
          if (w.setValue(bt, "projectionMatrix", t.projectionMatrix), Q.logarithmicDepthBuffer && w.setValue(bt, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), L !== t && (L = t, v = true, b = true), i.isShaderMaterial || i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshStandardMaterial || i.envMap) {
            const e = w.map.cameraPosition;
            void 0 !== e && e.setValue(bt, Y.setFromMatrixPosition(t.matrixWorld));
          }
          (i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial) && w.setValue(bt, "isOrthographic", true === t.isOrthographicCamera), (i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial || i.isShadowMaterial || n.isSkinnedMesh) && w.setValue(bt, "viewMatrix", t.matrixWorldInverse);
        }
        if (n.isSkinnedMesh) {
          w.setOptional(bt, n, "bindMatrix"), w.setOptional(bt, n, "bindMatrixInverse");
          const t = n.skeleton;
          t && (Q.floatVertexTextures ? (null === t.boneTexture && t.computeBoneTexture(), w.setValue(bt, "boneTexture", t.boneTexture, nt), w.setValue(bt, "boneTextureSize", t.boneTextureSize)) : w.setOptional(bt, t, "boneMatrices"));
        }
        var M, A;
        return (v || m.receiveShadow !== n.receiveShadow) && (m.receiveShadow = n.receiveShadow, w.setValue(bt, "receiveShadow", n.receiveShadow)), v && (w.setValue(bt, "toneMappingExposure", g.toneMappingExposure), m.needsLights && (A = b, (M = S).ambientLightColor.needsUpdate = A, M.lightProbe.needsUpdate = A, M.directionalLights.needsUpdate = A, M.directionalLightShadows.needsUpdate = A, M.pointLights.needsUpdate = A, M.pointLightShadows.needsUpdate = A, M.spotLights.needsUpdate = A, M.spotLightShadows.needsUpdate = A, M.rectAreaLights.needsUpdate = A, M.hemisphereLights.needsUpdate = A), r && i.fog && ht.refreshFogUniforms(S, r), ht.refreshMaterialUniforms(S, i, V, I, X), Jn.upload(bt, m.uniformsList, S, nt)), i.isShaderMaterial && true === i.uniformsNeedUpdate && (Jn.upload(bt, m.uniformsList, S, nt), i.uniformsNeedUpdate = false), i.isSpriteMaterial && w.setValue(bt, "center", n.center), w.setValue(bt, "modelViewMatrix", n.modelViewMatrix), w.setValue(bt, "normalMatrix", n.normalMatrix), w.setValue(bt, "modelMatrix", n.matrixWorld), y;
      }
      Rt.setAnimationLoop(function (t) {
        Et && Et(t);
      }), "undefined" != typeof window && Rt.setContext(window), this.setAnimationLoop = function (t) {
        Et = t, Mt.setAnimationLoop(t), null === t ? Rt.stop() : Rt.start();
      }, Mt.addEventListener("sessionstart", Lt), Mt.addEventListener("sessionend", Dt), this.render = function (t, e) {
        if (void 0 !== e && true !== e.isCamera) return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
        if (true === x) return;
        true === t.autoUpdate && t.updateMatrixWorld(), null === e.parent && e.updateMatrixWorld(), true === Mt.enabled && true === Mt.isPresenting && (true === Mt.cameraAutoUpdate && Mt.updateCamera(e), e = Mt.getCamera()), true === t.isScene && t.onBeforeRender(g, t, e, C), p = pt.get(t, y.length), p.init(), y.push(p), q.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), H.setFromProjectionMatrix(q), J = this.localClippingEnabled, W = mt.init(this.clippingPlanes, J, e), u = ut.get(t, d.length), u.init(), d.push(u), Bt(t, e, 0, g.sortObjects), u.finish(), true === g.sortObjects && u.sort(F, k), true === W && mt.beginShadows();
        const i = p.state.shadowsArray;
        if (dt.render(i, t, e), true === W && mt.endShadows(), true === this.info.autoReset && this.info.reset(), ft.render(u, t), p.setupLights(g.physicallyCorrectLights), e.isArrayCamera) {
          const i = e.cameras;
          for (let e = 0, n = i.length; e < n; e++) {
            const n = i[e];
            Pt(u, t, n, n.viewport);
          }
        } else Pt(u, t, e);
        null !== C && (nt.updateMultisampleRenderTarget(C), nt.updateRenderTargetMipmap(C)), true === t.isScene && t.onAfterRender(g, t, e), tt.buffers.depth.setTest(true), tt.buffers.depth.setMask(true), tt.buffers.color.setMask(true), tt.setPolygonOffset(false), vt.resetDefaultState(), T = -1, L = null, y.pop(), p = y.length > 0 ? y[y.length - 1] : null, d.pop(), u = d.length > 0 ? d[d.length - 1] : null;
      }, this.getActiveCubeFace = function () {
        return w;
      }, this.getActiveMipmapLevel = function () {
        return S;
      }, this.getRenderTarget = function () {
        return C;
      }, this.setRenderTarget = function (t, e = 0, i = 0) {
        C = t, w = e, S = i, t && void 0 === it.get(t).__webglFramebuffer && nt.setupRenderTarget(t);
        let n = null, r = false, o = false;
        if (t) {
          const i = t.texture;
          (i.isDataTexture3D || i.isDataTexture2DArray) && (o = true);
          const s = it.get(t).__webglFramebuffer;
          t.isWebGLCubeRenderTarget ? (n = s[e], r = true) : n = t.isWebGLMultisampleRenderTarget ? it.get(t).__webglMultisampledFramebuffer : s, D.copy(t.viewport), R.copy(t.scissor), B = t.scissorTest;
        } else D.copy(G).multiplyScalar(V).floor(), R.copy(U).multiplyScalar(V).floor(), B = z;
        if (tt.bindFramebuffer(36160, n) && Q.drawBuffers) {
          let e = false;
          if (t) if (t.isWebGLMultipleRenderTargets) {
            const i = t.texture;
            if (O.length !== i.length || 36064 !== O[0]) {
              for (let t = 0, e = i.length; t < e; t++) O[t] = 36064 + t;
              O.length = i.length, e = true;
            }
          } else 1 === O.length && 36064 === O[0] || (O[0] = 36064, O.length = 1, e = true); else 1 === O.length && 1029 === O[0] || (O[0] = 1029, O.length = 1, e = true);
          e && (Q.isWebGL2 ? bt.drawBuffers(O) : $.get("WEBGL_draw_buffers").drawBuffersWEBGL(O));
        }
        if (tt.viewport(D), tt.scissor(R), tt.setScissorTest(B), r) {
          const n = it.get(t.texture);
          bt.framebufferTexture2D(36160, 36064, 34069 + e, n.__webglTexture, i);
        } else if (o) {
          const n = it.get(t.texture), r = e || 0;
          bt.framebufferTextureLayer(36160, 36064, n.__webglTexture, i || 0, r);
        }
        T = -1;
      }, this.readRenderTargetPixels = function (t, e, i, n, r, o, s) {
        if (!t || !t.isWebGLRenderTarget) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
        let a = it.get(t).__webglFramebuffer;
        if (t.isWebGLCubeRenderTarget && void 0 !== s && (a = a[s]), a) {
          tt.bindFramebuffer(36160, a);
          try {
            const s = t.texture, a = s.format, l = s.type;
            if (a !== E && xt.convert(a) !== bt.getParameter(35739)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
            const c = l === A && ($.has("EXT_color_buffer_half_float") || Q.isWebGL2 && $.has("EXT_color_buffer_float"));
            if (!(l === b || xt.convert(l) === bt.getParameter(35738) || l === M && (Q.isWebGL2 || $.has("OES_texture_float") || $.has("WEBGL_color_buffer_float")) || c)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
            36053 === bt.checkFramebufferStatus(36160) ? e >= 0 && e <= t.width - n && i >= 0 && i <= t.height - r && bt.readPixels(e, i, n, r, xt.convert(a), xt.convert(l), o) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.");
          } finally {
            const t = null !== C ? it.get(C).__webglFramebuffer : null;
            tt.bindFramebuffer(36160, t);
          }
        }
      }, this.copyFramebufferToTexture = function (t, e, i = 0) {
        const n = Math.pow(2, -i), r = Math.floor(e.image.width * n), o = Math.floor(e.image.height * n);
        let s = xt.convert(e.format);
        Q.isWebGL2 && (6407 === s && (s = 32849), 6408 === s && (s = 32856)), nt.setTexture2D(e, 0), bt.copyTexImage2D(3553, i, s, t.x, t.y, r, o, 0), tt.unbindTexture();
      }, this.copyTextureToTexture = function (t, e, i, n = 0) {
        const r = e.image.width, o = e.image.height, s = xt.convert(i.format), a = xt.convert(i.type);
        nt.setTexture2D(i, 0), bt.pixelStorei(37440, i.flipY), bt.pixelStorei(37441, i.premultiplyAlpha), bt.pixelStorei(3317, i.unpackAlignment), e.isDataTexture ? bt.texSubImage2D(3553, n, t.x, t.y, r, o, s, a, e.image.data) : e.isCompressedTexture ? bt.compressedTexSubImage2D(3553, n, t.x, t.y, e.mipmaps[0].width, e.mipmaps[0].height, s, e.mipmaps[0].data) : bt.texSubImage2D(3553, n, t.x, t.y, s, a, e.image), 0 === n && i.generateMipmaps && bt.generateMipmap(3553), tt.unbindTexture();
      }, this.copyTextureToTexture3D = function (t, e, i, n, r = 0) {
        if (g.isWebGL1Renderer) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
        const o = t.max.x - t.min.x + 1, s = t.max.y - t.min.y + 1, a = t.max.z - t.min.z + 1, l = xt.convert(n.format), c = xt.convert(n.type);
        let h;
        if (n.isDataTexture3D) nt.setTexture3D(n, 0), h = 32879; else {
          if (!n.isDataTexture2DArray) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
          nt.setTexture2DArray(n, 0), h = 35866;
        }
        bt.pixelStorei(37440, n.flipY), bt.pixelStorei(37441, n.premultiplyAlpha), bt.pixelStorei(3317, n.unpackAlignment);
        const u = bt.getParameter(3314), p = bt.getParameter(32878), m = bt.getParameter(3316), d = bt.getParameter(3315), _ = bt.getParameter(32877), y = i.isCompressedTexture ? i.mipmaps[0] : i.image;
        bt.pixelStorei(3314, y.width), bt.pixelStorei(32878, y.height), bt.pixelStorei(3316, t.min.x), bt.pixelStorei(3315, t.min.y), bt.pixelStorei(32877, t.min.z), i.isDataTexture || i.isDataTexture3D ? bt.texSubImage3D(h, r, e.x, e.y, e.z, o, s, a, l, c, y.data) : i.isCompressedTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), bt.compressedTexSubImage3D(h, r, e.x, e.y, e.z, o, s, a, l, y.data)) : bt.texSubImage3D(h, r, e.x, e.y, e.z, o, s, a, l, c, y), bt.pixelStorei(3314, u), bt.pixelStorei(32878, p), bt.pixelStorei(3316, m), bt.pixelStorei(3315, d), bt.pixelStorei(32877, _), 0 === r && n.generateMipmaps && bt.generateMipmap(h), tt.unbindTexture();
      }, this.initTexture = function (t) {
        nt.setTexture2D(t, 0), tt.unbindTexture();
      }, this.resetState = function () {
        w = 0, S = 0, C = null, tt.reset(), vt.reset();
      }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {detail: this}));
    }
    (class WebGL1Renderer extends Dr {}.prototype.isWebGL1Renderer = true);
    class FogExp2 {
      constructor(t, e = 0.00025) {
        this.name = "", this.color = new three_module_Color(t), this.density = e;
      }
      clone() {
        return new FogExp2(this.color, this.density);
      }
      toJSON() {
        return {type: "FogExp2", color: this.color.getHex(), density: this.density};
      }
    }
    FogExp2.prototype.isFogExp2 = true;
    class Fog {
      constructor(t, e = 1, i = 1e3) {
        this.name = "", this.color = new three_module_Color(t), this.near = e, this.far = i;
      }
      clone() {
        return new Fog(this.color, this.near, this.far);
      }
      toJSON() {
        return {type: "Fog", color: this.color.getHex(), near: this.near, far: this.far};
      }
    }
    Fog.prototype.isFog = true;
    class Scene extends Object3D {
      constructor() {
        super(), this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = true, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {detail: this}));
      }
      copy(t, e) {
        return super.copy(t, e), null !== t.background && (this.background = t.background.clone()), null !== t.environment && (this.environment = t.environment.clone()), null !== t.fog && (this.fog = t.fog.clone()), null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()), this.autoUpdate = t.autoUpdate, this.matrixAutoUpdate = t.matrixAutoUpdate, this;
      }
      toJSON(t) {
        const e = super.toJSON(t);
        return null !== this.fog && (e.object.fog = this.fog.toJSON()), e;
      }
    }
    Scene.prototype.isScene = true;
    class InterleavedBuffer {
      constructor(t, e) {
        this.array = t, this.stride = e, this.count = void 0 !== t ? t.length / e : 0, this.usage = H, this.updateRange = {offset: 0, count: -1}, this.version = 0, this.uuid = Z();
      }
      onUploadCallback() {}
      set needsUpdate (t) {
        true === t && this.version++;
      }
      setUsage(t) {
        return this.usage = t, this;
      }
      copy(t) {
        return this.array = new t.array.constructor(t.array), this.count = t.count, this.stride = t.stride, this.usage = t.usage, this;
      }
      copyAt(t, e, i) {
        t *= this.stride, i *= e.stride;
        for (let n = 0, r = this.stride; n < r; n++) this.array[t + n] = e.array[i + n];
        return this;
      }
      set(t, e = 0) {
        return this.array.set(t, e), this;
      }
      clone(t) {
        void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Z()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
        const e = new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]), i = new this.constructor(e, this.stride);
        return i.setUsage(this.usage), i;
      }
      onUpload(t) {
        return this.onUploadCallback = t, this;
      }
      toJSON(t) {
        return void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Z()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))), {uuid: this.uuid, buffer: this.array.buffer._uuid, type: this.array.constructor.name, stride: this.stride};
      }
    }
    InterleavedBuffer.prototype.isInterleavedBuffer = true;
    const Rr = new three_module_Vector3;
    class InterleavedBufferAttribute {
      constructor(t, e, i, n = false) {
        this.name = "", this.data = t, this.itemSize = e, this.offset = i, this.normalized = true === n;
      }
      get count() {
        return this.data.count;
      }
      get array() {
        return this.data.array;
      }
      set needsUpdate (t) {
        this.data.needsUpdate = t;
      }
      applyMatrix4(t) {
        for (let e = 0, i = this.data.count; e < i; e++) Rr.x = this.getX(e), Rr.y = this.getY(e), Rr.z = this.getZ(e), Rr.applyMatrix4(t), this.setXYZ(e, Rr.x, Rr.y, Rr.z);
        return this;
      }
      applyNormalMatrix(t) {
        for (let e = 0, i = this.count; e < i; e++) Rr.x = this.getX(e), Rr.y = this.getY(e), Rr.z = this.getZ(e), Rr.applyNormalMatrix(t), this.setXYZ(e, Rr.x, Rr.y, Rr.z);
        return this;
      }
      transformDirection(t) {
        for (let e = 0, i = this.count; e < i; e++) Rr.x = this.getX(e), Rr.y = this.getY(e), Rr.z = this.getZ(e), Rr.transformDirection(t), this.setXYZ(e, Rr.x, Rr.y, Rr.z);
        return this;
      }
      setX(t, e) {
        return this.data.array[t * this.data.stride + this.offset] = e, this;
      }
      setY(t, e) {
        return this.data.array[t * this.data.stride + this.offset + 1] = e, this;
      }
      setZ(t, e) {
        return this.data.array[t * this.data.stride + this.offset + 2] = e, this;
      }
      setW(t, e) {
        return this.data.array[t * this.data.stride + this.offset + 3] = e, this;
      }
      getX(t) {
        return this.data.array[t * this.data.stride + this.offset];
      }
      getY(t) {
        return this.data.array[t * this.data.stride + this.offset + 1];
      }
      getZ(t) {
        return this.data.array[t * this.data.stride + this.offset + 2];
      }
      getW(t) {
        return this.data.array[t * this.data.stride + this.offset + 3];
      }
      setXY(t, e, i) {
        return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = i, this;
      }
      setXYZ(t, e, i, n) {
        return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = i, this.data.array[t + 2] = n, this;
      }
      setXYZW(t, e, i, n, r) {
        return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = i, this.data.array[t + 2] = n, this.data.array[t + 3] = r, this;
      }
      clone(t) {
        if (void 0 === t) {
          console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
          const t = [];
          for (let e = 0; e < this.count; e++) {
            const i = e * this.data.stride + this.offset;
            for (let e = 0; e < this.itemSize; e++) t.push(this.data.array[i + e]);
          }
          return new BufferAttribute(new this.array.constructor(t), this.itemSize, this.normalized);
        }
        return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)), new InterleavedBufferAttribute(t.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
      }
      toJSON(t) {
        if (void 0 === t) {
          console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
          const t = [];
          for (let e = 0; e < this.count; e++) {
            const i = e * this.data.stride + this.offset;
            for (let e = 0; e < this.itemSize; e++) t.push(this.data.array[i + e]);
          }
          return {itemSize: this.itemSize, type: this.array.constructor.name, array: t, normalized: this.normalized};
        }
        return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)), {isInterleavedBufferAttribute: true, itemSize: this.itemSize, data: this.data.uuid, offset: this.offset, normalized: this.normalized};
      }
    }
    InterleavedBufferAttribute.prototype.isInterleavedBufferAttribute = true;
    class SpriteMaterial extends Material {
      constructor(t) {
        super(), this.type = "SpriteMaterial", this.color = new three_module_Color(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = true, this.transparent = true, this.setValues(t);
      }
      copy(t) {
        return super.copy(t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.rotation = t.rotation, this.sizeAttenuation = t.sizeAttenuation, this;
      }
    }
    let Br;
    SpriteMaterial.prototype.isSpriteMaterial = true;
    const Pr = new three_module_Vector3, Ir = new three_module_Vector3, Vr = new three_module_Vector3, Fr = new Vector2, kr = new Vector2, Nr = new Matrix4, Gr = new three_module_Vector3, Ur = new three_module_Vector3, zr = new three_module_Vector3, Or = new Vector2, Hr = new Vector2, Wr = new Vector2;
    class Sprite extends Object3D {
      constructor(t) {
        if (super(), this.type = "Sprite", void 0 === Br) {
          Br = new BufferGeometry;
          const t = new Float32Array([-0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1]), e = new InterleavedBuffer(t, 5);
          Br.setIndex([0, 1, 2, 0, 2, 3]), Br.setAttribute("position", new InterleavedBufferAttribute(e, 3, 0, false)), Br.setAttribute("uv", new InterleavedBufferAttribute(e, 2, 3, false));
        }
        this.geometry = Br, this.material = void 0 !== t ? t : new SpriteMaterial, this.center = new Vector2(0.5, 0.5);
      }
      raycast(t, e) {
        null === t.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), Ir.setFromMatrixScale(this.matrixWorld), Nr.copy(t.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse, this.matrixWorld), Vr.setFromMatrixPosition(this.modelViewMatrix), t.camera.isPerspectiveCamera && false === this.material.sizeAttenuation && Ir.multiplyScalar(-Vr.z);
        const i = this.material.rotation;
        let n, r;
        0 !== i && (r = Math.cos(i), n = Math.sin(i));
        const o = this.center;
        Jr(Gr.set(-0.5, -0.5, 0), Vr, o, Ir, n, r), Jr(Ur.set(0.5, -0.5, 0), Vr, o, Ir, n, r), Jr(zr.set(0.5, 0.5, 0), Vr, o, Ir, n, r), Or.set(0, 0), Hr.set(1, 0), Wr.set(1, 1);
        let s = t.ray.intersectTriangle(Gr, Ur, zr, false, Pr);
        if (null === s && (Jr(Ur.set(-0.5, 0.5, 0), Vr, o, Ir, n, r), Hr.set(0, 1), s = t.ray.intersectTriangle(Gr, zr, Ur, false, Pr), null === s)) return;
        const a = t.ray.origin.distanceTo(Pr);
        a < t.near || a > t.far || e.push({distance: a, point: Pr.clone(), uv: Triangle.getUV(Pr, Gr, Ur, zr, Or, Hr, Wr, new Vector2), face: null, object: this});
      }
      copy(t) {
        return super.copy(t), void 0 !== t.center && this.center.copy(t.center), this.material = t.material, this;
      }
    }
    function Jr(t, e, i, n, r, o) {
      Fr.subVectors(t, i).addScalar(0.5).multiply(n), void 0 !== r ? (kr.x = o * Fr.x - r * Fr.y, kr.y = r * Fr.x + o * Fr.y) : kr.copy(Fr), t.copy(e), t.x += kr.x, t.y += kr.y, t.applyMatrix4(Nr);
    }
    Sprite.prototype.isSprite = true;
    const jr = new three_module_Vector3, Xr = new Vector4, qr = new Vector4, Yr = new three_module_Vector3, Zr = new Matrix4;
    class SkinnedMesh extends Mesh {
      constructor(t, e) {
        super(t, e), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new Matrix4, this.bindMatrixInverse = new Matrix4;
      }
      copy(t) {
        return super.copy(t), this.bindMode = t.bindMode, this.bindMatrix.copy(t.bindMatrix), this.bindMatrixInverse.copy(t.bindMatrixInverse), this.skeleton = t.skeleton, this;
      }
      bind(t, e) {
        this.skeleton = t, void 0 === e && (this.updateMatrixWorld(true), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.copy(e).invert();
      }
      pose() {
        this.skeleton.pose();
      }
      normalizeSkinWeights() {
        const t = new Vector4, e = this.geometry.attributes.skinWeight;
        for (let i = 0, n = e.count; i < n; i++) {
          t.x = e.getX(i), t.y = e.getY(i), t.z = e.getZ(i), t.w = e.getW(i);
          const n = 1 / t.manhattanLength();
          n !== Infinity ? t.multiplyScalar(n) : t.set(1, 0, 0, 0), e.setXYZW(i, t.x, t.y, t.z, t.w);
        }
      }
      updateMatrixWorld(t) {
        super.updateMatrixWorld(t), "attached" === this.bindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
      }
      boneTransform(t, e) {
        const i = this.skeleton, n = this.geometry;
        Xr.fromBufferAttribute(n.attributes.skinIndex, t), qr.fromBufferAttribute(n.attributes.skinWeight, t), jr.fromBufferAttribute(n.attributes.position, t).applyMatrix4(this.bindMatrix), e.set(0, 0, 0);
        for (let t = 0; t < 4; t++) {
          const n = qr.getComponent(t);
          if (0 !== n) {
            const r = Xr.getComponent(t);
            Zr.multiplyMatrices(i.bones[r].matrixWorld, i.boneInverses[r]), e.addScaledVector(Yr.copy(jr).applyMatrix4(Zr), n);
          }
        }
        return e.applyMatrix4(this.bindMatrixInverse);
      }
    }
    SkinnedMesh.prototype.isSkinnedMesh = true;
    class Bone extends Object3D {
      constructor() {
        super(), this.type = "Bone";
      }
    }
    Bone.prototype.isBone = true;
    class DataTexture extends Texture {
      constructor(t = null, e = 1, i = 1, n, r, o, s, a, l = 1003, c = 1003, h, u) {
        super(null, o, s, a, l, c, n, r, h, u), this.image = {data: t, width: e, height: i}, this.magFilter = l, this.minFilter = c, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1, this.needsUpdate = true;
      }
    }
    DataTexture.prototype.isDataTexture = true;
    class InstancedBufferAttribute extends BufferAttribute {
      constructor(t, e, i, n = 1) {
        "number" == typeof i && (n = i, i = false, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), super(t, e, i), this.meshPerAttribute = n;
      }
      copy(t) {
        return super.copy(t), this.meshPerAttribute = t.meshPerAttribute, this;
      }
      toJSON() {
        const t = super.toJSON();
        return t.meshPerAttribute = this.meshPerAttribute, t.isInstancedBufferAttribute = true, t;
      }
    }
    InstancedBufferAttribute.prototype.isInstancedBufferAttribute = true;
    const Kr = new Matrix4, $r = new Matrix4, Qr = [], to = new Mesh;
    class InstancedMesh extends Mesh {
      constructor(t, e, i) {
        super(t, e), this.instanceMatrix = new InstancedBufferAttribute(new Float32Array(16 * i), 16), this.instanceColor = null, this.count = i, this.frustumCulled = false;
      }
      copy(t) {
        return super.copy(t), this.instanceMatrix.copy(t.instanceMatrix), null !== t.instanceColor && (this.instanceColor = t.instanceColor.clone()), this.count = t.count, this;
      }
      getColorAt(t, e) {
        e.fromArray(this.instanceColor.array, 3 * t);
      }
      getMatrixAt(t, e) {
        e.fromArray(this.instanceMatrix.array, 16 * t);
      }
      raycast(t, e) {
        const i = this.matrixWorld, n = this.count;
        if (to.geometry = this.geometry, to.material = this.material, void 0 !== to.material) for (let r = 0; r < n; r++) {
          this.getMatrixAt(r, Kr), $r.multiplyMatrices(i, Kr), to.matrixWorld = $r, to.raycast(t, Qr);
          for (let t = 0, i = Qr.length; t < i; t++) {
            const i = Qr[t];
            i.instanceId = r, i.object = this, e.push(i);
          }
          Qr.length = 0;
        }
      }
      setColorAt(t, e) {
        null === this.instanceColor && (this.instanceColor = new InstancedBufferAttribute(new Float32Array(3 * this.instanceMatrix.count), 3)), e.toArray(this.instanceColor.array, 3 * t);
      }
      setMatrixAt(t, e) {
        e.toArray(this.instanceMatrix.array, 16 * t);
      }
      updateMorphTargets() {}
      dispose() {
        this.dispatchEvent({type: "dispose"});
      }
    }
    InstancedMesh.prototype.isInstancedMesh = true;
    class LineBasicMaterial extends Material {
      constructor(t) {
        super(), this.type = "LineBasicMaterial", this.color = new three_module_Color(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.setValues(t);
      }
      copy(t) {
        return super.copy(t), this.color.copy(t.color), this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this;
      }
    }
    LineBasicMaterial.prototype.isLineBasicMaterial = true;
    const eo = new three_module_Vector3, no = new three_module_Vector3, ro = new Matrix4, oo = new Ray, so = new Sphere;
    class Line extends Object3D {
      constructor(t = new BufferGeometry, e = new LineBasicMaterial) {
        super(), this.type = "Line", this.geometry = t, this.material = e, this.updateMorphTargets();
      }
      copy(t) {
        return super.copy(t), this.material = t.material, this.geometry = t.geometry, this;
      }
      computeLineDistances() {
        const t = this.geometry;
        if (t.isBufferGeometry) if (null === t.index) {
          const e = t.attributes.position, i = [0];
          for (let t = 1, n = e.count; t < n; t++) eo.fromBufferAttribute(e, t - 1), no.fromBufferAttribute(e, t), i[t] = i[t - 1], i[t] += eo.distanceTo(no);
          t.setAttribute("lineDistance", new Float32BufferAttribute(i, 1));
        } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); else t.isGeometry && console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
        return this;
      }
      raycast(t, e) {
        const i = this.geometry, n = this.matrixWorld, r = t.params.Line.threshold, o = i.drawRange;
        if (null === i.boundingSphere && i.computeBoundingSphere(), so.copy(i.boundingSphere), so.applyMatrix4(n), so.radius += r, false === t.ray.intersectsSphere(so)) return;
        ro.copy(n).invert(), oo.copy(t.ray).applyMatrix4(ro);
        const s = r / ((this.scale.x + this.scale.y + this.scale.z) / 3), a = s * s, l = new three_module_Vector3, c = new three_module_Vector3, h = new three_module_Vector3, u = new three_module_Vector3, p = this.isLineSegments ? 2 : 1;
        if (i.isBufferGeometry) {
          const n = i.index, r = i.attributes.position;
          if (null !== n) {
            for (let i = Math.max(0, o.start), s = Math.min(n.count, o.start + o.count) - 1; i < s; i += p) {
              const o = n.getX(i), s = n.getX(i + 1);
              l.fromBufferAttribute(r, o), c.fromBufferAttribute(r, s);
              if (oo.distanceSqToSegment(l, c, u, h) > a) continue;
              u.applyMatrix4(this.matrixWorld);
              const p = t.ray.origin.distanceTo(u);
              p < t.near || p > t.far || e.push({distance: p, point: h.clone().applyMatrix4(this.matrixWorld), index: i, face: null, faceIndex: null, object: this});
            }
          } else {
            for (let i = Math.max(0, o.start), n = Math.min(r.count, o.start + o.count) - 1; i < n; i += p) {
              l.fromBufferAttribute(r, i), c.fromBufferAttribute(r, i + 1);
              if (oo.distanceSqToSegment(l, c, u, h) > a) continue;
              u.applyMatrix4(this.matrixWorld);
              const n = t.ray.origin.distanceTo(u);
              n < t.near || n > t.far || e.push({distance: n, point: h.clone().applyMatrix4(this.matrixWorld), index: i, face: null, faceIndex: null, object: this});
            }
          }
        } else i.isGeometry && console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
      updateMorphTargets() {
        const t = this.geometry;
        if (t.isBufferGeometry) {
          const e = t.morphAttributes, i = Object.keys(e);
          if (i.length > 0) {
            const t = e[i[0]];
            if (void 0 !== t) {
              this.morphTargetInfluences = [], this.morphTargetDictionary = {};
              for (let e = 0, i = t.length; e < i; e++) {
                const i = t[e].name || String(e);
                this.morphTargetInfluences.push(0), this.morphTargetDictionary[i] = e;
              }
            }
          }
        } else {
          const e = t.morphTargets;
          void 0 !== e && e.length > 0 && console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
        }
      }
    }
    Line.prototype.isLine = true;
    const ao = new three_module_Vector3, lo = new three_module_Vector3;
    class LineSegments extends Line {
      constructor(t, e) {
        super(t, e), this.type = "LineSegments";
      }
      computeLineDistances() {
        const t = this.geometry;
        if (t.isBufferGeometry) if (null === t.index) {
          const e = t.attributes.position, i = [];
          for (let t = 0, n = e.count; t < n; t += 2) ao.fromBufferAttribute(e, t), lo.fromBufferAttribute(e, t + 1), i[t] = 0 === t ? 0 : i[t - 1], i[t + 1] = i[t] + ao.distanceTo(lo);
          t.setAttribute("lineDistance", new Float32BufferAttribute(i, 1));
        } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); else t.isGeometry && console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
        return this;
      }
    }
    LineSegments.prototype.isLineSegments = true;
    class LineLoop extends Line {
      constructor(t, e) {
        super(t, e), this.type = "LineLoop";
      }
    }
    LineLoop.prototype.isLineLoop = true;
    class PointsMaterial extends Material {
      constructor(t) {
        super(), this.type = "PointsMaterial", this.color = new three_module_Color(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = true, this.setValues(t);
      }
      copy(t) {
        return super.copy(t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this;
      }
    }
    PointsMaterial.prototype.isPointsMaterial = true;
    const co = new Matrix4, ho = new Ray, uo = new Sphere, po = new three_module_Vector3;
    class Points extends Object3D {
      constructor(t = new BufferGeometry, e = new PointsMaterial) {
        super(), this.type = "Points", this.geometry = t, this.material = e, this.updateMorphTargets();
      }
      copy(t) {
        return super.copy(t), this.material = t.material, this.geometry = t.geometry, this;
      }
      raycast(t, e) {
        const i = this.geometry, n = this.matrixWorld, r = t.params.Points.threshold, o = i.drawRange;
        if (null === i.boundingSphere && i.computeBoundingSphere(), uo.copy(i.boundingSphere), uo.applyMatrix4(n), uo.radius += r, false === t.ray.intersectsSphere(uo)) return;
        co.copy(n).invert(), ho.copy(t.ray).applyMatrix4(co);
        const s = r / ((this.scale.x + this.scale.y + this.scale.z) / 3), a = s * s;
        if (i.isBufferGeometry) {
          const r = i.index, s = i.attributes.position;
          if (null !== r) {
            for (let i = Math.max(0, o.start), l = Math.min(r.count, o.start + o.count); i < l; i++) {
              const o = r.getX(i);
              po.fromBufferAttribute(s, o), mo(po, o, a, n, t, e, this);
            }
          } else {
            for (let i = Math.max(0, o.start), r = Math.min(s.count, o.start + o.count); i < r; i++) po.fromBufferAttribute(s, i), mo(po, i, a, n, t, e, this);
          }
        } else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
      updateMorphTargets() {
        const t = this.geometry;
        if (t.isBufferGeometry) {
          const e = t.morphAttributes, i = Object.keys(e);
          if (i.length > 0) {
            const t = e[i[0]];
            if (void 0 !== t) {
              this.morphTargetInfluences = [], this.morphTargetDictionary = {};
              for (let e = 0, i = t.length; e < i; e++) {
                const i = t[e].name || String(e);
                this.morphTargetInfluences.push(0), this.morphTargetDictionary[i] = e;
              }
            }
          }
        } else {
          const e = t.morphTargets;
          void 0 !== e && e.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
        }
      }
    }
    function mo(t, e, i, n, r, o, s) {
      const a = ho.distanceSqToPoint(t);
      if (a < i) {
        const i = new three_module_Vector3;
        ho.closestPointToPoint(t, i), i.applyMatrix4(n);
        const l = r.ray.origin.distanceTo(i);
        if (l < r.near || l > r.far) return;
        o.push({distance: l, distanceToRay: Math.sqrt(a), point: i, index: e, face: null, object: s});
      }
    }
    Points.prototype.isPoints = true;
    (class VideoTexture extends Texture {
      constructor(t, e, i, n, r, o, s, a, l) {
        super(t, e, i, n, r, o, s, a, l), this.format = void 0 !== s ? s : T, this.minFilter = void 0 !== o ? o : x, this.magFilter = void 0 !== r ? r : x, this.generateMipmaps = false;
        const c = this;
        "requestVideoFrameCallback" in t && t.requestVideoFrameCallback(function e() {
          c.needsUpdate = true, t.requestVideoFrameCallback(e);
        });
      }
      clone() {
        return new this.constructor(this.image).copy(this);
      }
      update() {
        const t = this.image;
        false === "requestVideoFrameCallback" in t && t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = true);
      }
    }.prototype.isVideoTexture = true);
    class CompressedTexture extends Texture {
      constructor(t, e, i, n, r, o, s, a, l, c, h, u) {
        super(null, o, s, a, l, c, n, r, h, u), this.image = {width: e, height: i}, this.mipmaps = t, this.flipY = false, this.generateMipmaps = false;
      }
    }
    CompressedTexture.prototype.isCompressedTexture = true;
    (class CanvasTexture extends Texture {
      constructor(t, e, i, n, r, o, s, a, l) {
        super(t, e, i, n, r, o, s, a, l), this.needsUpdate = true;
      }
    }.prototype.isCanvasTexture = true);
    (class DepthTexture extends Texture {
      constructor(t, e, i, n, r, o, s, a, l, c) {
        if ((c = void 0 !== c ? c : L) !== L && c !== D) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        void 0 === i && c === L && (i = w), void 0 === i && c === D && (i = C), super(null, n, r, o, s, a, c, i, l), this.image = {width: t, height: e}, this.magFilter = void 0 !== s ? s : _, this.minFilter = void 0 !== a ? a : _, this.flipY = false, this.generateMipmaps = false;
      }
    }.prototype.isDepthTexture = true);
    new three_module_Vector3, new three_module_Vector3, new three_module_Vector3, new Triangle;
    class Curve {
      constructor() {
        this.type = "Curve", this.arcLengthDivisions = 200;
      }
      getPoint() {
        return console.warn("THREE.Curve: .getPoint() not implemented."), null;
      }
      getPointAt(t, e) {
        const i = this.getUtoTmapping(t);
        return this.getPoint(i, e);
      }
      getPoints(t = 5) {
        const e = [];
        for (let i = 0; i <= t; i++) e.push(this.getPoint(i / t));
        return e;
      }
      getSpacedPoints(t = 5) {
        const e = [];
        for (let i = 0; i <= t; i++) e.push(this.getPointAt(i / t));
        return e;
      }
      getLength() {
        const t = this.getLengths();
        return t[t.length - 1];
      }
      getLengths(t = this.arcLengthDivisions) {
        if (this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this.cacheArcLengths;
        this.needsUpdate = false;
        const e = [];
        let i, n = this.getPoint(0), r = 0;
        e.push(0);
        for (let o = 1; o <= t; o++) i = this.getPoint(o / t), r += i.distanceTo(n), e.push(r), n = i;
        return this.cacheArcLengths = e, e;
      }
      updateArcLengths() {
        this.needsUpdate = true, this.getLengths();
      }
      getUtoTmapping(t, e) {
        const i = this.getLengths();
        let n = 0;
        const r = i.length;
        let o;
        o = e || t * i[r - 1];
        let s, a = 0, l = r - 1;
        for (; a <= l;) if (n = Math.floor(a + (l - a) / 2), s = i[n] - o, s < 0) a = n + 1; else {
          if (!(s > 0)) {
            l = n;
            break;
          }
          l = n - 1;
        }
        if (n = l, i[n] === o) return n / (r - 1);
        const c = i[n];
        return (n + (o - c) / (i[n + 1] - c)) / (r - 1);
      }
      getTangent(t, e) {
        const i = 0.0001;
        let n = t - i, r = t + i;
        n < 0 && (n = 0), r > 1 && (r = 1);
        const o = this.getPoint(n), s = this.getPoint(r), a = e || (o.isVector2 ? new Vector2 : new three_module_Vector3);
        return a.copy(s).sub(o).normalize(), a;
      }
      getTangentAt(t, e) {
        const i = this.getUtoTmapping(t);
        return this.getTangent(i, e);
      }
      computeFrenetFrames(t, e) {
        const i = new three_module_Vector3, n = [], r = [], o = [], s = new three_module_Vector3, a = new Matrix4;
        for (let e = 0; e <= t; e++) {
          const i = e / t;
          n[e] = this.getTangentAt(i, new three_module_Vector3), n[e].normalize();
        }
        r[0] = new three_module_Vector3, o[0] = new three_module_Vector3;
        let l = Number.MAX_VALUE;
        const c = Math.abs(n[0].x), h = Math.abs(n[0].y), u = Math.abs(n[0].z);
        c <= l && (l = c, i.set(1, 0, 0)), h <= l && (l = h, i.set(0, 1, 0)), u <= l && i.set(0, 0, 1), s.crossVectors(n[0], i).normalize(), r[0].crossVectors(n[0], s), o[0].crossVectors(n[0], r[0]);
        for (let e = 1; e <= t; e++) {
          if (r[e] = r[e - 1].clone(), o[e] = o[e - 1].clone(), s.crossVectors(n[e - 1], n[e]), s.length() > Number.EPSILON) {
            s.normalize();
            const t = Math.acos(Math.max(-1, Math.min(1, n[e - 1].dot(n[e]))));
            r[e].applyMatrix4(a.makeRotationAxis(s, t));
          }
          o[e].crossVectors(n[e], r[e]);
        }
        if (true === e) {
          let e = Math.acos(Math.max(-1, Math.min(1, r[0].dot(r[t]))));
          e /= t, n[0].dot(s.crossVectors(r[0], r[t])) > 0 && (e = -e);
          for (let i = 1; i <= t; i++) r[i].applyMatrix4(a.makeRotationAxis(n[i], e * i)), o[i].crossVectors(n[i], r[i]);
        }
        return {tangents: n, normals: r, binormals: o};
      }
      clone() {
        return (new this.constructor).copy(this);
      }
      copy(t) {
        return this.arcLengthDivisions = t.arcLengthDivisions, this;
      }
      toJSON() {
        const t = {metadata: {version: 4.5, type: "Curve", generator: "Curve.toJSON"}};
        return t.arcLengthDivisions = this.arcLengthDivisions, t.type = this.type, t;
      }
      fromJSON(t) {
        return this.arcLengthDivisions = t.arcLengthDivisions, this;
      }
    }
    class EllipseCurve extends Curve {
      constructor(t = 0, e = 0, i = 1, n = 1, r = 0, o = 2 * Math.PI, s = false, a = 0) {
        super(), this.type = "EllipseCurve", this.aX = t, this.aY = e, this.xRadius = i, this.yRadius = n, this.aStartAngle = r, this.aEndAngle = o, this.aClockwise = s, this.aRotation = a;
      }
      getPoint(t, e) {
        const i = e || new Vector2, n = 2 * Math.PI;
        let r = this.aEndAngle - this.aStartAngle;
        const o = Math.abs(r) < Number.EPSILON;
        for (; r < 0;) r += n;
        for (; r > n;) r -= n;
        r < Number.EPSILON && (r = o ? 0 : n), true !== this.aClockwise || o || (r === n ? r = -n : r -= n);
        const s = this.aStartAngle + t * r;
        let a = this.aX + this.xRadius * Math.cos(s), l = this.aY + this.yRadius * Math.sin(s);
        if (0 !== this.aRotation) {
          const t = Math.cos(this.aRotation), e = Math.sin(this.aRotation), i = a - this.aX, n = l - this.aY;
          a = i * t - n * e + this.aX, l = i * e + n * t + this.aY;
        }
        return i.set(a, l);
      }
      copy(t) {
        return super.copy(t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this;
      }
      toJSON() {
        const t = super.toJSON();
        return t.aX = this.aX, t.aY = this.aY, t.xRadius = this.xRadius, t.yRadius = this.yRadius, t.aStartAngle = this.aStartAngle, t.aEndAngle = this.aEndAngle, t.aClockwise = this.aClockwise, t.aRotation = this.aRotation, t;
      }
      fromJSON(t) {
        return super.fromJSON(t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this;
      }
    }
    EllipseCurve.prototype.isEllipseCurve = true;
    class ArcCurve extends EllipseCurve {
      constructor(t, e, i, n, r, o) {
        super(t, e, i, i, n, r, o), this.type = "ArcCurve";
      }
    }
    function fo() {
      let t = 0, e = 0, i = 0, n = 0;
      function r(r, o, s, a) {
        t = r, e = s, i = -3 * r + 3 * o - 2 * s - a, n = 2 * r - 2 * o + s + a;
      }
      return {initCatmullRom: function (t, e, i, n, o) {
        r(e, i, o * (i - t), o * (n - e));
      }, initNonuniformCatmullRom: function (t, e, i, n, o, s, a) {
        let l = (e - t) / o - (i - t) / (o + s) + (i - e) / s, c = (i - e) / s - (n - e) / (s + a) + (n - i) / a;
        l *= s, c *= s, r(e, i, l, c);
      }, calc: function (r) {
        const o = r * r;
        return t + e * r + i * o + n * (o * r);
      }};
    }
    ArcCurve.prototype.isArcCurve = true;
    const _o = new three_module_Vector3, yo = new fo, go = new fo, xo = new fo;
    class CatmullRomCurve3 extends Curve {
      constructor(t = [], e = false, i = "centripetal", n = 0.5) {
        super(), this.type = "CatmullRomCurve3", this.points = t, this.closed = e, this.curveType = i, this.tension = n;
      }
      getPoint(t, e = new three_module_Vector3) {
        const i = e, n = this.points, r = n.length, o = (r - (this.closed ? 0 : 1)) * t;
        let s, a, l = Math.floor(o), c = o - l;
        this.closed ? l += l > 0 ? 0 : (Math.floor(Math.abs(l) / r) + 1) * r : 0 === c && l === r - 1 && (l = r - 2, c = 1), this.closed || l > 0 ? s = n[(l - 1) % r] : (_o.subVectors(n[0], n[1]).add(n[0]), s = _o);
        const h = n[l % r], u = n[(l + 1) % r];
        if (this.closed || l + 2 < r ? a = n[(l + 2) % r] : (_o.subVectors(n[r - 1], n[r - 2]).add(n[r - 1]), a = _o), "centripetal" === this.curveType || "chordal" === this.curveType) {
          const t = "chordal" === this.curveType ? 0.5 : 0.25;
          let e = Math.pow(s.distanceToSquared(h), t), i = Math.pow(h.distanceToSquared(u), t), n = Math.pow(u.distanceToSquared(a), t);
          i < 0.0001 && (i = 1), e < 0.0001 && (e = i), n < 0.0001 && (n = i), yo.initNonuniformCatmullRom(s.x, h.x, u.x, a.x, e, i, n), go.initNonuniformCatmullRom(s.y, h.y, u.y, a.y, e, i, n), xo.initNonuniformCatmullRom(s.z, h.z, u.z, a.z, e, i, n);
        } else "catmullrom" === this.curveType && (yo.initCatmullRom(s.x, h.x, u.x, a.x, this.tension), go.initCatmullRom(s.y, h.y, u.y, a.y, this.tension), xo.initCatmullRom(s.z, h.z, u.z, a.z, this.tension));
        return i.set(yo.calc(c), go.calc(c), xo.calc(c)), i;
      }
      copy(t) {
        super.copy(t), this.points = [];
        for (let e = 0, i = t.points.length; e < i; e++) {
          const i = t.points[e];
          this.points.push(i.clone());
        }
        return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this;
      }
      toJSON() {
        const t = super.toJSON();
        t.points = [];
        for (let e = 0, i = this.points.length; e < i; e++) {
          const i = this.points[e];
          t.points.push(i.toArray());
        }
        return t.closed = this.closed, t.curveType = this.curveType, t.tension = this.tension, t;
      }
      fromJSON(t) {
        super.fromJSON(t), this.points = [];
        for (let e = 0, i = t.points.length; e < i; e++) {
          const i = t.points[e];
          this.points.push((new three_module_Vector3).fromArray(i));
        }
        return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this;
      }
    }
    function vo(t, e, i, n, r) {
      const o = 0.5 * (n - e), s = 0.5 * (r - i), a = t * t;
      return (2 * i - 2 * n + o + s) * (t * a) + (-3 * i + 3 * n - 2 * o - s) * a + o * t + i;
    }
    function bo(t, e, i, n) {
      return function (t, e) {
        const i = 1 - t;
        return i * i * e;
      }(t, e) + function (t, e) {
        return 2 * (1 - t) * t * e;
      }(t, i) + function (t, e) {
        return t * t * e;
      }(t, n);
    }
    function wo(t, e, i, n, r) {
      return function (t, e) {
        const i = 1 - t;
        return i * i * i * e;
      }(t, e) + function (t, e) {
        const i = 1 - t;
        return 3 * i * i * t * e;
      }(t, i) + function (t, e) {
        return 3 * (1 - t) * t * t * e;
      }(t, n) + function (t, e) {
        return t * t * t * e;
      }(t, r);
    }
    CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;
    class CubicBezierCurve extends Curve {
      constructor(t = new Vector2, e = new Vector2, i = new Vector2, n = new Vector2) {
        super(), this.type = "CubicBezierCurve", this.v0 = t, this.v1 = e, this.v2 = i, this.v3 = n;
      }
      getPoint(t, e = new Vector2) {
        const i = e, n = this.v0, r = this.v1, o = this.v2, s = this.v3;
        return i.set(wo(t, n.x, r.x, o.x, s.x), wo(t, n.y, r.y, o.y, s.y)), i;
      }
      copy(t) {
        return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this;
      }
      toJSON() {
        const t = super.toJSON();
        return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t;
      }
      fromJSON(t) {
        return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this;
      }
    }
    CubicBezierCurve.prototype.isCubicBezierCurve = true;
    class CubicBezierCurve3 extends Curve {
      constructor(t = new three_module_Vector3, e = new three_module_Vector3, i = new three_module_Vector3, n = new three_module_Vector3) {
        super(), this.type = "CubicBezierCurve3", this.v0 = t, this.v1 = e, this.v2 = i, this.v3 = n;
      }
      getPoint(t, e = new three_module_Vector3) {
        const i = e, n = this.v0, r = this.v1, o = this.v2, s = this.v3;
        return i.set(wo(t, n.x, r.x, o.x, s.x), wo(t, n.y, r.y, o.y, s.y), wo(t, n.z, r.z, o.z, s.z)), i;
      }
      copy(t) {
        return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this;
      }
      toJSON() {
        const t = super.toJSON();
        return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t;
      }
      fromJSON(t) {
        return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this;
      }
    }
    CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;
    class LineCurve extends Curve {
      constructor(t = new Vector2, e = new Vector2) {
        super(), this.type = "LineCurve", this.v1 = t, this.v2 = e;
      }
      getPoint(t, e = new Vector2) {
        const i = e;
        return 1 === t ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(t).add(this.v1)), i;
      }
      getPointAt(t, e) {
        return this.getPoint(t, e);
      }
      getTangent(t, e) {
        const i = e || new Vector2;
        return i.copy(this.v2).sub(this.v1).normalize(), i;
      }
      copy(t) {
        return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
      }
      toJSON() {
        const t = super.toJSON();
        return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t;
      }
      fromJSON(t) {
        return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
      }
    }
    LineCurve.prototype.isLineCurve = true;
    class QuadraticBezierCurve extends Curve {
      constructor(t = new Vector2, e = new Vector2, i = new Vector2) {
        super(), this.type = "QuadraticBezierCurve", this.v0 = t, this.v1 = e, this.v2 = i;
      }
      getPoint(t, e = new Vector2) {
        const i = e, n = this.v0, r = this.v1, o = this.v2;
        return i.set(bo(t, n.x, r.x, o.x), bo(t, n.y, r.y, o.y)), i;
      }
      copy(t) {
        return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
      }
      toJSON() {
        const t = super.toJSON();
        return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t;
      }
      fromJSON(t) {
        return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
      }
    }
    QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;
    class QuadraticBezierCurve3 extends Curve {
      constructor(t = new three_module_Vector3, e = new three_module_Vector3, i = new three_module_Vector3) {
        super(), this.type = "QuadraticBezierCurve3", this.v0 = t, this.v1 = e, this.v2 = i;
      }
      getPoint(t, e = new three_module_Vector3) {
        const i = e, n = this.v0, r = this.v1, o = this.v2;
        return i.set(bo(t, n.x, r.x, o.x), bo(t, n.y, r.y, o.y), bo(t, n.z, r.z, o.z)), i;
      }
      copy(t) {
        return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
      }
      toJSON() {
        const t = super.toJSON();
        return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t;
      }
      fromJSON(t) {
        return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
      }
    }
    QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;
    class SplineCurve extends Curve {
      constructor(t = []) {
        super(), this.type = "SplineCurve", this.points = t;
      }
      getPoint(t, e = new Vector2) {
        const i = e, n = this.points, r = (n.length - 1) * t, o = Math.floor(r), s = r - o, a = n[0 === o ? o : o - 1], l = n[o], c = n[o > n.length - 2 ? n.length - 1 : o + 1], h = n[o > n.length - 3 ? n.length - 1 : o + 2];
        return i.set(vo(s, a.x, l.x, c.x, h.x), vo(s, a.y, l.y, c.y, h.y)), i;
      }
      copy(t) {
        super.copy(t), this.points = [];
        for (let e = 0, i = t.points.length; e < i; e++) {
          const i = t.points[e];
          this.points.push(i.clone());
        }
        return this;
      }
      toJSON() {
        const t = super.toJSON();
        t.points = [];
        for (let e = 0, i = this.points.length; e < i; e++) {
          const i = this.points[e];
          t.points.push(i.toArray());
        }
        return t;
      }
      fromJSON(t) {
        super.fromJSON(t), this.points = [];
        for (let e = 0, i = t.points.length; e < i; e++) {
          const i = t.points[e];
          this.points.push((new Vector2).fromArray(i));
        }
        return this;
      }
    }
    SplineCurve.prototype.isSplineCurve = true;
    var So = Object.freeze({__proto__: null, ArcCurve, CatmullRomCurve3, CubicBezierCurve, CubicBezierCurve3, EllipseCurve, LineCurve, LineCurve3: class LineCurve3 extends Curve {
      constructor(t = new three_module_Vector3, e = new three_module_Vector3) {
        super(), this.type = "LineCurve3", this.isLineCurve3 = true, this.v1 = t, this.v2 = e;
      }
      getPoint(t, e = new three_module_Vector3) {
        const i = e;
        return 1 === t ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(t).add(this.v1)), i;
      }
      getPointAt(t, e) {
        return this.getPoint(t, e);
      }
      copy(t) {
        return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
      }
      toJSON() {
        const t = super.toJSON();
        return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t;
      }
      fromJSON(t) {
        return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
      }
    }, QuadraticBezierCurve, QuadraticBezierCurve3, SplineCurve});
    const Mo = function (t, e, i = 2) {
      const n = e && e.length, r = n ? e[0] * i : t.length;
      let o = Ao(t, 0, r, i, true);
      const s = [];
      if (!o || o.next === o.prev) return s;
      let a, l, c, h, u, p, m;
      if (n && (o = function (t, e, i, n) {
        const r = [];
        let o, s, a, l, c;
        for (o = 0, s = e.length; o < s; o++) a = e[o] * n, l = o < s - 1 ? e[o + 1] * n : t.length, c = Ao(t, a, l, n, false), c === c.next && (c.steiner = true), r.push(Fo(c));
        for (r.sort(Bo), o = 0; o < r.length; o++) Po(r[o], i), i = Co(i, i.next);
        return i;
      }(t, e, o, i)), t.length > 80 * i) {
        a = c = t[0], l = h = t[1];
        for (let e = i; e < r; e += i) u = t[e], p = t[e + 1], u < a && (a = u), p < l && (l = p), u > c && (c = u), p > h && (h = p);
        m = Math.max(c - a, h - l), m = 0 !== m ? 1 / m : 0;
      }
      return To(o, s, i, a, l, m), s;
    };
    function Ao(t, e, i, n, r) {
      let o, s;
      if (r === function (t, e, i, n) {
        let r = 0;
        for (let o = e, s = i - n; o < i; o += n) r += (t[s] - t[o]) * (t[o + 1] + t[s + 1]), s = o;
        return r;
      }(t, e, i, n) > 0) for (o = e; o < i; o += n) s = jo(o, t[o], t[o + 1], s); else for (o = i - n; o >= e; o -= n) s = jo(o, t[o], t[o + 1], s);
      return s && (s.x === s.next.x && s.y === s.next.y) && (Xo(s), s = s.next), s;
    }
    function Co(t, e) {
      if (!t) return t;
      e || (e = t);
      let i, n = t;
      do {
        if (i = false, n.steiner || !(n.x === n.next.x && n.y === n.next.y) && 0 !== (n.y - n.prev.y) * (n.next.x - n.x) - (n.x - n.prev.x) * (n.next.y - n.y)) n = n.next; else {
          if (Xo(n), n = e = n.prev, n === n.next) break;
          i = true;
        }
      } while (i || n !== e);
      return e;
    }
    function To(t, e, i, n, r, o, s) {
      if (!t) return;
      !s && o && function (t, e, i, n) {
        let r = t;
        do {
          null === r.z && (r.z = (r.x = 1431655765 & ((r.x = 858993459 & ((r.x = 252645135 & ((r.x = 16711935 & ((r.x = 32767 * (r.x - e) * n) | r.x << 8)) | r.x << 4)) | r.x << 2)) | r.x << 1)) | (r.y = 1431655765 & ((r.y = 858993459 & ((r.y = 252645135 & ((r.y = 16711935 & ((r.y = 32767 * (r.y - i) * n) | r.y << 8)) | r.y << 4)) | r.y << 2)) | r.y << 1)) << 1), r.prevZ = r.prev, r.nextZ = r.next, r = r.next;
        } while (r !== t);
        r.prevZ.nextZ = null, r.prevZ = null, function (t) {
          let e, i, n, r, o, s, a, l, c = 1;
          do {
            for (i = t, t = null, o = null, s = 0; i;) {
              for (s++, n = i, a = 0, e = 0; e < c && (a++, n = n.nextZ, n); e++) ;
              for (l = c; a > 0 || l > 0 && n;) 0 !== a && (0 === l || !n || i.z <= n.z) ? (r = i, i = i.nextZ, a--) : (r = n, n = n.nextZ, l--), o ? o.nextZ = r : t = r, r.prevZ = o, o = r;
              i = n;
            }
            o.nextZ = null, c *= 2;
          } while (s > 1);
        }(r);
      }(t, n, r, o);
      let a, l, c = t;
      for (; t.prev !== t.next;) if (a = t.prev, l = t.next, o ? Lo(t, n, r, o) : Eo(t)) e.push(a.i / i), e.push(t.i / i), e.push(l.i / i), Xo(t), t = l.next, c = l.next; else if ((t = l) === c) {
        s ? 1 === s ? To(t = Do(Co(t), e, i), e, i, n, r, o, 2) : 2 === s && Ro(t, e, i, n, r, o) : To(Co(t), e, i, n, r, o, 1);
        break;
      }
    }
    function Eo(t) {
      const e = t.prev, i = t, n = t.next;
      if ((i.y - e.y) * (n.x - i.x) - (i.x - e.x) * (n.y - i.y) >= 0) return false;
      let r = t.next.next;
      for (; r !== t.prev;) {
        if ((n.x - r.x) * (e.y - r.y) - (e.x - r.x) * (n.y - r.y) >= 0 && (e.x - r.x) * (i.y - r.y) - (i.x - r.x) * (e.y - r.y) >= 0 && (i.x - r.x) * (n.y - r.y) - (n.x - r.x) * (i.y - r.y) >= 0 && (r.y - r.prev.y) * (r.next.x - r.x) - (r.x - r.prev.x) * (r.next.y - r.y) >= 0) return false;
        r = r.next;
      }
      return true;
    }
    function Lo(t, e, i, n) {
      const r = t.prev, o = t, s = t.next;
      if ((o.y - r.y) * (s.x - o.x) - (o.x - r.x) * (s.y - o.y) >= 0) return false;
      const a = r.x < o.x ? r.x < s.x ? r.x : s.x : o.x < s.x ? o.x : s.x, l = r.y < o.y ? r.y < s.y ? r.y : s.y : o.y < s.y ? o.y : s.y, c = r.x > o.x ? r.x > s.x ? r.x : s.x : o.x > s.x ? o.x : s.x, h = r.y > o.y ? r.y > s.y ? r.y : s.y : o.y > s.y ? o.y : s.y, u = (a = 1431655765 & ((a = 858993459 & ((a = 252645135 & ((a = 16711935 & ((a = 32767 * (a - e) * n) | a << 8)) | a << 4)) | a << 2)) | a << 1)) | (l = 1431655765 & ((l = 858993459 & ((l = 252645135 & ((l = 16711935 & ((l = 32767 * (l - i) * n) | l << 8)) | l << 4)) | l << 2)) | l << 1)) << 1, p = (c = 1431655765 & ((c = 858993459 & ((c = 252645135 & ((c = 16711935 & ((c = 32767 * (c - e) * n) | c << 8)) | c << 4)) | c << 2)) | c << 1)) | (h = 1431655765 & ((h = 858993459 & ((h = 252645135 & ((h = 16711935 & ((h = 32767 * (h - i) * n) | h << 8)) | h << 4)) | h << 2)) | h << 1)) << 1;
      let m = t.prevZ, d = t.nextZ;
      for (; m && m.z >= u && d && d.z <= p;) {
        if (m !== t.prev && m !== t.next && ((s.x - m.x) * (r.y - m.y) - (r.x - m.x) * (s.y - m.y) >= 0 && (r.x - m.x) * (o.y - m.y) - (o.x - m.x) * (r.y - m.y) >= 0 && (o.x - m.x) * (s.y - m.y) - (s.x - m.x) * (o.y - m.y) >= 0) && (m.y - m.prev.y) * (m.next.x - m.x) - (m.x - m.prev.x) * (m.next.y - m.y) >= 0) return false;
        if (m = m.prevZ, d !== t.prev && d !== t.next && ((s.x - d.x) * (r.y - d.y) - (r.x - d.x) * (s.y - d.y) >= 0 && (r.x - d.x) * (o.y - d.y) - (o.x - d.x) * (r.y - d.y) >= 0 && (o.x - d.x) * (s.y - d.y) - (s.x - d.x) * (o.y - d.y) >= 0) && (d.y - d.prev.y) * (d.next.x - d.x) - (d.x - d.prev.x) * (d.next.y - d.y) >= 0) return false;
        d = d.nextZ;
      }
      for (; m && m.z >= u;) {
        if (m !== t.prev && m !== t.next && ((s.x - m.x) * (r.y - m.y) - (r.x - m.x) * (s.y - m.y) >= 0 && (r.x - m.x) * (o.y - m.y) - (o.x - m.x) * (r.y - m.y) >= 0 && (o.x - m.x) * (s.y - m.y) - (s.x - m.x) * (o.y - m.y) >= 0) && (m.y - m.prev.y) * (m.next.x - m.x) - (m.x - m.prev.x) * (m.next.y - m.y) >= 0) return false;
        m = m.prevZ;
      }
      for (; d && d.z <= p;) {
        if (d !== t.prev && d !== t.next && ((s.x - d.x) * (r.y - d.y) - (r.x - d.x) * (s.y - d.y) >= 0 && (r.x - d.x) * (o.y - d.y) - (o.x - d.x) * (r.y - d.y) >= 0 && (o.x - d.x) * (s.y - d.y) - (s.x - d.x) * (o.y - d.y) >= 0) && (d.y - d.prev.y) * (d.next.x - d.x) - (d.x - d.prev.x) * (d.next.y - d.y) >= 0) return false;
        d = d.nextZ;
      }
      return true;
    }
    function Do(t, e, i) {
      let n = t;
      do {
        const r = n.prev, o = n.next.next;
        !(r.x === o.x && r.y === o.y) && zo(r, n, n.next, o) && Wo(r, o) && Wo(o, r) && (e.push(r.i / i), e.push(n.i / i), e.push(o.i / i), Xo(n), Xo(n.next), n = t = o), n = n.next;
      } while (n !== t);
      return Co(n);
    }
    function Ro(t, e, i, n, r, o) {
      let s = t;
      do {
        let t = s.next.next;
        for (; t !== s.prev;) {
          if (s.i !== t.i && No(s, t)) {
            let a = Jo(s, t);
            return s = Co(s, s.next), a = Co(a, a.next), To(s, e, i, n, r, o), void To(a, e, i, n, r, o);
          }
          t = t.next;
        }
        s = s.next;
      } while (s !== t);
    }
    function Po(t, e) {
      if (e = function (t, e) {
        let i = e;
        const n = t.x, r = t.y;
        let o, s = -Infinity;
        do {
          if (r <= i.y && r >= i.next.y && i.next.y !== i.y) {
            const t = i.x + (r - i.y) * (i.next.x - i.x) / (i.next.y - i.y);
            if (t <= n && t > s) {
              if (s = t, t === n) {
                if (r === i.y) return i;
                if (r === i.next.y) return i.next;
              }
              o = i.x < i.next.x ? i : i.next;
            }
          }
          i = i.next;
        } while (i !== e);
        if (!o) return null;
        if (n === s) return o;
        const a = o, l = o.x, c = o.y;
        let h, u = Infinity;
        i = o;
        do {
          n >= i.x && i.x >= l && n !== i.x && (((r < c ? s : n) - i.x) * (r - i.y) - ((r < c ? n : s) - i.x) * (r - i.y) >= 0 && ((r < c ? n : s) - i.x) * (c - i.y) - (l - i.x) * (r - i.y) >= 0 && (l - i.x) * (r - i.y) - ((r < c ? s : n) - i.x) * (c - i.y) >= 0) && (h = Math.abs(r - i.y) / (n - i.x), Wo(i, t) && (h < u || h === u && (i.x > o.x || i.x === o.x && ((o.y - o.prev.y) * (i.prev.x - o.x) - (o.x - o.prev.x) * (i.prev.y - o.y) < 0 && (o.y - i.next.y) * (o.next.x - o.x) - (o.x - i.next.x) * (o.next.y - o.y) < 0))) && (o = i, u = h)), i = i.next;
        } while (i !== a);
        return o;
      }(t, e)) {
        const i = Jo(e, t);
        Co(e, e.next), Co(i, i.next);
      }
    }
    function Fo(t) {
      let e = t, i = t;
      do {
        (e.x < i.x || e.x === i.x && e.y < i.y) && (i = e), e = e.next;
      } while (e !== t);
      return i;
    }
    function No(t, e) {
      return t.next.i !== e.i && t.prev.i !== e.i && !function (t, e) {
        let i = t;
        do {
          if (i.i !== t.i && i.next.i !== t.i && i.i !== e.i && i.next.i !== e.i && zo(i, i.next, t, e)) return true;
          i = i.next;
        } while (i !== t);
        return false;
      }(t, e) && (Wo(t, e) && Wo(e, t) && function (t, e) {
        let i = t, n = false;
        const r = (t.x + e.x) / 2, o = (t.y + e.y) / 2;
        do {
          i.y > o != i.next.y > o && i.next.y !== i.y && r < (i.next.x - i.x) * (o - i.y) / (i.next.y - i.y) + i.x && (n = !n), i = i.next;
        } while (i !== t);
        return n;
      }(t, e) && ((t.y - t.prev.y) * (e.prev.x - t.x) - (t.x - t.prev.x) * (e.prev.y - t.y) || (e.prev.y - t.y) * (e.x - e.prev.x) - (e.prev.x - t.x) * (e.y - e.prev.y)) || t.x === e.x && t.y === e.y && (t.y - t.prev.y) * (t.next.x - t.x) - (t.x - t.prev.x) * (t.next.y - t.y) > 0 && (e.y - e.prev.y) * (e.next.x - e.x) - (e.x - e.prev.x) * (e.next.y - e.y) > 0);
    }
    function zo(t, e, i, n) {
      const r = Ho((e.y - t.y) * (i.x - e.x) - (e.x - t.x) * (i.y - e.y)), o = Ho((e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)), s = Ho((n.y - i.y) * (t.x - n.x) - (n.x - i.x) * (t.y - n.y)), a = Ho((n.y - i.y) * (e.x - n.x) - (n.x - i.x) * (e.y - n.y));
      return r !== o && s !== a || (!(0 !== r || !(i.x <= Math.max(t.x, e.x) && i.x >= Math.min(t.x, e.x) && i.y <= Math.max(t.y, e.y) && i.y >= Math.min(t.y, e.y))) || (!(0 !== o || !(n.x <= Math.max(t.x, e.x) && n.x >= Math.min(t.x, e.x) && n.y <= Math.max(t.y, e.y) && n.y >= Math.min(t.y, e.y))) || (!(0 !== s || !(t.x <= Math.max(i.x, n.x) && t.x >= Math.min(i.x, n.x) && t.y <= Math.max(i.y, n.y) && t.y >= Math.min(i.y, n.y))) || !(0 !== a || !(e.x <= Math.max(i.x, n.x) && e.x >= Math.min(i.x, n.x) && e.y <= Math.max(i.y, n.y) && e.y >= Math.min(i.y, n.y))))));
    }
    function Ho(t) {
      return t > 0 ? 1 : t < 0 ? -1 : 0;
    }
    function Wo(t, e) {
      return (t.y - t.prev.y) * (t.next.x - t.x) - (t.x - t.prev.x) * (t.next.y - t.y) < 0 ? (e.y - t.y) * (t.next.x - e.x) - (e.x - t.x) * (t.next.y - e.y) >= 0 && (t.prev.y - t.y) * (e.x - t.prev.x) - (t.prev.x - t.x) * (e.y - t.prev.y) >= 0 : (e.y - t.y) * (t.prev.x - e.x) - (e.x - t.x) * (t.prev.y - e.y) < 0 || (t.next.y - t.y) * (e.x - t.next.x) - (t.next.x - t.x) * (e.y - t.next.y) < 0;
    }
    function Jo(t, e) {
      const i = new qo(t.i, t.x, t.y), n = new qo(e.i, e.x, e.y), r = t.next, o = e.prev;
      return t.next = e, e.prev = t, i.next = r, r.prev = i, n.next = i, i.prev = n, o.next = n, n.prev = o, n;
    }
    function jo(t, e, i, n) {
      const r = new qo(t, e, i);
      return n ? (r.next = n.next, r.prev = n, n.next.prev = r, n.next = r) : (r.prev = r, r.next = r), r;
    }
    function Xo(t) {
      t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ);
    }
    function qo(t, e, i) {
      this.i = t, this.x = e, this.y = i, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = false;
    }
    class ShapeUtils {
      static area(t) {
        const e = t.length;
        let i = 0;
        for (let n = e - 1, r = 0; r < e; n = r++) i += t[n].x * t[r].y - t[r].x * t[n].y;
        return 0.5 * i;
      }
      static isClockWise(t) {
        return ShapeUtils.area(t) < 0;
      }
      static triangulateShape(t, e) {
        const i = [], n = [], r = [];
        Yo(t), Zo(i, t);
        let o = t.length;
        e.forEach(Yo);
        for (let t = 0; t < e.length; t++) n.push(o), o += e[t].length, Zo(i, e[t]);
        const s = Mo(i, n);
        for (let t = 0; t < s.length; t += 3) r.push(s.slice(t, t + 3));
        return r;
      }
    }
    function Yo(t) {
      const e = t.length;
      e > 2 && t[e - 1].equals(t[0]) && t.pop();
    }
    function Zo(t, e) {
      for (let i = 0; i < e.length; i++) t.push(e[i].x), t.push(e[i].y);
    }
    class ExtrudeGeometry extends BufferGeometry {
      constructor(t, e) {
        super(), this.type = "ExtrudeGeometry", this.parameters = {shapes: t, options: e}, t = Array.isArray(t) ? t : [t];
        const i = this, n = [], r = [];
        for (let e = 0, i = t.length; e < i; e++) {
          o(t[e]);
        }
        function o(t) {
          const o = [], s = void 0 !== e.curveSegments ? e.curveSegments : 12, a = void 0 !== e.steps ? e.steps : 1;
          let l = void 0 !== e.depth ? e.depth : 100, c = void 0 === e.bevelEnabled || e.bevelEnabled, h = void 0 !== e.bevelThickness ? e.bevelThickness : 6, u = void 0 !== e.bevelSize ? e.bevelSize : h - 2, p = void 0 !== e.bevelOffset ? e.bevelOffset : 0, m = void 0 !== e.bevelSegments ? e.bevelSegments : 3;
          const d = e.extrudePath, _ = void 0 !== e.UVGenerator ? e.UVGenerator : Ko;
          void 0 !== e.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), l = e.amount);
          let y, g, x, v, b, w = false;
          d && (y = d.getSpacedPoints(a), w = true, c = false, g = d.computeFrenetFrames(a, false), x = new three_module_Vector3, v = new three_module_Vector3, b = new three_module_Vector3), c || (m = 0, h = 0, u = 0, p = 0);
          const S = t.extractPoints(s);
          let M = S.shape;
          const A = S.holes;
          if (!ShapeUtils.isClockWise(M)) {
            M = M.reverse();
            for (let t = 0, e = A.length; t < e; t++) {
              const e = A[t];
              ShapeUtils.isClockWise(e) && (A[t] = e.reverse());
            }
          }
          const C = ShapeUtils.triangulateShape(M, A), T = M;
          for (let t = 0, e = A.length; t < e; t++) {
            const e = A[t];
            M = M.concat(e);
          }
          const L = M.length, D = C.length;
          function R(t, e, i) {
            let n, r, o;
            const s = t.x - e.x, a = t.y - e.y, l = i.x - t.x, c = i.y - t.y, h = s * s + a * a, u = s * c - a * l;
            if (Math.abs(u) > Number.EPSILON) {
              const u = Math.sqrt(h), p = Math.sqrt(l * l + c * c), m = e.x - a / u, d = e.y + s / u, _ = ((i.x - c / p - m) * c - (i.y + l / p - d) * l) / (s * c - a * l);
              n = m + s * _ - t.x, r = d + a * _ - t.y;
              const y = n * n + r * r;
              if (y <= 2) return new Vector2(n, r);
              o = Math.sqrt(y / 2);
            } else {
              let t = false;
              s > Number.EPSILON ? l > Number.EPSILON && (t = true) : s < -Number.EPSILON ? l < -Number.EPSILON && (t = true) : Math.sign(a) === Math.sign(c) && (t = true), t ? (n = -a, r = s, o = Math.sqrt(h)) : (n = s, r = a, o = Math.sqrt(h / 2));
            }
            return new Vector2(n / o, r / o);
          }
          const B = [];
          for (let t = 0, e = T.length, i = e - 1, n = t + 1; t < e; t++, i++, n++) i === e && (i = 0), n === e && (n = 0), B[t] = R(T[t], T[i], T[n]);
          const P = [];
          let I, V = B.concat();
          for (let t = 0, e = A.length; t < e; t++) {
            const e = A[t];
            I = [];
            for (let t = 0, i = e.length, n = i - 1, r = t + 1; t < i; t++, n++, r++) n === i && (n = 0), r === i && (r = 0), I[t] = R(e[t], e[n], e[r]);
            P.push(I), V = V.concat(I);
          }
          for (let t = 0; t < m; t++) {
            const e = t / m, i = h * Math.cos(e * Math.PI / 2), n = u * Math.sin(e * Math.PI / 2) + p;
            for (let t = 0, e = T.length; t < e; t++) {
              const e = (B[t] || console.error("THREE.ExtrudeGeometry: vec does not exist"), B[t].clone().multiplyScalar(n).add(T[t]));
              N(e.x, e.y, -i);
            }
            for (let t = 0, e = A.length; t < e; t++) {
              const e = A[t];
              I = P[t];
              for (let t = 0, r = e.length; t < r; t++) {
                const r = (I[t] || console.error("THREE.ExtrudeGeometry: vec does not exist"), I[t].clone().multiplyScalar(n).add(e[t]));
                N(r.x, r.y, -i);
              }
            }
          }
          const F = u + p;
          for (let t = 0; t < L; t++) {
            const e = c ? (V[t] || console.error("THREE.ExtrudeGeometry: vec does not exist"), V[t].clone().multiplyScalar(F).add(M[t])) : M[t];
            w ? (v.copy(g.normals[0]).multiplyScalar(e.x), x.copy(g.binormals[0]).multiplyScalar(e.y), b.copy(y[0]).add(v).add(x), N(b.x, b.y, b.z)) : N(e.x, e.y, 0);
          }
          for (let t = 1; t <= a; t++) for (let e = 0; e < L; e++) {
            const i = c ? (V[e] || console.error("THREE.ExtrudeGeometry: vec does not exist"), V[e].clone().multiplyScalar(F).add(M[e])) : M[e];
            w ? (v.copy(g.normals[t]).multiplyScalar(i.x), x.copy(g.binormals[t]).multiplyScalar(i.y), b.copy(y[t]).add(v).add(x), N(b.x, b.y, b.z)) : N(i.x, i.y, l / a * t);
          }
          for (let t = m - 1; t >= 0; t--) {
            const e = t / m, i = h * Math.cos(e * Math.PI / 2), n = u * Math.sin(e * Math.PI / 2) + p;
            for (let t = 0, e = T.length; t < e; t++) {
              const e = (B[t] || console.error("THREE.ExtrudeGeometry: vec does not exist"), B[t].clone().multiplyScalar(n).add(T[t]));
              N(e.x, e.y, l + i);
            }
            for (let t = 0, e = A.length; t < e; t++) {
              const e = A[t];
              I = P[t];
              for (let t = 0, r = e.length; t < r; t++) {
                const r = (I[t] || console.error("THREE.ExtrudeGeometry: vec does not exist"), I[t].clone().multiplyScalar(n).add(e[t]));
                w ? N(r.x, r.y + y[a - 1].y, y[a - 1].x + i) : N(r.x, r.y, l + i);
              }
            }
          }
          function k(t, e) {
            let i = t.length;
            for (; --i >= 0;) {
              const n = i;
              let r = i - 1;
              r < 0 && (r = t.length - 1);
              for (let t = 0, i = a + 2 * m; t < i; t++) {
                const i = L * t, o = L * (t + 1);
                U(e + n + i, e + r + i, e + r + o, e + n + o);
              }
            }
          }
          function N(t, e, i) {
            o.push(t), o.push(e), o.push(i);
          }
          function G(t, e, r) {
            z(t), z(e), z(r);
            const o = n.length / 3, s = _.generateTopUV(i, n, o - 3, o - 2, o - 1);
            O(s[0]), O(s[1]), O(s[2]);
          }
          function U(t, e, r, o) {
            z(t), z(e), z(o), z(e), z(r), z(o);
            const s = n.length / 3, a = _.generateSideWallUV(i, n, s - 6, s - 3, s - 2, s - 1);
            O(a[0]), O(a[1]), O(a[3]), O(a[1]), O(a[2]), O(a[3]);
          }
          function z(t) {
            n.push(o[3 * t + 0]), n.push(o[3 * t + 1]), n.push(o[3 * t + 2]);
          }
          function O(t) {
            r.push(t.x), r.push(t.y);
          }
          !function () {
            const t = n.length / 3;
            if (c) {
              let t = 0, e = L * t;
              for (let t = 0; t < D; t++) {
                const i = C[t];
                G(i[2] + e, i[1] + e, i[0] + e);
              }
              t = a + 2 * m, e = L * t;
              for (let t = 0; t < D; t++) {
                const i = C[t];
                G(i[0] + e, i[1] + e, i[2] + e);
              }
            } else {
              for (let t = 0; t < D; t++) {
                const e = C[t];
                G(e[2], e[1], e[0]);
              }
              for (let t = 0; t < D; t++) {
                const e = C[t];
                G(e[0] + L * a, e[1] + L * a, e[2] + L * a);
              }
            }
            i.addGroup(t, n.length / 3 - t, 0);
          }(), function () {
            const t = n.length / 3;
            let e = 0;
            k(T, e), e += T.length;
            for (let t = 0, i = A.length; t < i; t++) {
              const i = A[t];
              k(i, e), e += i.length;
            }
            i.addGroup(t, n.length / 3 - t, 1);
          }();
        }
        this.setAttribute("position", new Float32BufferAttribute(n, 3)), this.setAttribute("uv", new Float32BufferAttribute(r, 2)), this.computeVertexNormals();
      }
      toJSON() {
        const t = super.toJSON();
        return function (t, e, i) {
          if (i.shapes = [], Array.isArray(t)) for (let e = 0, n = t.length; e < n; e++) {
            const n = t[e];
            i.shapes.push(n.uuid);
          } else i.shapes.push(t.uuid);
          void 0 !== e.extrudePath && (i.options.extrudePath = e.extrudePath.toJSON());
          return i;
        }(this.parameters.shapes, this.parameters.options, t);
      }
      static fromJSON(t, e) {
        const i = [];
        for (let n = 0, r = t.shapes.length; n < r; n++) {
          const r = e[t.shapes[n]];
          i.push(r);
        }
        const n = t.options.extrudePath;
        return void 0 !== n && (t.options.extrudePath = (new So[n.type]).fromJSON(n)), new ExtrudeGeometry(i, t.options);
      }
    }
    const Ko = {generateTopUV: function (t, e, i, n, r) {
      const o = e[3 * i], s = e[3 * i + 1], a = e[3 * n], l = e[3 * n + 1], c = e[3 * r], h = e[3 * r + 1];
      return [new Vector2(o, s), new Vector2(a, l), new Vector2(c, h)];
    }, generateSideWallUV: function (t, e, i, n, r, o) {
      const s = e[3 * i], a = e[3 * i + 1], l = e[3 * i + 2], c = e[3 * n], h = e[3 * n + 1], u = e[3 * n + 2], p = e[3 * r], m = e[3 * r + 1], d = e[3 * r + 2], _ = e[3 * o], y = e[3 * o + 1], g = e[3 * o + 2];
      return Math.abs(a - h) < Math.abs(s - c) ? [new Vector2(s, 1 - l), new Vector2(c, 1 - u), new Vector2(p, 1 - d), new Vector2(_, 1 - g)] : [new Vector2(a, 1 - l), new Vector2(h, 1 - u), new Vector2(m, 1 - d), new Vector2(y, 1 - g)];
    }};
    class ShapeGeometry extends BufferGeometry {
      constructor(t, e = 12) {
        super(), this.type = "ShapeGeometry", this.parameters = {shapes: t, curveSegments: e};
        const i = [], n = [], r = [], o = [];
        let s = 0, a = 0;
        if (false === Array.isArray(t)) l(t); else for (let e = 0; e < t.length; e++) l(t[e]), this.addGroup(s, a, e), s += a, a = 0;
        function l(t) {
          const s = n.length / 3, l = t.extractPoints(e);
          let c = l.shape;
          const h = l.holes;
          false === ShapeUtils.isClockWise(c) && (c = c.reverse());
          for (let t = 0, e = h.length; t < e; t++) {
            const e = h[t];
            true === ShapeUtils.isClockWise(e) && (h[t] = e.reverse());
          }
          const u = ShapeUtils.triangulateShape(c, h);
          for (let t = 0, e = h.length; t < e; t++) {
            const e = h[t];
            c = c.concat(e);
          }
          for (let t = 0, e = c.length; t < e; t++) {
            const e = c[t];
            n.push(e.x, e.y, 0), r.push(0, 0, 1), o.push(e.x, e.y);
          }
          for (let t = 0, e = u.length; t < e; t++) {
            const e = u[t], n = e[0] + s, r = e[1] + s, o = e[2] + s;
            i.push(n, r, o), a += 3;
          }
        }
        this.setIndex(i), this.setAttribute("position", new Float32BufferAttribute(n, 3)), this.setAttribute("normal", new Float32BufferAttribute(r, 3)), this.setAttribute("uv", new Float32BufferAttribute(o, 2));
      }
      toJSON() {
        const t = super.toJSON();
        return function (t, e) {
          if (e.shapes = [], Array.isArray(t)) for (let i = 0, n = t.length; i < n; i++) {
            const n = t[i];
            e.shapes.push(n.uuid);
          } else e.shapes.push(t.uuid);
          return e;
        }(this.parameters.shapes, t);
      }
      static fromJSON(t, e) {
        const i = [];
        for (let n = 0, r = t.shapes.length; n < r; n++) {
          const r = e[t.shapes[n]];
          i.push(r);
        }
        return new ShapeGeometry(i, t.curveSegments);
      }
    }
    class ShadowMaterial extends Material {
      constructor(t) {
        super(), this.type = "ShadowMaterial", this.color = new three_module_Color(0), this.transparent = true, this.setValues(t);
      }
      copy(t) {
        return super.copy(t), this.color.copy(t.color), this;
      }
    }
    ShadowMaterial.prototype.isShadowMaterial = true;
    class MeshStandardMaterial extends Material {
      constructor(t) {
        super(), this.defines = {STANDARD: ""}, this.type = "MeshStandardMaterial", this.color = new three_module_Color(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new three_module_Color(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new Vector2(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = false, this.setValues(t);
      }
      copy(t) {
        return super.copy(t), this.defines = {STANDARD: ""}, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapIntensity = t.envMapIntensity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.flatShading = t.flatShading, this;
      }
    }
    MeshStandardMaterial.prototype.isMeshStandardMaterial = true;
    var $o = "__private_" + i++ + "_" + "clearcoat", Qo = "__private_" + i++ + "_" + "transmission";
    class MeshPhysicalMaterial extends MeshStandardMaterial {
      constructor(t) {
        super(), Object.defineProperty(this, $o, {writable: true, value: 0}), Object.defineProperty(this, Qo, {writable: true, value: 0}), this.defines = {STANDARD: "", PHYSICAL: ""}, this.type = "MeshPhysicalMaterial", this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new Vector2(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {get: function () {
          return Math.max(0, Math.min(1, 2.5 * (this.ior - 1) / (this.ior + 1)));
        }, set: function (t) {
          this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
        }}), this.sheenTint = new three_module_Color(0), this.transmission = 0, this.transmissionMap = null, this.thickness = 0.01, this.thicknessMap = null, this.attenuationDistance = 0, this.attenuationTint = new three_module_Color(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularTint = new three_module_Color(1, 1, 1), this.specularTintMap = null, this.setValues(t);
      }
      get clearcoat() {
        return e(this, $o)[$o];
      }
      set clearcoat (t) {
        e(this, $o)[$o] > 0 != t > 0 && this.version++, e(this, $o)[$o] = t;
      }
      get transmission() {
        return e(this, Qo)[Qo];
      }
      set transmission (t) {
        e(this, Qo)[Qo] > 0 != t > 0 && this.version++, e(this, Qo)[Qo] = t;
      }
      copy(t) {
        return super.copy(t), this.defines = {STANDARD: "", PHYSICAL: ""}, this.clearcoat = t.clearcoat, this.clearcoatMap = t.clearcoatMap, this.clearcoatRoughness = t.clearcoatRoughness, this.clearcoatRoughnessMap = t.clearcoatRoughnessMap, this.clearcoatNormalMap = t.clearcoatNormalMap, this.clearcoatNormalScale.copy(t.clearcoatNormalScale), this.ior = t.ior, this.sheenTint.copy(t.sheenTint), this.transmission = t.transmission, this.transmissionMap = t.transmissionMap, this.thickness = t.thickness, this.thicknessMap = t.thicknessMap, this.attenuationDistance = t.attenuationDistance, this.attenuationTint.copy(t.attenuationTint), this.specularIntensity = t.specularIntensity, this.specularIntensityMap = t.specularIntensityMap, this.specularTint.copy(t.specularTint), this.specularTintMap = t.specularTintMap, this;
      }
    }
    MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;
    class MeshPhongMaterial extends Material {
      constructor(t) {
        super(), this.type = "MeshPhongMaterial", this.color = new three_module_Color(16777215), this.specular = new three_module_Color(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new three_module_Color(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new Vector2(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = false, this.setValues(t);
      }
      copy(t) {
        return super.copy(t), this.color.copy(t.color), this.specular.copy(t.specular), this.shininess = t.shininess, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.flatShading = t.flatShading, this;
      }
    }
    MeshPhongMaterial.prototype.isMeshPhongMaterial = true;
    class MeshToonMaterial extends Material {
      constructor(t) {
        super(), this.defines = {TOON: ""}, this.type = "MeshToonMaterial", this.color = new three_module_Color(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new three_module_Color(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new Vector2(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(t);
      }
      copy(t) {
        return super.copy(t), this.color.copy(t.color), this.map = t.map, this.gradientMap = t.gradientMap, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this;
      }
    }
    MeshToonMaterial.prototype.isMeshToonMaterial = true;
    class MeshNormalMaterial extends Material {
      constructor(t) {
        super(), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new Vector2(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = false, this.wireframeLinewidth = 1, this.fog = false, this.flatShading = false, this.setValues(t);
      }
      copy(t) {
        return super.copy(t), this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.flatShading = t.flatShading, this;
      }
    }
    MeshNormalMaterial.prototype.isMeshNormalMaterial = true;
    class MeshLambertMaterial extends Material {
      constructor(t) {
        super(), this.type = "MeshLambertMaterial", this.color = new three_module_Color(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new three_module_Color(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(t);
      }
      copy(t) {
        return super.copy(t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this;
      }
    }
    MeshLambertMaterial.prototype.isMeshLambertMaterial = true;
    class MeshMatcapMaterial extends Material {
      constructor(t) {
        super(), this.defines = {MATCAP: ""}, this.type = "MeshMatcapMaterial", this.color = new three_module_Color(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new Vector2(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = false, this.setValues(t);
      }
      copy(t) {
        return super.copy(t), this.defines = {MATCAP: ""}, this.color.copy(t.color), this.matcap = t.matcap, this.map = t.map, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.flatShading = t.flatShading, this;
      }
    }
    MeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;
    class LineDashedMaterial extends LineBasicMaterial {
      constructor(t) {
        super(), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(t);
      }
      copy(t) {
        return super.copy(t), this.scale = t.scale, this.dashSize = t.dashSize, this.gapSize = t.gapSize, this;
      }
    }
    LineDashedMaterial.prototype.isLineDashedMaterial = true;
    const ts = {arraySlice: function (t, e, i) {
      return ts.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== i ? i : t.length)) : t.slice(e, i);
    }, convertArray: function (t, e, i) {
      return !t || !i && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t);
    }, isTypedArray: function (t) {
      return ArrayBuffer.isView(t) && !(t instanceof DataView);
    }, getKeyframeOrder: function (t) {
      const e = t.length, i = new Array(e);
      for (let t = 0; t !== e; ++t) i[t] = t;
      return i.sort(function (e, i) {
        return t[e] - t[i];
      }), i;
    }, sortedArray: function (t, e, i) {
      const n = t.length, r = new t.constructor(n);
      for (let o = 0, s = 0; s !== n; ++o) {
        const n = i[o] * e;
        for (let i = 0; i !== e; ++i) r[s++] = t[n + i];
      }
      return r;
    }, flattenJSON: function (t, e, i, n) {
      let r = 1, o = t[0];
      for (; void 0 !== o && void 0 === o[n];) o = t[r++];
      if (void 0 === o) return;
      let s = o[n];
      if (void 0 !== s) if (Array.isArray(s)) do {
        s = o[n], void 0 !== s && (e.push(o.time), i.push.apply(i, s)), o = t[r++];
      } while (void 0 !== o); else if (void 0 !== s.toArray) do {
        s = o[n], void 0 !== s && (e.push(o.time), s.toArray(i, i.length)), o = t[r++];
      } while (void 0 !== o); else do {
        s = o[n], void 0 !== s && (e.push(o.time), i.push(s)), o = t[r++];
      } while (void 0 !== o);
    }, subclip: function (t, e, i, n, r = 30) {
      const o = t.clone();
      o.name = e;
      const s = [];
      for (let t = 0; t < o.tracks.length; ++t) {
        const e = o.tracks[t], a = e.getValueSize(), l = [], c = [];
        for (let t = 0; t < e.times.length; ++t) {
          const o = e.times[t] * r;
          if (!(o < i || o >= n)) {
            l.push(e.times[t]);
            for (let i = 0; i < a; ++i) c.push(e.values[t * a + i]);
          }
        }
        0 !== l.length && (e.times = ts.convertArray(l, e.times.constructor), e.values = ts.convertArray(c, e.values.constructor), s.push(e));
      }
      o.tracks = s;
      let a = Infinity;
      for (let t = 0; t < o.tracks.length; ++t) a > o.tracks[t].times[0] && (a = o.tracks[t].times[0]);
      for (let t = 0; t < o.tracks.length; ++t) o.tracks[t].shift(-1 * a);
      return o.resetDuration(), o;
    }, makeClipAdditive: function (t, e = 0, i = t, n = 30) {
      n <= 0 && (n = 30);
      const r = i.tracks.length, o = e / n;
      for (let e = 0; e < r; ++e) {
        const n = i.tracks[e], r = n.ValueTypeName;
        if ("bool" === r || "string" === r) continue;
        const s = t.tracks.find(function (t) {
          return t.name === n.name && t.ValueTypeName === r;
        });
        if (void 0 === s) continue;
        let a = 0;
        const l = n.getValueSize();
        n.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (a = l / 3);
        let c = 0;
        const h = s.getValueSize();
        s.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (c = h / 3);
        const u = n.times.length - 1;
        let p;
        if (o <= n.times[0]) {
          const t = a, e = l - a;
          p = ts.arraySlice(n.values, t, e);
        } else if (o >= n.times[u]) {
          const t = u * l + a, e = t + l - a;
          p = ts.arraySlice(n.values, t, e);
        } else {
          const t = n.createInterpolant(), e = a, i = l - a;
          t.evaluate(o), p = ts.arraySlice(t.resultBuffer, e, i);
        }
        if ("quaternion" === r) {
          (new Quaternion).fromArray(p).normalize().conjugate().toArray(p);
        }
        const m = s.times.length;
        for (let t = 0; t < m; ++t) {
          const e = t * h + c;
          if ("quaternion" === r) Quaternion.multiplyQuaternionsFlat(s.values, e, p, 0, s.values, e); else {
            const t = h - 2 * c;
            for (let i = 0; i < t; ++i) s.values[e + i] -= p[i];
          }
        }
      }
      return t.blendMode = 2501, t;
    }};
    class Interpolant {
      constructor(t, e, i, n) {
        this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = void 0 !== n ? n : new e.constructor(i), this.sampleValues = e, this.valueSize = i, this.settings = null, this.DefaultSettings_ = {};
      }
      evaluate(t) {
        const e = this.parameterPositions;
        let i = this._cachedIndex, n = e[i], r = e[i - 1];
        t: {
          e: {
            let o;
            i: {
              n: if (!(t < n)) {
                for (let o = i + 2;;) {
                  if (void 0 === n) {
                    if (t < r) break n;
                    return i = e.length, this._cachedIndex = i, this.afterEnd_(i - 1, t, r);
                  }
                  if (i === o) break;
                  if (r = n, n = e[++i], t < n) break e;
                }
                o = e.length;
                break i;
              }
              if (t >= r) break t;
              {
                const s = e[1];
                t < s && (i = 2, r = s);
                for (let o = i - 2;;) {
                  if (void 0 === r) return this._cachedIndex = 0, this.beforeStart_(0, t, n);
                  if (i === o) break;
                  if (n = r, r = e[--i - 1], t >= r) break e;
                }
                o = i, i = 0;
              }
            }
            for (; i < o;) {
              const n = i + o >>> 1;
              t < e[n] ? o = n : i = n + 1;
            }
            if (n = e[i], r = e[i - 1], void 0 === r) return this._cachedIndex = 0, this.beforeStart_(0, t, n);
            if (void 0 === n) return i = e.length, this._cachedIndex = i, this.afterEnd_(i - 1, r, t);
          }
          this._cachedIndex = i, this.intervalChanged_(i, r, n);
        }
        return this.interpolate_(i, r, t, n);
      }
      getSettings_() {
        return this.settings || this.DefaultSettings_;
      }
      copySampleValue_(t) {
        const e = this.resultBuffer, i = this.sampleValues, n = this.valueSize, r = t * n;
        for (let t = 0; t !== n; ++t) e[t] = i[r + t];
        return e;
      }
      interpolate_() {
        throw new Error("call to abstract method");
      }
      intervalChanged_() {}
    }
    Interpolant.prototype.beforeStart_ = Interpolant.prototype.copySampleValue_, Interpolant.prototype.afterEnd_ = Interpolant.prototype.copySampleValue_;
    class CubicInterpolant extends Interpolant {
      constructor(t, e, i, n) {
        super(t, e, i, n), this._weightPrev = 0, this._offsetPrev = 0, this._weightNext = 0, this._offsetNext = 0, this.DefaultSettings_ = {endingStart: I, endingEnd: I};
      }
      intervalChanged_(t, e, i) {
        const n = this.parameterPositions;
        let r = t - 2, o = t + 1, s = n[r], a = n[o];
        if (void 0 === s) switch (this.getSettings_().endingStart) {
          case V:
            r = t, s = 2 * e - i;
            break;
          case F:
            r = n.length - 2, s = e + n[r] - n[r + 1];
            break;
          default:
            r = t, s = i;
        }
        if (void 0 === a) switch (this.getSettings_().endingEnd) {
          case V:
            o = t, a = 2 * i - e;
            break;
          case F:
            o = 1, a = i + n[1] - n[0];
            break;
          default:
            o = t - 1, a = e;
        }
        const l = 0.5 * (i - e), c = this.valueSize;
        this._weightPrev = l / (e - s), this._weightNext = l / (a - i), this._offsetPrev = r * c, this._offsetNext = o * c;
      }
      interpolate_(t, e, i, n) {
        const r = this.resultBuffer, o = this.sampleValues, s = this.valueSize, a = t * s, l = a - s, c = this._offsetPrev, h = this._offsetNext, u = this._weightPrev, p = this._weightNext, m = (i - e) / (n - e), d = m * m, _ = d * m, y = -u * _ + 2 * u * d - u * m, g = (1 + u) * _ + (-1.5 - 2 * u) * d + (-0.5 + u) * m + 1, x = (-1 - p) * _ + (1.5 + p) * d + 0.5 * m, v = p * _ - p * d;
        for (let t = 0; t !== s; ++t) r[t] = y * o[c + t] + g * o[l + t] + x * o[a + t] + v * o[h + t];
        return r;
      }
    }
    class LinearInterpolant extends Interpolant {
      constructor(t, e, i, n) {
        super(t, e, i, n);
      }
      interpolate_(t, e, i, n) {
        const r = this.resultBuffer, o = this.sampleValues, s = this.valueSize, a = t * s, l = a - s, c = (i - e) / (n - e), h = 1 - c;
        for (let t = 0; t !== s; ++t) r[t] = o[l + t] * h + o[a + t] * c;
        return r;
      }
    }
    class DiscreteInterpolant extends Interpolant {
      constructor(t, e, i, n) {
        super(t, e, i, n);
      }
      interpolate_(t) {
        return this.copySampleValue_(t - 1);
      }
    }
    class KeyframeTrack {
      constructor(t, e, i, n) {
        if (void 0 === t) throw new Error("THREE.KeyframeTrack: track name is undefined");
        if (void 0 === e || 0 === e.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
        this.name = t, this.times = ts.convertArray(e, this.TimeBufferType), this.values = ts.convertArray(i, this.ValueBufferType), this.setInterpolation(n || this.DefaultInterpolation);
      }
      static toJSON(t) {
        const e = t.constructor;
        let i;
        if (e.toJSON !== this.toJSON) i = e.toJSON(t); else {
          i = {name: t.name, times: ts.convertArray(t.times, Array), values: ts.convertArray(t.values, Array)};
          const e = t.getInterpolation();
          e !== t.DefaultInterpolation && (i.interpolation = e);
        }
        return i.type = t.ValueTypeName, i;
      }
      InterpolantFactoryMethodDiscrete(t) {
        return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), t);
      }
      InterpolantFactoryMethodLinear(t) {
        return new LinearInterpolant(this.times, this.values, this.getValueSize(), t);
      }
      InterpolantFactoryMethodSmooth(t) {
        return new CubicInterpolant(this.times, this.values, this.getValueSize(), t);
      }
      setInterpolation(t) {
        let e;
        switch (t) {
          case R:
            e = this.InterpolantFactoryMethodDiscrete;
            break;
          case B:
            e = this.InterpolantFactoryMethodLinear;
            break;
          case P:
            e = this.InterpolantFactoryMethodSmooth;
        }
        if (void 0 === e) {
          const e = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
          if (void 0 === this.createInterpolant) {
            if (t === this.DefaultInterpolation) throw new Error(e);
            this.setInterpolation(this.DefaultInterpolation);
          }
          return console.warn("THREE.KeyframeTrack:", e), this;
        }
        return this.createInterpolant = e, this;
      }
      getInterpolation() {
        switch (this.createInterpolant) {
          case this.InterpolantFactoryMethodDiscrete:
            return R;
          case this.InterpolantFactoryMethodLinear:
            return B;
          case this.InterpolantFactoryMethodSmooth:
            return P;
        }
      }
      getValueSize() {
        return this.values.length / this.times.length;
      }
      shift(t) {
        if (0 !== t) {
          const e = this.times;
          for (let i = 0, n = e.length; i !== n; ++i) e[i] += t;
        }
        return this;
      }
      scale(t) {
        if (1 !== t) {
          const e = this.times;
          for (let i = 0, n = e.length; i !== n; ++i) e[i] *= t;
        }
        return this;
      }
      trim(t, e) {
        const i = this.times, n = i.length;
        let r = 0, o = n - 1;
        for (; r !== n && i[r] < t;) ++r;
        for (; -1 !== o && i[o] > e;) --o;
        if (++o, 0 !== r || o !== n) {
          r >= o && (o = Math.max(o, 1), r = o - 1);
          const t = this.getValueSize();
          this.times = ts.arraySlice(i, r, o), this.values = ts.arraySlice(this.values, r * t, o * t);
        }
        return this;
      }
      validate() {
        let t = true;
        const e = this.getValueSize();
        e - Math.floor(e) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t = false);
        const i = this.times, n = this.values, r = i.length;
        0 === r && (console.error("THREE.KeyframeTrack: Track is empty.", this), t = false);
        let o = null;
        for (let e = 0; e !== r; e++) {
          const n = i[e];
          if ("number" == typeof n && isNaN(n)) {
            console.error("THREE.KeyframeTrack: Time is not a valid number.", this, e, n), t = false;
            break;
          }
          if (null !== o && o > n) {
            console.error("THREE.KeyframeTrack: Out of order keys.", this, e, n, o), t = false;
            break;
          }
          o = n;
        }
        if (void 0 !== n && ts.isTypedArray(n)) for (let e = 0, i = n.length; e !== i; ++e) {
          const i = n[e];
          if (isNaN(i)) {
            console.error("THREE.KeyframeTrack: Value is not a valid number.", this, e, i), t = false;
            break;
          }
        }
        return t;
      }
      optimize() {
        const t = ts.arraySlice(this.times), e = ts.arraySlice(this.values), i = this.getValueSize(), n = this.getInterpolation() === P, r = t.length - 1;
        let o = 1;
        for (let s = 1; s < r; ++s) {
          let r = false;
          const a = t[s];
          if (a !== t[s + 1] && (1 !== s || a !== t[0])) if (n) r = true; else {
            const t = s * i, n = t - i, o = t + i;
            for (let s = 0; s !== i; ++s) {
              const i = e[t + s];
              if (i !== e[n + s] || i !== e[o + s]) {
                r = true;
                break;
              }
            }
          }
          if (r) {
            if (s !== o) {
              t[o] = t[s];
              const n = s * i, r = o * i;
              for (let t = 0; t !== i; ++t) e[r + t] = e[n + t];
            }
            ++o;
          }
        }
        if (r > 0) {
          t[o] = t[r];
          for (let t = r * i, n = o * i, s = 0; s !== i; ++s) e[n + s] = e[t + s];
          ++o;
        }
        return o !== t.length ? (this.times = ts.arraySlice(t, 0, o), this.values = ts.arraySlice(e, 0, o * i)) : (this.times = t, this.values = e), this;
      }
      clone() {
        const t = ts.arraySlice(this.times, 0), e = ts.arraySlice(this.values, 0), i = new (0, this.constructor)(this.name, t, e);
        return i.createInterpolant = this.createInterpolant, i;
      }
    }
    KeyframeTrack.prototype.TimeBufferType = Float32Array, KeyframeTrack.prototype.ValueBufferType = Float32Array, KeyframeTrack.prototype.DefaultInterpolation = B;
    class BooleanKeyframeTrack extends KeyframeTrack {}
    BooleanKeyframeTrack.prototype.ValueTypeName = "bool", BooleanKeyframeTrack.prototype.ValueBufferType = Array, BooleanKeyframeTrack.prototype.DefaultInterpolation = R, BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0, BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
    class ColorKeyframeTrack extends KeyframeTrack {}
    ColorKeyframeTrack.prototype.ValueTypeName = "color";
    class NumberKeyframeTrack extends KeyframeTrack {}
    NumberKeyframeTrack.prototype.ValueTypeName = "number";
    class QuaternionLinearInterpolant extends Interpolant {
      constructor(t, e, i, n) {
        super(t, e, i, n);
      }
      interpolate_(t, e, i, n) {
        const r = this.resultBuffer, o = this.sampleValues, s = this.valueSize, a = (i - e) / (n - e);
        let l = t * s;
        for (let t = l + s; l !== t; l += 4) Quaternion.slerpFlat(r, 0, o, l - s, o, l, a);
        return r;
      }
    }
    class QuaternionKeyframeTrack extends KeyframeTrack {
      InterpolantFactoryMethodLinear(t) {
        return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), t);
      }
    }
    QuaternionKeyframeTrack.prototype.ValueTypeName = "quaternion", QuaternionKeyframeTrack.prototype.DefaultInterpolation = B, QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
    class StringKeyframeTrack extends KeyframeTrack {}
    StringKeyframeTrack.prototype.ValueTypeName = "string", StringKeyframeTrack.prototype.ValueBufferType = Array, StringKeyframeTrack.prototype.DefaultInterpolation = R, StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0, StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
    class VectorKeyframeTrack extends KeyframeTrack {}
    VectorKeyframeTrack.prototype.ValueTypeName = "vector";
    class AnimationClip {
      constructor(t, e = -1, i, n = 2500) {
        this.name = t, this.tracks = i, this.duration = e, this.blendMode = n, this.uuid = Z(), this.duration < 0 && this.resetDuration();
      }
      static parse(t) {
        const e = [], i = t.tracks, n = 1 / (t.fps || 1);
        for (let t = 0, r = i.length; t !== r; ++t) e.push(es(i[t]).scale(n));
        const r = new this(t.name, t.duration, e, t.blendMode);
        return r.uuid = t.uuid, r;
      }
      static toJSON(t) {
        const e = [], i = t.tracks, n = {name: t.name, duration: t.duration, tracks: e, uuid: t.uuid, blendMode: t.blendMode};
        for (let t = 0, n = i.length; t !== n; ++t) e.push(KeyframeTrack.toJSON(i[t]));
        return n;
      }
      static CreateFromMorphTargetSequence(t, e, i, n) {
        const r = e.length, o = [];
        for (let t = 0; t < r; t++) {
          let s = [], a = [];
          s.push((t + r - 1) % r, t, (t + 1) % r), a.push(0, 1, 0);
          const l = ts.getKeyframeOrder(s);
          s = ts.sortedArray(s, 1, l), a = ts.sortedArray(a, 1, l), n || 0 !== s[0] || (s.push(r), a.push(a[0])), o.push(new NumberKeyframeTrack(".morphTargetInfluences[" + e[t].name + "]", s, a).scale(1 / i));
        }
        return new this(t, -1, o);
      }
      static findByName(t, e) {
        let i = t;
        if (!Array.isArray(t)) {
          const e = t;
          i = e.geometry && e.geometry.animations || e.animations;
        }
        for (let t = 0; t < i.length; t++) if (i[t].name === e) return i[t];
        return null;
      }
      static CreateClipsFromMorphTargetSequences(t, e, i) {
        const n = {}, r = /^([\w-]*?)([\d]+)$/;
        for (let e = 0, i = t.length; e < i; e++) {
          const i = t[e], o = i.name.match(r);
          if (o && o.length > 1) {
            const t = o[1];
            let e = n[t];
            e || (n[t] = e = []), e.push(i);
          }
        }
        const o = [];
        for (const t in n) o.push(this.CreateFromMorphTargetSequence(t, n[t], e, i));
        return o;
      }
      static parseAnimation(t, e) {
        if (!t) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
        const i = function (t, e, i, n, r) {
          if (0 !== i.length) {
            const o = [], s = [];
            ts.flattenJSON(i, o, s, n), 0 !== o.length && r.push(new t(e, o, s));
          }
        }, n = [], r = t.name || "default", o = t.fps || 30, s = t.blendMode;
        let a = t.length || -1;
        const l = t.hierarchy || [];
        for (let t = 0; t < l.length; t++) {
          const r = l[t].keys;
          if (r && 0 !== r.length) if (r[0].morphTargets) {
            const t = {};
            let e;
            for (e = 0; e < r.length; e++) if (r[e].morphTargets) for (let i = 0; i < r[e].morphTargets.length; i++) t[r[e].morphTargets[i]] = -1;
            for (const i in t) {
              const t = [], o = [];
              for (let n = 0; n !== r[e].morphTargets.length; ++n) {
                const n = r[e];
                t.push(n.time), o.push(n.morphTarget === i ? 1 : 0);
              }
              n.push(new NumberKeyframeTrack(".morphTargetInfluence[" + i + "]", t, o));
            }
            a = t.length * (o || 1);
          } else {
            const o = ".bones[" + e[t].name + "]";
            i(VectorKeyframeTrack, o + ".position", r, "pos", n), i(QuaternionKeyframeTrack, o + ".quaternion", r, "rot", n), i(VectorKeyframeTrack, o + ".scale", r, "scl", n);
          }
        }
        if (0 === n.length) return null;
        return new this(r, a, n, s);
      }
      resetDuration() {
        let t = 0;
        for (let e = 0, i = this.tracks.length; e !== i; ++e) {
          const i = this.tracks[e];
          t = Math.max(t, i.times[i.times.length - 1]);
        }
        return this.duration = t, this;
      }
      trim() {
        for (let t = 0; t < this.tracks.length; t++) this.tracks[t].trim(0, this.duration);
        return this;
      }
      validate() {
        let t = true;
        for (let e = 0; e < this.tracks.length; e++) t = t && this.tracks[e].validate();
        return t;
      }
      optimize() {
        for (let t = 0; t < this.tracks.length; t++) this.tracks[t].optimize();
        return this;
      }
      clone() {
        const t = [];
        for (let e = 0; e < this.tracks.length; e++) t.push(this.tracks[e].clone());
        return new this.constructor(this.name, this.duration, t, this.blendMode);
      }
      toJSON() {
        return this.constructor.toJSON(this);
      }
    }
    function es(t) {
      if (void 0 === t.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
      const e = function (t) {
        switch (t.toLowerCase()) {
          case "scalar":
          case "double":
          case "float":
          case "number":
          case "integer":
            return NumberKeyframeTrack;
          case "vector":
          case "vector2":
          case "vector3":
          case "vector4":
            return VectorKeyframeTrack;
          case "color":
            return ColorKeyframeTrack;
          case "quaternion":
            return QuaternionKeyframeTrack;
          case "bool":
          case "boolean":
            return BooleanKeyframeTrack;
          case "string":
            return StringKeyframeTrack;
        }
        throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t);
      }(t.type);
      if (void 0 === t.times) {
        const e = [], i = [];
        ts.flattenJSON(t.keys, e, i, "value"), t.times = e, t.values = i;
      }
      return void 0 !== e.parse ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation);
    }
    const is = {enabled: false, files: {}, add: function (t, e) {
      false !== this.enabled && (this.files[t] = e);
    }, get: function (t) {
      if (false !== this.enabled) return this.files[t];
    }, remove: function (t) {
      delete this.files[t];
    }, clear: function () {
      this.files = {};
    }};
    class LoadingManager {
      constructor(t, e, i) {
        const n = this;
        let r, o = false, s = 0, a = 0;
        const l = [];
        this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = i, this.itemStart = function (t) {
          a++, false === o && void 0 !== n.onStart && n.onStart(t, s, a), o = true;
        }, this.itemEnd = function (t) {
          s++, void 0 !== n.onProgress && n.onProgress(t, s, a), s === a && (o = false, void 0 !== n.onLoad && n.onLoad());
        }, this.itemError = function (t) {
          void 0 !== n.onError && n.onError(t);
        }, this.resolveURL = function (t) {
          return r ? r(t) : t;
        }, this.setURLModifier = function (t) {
          return r = t, this;
        }, this.addHandler = function (t, e) {
          return l.push(t, e), this;
        }, this.removeHandler = function (t) {
          const e = l.indexOf(t);
          return -1 !== e && l.splice(e, 2), this;
        }, this.getHandler = function (t) {
          for (let e = 0, i = l.length; e < i; e += 2) {
            const i = l[e], n = l[e + 1];
            if (i.global && (i.lastIndex = 0), i.test(t)) return n;
          }
          return null;
        };
      }
    }
    const ns = new LoadingManager;
    class Loader {
      constructor(t) {
        this.manager = void 0 !== t ? t : ns, this.crossOrigin = "anonymous", this.withCredentials = false, this.path = "", this.resourcePath = "", this.requestHeader = {};
      }
      load() {}
      loadAsync(t, e) {
        const i = this;
        return new Promise(function (n, r) {
          i.load(t, n, e, r);
        });
      }
      parse() {}
      setCrossOrigin(t) {
        return this.crossOrigin = t, this;
      }
      setWithCredentials(t) {
        return this.withCredentials = t, this;
      }
      setPath(t) {
        return this.path = t, this;
      }
      setResourcePath(t) {
        return this.resourcePath = t, this;
      }
      setRequestHeader(t) {
        return this.requestHeader = t, this;
      }
    }
    const rs = {};
    class FileLoader extends Loader {
      constructor(t) {
        super(t);
      }
      load(t, e, i, n) {
        void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
        const r = this, o = is.get(t);
        if (void 0 !== o) return r.manager.itemStart(t), setTimeout(function () {
          e && e(o), r.manager.itemEnd(t);
        }, 0), o;
        if (void 0 !== rs[t]) return void rs[t].push({onLoad: e, onProgress: i, onError: n});
        const s = t.match(/^data:(.*?)(;base64)?,(.*)$/);
        let a;
        if (s) {
          const i = s[1], o = !!s[2];
          let a = s[3];
          a = decodeURIComponent(a), o && (a = atob(a));
          try {
            let n;
            const o = (this.responseType || "").toLowerCase();
            switch (o) {
              case "arraybuffer":
              case "blob":
                const t = new Uint8Array(a.length);
                for (let e = 0; e < a.length; e++) t[e] = a.charCodeAt(e);
                n = "blob" === o ? new Blob([t.buffer], {type: i}) : t.buffer;
                break;
              case "document":
                const e = new DOMParser;
                n = e.parseFromString(a, i);
                break;
              case "json":
                n = JSON.parse(a);
                break;
              default:
                n = a;
            }
            setTimeout(function () {
              e && e(n), r.manager.itemEnd(t);
            }, 0);
          } catch (e) {
            setTimeout(function () {
              n && "__private_" + i++ + "_" + e, r.manager.itemError(t), r.manager.itemEnd(t);
            }, 0);
          }
        } else {
          rs[t] = [], rs[t].push({onLoad: e, onProgress: i, onError: n}), a = new XMLHttpRequest, a.open("GET", t, true), a.addEventListener("load", function (e) {
            const i = this.response, n = rs[t];
            if (delete rs[t], 200 === this.status || 0 === this.status) {
              0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), is.add(t, i);
              for (let t = 0, e = n.length; t < e; t++) {
                const e = n[t];
                e.onLoad && e.onLoad(i);
              }
              r.manager.itemEnd(t);
            } else {
              for (let t = 0, i = n.length; t < i; t++) {
                const i = n[t];
                i.onError && i.onError(e);
              }
              r.manager.itemError(t), r.manager.itemEnd(t);
            }
          }, false), a.addEventListener("progress", function (e) {
            const i = rs[t];
            for (let t = 0, n = i.length; t < n; t++) {
              const n = i[t];
              n.onProgress && n.onProgress(e);
            }
          }, false), a.addEventListener("error", function (e) {
            const i = rs[t];
            delete rs[t];
            for (let t = 0, n = i.length; t < n; t++) {
              const n = i[t];
              n.onError && n.onError(e);
            }
            r.manager.itemError(t), r.manager.itemEnd(t);
          }, false), a.addEventListener("abort", function (e) {
            const i = rs[t];
            delete rs[t];
            for (let t = 0, n = i.length; t < n; t++) {
              const n = i[t];
              n.onError && n.onError(e);
            }
            r.manager.itemError(t), r.manager.itemEnd(t);
          }, false), void 0 !== this.responseType && (a.responseType = this.responseType), void 0 !== this.withCredentials && (a.withCredentials = this.withCredentials), a.overrideMimeType && a.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain");
          for (const t in this.requestHeader) a.setRequestHeader(t, this.requestHeader[t]);
          a.send(null);
        }
        return r.manager.itemStart(t), a;
      }
      setResponseType(t) {
        return this.responseType = t, this;
      }
      setMimeType(t) {
        return this.mimeType = t, this;
      }
    }
    class ImageLoader extends Loader {
      constructor(t) {
        super(t);
      }
      load(t, e, i, n) {
        void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
        const r = this, o = is.get(t);
        if (void 0 !== o) return r.manager.itemStart(t), setTimeout(function () {
          e && e(o), r.manager.itemEnd(t);
        }, 0), o;
        const s = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
        function a() {
          s.removeEventListener("load", a, false), s.removeEventListener("error", l, false), is.add(t, this), e && e(this), r.manager.itemEnd(t);
        }
        function l(e) {
          s.removeEventListener("load", a, false), s.removeEventListener("error", l, false), n && "__private_" + i++ + "_" + e, r.manager.itemError(t), r.manager.itemEnd(t);
        }
        return s.addEventListener("load", a, false), s.addEventListener("error", l, false), "data:" !== t.substr(0, 5) && void 0 !== this.crossOrigin && (s.crossOrigin = this.crossOrigin), r.manager.itemStart(t), s.src = t, s;
      }
    }
    class CubeTextureLoader extends Loader {
      constructor(t) {
        super(t);
      }
      load(t, e, i, n) {
        const r = new CubeTexture, o = new ImageLoader(this.manager);
        o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
        let s = 0;
        function a(i) {
          o.load(t[i], function (t) {
            r.images[i] = t, s++, 6 === s && (r.needsUpdate = true, e && e(r));
          }, void 0, n);
        }
        for (let e = 0; e < t.length; ++e) a(e);
        return r;
      }
    }
    class TextureLoader extends Loader {
      constructor(t) {
        super(t);
      }
      load(t, e, i, n) {
        const r = new Texture, o = new ImageLoader(this.manager);
        return o.setCrossOrigin(this.crossOrigin), o.setPath(this.path), o.load(t, function (i) {
          r.image = i;
          const n = t.search(/\.jpe?g($|\?)/i) > 0 || 0 === t.search(/^data\:image\/jpeg/);
          r.format = n ? T : E, r.needsUpdate = true, void 0 !== e && e(r);
        }, i, n), r;
      }
    }
    class CurvePath extends Curve {
      constructor() {
        super(), this.type = "CurvePath", this.curves = [], this.autoClose = false;
      }
      add(t) {
        this.curves.push(t);
      }
      closePath() {
        const t = this.curves[0].getPoint(0), e = this.curves[this.curves.length - 1].getPoint(1);
        t.equals(e) || this.curves.push(new LineCurve(e, t));
      }
      getPoint(t) {
        const e = t * this.getLength(), i = this.getCurveLengths();
        let n = 0;
        for (; n < i.length;) {
          if (i[n] >= e) {
            const t = i[n] - e, r = this.curves[n], o = r.getLength(), s = 0 === o ? 0 : 1 - t / o;
            return r.getPointAt(s);
          }
          n++;
        }
        return null;
      }
      getLength() {
        const t = this.getCurveLengths();
        return t[t.length - 1];
      }
      updateArcLengths() {
        this.needsUpdate = true, this.cacheLengths = null, this.getCurveLengths();
      }
      getCurveLengths() {
        if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
        const t = [];
        let e = 0;
        for (let i = 0, n = this.curves.length; i < n; i++) e += this.curves[i].getLength(), t.push(e);
        return this.cacheLengths = t, t;
      }
      getSpacedPoints(t = 40) {
        const e = [];
        for (let i = 0; i <= t; i++) e.push(this.getPoint(i / t));
        return this.autoClose && e.push(e[0]), e;
      }
      getPoints(t = 12) {
        const e = [];
        let i;
        for (let n = 0, r = this.curves; n < r.length; n++) {
          const o = r[n], s = o && o.isEllipseCurve ? 2 * t : o && (o.isLineCurve || o.isLineCurve3) ? 1 : o && o.isSplineCurve ? t * o.points.length : t, a = o.getPoints(s);
          for (let t = 0; t < a.length; t++) {
            const n = a[t];
            i && i.equals(n) || (e.push(n), i = n);
          }
        }
        return this.autoClose && e.length > 1 && !e[e.length - 1].equals(e[0]) && e.push(e[0]), e;
      }
      copy(t) {
        super.copy(t), this.curves = [];
        for (let e = 0, i = t.curves.length; e < i; e++) {
          const i = t.curves[e];
          this.curves.push(i.clone());
        }
        return this.autoClose = t.autoClose, this;
      }
      toJSON() {
        const t = super.toJSON();
        t.autoClose = this.autoClose, t.curves = [];
        for (let e = 0, i = this.curves.length; e < i; e++) {
          const i = this.curves[e];
          t.curves.push(i.toJSON());
        }
        return t;
      }
      fromJSON(t) {
        super.fromJSON(t), this.autoClose = t.autoClose, this.curves = [];
        for (let e = 0, i = t.curves.length; e < i; e++) {
          const i = t.curves[e];
          this.curves.push((new So[i.type]).fromJSON(i));
        }
        return this;
      }
    }
    class Path extends CurvePath {
      constructor(t) {
        super(), this.type = "Path", this.currentPoint = new Vector2, t && this.setFromPoints(t);
      }
      setFromPoints(t) {
        this.moveTo(t[0].x, t[0].y);
        for (let e = 1, i = t.length; e < i; e++) this.lineTo(t[e].x, t[e].y);
        return this;
      }
      moveTo(t, e) {
        return this.currentPoint.set(t, e), this;
      }
      lineTo(t, e) {
        const i = new LineCurve(this.currentPoint.clone(), new Vector2(t, e));
        return this.curves.push(i), this.currentPoint.set(t, e), this;
      }
      quadraticCurveTo(t, e, i, n) {
        const r = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(t, e), new Vector2(i, n));
        return this.curves.push(r), this.currentPoint.set(i, n), this;
      }
      bezierCurveTo(t, e, i, n, r, o) {
        const s = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(t, e), new Vector2(i, n), new Vector2(r, o));
        return this.curves.push(s), this.currentPoint.set(r, o), this;
      }
      splineThru(t) {
        const e = [this.currentPoint.clone()].concat(t), i = new SplineCurve(e);
        return this.curves.push(i), this.currentPoint.copy(t[t.length - 1]), this;
      }
      arc(t, e, i, n, r, o) {
        const s = this.currentPoint.x, a = this.currentPoint.y;
        return this.absarc(t + s, e + a, i, n, r, o), this;
      }
      absarc(t, e, i, n, r, o) {
        return this.absellipse(t, e, i, i, n, r, o), this;
      }
      ellipse(t, e, i, n, r, o, s, a) {
        const l = this.currentPoint.x, c = this.currentPoint.y;
        return this.absellipse(t + l, e + c, i, n, r, o, s, a), this;
      }
      absellipse(t, e, i, n, r, o, s, a) {
        const l = new EllipseCurve(t, e, i, n, r, o, s, a);
        if (this.curves.length > 0) {
          const t = l.getPoint(0);
          t.equals(this.currentPoint) || this.lineTo(t.x, t.y);
        }
        this.curves.push(l);
        const c = l.getPoint(1);
        return this.currentPoint.copy(c), this;
      }
      copy(t) {
        return super.copy(t), this.currentPoint.copy(t.currentPoint), this;
      }
      toJSON() {
        const t = super.toJSON();
        return t.currentPoint = this.currentPoint.toArray(), t;
      }
      fromJSON(t) {
        return super.fromJSON(t), this.currentPoint.fromArray(t.currentPoint), this;
      }
    }
    class Shape extends Path {
      constructor(t) {
        super(t), this.uuid = Z(), this.type = "Shape", this.holes = [];
      }
      getPointsHoles(t) {
        const e = [];
        for (let i = 0, n = this.holes.length; i < n; i++) e[i] = this.holes[i].getPoints(t);
        return e;
      }
      extractPoints(t) {
        return {shape: this.getPoints(t), holes: this.getPointsHoles(t)};
      }
      copy(t) {
        super.copy(t), this.holes = [];
        for (let e = 0, i = t.holes.length; e < i; e++) {
          const i = t.holes[e];
          this.holes.push(i.clone());
        }
        return this;
      }
      toJSON() {
        const t = super.toJSON();
        t.uuid = this.uuid, t.holes = [];
        for (let e = 0, i = this.holes.length; e < i; e++) {
          const i = this.holes[e];
          t.holes.push(i.toJSON());
        }
        return t;
      }
      fromJSON(t) {
        super.fromJSON(t), this.uuid = t.uuid, this.holes = [];
        for (let e = 0, i = t.holes.length; e < i; e++) {
          const i = t.holes[e];
          this.holes.push((new Path).fromJSON(i));
        }
        return this;
      }
    }
    class Light extends Object3D {
      constructor(t, e = 1) {
        super(), this.type = "Light", this.color = new three_module_Color(t), this.intensity = e;
      }
      dispose() {}
      copy(t) {
        return super.copy(t), this.color.copy(t.color), this.intensity = t.intensity, this;
      }
      toJSON(t) {
        const e = super.toJSON(t);
        return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (e.object.distance = this.distance), void 0 !== this.angle && (e.object.angle = this.angle), void 0 !== this.decay && (e.object.decay = this.decay), void 0 !== this.penumbra && (e.object.penumbra = this.penumbra), void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()), e;
      }
    }
    Light.prototype.isLight = true;
    class HemisphereLight extends Light {
      constructor(t, e, i) {
        super(t, i), this.type = "HemisphereLight", this.position.copy(Object3D.DefaultUp), this.updateMatrix(), this.groundColor = new three_module_Color(e);
      }
      copy(t) {
        return Light.prototype.copy.call(this, t), this.groundColor.copy(t.groundColor), this;
      }
    }
    HemisphereLight.prototype.isHemisphereLight = true;
    const os = new Matrix4, ss = new three_module_Vector3, as = new three_module_Vector3;
    class LightShadow {
      constructor(t) {
        this.camera = t, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new Vector2(512, 512), this.map = null, this.mapPass = null, this.matrix = new Matrix4, this.autoUpdate = true, this.needsUpdate = false, this._frustum = new Frustum, this._frameExtents = new Vector2(1, 1), this._viewportCount = 1, this._viewports = [new Vector4(0, 0, 1, 1)];
      }
      getViewportCount() {
        return this._viewportCount;
      }
      getFrustum() {
        return this._frustum;
      }
      updateMatrices(t) {
        const e = this.camera, i = this.matrix;
        ss.setFromMatrixPosition(t.matrixWorld), e.position.copy(ss), as.setFromMatrixPosition(t.target.matrixWorld), e.lookAt(as), e.updateMatrixWorld(), os.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), this._frustum.setFromProjectionMatrix(os), i.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1), i.multiply(e.projectionMatrix), i.multiply(e.matrixWorldInverse);
      }
      getViewport(t) {
        return this._viewports[t];
      }
      getFrameExtents() {
        return this._frameExtents;
      }
      dispose() {
        this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
      }
      copy(t) {
        return this.camera = t.camera.clone(), this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this;
      }
      clone() {
        return (new this.constructor).copy(this);
      }
      toJSON() {
        const t = {};
        return 0 !== this.bias && (t.bias = this.bias), 0 !== this.normalBias && (t.normalBias = this.normalBias), 1 !== this.radius && (t.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(false).object, delete t.camera.matrix, t;
      }
    }
    class SpotLightShadow extends LightShadow {
      constructor() {
        super(new PerspectiveCamera(50, 1, 0.5, 500)), this.focus = 1;
      }
      updateMatrices(t) {
        const e = this.camera, i = 2 * Y * t.angle * this.focus, n = this.mapSize.width / this.mapSize.height, r = t.distance || e.far;
        i === e.fov && n === e.aspect && r === e.far || (e.fov = i, e.aspect = n, e.far = r, e.updateProjectionMatrix()), super.updateMatrices(t);
      }
      copy(t) {
        return super.copy(t), this.focus = t.focus, this;
      }
    }
    SpotLightShadow.prototype.isSpotLightShadow = true;
    class SpotLight extends Light {
      constructor(t, e, i = 0, n = Math.PI / 3, r = 0, o = 1) {
        super(t, e), this.type = "SpotLight", this.position.copy(Object3D.DefaultUp), this.updateMatrix(), this.target = new Object3D, this.distance = i, this.angle = n, this.penumbra = r, this.decay = o, this.shadow = new SpotLightShadow;
      }
      get power() {
        return this.intensity * Math.PI;
      }
      set power (t) {
        this.intensity = t / Math.PI;
      }
      dispose() {
        this.shadow.dispose();
      }
      copy(t) {
        return super.copy(t), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this;
      }
    }
    SpotLight.prototype.isSpotLight = true;
    const ls = new Matrix4, cs = new three_module_Vector3, hs = new three_module_Vector3;
    class PointLightShadow extends LightShadow {
      constructor() {
        super(new PerspectiveCamera(90, 1, 0.5, 500)), this._frameExtents = new Vector2(4, 2), this._viewportCount = 6, this._viewports = [new Vector4(2, 1, 1, 1), new Vector4(0, 1, 1, 1), new Vector4(3, 1, 1, 1), new Vector4(1, 1, 1, 1), new Vector4(3, 0, 1, 1), new Vector4(1, 0, 1, 1)], this._cubeDirections = [new three_module_Vector3(1, 0, 0), new three_module_Vector3(-1, 0, 0), new three_module_Vector3(0, 0, 1), new three_module_Vector3(0, 0, -1), new three_module_Vector3(0, 1, 0), new three_module_Vector3(0, -1, 0)], this._cubeUps = [new three_module_Vector3(0, 1, 0), new three_module_Vector3(0, 1, 0), new three_module_Vector3(0, 1, 0), new three_module_Vector3(0, 1, 0), new three_module_Vector3(0, 0, 1), new three_module_Vector3(0, 0, -1)];
      }
      updateMatrices(t, e = 0) {
        const i = this.camera, n = this.matrix, r = t.distance || i.far;
        r !== i.far && (i.far = r, i.updateProjectionMatrix()), cs.setFromMatrixPosition(t.matrixWorld), i.position.copy(cs), hs.copy(i.position), hs.add(this._cubeDirections[e]), i.up.copy(this._cubeUps[e]), i.lookAt(hs), i.updateMatrixWorld(), n.makeTranslation(-cs.x, -cs.y, -cs.z), ls.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse), this._frustum.setFromProjectionMatrix(ls);
      }
    }
    PointLightShadow.prototype.isPointLightShadow = true;
    class PointLight extends Light {
      constructor(t, e, i = 0, n = 1) {
        super(t, e), this.type = "PointLight", this.distance = i, this.decay = n, this.shadow = new PointLightShadow;
      }
      get power() {
        return 4 * this.intensity * Math.PI;
      }
      set power (t) {
        this.intensity = t / (4 * Math.PI);
      }
      dispose() {
        this.shadow.dispose();
      }
      copy(t) {
        return super.copy(t), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this;
      }
    }
    PointLight.prototype.isPointLight = true;
    class DirectionalLightShadow extends LightShadow {
      constructor() {
        super(new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
      }
    }
    DirectionalLightShadow.prototype.isDirectionalLightShadow = true;
    class DirectionalLight extends Light {
      constructor(t, e) {
        super(t, e), this.type = "DirectionalLight", this.position.copy(Object3D.DefaultUp), this.updateMatrix(), this.target = new Object3D, this.shadow = new DirectionalLightShadow;
      }
      dispose() {
        this.shadow.dispose();
      }
      copy(t) {
        return super.copy(t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this;
      }
    }
    DirectionalLight.prototype.isDirectionalLight = true;
    class AmbientLight extends Light {
      constructor(t, e) {
        super(t, e), this.type = "AmbientLight";
      }
    }
    AmbientLight.prototype.isAmbientLight = true;
    class RectAreaLight extends Light {
      constructor(t, e, i = 10, n = 10) {
        super(t, e), this.type = "RectAreaLight", this.width = i, this.height = n;
      }
      get power() {
        return this.intensity * this.width * this.height * Math.PI;
      }
      set power (t) {
        this.intensity = t / (this.width * this.height * Math.PI);
      }
      copy(t) {
        return super.copy(t), this.width = t.width, this.height = t.height, this;
      }
      toJSON(t) {
        const e = super.toJSON(t);
        return e.object.width = this.width, e.object.height = this.height, e;
      }
    }
    RectAreaLight.prototype.isRectAreaLight = true;
    class SphericalHarmonics3 {
      constructor() {
        this.coefficients = [];
        for (let t = 0; t < 9; t++) this.coefficients.push(new three_module_Vector3);
      }
      set(t) {
        for (let e = 0; e < 9; e++) this.coefficients[e].copy(t[e]);
        return this;
      }
      zero() {
        for (let t = 0; t < 9; t++) this.coefficients[t].set(0, 0, 0);
        return this;
      }
      getAt(t, e) {
        const i = t.x, n = t.y, r = t.z, o = this.coefficients;
        return e.copy(o[0]).multiplyScalar(0.282095), e.addScaledVector(o[1], 0.488603 * n), e.addScaledVector(o[2], 0.488603 * r), e.addScaledVector(o[3], 0.488603 * i), e.addScaledVector(o[4], i * n * 1.092548), e.addScaledVector(o[5], n * r * 1.092548), e.addScaledVector(o[6], 0.315392 * (3 * r * r - 1)), e.addScaledVector(o[7], i * r * 1.092548), e.addScaledVector(o[8], 0.546274 * (i * i - n * n)), e;
      }
      getIrradianceAt(t, e) {
        const i = t.x, n = t.y, r = t.z, o = this.coefficients;
        return e.copy(o[0]).multiplyScalar(0.886227), e.addScaledVector(o[1], 1.023328 * n), e.addScaledVector(o[2], 1.023328 * r), e.addScaledVector(o[3], 1.023328 * i), e.addScaledVector(o[4], 0.858086 * i * n), e.addScaledVector(o[5], 0.858086 * n * r), e.addScaledVector(o[6], 0.743125 * r * r - 0.247708), e.addScaledVector(o[7], 0.858086 * i * r), e.addScaledVector(o[8], 0.429043 * (i * i - n * n)), e;
      }
      add(t) {
        for (let e = 0; e < 9; e++) this.coefficients[e].add(t.coefficients[e]);
        return this;
      }
      addScaledSH(t, e) {
        for (let i = 0; i < 9; i++) this.coefficients[i].addScaledVector(t.coefficients[i], e);
        return this;
      }
      scale(t) {
        for (let e = 0; e < 9; e++) this.coefficients[e].multiplyScalar(t);
        return this;
      }
      lerp(t, e) {
        for (let i = 0; i < 9; i++) this.coefficients[i].lerp(t.coefficients[i], e);
        return this;
      }
      equals(t) {
        for (let e = 0; e < 9; e++) if (!this.coefficients[e].equals(t.coefficients[e])) return false;
        return true;
      }
      copy(t) {
        return this.set(t.coefficients);
      }
      clone() {
        return (new this.constructor).copy(this);
      }
      fromArray(t, e = 0) {
        const i = this.coefficients;
        for (let n = 0; n < 9; n++) i[n].fromArray(t, e + 3 * n);
        return this;
      }
      toArray(t = [], e = 0) {
        const i = this.coefficients;
        for (let n = 0; n < 9; n++) i[n].toArray(t, e + 3 * n);
        return t;
      }
      static getBasisAt(t, e) {
        const i = t.x, n = t.y, r = t.z;
        e[0] = 0.282095, e[1] = 0.488603 * n, e[2] = 0.488603 * r, e[3] = 0.488603 * i, e[4] = 1.092548 * i * n, e[5] = 1.092548 * n * r, e[6] = 0.315392 * (3 * r * r - 1), e[7] = 1.092548 * i * r, e[8] = 0.546274 * (i * i - n * n);
      }
    }
    SphericalHarmonics3.prototype.isSphericalHarmonics3 = true;
    class LightProbe extends Light {
      constructor(t = new SphericalHarmonics3, e = 1) {
        super(void 0, e), this.sh = t;
      }
      copy(t) {
        return super.copy(t), this.sh.copy(t.sh), this;
      }
      fromJSON(t) {
        return this.intensity = t.intensity, this.sh.fromArray(t.sh), this;
      }
      toJSON(t) {
        const e = super.toJSON(t);
        return e.object.sh = this.sh.toArray(), e;
      }
    }
    LightProbe.prototype.isLightProbe = true;
    class LoaderUtils {
      static decodeText(t) {
        if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(t);
        let e = "";
        for (let i = 0, n = t.length; i < n; i++) e += String.fromCharCode(t[i]);
        try {
          return decodeURIComponent(escape(e));
        } catch (t) {
          return e;
        }
      }
      static extractUrlBase(t) {
        const e = t.lastIndexOf("/");
        return -1 === e ? "./" : t.substr(0, e + 1);
      }
    }
    class InstancedBufferGeometry extends BufferGeometry {
      constructor() {
        super(), this.type = "InstancedBufferGeometry", this.instanceCount = Infinity;
      }
      copy(t) {
        return super.copy(t), this.instanceCount = t.instanceCount, this;
      }
      clone() {
        return (new this.constructor).copy(this);
      }
      toJSON() {
        const t = super.toJSON(this);
        return t.instanceCount = this.instanceCount, t.isInstancedBufferGeometry = true, t;
      }
    }
    InstancedBufferGeometry.prototype.isInstancedBufferGeometry = true;
    (class ImageBitmapLoader extends Loader {
      constructor(t) {
        super(t), "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = {premultiplyAlpha: "none"};
      }
      setOptions(t) {
        return this.options = t, this;
      }
      load(t, e, i, n) {
        void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
        const r = this, o = is.get(t);
        if (void 0 !== o) return r.manager.itemStart(t), setTimeout(function () {
          e && e(o), r.manager.itemEnd(t);
        }, 0), o;
        const s = {};
        s.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include", s.headers = this.requestHeader, fetch(t, s).then(function (t) {
          return t.blob();
        }).then(function (t) {
          return createImageBitmap(t, Object.assign(r.options, {colorSpaceConversion: "none"}));
        }).then(function (i) {
          is.add(t, i), e && e(i), r.manager.itemEnd(t);
        }).catch(function (e) {
          n && "__private_" + i++ + "_" + e, r.manager.itemError(t), r.manager.itemEnd(t);
        }), r.manager.itemStart(t);
      }
    }.prototype.isImageBitmapLoader = true);
    class ShapePath {
      constructor() {
        this.type = "ShapePath", this.color = new three_module_Color, this.subPaths = [], this.currentPath = null;
      }
      moveTo(t, e) {
        return this.currentPath = new Path, this.subPaths.push(this.currentPath), this.currentPath.moveTo(t, e), this;
      }
      lineTo(t, e) {
        return this.currentPath.lineTo(t, e), this;
      }
      quadraticCurveTo(t, e, i, n) {
        return this.currentPath.quadraticCurveTo(t, e, i, n), this;
      }
      bezierCurveTo(t, e, i, n, r, o) {
        return this.currentPath.bezierCurveTo(t, e, i, n, r, o), this;
      }
      splineThru(t) {
        return this.currentPath.splineThru(t), this;
      }
      toShapes(t, e) {
        function i(t) {
          const e = [];
          for (let i = 0, n = t.length; i < n; i++) {
            const n = t[i], r = new Shape;
            r.curves = n.curves, e.push(r);
          }
          return e;
        }
        function n(t, e) {
          const i = e.length;
          let n = false;
          for (let r = i - 1, o = 0; o < i; r = o++) {
            let i = e[r], s = e[o], a = s.x - i.x, l = s.y - i.y;
            if (Math.abs(l) > Number.EPSILON) {
              if (l < 0 && (i = e[o], a = -a, s = e[r], l = -l), t.y < i.y || t.y > s.y) continue;
              if (t.y === i.y) {
                if (t.x === i.x) return true;
              } else {
                const e = l * (t.x - i.x) - a * (t.y - i.y);
                if (0 === e) return true;
                if (e < 0) continue;
                n = !n;
              }
            } else {
              if (t.y !== i.y) continue;
              if (s.x <= t.x && t.x <= i.x || i.x <= t.x && t.x <= s.x) return true;
            }
          }
          return n;
        }
        const r = ShapeUtils.isClockWise, o = this.subPaths;
        if (0 === o.length) return [];
        if (true === e) return i(o);
        let s, a, l;
        const c = [];
        if (1 === o.length) return a = o[0], l = new Shape, l.curves = a.curves, c.push(l), c;
        let h = !r(o[0].getPoints());
        h = t ? !h : h;
        const u = [], p = [];
        let m, d, _ = [], y = 0;
        p[y] = void 0, _[y] = [];
        for (let e = 0, i = o.length; e < i; e++) a = o[e], m = a.getPoints(), s = r(m), s = t ? !s : s, s ? (!h && p[y] && y++, p[y] = {s: new Shape, p: m}, p[y].s.curves = a.curves, h && y++, _[y] = []) : _[y].push({h: a, p: m[0]});
        if (!p[0]) return i(o);
        if (p.length > 1) {
          let t = false;
          const e = [];
          for (let t = 0, e = p.length; t < e; t++) u[t] = [];
          for (let i = 0, r = p.length; i < r; i++) {
            const r = _[i];
            for (let o = 0; o < r.length; o++) {
              const s = r[o];
              let a = true;
              for (let r = 0; r < p.length; r++) "__private_" + i++ + "_" + s.p && (i !== r && e.push({froms: i, tos: r, hole: o}), a ? (a = false, u[r].push(s)) : t = true);
              a && u[i].push(s);
            }
          }
          e.length > 0 && (t || (_ = u));
        }
        for (let t = 0, e = p.length; t < e; t++) {
          l = p[t].s, c.push(l), d = _[t];
          for (let t = 0, e = d.length; t < e; t++) l.holes.push(d[t].h);
        }
        return c;
      }
    }
    class Font {
      constructor(t) {
        this.type = "Font", this.data = t;
      }
      generateShapes(t, e = 100) {
        const i = [], n = function (t, e, i) {
          const n = Array.from(t), r = e / i.resolution, o = (i.boundingBox.yMax - i.boundingBox.yMin + i.underlineThickness) * r, s = [];
          let a = 0, l = 0;
          for (let t = 0; t < n.length; t++) {
            const e = n[t];
            if ("\n" === e) a = 0, l -= o; else {
              const t = us(e, r, a, l, i);
              a += t.offsetX, s.push(t.path);
            }
          }
          return s;
        }(t, e, this.data);
        for (let t = 0, e = n.length; t < e; t++) Array.prototype.push.apply(i, n[t].toShapes());
        return i;
      }
    }
    function us(t, e, i, n, r) {
      const o = r.glyphs[t] || r.glyphs["?"];
      if (!o) return void console.error('THREE.Font: character "' + t + '" does not exists in font family ' + r.familyName + ".");
      const s = new ShapePath;
      let a, l, c, h, u, p, m, d;
      if (o.o) {
        const t = o._cachedOutline || (o._cachedOutline = o.o.split(" "));
        for (let r = 0, o = t.length; r < o;) {
          switch (t[r++]) {
            case "m":
              a = t[r++] * e + i, l = t[r++] * e + n, s.moveTo(a, l);
              break;
            case "l":
              a = t[r++] * e + i, l = t[r++] * e + n, s.lineTo(a, l);
              break;
            case "q":
              c = t[r++] * e + i, h = t[r++] * e + n, u = t[r++] * e + i, p = t[r++] * e + n, s.quadraticCurveTo(u, p, c, h);
              break;
            case "b":
              c = t[r++] * e + i, h = t[r++] * e + n, u = t[r++] * e + i, p = t[r++] * e + n, m = t[r++] * e + i, d = t[r++] * e + n, s.bezierCurveTo(u, p, m, d, c, h);
          }
        }
      }
      return {offsetX: o.ha * e, path: s};
    }
    Font.prototype.isFont = true;
    let ps;
    class AudioLoader extends Loader {
      constructor(t) {
        super(t);
      }
      load(t, e, i, n) {
        const r = this, o = new FileLoader(this.manager);
        o.setResponseType("arraybuffer"), o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(t, function (i) {
          try {
            const t = i.slice(0);
            (void 0 === ps && (ps = new (window.AudioContext || window.webkitAudioContext)), ps).decodeAudioData(t, function (t) {
              e(t);
            });
          } catch (e) {
            n ? "__private_" + i++ + "_" + e : console.error(e), r.manager.itemError(t);
          }
        }, i, n);
      }
    }
    (class HemisphereLightProbe extends LightProbe {
      constructor(t, e, i = 1) {
        super(void 0, i);
        const n = (new three_module_Color).set(t), r = (new three_module_Color).set(e), o = new three_module_Vector3(n.r, n.g, n.b), s = new three_module_Vector3(r.r, r.g, r.b), a = Math.sqrt(Math.PI), l = a * Math.sqrt(0.75);
        this.sh.coefficients[0].copy(o).add(s).multiplyScalar(a), this.sh.coefficients[1].copy(o).sub(s).multiplyScalar(l);
      }
    }.prototype.isHemisphereLightProbe = true);
    (class AmbientLightProbe extends LightProbe {
      constructor(t, e = 1) {
        super(void 0, e);
        const i = (new three_module_Color).set(t);
        this.sh.coefficients[0].set(i.r, i.g, i.b).multiplyScalar(2 * Math.sqrt(Math.PI));
      }
    }.prototype.isAmbientLightProbe = true);
    class Audio extends Object3D {
      constructor(t) {
        super(), this.type = "Audio", this.listener = t, this.context = t.context, this.gain = this.context.createGain(), this.gain.connect(t.getInput()), this.autoplay = false, this.buffer = null, this.detune = 0, this.loop = false, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = false, this.hasPlaybackControl = true, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = false, this.filters = [];
      }
      getOutput() {
        return this.gain;
      }
      setNodeSource(t) {
        return this.hasPlaybackControl = false, this.sourceType = "audioNode", this.source = t, this.connect(), this;
      }
      setMediaElementSource(t) {
        return this.hasPlaybackControl = false, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(t), this.connect(), this;
      }
      setMediaStreamSource(t) {
        return this.hasPlaybackControl = false, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(t), this.connect(), this;
      }
      setBuffer(t) {
        return this.buffer = t, this.sourceType = "buffer", this.autoplay && this.play(), this;
      }
      play(t = 0) {
        if (true === this.isPlaying) return void console.warn("THREE.Audio: Audio is already playing.");
        if (false === this.hasPlaybackControl) return void console.warn("THREE.Audio: this Audio has no playback control.");
        this._startedAt = this.context.currentTime + t;
        const e = this.context.createBufferSource();
        return e.buffer = this.buffer, e.loop = this.loop, e.loopStart = this.loopStart, e.loopEnd = this.loopEnd, e.onended = this.onEnded.bind(this), e.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = true, this.source = e, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect();
      }
      pause() {
        if (false !== this.hasPlaybackControl) return true === this.isPlaying && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, true === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = false), this;
        console.warn("THREE.Audio: this Audio has no playback control.");
      }
      stop() {
        if (false !== this.hasPlaybackControl) return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = false, this;
        console.warn("THREE.Audio: this Audio has no playback control.");
      }
      connect() {
        if (this.filters.length > 0) {
          this.source.connect(this.filters[0]);
          for (let t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].connect(this.filters[t]);
          this.filters[this.filters.length - 1].connect(this.getOutput());
        } else this.source.connect(this.getOutput());
        return this._connected = true, this;
      }
      disconnect() {
        if (this.filters.length > 0) {
          this.source.disconnect(this.filters[0]);
          for (let t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].disconnect(this.filters[t]);
          this.filters[this.filters.length - 1].disconnect(this.getOutput());
        } else this.source.disconnect(this.getOutput());
        return this._connected = false, this;
      }
      getFilters() {
        return this.filters;
      }
      setFilters(t) {
        return t || (t = []), true === this._connected ? (this.disconnect(), this.filters = t.slice(), this.connect()) : this.filters = t.slice(), this;
      }
      setDetune(t) {
        if (this.detune = t, void 0 !== this.source.detune) return true === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01), this;
      }
      getDetune() {
        return this.detune;
      }
      getFilter() {
        return this.getFilters()[0];
      }
      setFilter(t) {
        return this.setFilters(t ? [t] : []);
      }
      setPlaybackRate(t) {
        if (false !== this.hasPlaybackControl) return this.playbackRate = t, true === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01), this;
        console.warn("THREE.Audio: this Audio has no playback control.");
      }
      getPlaybackRate() {
        return this.playbackRate;
      }
      onEnded() {
        this.isPlaying = false;
      }
      getLoop() {
        return false === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), false) : this.loop;
      }
      setLoop(t) {
        if (false !== this.hasPlaybackControl) return this.loop = t, true === this.isPlaying && (this.source.loop = this.loop), this;
        console.warn("THREE.Audio: this Audio has no playback control.");
      }
      setLoopStart(t) {
        return this.loopStart = t, this;
      }
      setLoopEnd(t) {
        return this.loopEnd = t, this;
      }
      getVolume() {
        return this.gain.gain.value;
      }
      setVolume(t) {
        return this.gain.gain.setTargetAtTime(t, this.context.currentTime, 0.01), this;
      }
    }
    class PropertyMixer {
      constructor(t, e, i) {
        let n, r, o;
        switch (this.binding = t, this.valueSize = i, e) {
          case "quaternion":
            n = this._slerp, r = this._slerpAdditive, o = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * i), this._workIndex = 5;
            break;
          case "string":
          case "bool":
            n = this._select, r = this._select, o = this._setAdditiveIdentityOther, this.buffer = new Array(5 * i);
            break;
          default:
            n = this._lerp, r = this._lerpAdditive, o = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * i);
        }
        this._mixBufferRegion = n, this._mixBufferRegionAdditive = r, this._setIdentity = o, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0;
      }
      accumulate(t, e) {
        const i = this.buffer, n = this.valueSize, r = t * n + n;
        let o = this.cumulativeWeight;
        if (0 === o) {
          for (let t = 0; t !== n; ++t) i[r + t] = i[t];
          o = e;
        } else {
          o += e;
          const t = e / o;
          this._mixBufferRegion(i, r, 0, t, n);
        }
        this.cumulativeWeight = o;
      }
      accumulateAdditive(t) {
        const e = this.buffer, i = this.valueSize, n = i * this._addIndex;
        0 === this.cumulativeWeightAdditive && this._setIdentity(), this._mixBufferRegionAdditive(e, n, 0, t, i), this.cumulativeWeightAdditive += t;
      }
      apply(t) {
        const e = this.valueSize, i = this.buffer, n = t * e + e, r = this.cumulativeWeight, o = this.cumulativeWeightAdditive, s = this.binding;
        if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, r < 1) {
          const t = e * this._origIndex;
          this._mixBufferRegion(i, n, t, 1 - r, e);
        }
        o > 0 && this._mixBufferRegionAdditive(i, n, this._addIndex * e, 1, e);
        for (let t = e, r = e + e; t !== r; ++t) if (i[t] !== i[t + e]) {
          s.setValue(i, n);
          break;
        }
      }
      saveOriginalState() {
        const t = this.binding, e = this.buffer, i = this.valueSize, n = i * this._origIndex;
        t.getValue(e, n);
        for (let t = i; t !== r; ++t) e[t] = e[n + t % i];
        this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0;
      }
      restoreOriginalState() {
        const t = 3 * this.valueSize;
        this.binding.setValue(this.buffer, t);
      }
      _setAdditiveIdentityNumeric() {
        const t = this._addIndex * this.valueSize, e = t + this.valueSize;
        for (let i = t; i < e; i++) this.buffer[i] = 0;
      }
      _setAdditiveIdentityQuaternion() {
        this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1;
      }
      _setAdditiveIdentityOther() {
        const t = this._origIndex * this.valueSize, e = this._addIndex * this.valueSize;
        for (let i = 0; i < this.valueSize; i++) this.buffer[e + i] = this.buffer[t + i];
      }
      _select(t, e, i, n, r) {
        if (n >= 0.5) for (let n = 0; n !== r; ++n) t[e + n] = t[i + n];
      }
      _slerp(t, e, i, n) {
        Quaternion.slerpFlat(t, e, t, e, t, i, n);
      }
      _slerpAdditive(t, e, i, n, r) {
        const o = this._workIndex * r;
        Quaternion.multiplyQuaternionsFlat(t, o, t, e, t, i), Quaternion.slerpFlat(t, e, t, e, t, o, n);
      }
      _lerp(t, e, i, n, r) {
        const o = 1 - n;
        for (let s = 0; s !== r; ++s) {
          const r = e + s;
          t[r] = t[r] * o + t[i + s] * n;
        }
      }
      _lerpAdditive(t, e, i, n, r) {
        for (let o = 0; o !== r; ++o) {
          const r = e + o;
          t[r] = t[r] + t[i + o] * n;
        }
      }
    }
    const ds = "\\[\\]\\.:\\/", fs = new RegExp("[\\[\\]\\.:\\/]", "g"), _s = "[^\\[\\]\\.:\\/]", ys = "[^" + ds.replace("\\.", "") + "]", gs = /((?:WC+[\/:])*)/.source.replace("WC", _s), xs = /(WCOD+)?/.source.replace("WCOD", ys), vs = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", _s), bs = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", _s), ws = new RegExp("^" + gs + xs + vs + bs + "$"), Ss = ["material", "materials", "bones"];
    class PropertyBinding {
      constructor(t, e, i) {
        this.path = e, this.parsedPath = i || PropertyBinding.parseTrackName(e), this.node = PropertyBinding.findNode(t, this.parsedPath.nodeName) || t, this.rootNode = t, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
      }
      static create(t, e, i) {
        return t && t.isAnimationObjectGroup ? new PropertyBinding.Composite(t, e, i) : new PropertyBinding(t, e, i);
      }
      static sanitizeNodeName(t) {
        return t.replace(/\s/g, "_").replace(fs, "");
      }
      static parseTrackName(t) {
        const e = ws.exec(t);
        if (!e) throw new Error("PropertyBinding: Cannot parse trackName: " + t);
        const i = {nodeName: e[2], objectName: e[3], objectIndex: e[4], propertyName: e[5], propertyIndex: e[6]}, n = i.nodeName && i.nodeName.lastIndexOf(".");
        if (void 0 !== n && -1 !== n) {
          const t = i.nodeName.substring(n + 1);
          -1 !== Ss.indexOf(t) && (i.nodeName = i.nodeName.substring(0, n), i.objectName = t);
        }
        if (null === i.propertyName || 0 === i.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
        return i;
      }
      static findNode(t, e) {
        if (!e || "" === e || "." === e || -1 === e || e === t.name || e === t.uuid) return t;
        if (t.skeleton) {
          const i = t.skeleton.getBoneByName(e);
          if (void 0 !== i) return i;
        }
        if (t.children) {
          const i = function (t) {
            for (let n = 0; n < t.length; n++) {
              const r = t[n];
              if (r.name === e || r.uuid === e) return r;
              const o = i(r.children);
              if (o) return o;
            }
            return null;
          }, n = i(t.children);
          if (n) return n;
        }
        return null;
      }
      _getValue_unavailable() {}
      _setValue_unavailable() {}
      _getValue_direct(t, e) {
        t[e] = this.targetObject[this.propertyName];
      }
      _getValue_array(t, e) {
        const i = this.resolvedProperty;
        for (let n = 0, r = i.length; n !== r; ++n) t[e++] = i[n];
      }
      _getValue_arrayElement(t, e) {
        t[e] = this.resolvedProperty[this.propertyIndex];
      }
      _getValue_toArray(t, e) {
        this.resolvedProperty.toArray(t, e);
      }
      _setValue_direct(t, e) {
        this.targetObject[this.propertyName] = t[e];
      }
      _setValue_direct_setNeedsUpdate(t, e) {
        this.targetObject[this.propertyName] = t[e], this.targetObject.needsUpdate = true;
      }
      _setValue_direct_setMatrixWorldNeedsUpdate(t, e) {
        this.targetObject[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = true;
      }
      _setValue_array(t, e) {
        const i = this.resolvedProperty;
        for (let n = 0, r = i.length; n !== r; ++n) i[n] = t[e++];
      }
      _setValue_array_setNeedsUpdate(t, e) {
        const i = this.resolvedProperty;
        for (let n = 0, r = i.length; n !== r; ++n) i[n] = t[e++];
        this.targetObject.needsUpdate = true;
      }
      _setValue_array_setMatrixWorldNeedsUpdate(t, e) {
        const i = this.resolvedProperty;
        for (let n = 0, r = i.length; n !== r; ++n) i[n] = t[e++];
        this.targetObject.matrixWorldNeedsUpdate = true;
      }
      _setValue_arrayElement(t, e) {
        this.resolvedProperty[this.propertyIndex] = t[e];
      }
      _setValue_arrayElement_setNeedsUpdate(t, e) {
        this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = true;
      }
      _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, e) {
        this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = true;
      }
      _setValue_fromArray(t, e) {
        this.resolvedProperty.fromArray(t, e);
      }
      _setValue_fromArray_setNeedsUpdate(t, e) {
        this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = true;
      }
      _setValue_fromArray_setMatrixWorldNeedsUpdate(t, e) {
        this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = true;
      }
      _getValue_unbound(t, e) {
        this.bind(), this.getValue(t, e);
      }
      _setValue_unbound(t, e) {
        this.bind(), this.setValue(t, e);
      }
      bind() {
        let t = this.node;
        const e = this.parsedPath, i = e.objectName, n = e.propertyName;
        let r = e.propertyIndex;
        if (t || (t = PropertyBinding.findNode(this.rootNode, e.nodeName) || this.rootNode, this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !t) return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
        if (i) {
          let n = e.objectIndex;
          switch (i) {
            case "materials":
              if (!t.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
              if (!t.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
              t = t.material.materials;
              break;
            case "bones":
              if (!t.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
              t = t.skeleton.bones;
              for (let e = 0; e < t.length; e++) if (t[e].name === n) {
                n = e;
                break;
              }
              break;
            default:
              if (void 0 === t[i]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
              t = t[i];
          }
          if (void 0 !== n) {
            if (void 0 === t[n]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
            t = t[n];
          }
        }
        const o = t[n];
        if (void 0 === o) {
          const i = e.nodeName;
          return void console.error("THREE.PropertyBinding: Trying to update property for track: " + i + "." + n + " but it wasn't found.", t);
        }
        let s = this.Versioning.None;
        this.targetObject = t, void 0 !== t.needsUpdate ? s = this.Versioning.NeedsUpdate : void 0 !== t.matrixWorldNeedsUpdate && (s = this.Versioning.MatrixWorldNeedsUpdate);
        let a = this.BindingType.Direct;
        if (void 0 !== r) {
          if ("morphTargetInfluences" === n) {
            if (!t.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
            if (!t.geometry.isBufferGeometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
            if (!t.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
            void 0 !== t.morphTargetDictionary[r] && (r = t.morphTargetDictionary[r]);
          }
          a = this.BindingType.ArrayElement, this.resolvedProperty = o, this.propertyIndex = r;
        } else void 0 !== o.fromArray && void 0 !== o.toArray ? (a = this.BindingType.HasFromToArray, this.resolvedProperty = o) : Array.isArray(o) ? (a = this.BindingType.EntireArray, this.resolvedProperty = o) : this.propertyName = n;
        this.getValue = this.GetterByBindingType[a], this.setValue = this.SetterByBindingTypeAndVersioning[a][s];
      }
      unbind() {
        this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
      }
    }
    PropertyBinding.Composite = class Composite {
      constructor(t, e, i) {
        const n = i || PropertyBinding.parseTrackName(e);
        this._targetGroup = t, this._bindings = t.subscribe_(e, n);
      }
      getValue(t, e) {
        this.bind();
        const i = this._targetGroup.nCachedObjects_, n = this._bindings[i];
        void 0 !== n && n.getValue(t, e);
      }
      setValue(t, e) {
        const i = this._bindings;
        for (let n = this._targetGroup.nCachedObjects_, r = i.length; n !== r; ++n) i[n].setValue(t, e);
      }
      bind() {
        const t = this._bindings;
        for (let e = this._targetGroup.nCachedObjects_, i = t.length; e !== i; ++e) t[e].bind();
      }
      unbind() {
        const t = this._bindings;
        for (let e = this._targetGroup.nCachedObjects_, i = t.length; e !== i; ++e) t[e].unbind();
      }
    }, PropertyBinding.prototype.BindingType = {Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3}, PropertyBinding.prototype.Versioning = {None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2}, PropertyBinding.prototype.GetterByBindingType = [PropertyBinding.prototype._getValue_direct, PropertyBinding.prototype._getValue_array, PropertyBinding.prototype._getValue_arrayElement, PropertyBinding.prototype._getValue_toArray], PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [[PropertyBinding.prototype._setValue_direct, PropertyBinding.prototype._setValue_direct_setNeedsUpdate, PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [PropertyBinding.prototype._setValue_array, PropertyBinding.prototype._setValue_array_setNeedsUpdate, PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate], [PropertyBinding.prototype._setValue_arrayElement, PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate, PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [PropertyBinding.prototype._setValue_fromArray, PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate, PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];
    class AnimationAction {
      constructor(t, e, i = null, n = e.blendMode) {
        this._mixer = t, this._clip = e, this._localRoot = i, this.blendMode = n;
        const r = e.tracks, o = r.length, s = new Array(o), a = {endingStart: I, endingEnd: I};
        for (let t = 0; t !== o; ++t) {
          const e = r[t].createInterpolant(null);
          s[t] = e, e.settings = a;
        }
        this._interpolantSettings = a, this._interpolants = s, this._propertyBindings = new Array(o), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = 2201, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = Infinity, this.paused = false, this.enabled = true, this.clampWhenFinished = false, this.zeroSlopeAtStart = true, this.zeroSlopeAtEnd = true;
      }
      play() {
        return this._mixer._activateAction(this), this;
      }
      stop() {
        return this._mixer._deactivateAction(this), this.reset();
      }
      reset() {
        return this.paused = false, this.enabled = true, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping();
      }
      isRunning() {
        return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this);
      }
      isScheduled() {
        return this._mixer._isActiveAction(this);
      }
      startAt(t) {
        return this._startTime = t, this;
      }
      setLoop(t, e) {
        return this.loop = t, this.repetitions = e, this;
      }
      setEffectiveWeight(t) {
        return this.weight = t, this._effectiveWeight = this.enabled ? t : 0, this.stopFading();
      }
      getEffectiveWeight() {
        return this._effectiveWeight;
      }
      fadeIn(t) {
        return this._scheduleFading(t, 0, 1);
      }
      fadeOut(t) {
        return this._scheduleFading(t, 1, 0);
      }
      crossFadeFrom(t, e, i) {
        if (t.fadeOut(e), this.fadeIn(e), i) {
          const i = this._clip.duration, n = t._clip.duration, r = n / i, o = i / n;
          t.warp(1, r, e), this.warp(o, 1, e);
        }
        return this;
      }
      crossFadeTo(t, e, i) {
        return t.crossFadeFrom(this, e, i);
      }
      stopFading() {
        const t = this._weightInterpolant;
        return null !== t && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this;
      }
      setEffectiveTimeScale(t) {
        return this.timeScale = t, this._effectiveTimeScale = this.paused ? 0 : t, this.stopWarping();
      }
      getEffectiveTimeScale() {
        return this._effectiveTimeScale;
      }
      setDuration(t) {
        return this.timeScale = this._clip.duration / t, this.stopWarping();
      }
      syncWith(t) {
        return this.time = t.time, this.timeScale = t.timeScale, this.stopWarping();
      }
      halt(t) {
        return this.warp(this._effectiveTimeScale, 0, t);
      }
      warp(t, e, i) {
        const n = this._mixer, r = n.time, o = this.timeScale;
        let s = this._timeScaleInterpolant;
        null === s && (s = n._lendControlInterpolant(), this._timeScaleInterpolant = s);
        const a = s.parameterPositions, l = s.sampleValues;
        return a[0] = r, a[1] = r + i, l[0] = t / o, l[1] = e / o, this;
      }
      stopWarping() {
        const t = this._timeScaleInterpolant;
        return null !== t && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this;
      }
      getMixer() {
        return this._mixer;
      }
      getClip() {
        return this._clip;
      }
      getRoot() {
        return this._localRoot || this._mixer._root;
      }
      _update(t, e, i, n) {
        if (!this.enabled) return void this._updateWeight(t);
        const r = this._startTime;
        if (null !== r) {
          const n = (t - r) * i;
          if (n < 0 || 0 === i) return;
          this._startTime = null, e = i * n;
        }
        e *= this._updateTimeScale(t);
        const o = this._updateTime(e), s = this._updateWeight(t);
        if (s > 0) {
          const t = this._interpolants, e = this._propertyBindings;
          switch (this.blendMode) {
            case 2501:
              for (let i = 0, n = t.length; i !== n; ++i) t[i].evaluate(o), e[i].accumulateAdditive(s);
              break;
            case k:
            default:
              for (let i = 0, r = t.length; i !== r; ++i) t[i].evaluate(o), e[i].accumulate(n, s);
          }
        }
      }
      _updateWeight(t) {
        let e = 0;
        if (this.enabled) {
          e = this.weight;
          const i = this._weightInterpolant;
          if (null !== i) {
            const n = i.evaluate(t)[0];
            e *= n, t > i.parameterPositions[1] && (this.stopFading(), 0 === n && (this.enabled = false));
          }
        }
        return this._effectiveWeight = e, e;
      }
      _updateTimeScale(t) {
        let e = 0;
        if (!this.paused) {
          e = this.timeScale;
          const i = this._timeScaleInterpolant;
          if (null !== i) {
            e *= i.evaluate(t)[0], t > i.parameterPositions[1] && (this.stopWarping(), 0 === e ? this.paused = true : this.timeScale = e);
          }
        }
        return this._effectiveTimeScale = e, e;
      }
      _updateTime(t) {
        const e = this._clip.duration, i = this.loop;
        let n = this.time + t, r = this._loopCount;
        const o = 2202 === i;
        if (0 === t) return -1 === r ? n : o && 1 == (1 & r) ? e - n : n;
        if (2200 === i) {
          -1 === r && (this._loopCount = 0, this._setEndings(true, true, false));
          t: {
            if (n >= e) n = e; else {
              if (!(n < 0)) {
                this.time = n;
                break t;
              }
              n = 0;
            }
            this.clampWhenFinished ? this.paused = true : this.enabled = false, this.time = n, this._mixer.dispatchEvent({type: "finished", action: this, direction: t < 0 ? -1 : 1});
          }
        } else {
          if (-1 === r && (t >= 0 ? (r = 0, this._setEndings(true, 0 === this.repetitions, o)) : this._setEndings(0 === this.repetitions, true, o)), n >= e || n < 0) {
            const i = Math.floor(n / e);
            n -= e * i, r += Math.abs(i);
            const s = this.repetitions - r;
            if (s <= 0) this.clampWhenFinished ? this.paused = true : this.enabled = false, n = t > 0 ? e : 0, this.time = n, this._mixer.dispatchEvent({type: "finished", action: this, direction: t > 0 ? 1 : -1}); else {
              if (1 === s) {
                const e = t < 0;
                this._setEndings(e, !e, o);
              } else this._setEndings(false, false, o);
              this._loopCount = r, this.time = n, this._mixer.dispatchEvent({type: "loop", action: this, loopDelta: i});
            }
          } else this.time = n;
          if (o && 1 == (1 & r)) return e - n;
        }
        return n;
      }
      _setEndings(t, e, i) {
        const n = this._interpolantSettings;
        i ? (n.endingStart = V, n.endingEnd = V) : (n.endingStart = t ? this.zeroSlopeAtStart ? V : I : F, n.endingEnd = e ? this.zeroSlopeAtEnd ? V : I : F);
      }
      _scheduleFading(t, e, i) {
        const n = this._mixer, r = n.time;
        let o = this._weightInterpolant;
        null === o && (o = n._lendControlInterpolant(), this._weightInterpolant = o);
        const s = o.parameterPositions, a = o.sampleValues;
        return s[0] = r, a[0] = e, s[1] = r + t, a[1] = i, this;
      }
    }
    (class AnimationMixer extends EventDispatcher {
      constructor(t) {
        super(), this._root = t, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1;
      }
      _bindAction(t, e) {
        const i = t._localRoot || this._root, n = t._clip.tracks, r = n.length, o = t._propertyBindings, s = t._interpolants, a = i.uuid, l = this._bindingsByRootAndName;
        let c = l[a];
        void 0 === c && (c = {}, l[a] = c);
        for (let t = 0; t !== r; ++t) {
          const r = n[t], l = r.name;
          let h = c[l];
          if (void 0 !== h) o[t] = h; else {
            if (h = o[t], void 0 !== h) {
              null === h._cacheIndex && (++h.referenceCount, this._addInactiveBinding(h, a, l));
              continue;
            }
            const n = e && e._propertyBindings[t].binding.parsedPath;
            h = new PropertyMixer(PropertyBinding.create(i, l, n), r.ValueTypeName, r.getValueSize()), ++h.referenceCount, this._addInactiveBinding(h, a, l), o[t] = h;
          }
          s[t].resultBuffer = h.buffer;
        }
      }
      _activateAction(t) {
        if (!this._isActiveAction(t)) {
          if (null === t._cacheIndex) {
            const e = (t._localRoot || this._root).uuid, i = t._clip.uuid, n = this._actionsByClip[i];
            this._bindAction(t, n && n.knownActions[0]), this._addInactiveAction(t, i, e);
          }
          const e = t._propertyBindings;
          for (let t = 0, i = e.length; t !== i; ++t) {
            const i = e[t];
            0 == i.useCount++ && (this._lendBinding(i), i.saveOriginalState());
          }
          this._lendAction(t);
        }
      }
      _deactivateAction(t) {
        if (this._isActiveAction(t)) {
          const e = t._propertyBindings;
          for (let t = 0, i = e.length; t !== i; ++t) {
            const i = e[t];
            0 == --i.useCount && (i.restoreOriginalState(), this._takeBackBinding(i));
          }
          this._takeBackAction(t);
        }
      }
      _initMemoryManager() {
        this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
        const t = this;
        this.stats = {actions: {get total() {
          return t._actions.length;
        }, get inUse() {
          return t._nActiveActions;
        }}, bindings: {get total() {
          return t._bindings.length;
        }, get inUse() {
          return t._nActiveBindings;
        }}, controlInterpolants: {get total() {
          return t._controlInterpolants.length;
        }, get inUse() {
          return t._nActiveControlInterpolants;
        }}};
      }
      _isActiveAction(t) {
        const e = t._cacheIndex;
        return null !== e && e < this._nActiveActions;
      }
      _addInactiveAction(t, e, i) {
        const n = this._actions, r = this._actionsByClip;
        let o = r[e];
        if (void 0 === o) o = {knownActions: [t], actionByRoot: {}}, t._byClipCacheIndex = 0, r[e] = o; else {
          const e = o.knownActions;
          t._byClipCacheIndex = e.length, e.push(t);
        }
        t._cacheIndex = n.length, n.push(t), o.actionByRoot[i] = t;
      }
      _removeInactiveAction(t) {
        const e = this._actions, i = e[e.length - 1], n = t._cacheIndex;
        i._cacheIndex = n, e[n] = i, e.pop(), t._cacheIndex = null;
        const r = t._clip.uuid, o = this._actionsByClip, s = o[r], a = s.knownActions, l = a[a.length - 1], c = t._byClipCacheIndex;
        l._byClipCacheIndex = c, a[c] = l, a.pop(), t._byClipCacheIndex = null;
        delete s.actionByRoot[(t._localRoot || this._root).uuid], 0 === a.length && delete o[r], this._removeInactiveBindingsForAction(t);
      }
      _removeInactiveBindingsForAction(t) {
        const e = t._propertyBindings;
        for (let t = 0, i = e.length; t !== i; ++t) {
          const i = e[t];
          0 == --i.referenceCount && this._removeInactiveBinding(i);
        }
      }
      _lendAction(t) {
        const e = this._actions, i = t._cacheIndex, n = this._nActiveActions++, r = e[n];
        t._cacheIndex = n, e[n] = t, r._cacheIndex = i, e[i] = r;
      }
      _takeBackAction(t) {
        const e = this._actions, i = t._cacheIndex, n = --this._nActiveActions, r = e[n];
        t._cacheIndex = n, e[n] = t, r._cacheIndex = i, e[i] = r;
      }
      _addInactiveBinding(t, e, i) {
        const n = this._bindingsByRootAndName, r = this._bindings;
        let o = n[e];
        void 0 === o && (o = {}, n[e] = o), o[i] = t, t._cacheIndex = r.length, r.push(t);
      }
      _removeInactiveBinding(t) {
        const e = this._bindings, i = t.binding, n = i.rootNode.uuid, r = i.path, o = this._bindingsByRootAndName, s = o[n], a = e[e.length - 1], l = t._cacheIndex;
        a._cacheIndex = l, e[l] = a, e.pop(), delete s[r], 0 === Object.keys(s).length && delete o[n];
      }
      _lendBinding(t) {
        const e = this._bindings, i = t._cacheIndex, n = this._nActiveBindings++, r = e[n];
        t._cacheIndex = n, e[n] = t, r._cacheIndex = i, e[i] = r;
      }
      _takeBackBinding(t) {
        const e = this._bindings, i = t._cacheIndex, n = --this._nActiveBindings, r = e[n];
        t._cacheIndex = n, e[n] = t, r._cacheIndex = i, e[i] = r;
      }
      _lendControlInterpolant() {
        const t = this._controlInterpolants, e = this._nActiveControlInterpolants++;
        let i = t[e];
        return void 0 === i && (i = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), i.__cacheIndex = e, t[e] = i), i;
      }
      _takeBackControlInterpolant(t) {
        const e = this._controlInterpolants, i = t.__cacheIndex, n = --this._nActiveControlInterpolants, r = e[n];
        t.__cacheIndex = n, e[n] = t, r.__cacheIndex = i, e[i] = r;
      }
      clipAction(t, e, i) {
        const n = e || this._root, r = n.uuid;
        let o = "string" == typeof t ? AnimationClip.findByName(n, t) : t;
        const s = null !== o ? o.uuid : t, a = this._actionsByClip[s];
        let l = null;
        if (void 0 === i && (i = null !== o ? o.blendMode : k), void 0 !== a) {
          const t = a.actionByRoot[r];
          if (void 0 !== t && t.blendMode === i) return t;
          l = a.knownActions[0], null === o && (o = l._clip);
        }
        if (null === o) return null;
        const c = new AnimationAction(this, o, e, i);
        return this._bindAction(c, l), this._addInactiveAction(c, s, r), c;
      }
      existingAction(t, e) {
        const i = e || this._root, n = i.uuid, r = "string" == typeof t ? AnimationClip.findByName(i, t) : t, o = r ? r.uuid : t, s = this._actionsByClip[o];
        return void 0 !== s && s.actionByRoot[n] || null;
      }
      stopAllAction() {
        const t = this._actions;
        for (let e = this._nActiveActions - 1; e >= 0; --e) t[e].stop();
        return this;
      }
      update(t) {
        t *= this.timeScale;
        const e = this._actions, i = this._nActiveActions, n = this.time += t, r = Math.sign(t), o = this._accuIndex ^= 1;
        for (let s = 0; s !== i; ++s) {
          e[s]._update(n, t, r, o);
        }
        const s = this._bindings, a = this._nActiveBindings;
        for (let t = 0; t !== a; ++t) s[t].apply(o);
        return this;
      }
      setTime(t) {
        this.time = 0;
        for (let t = 0; t < this._actions.length; t++) this._actions[t].time = 0;
        return this.update(t);
      }
      getRoot() {
        return this._root;
      }
      uncacheClip(t) {
        const e = this._actions, i = t.uuid, n = this._actionsByClip, r = n[i];
        if (void 0 !== r) {
          const t = r.knownActions;
          for (let i = 0, n = t.length; i !== n; ++i) {
            const n = t[i];
            this._deactivateAction(n);
            const r = n._cacheIndex, o = e[e.length - 1];
            n._cacheIndex = null, n._byClipCacheIndex = null, o._cacheIndex = r, e[r] = o, e.pop(), this._removeInactiveBindingsForAction(n);
          }
          delete n[i];
        }
      }
      uncacheRoot(t) {
        const e = t.uuid, i = this._actionsByClip;
        for (const t in i) {
          const n = i[t].actionByRoot[e];
          void 0 !== n && (this._deactivateAction(n), this._removeInactiveAction(n));
        }
        const n = this._bindingsByRootAndName[e];
        if (void 0 !== n) for (const t in n) {
          const e = n[t];
          e.restoreOriginalState(), this._removeInactiveBinding(e);
        }
      }
      uncacheAction(t, e) {
        const i = this.existingAction(t, e);
        null !== i && (this._deactivateAction(i), this._removeInactiveAction(i));
      }
    }.prototype._controlInterpolantsResultBuffer = new Float32Array(1));
    class Uniform {
      constructor(t) {
        "string" == typeof t && (console.warn("THREE.Uniform: Type parameter is no longer needed."), t = arguments[1]), this.value = t;
      }
      clone() {
        return new Uniform(void 0 === this.value.clone ? this.value : this.value.clone());
      }
    }
    (class InstancedInterleavedBuffer extends InterleavedBuffer {
      constructor(t, e, i = 1) {
        super(t, e), this.meshPerAttribute = i;
      }
      copy(t) {
        return super.copy(t), this.meshPerAttribute = t.meshPerAttribute, this;
      }
      clone(t) {
        const e = super.clone(t);
        return e.meshPerAttribute = this.meshPerAttribute, e;
      }
      toJSON(t) {
        const e = super.toJSON(t);
        return e.isInstancedInterleavedBuffer = true, e.meshPerAttribute = this.meshPerAttribute, e;
      }
    }.prototype.isInstancedInterleavedBuffer = true);
    const Ms = new Vector2;
    class Box2 {
      constructor(t = new Vector2(Infinity, Infinity), e = new Vector2(-Infinity, -Infinity)) {
        this.min = t, this.max = e;
      }
      set(t, e) {
        return this.min.copy(t), this.max.copy(e), this;
      }
      setFromPoints(t) {
        this.makeEmpty();
        for (let e = 0, i = t.length; e < i; e++) this.expandByPoint(t[e]);
        return this;
      }
      setFromCenterAndSize(t, e) {
        const i = Ms.copy(e).multiplyScalar(0.5);
        return this.min.copy(t).sub(i), this.max.copy(t).add(i), this;
      }
      clone() {
        return (new this.constructor).copy(this);
      }
      copy(t) {
        return this.min.copy(t.min), this.max.copy(t.max), this;
      }
      makeEmpty() {
        return this.min.x = this.min.y = Infinity, this.max.x = this.max.y = -Infinity, this;
      }
      isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y;
      }
      getCenter(t) {
        return this.isEmpty() ? t.set(0, 0) : t.addVectors(this.min, this.max).multiplyScalar(0.5);
      }
      getSize(t) {
        return this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min);
      }
      expandByPoint(t) {
        return this.min.min(t), this.max.max(t), this;
      }
      expandByVector(t) {
        return this.min.sub(t), this.max.add(t), this;
      }
      expandByScalar(t) {
        return this.min.addScalar(-t), this.max.addScalar(t), this;
      }
      containsPoint(t) {
        return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y);
      }
      containsBox(t) {
        return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y;
      }
      getParameter(t, e) {
        return e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y));
      }
      intersectsBox(t) {
        return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y);
      }
      clampPoint(t, e) {
        return e.copy(t).clamp(this.min, this.max);
      }
      distanceToPoint(t) {
        return Ms.copy(t).clamp(this.min, this.max).sub(t).length();
      }
      intersect(t) {
        return this.min.max(t.min), this.max.min(t.max), this;
      }
      union(t) {
        return this.min.min(t.min), this.max.max(t.max), this;
      }
      translate(t) {
        return this.min.add(t), this.max.add(t), this;
      }
      equals(t) {
        return t.min.equals(this.min) && t.max.equals(this.max);
      }
    }
    Box2.prototype.isBox2 = true;
    (class ImmediateRenderObject extends Object3D {
      constructor(t) {
        super(), this.material = t, this.render = function () {}, this.hasPositions = false, this.hasNormals = false, this.hasColors = false, this.hasUvs = false, this.positionArray = null, this.normalArray = null, this.colorArray = null, this.uvArray = null, this.count = 0;
      }
    }.prototype.isImmediateRenderObject = true);
    const As = new three_module_Vector3, Cs = new Matrix4, Ts = new Matrix4;
    function Es(t) {
      const e = [];
      t && t.isBone && e.push(t);
      for (let i = 0; i < t.children.length; i++) e.push.apply(e, Es(t.children[i]));
      return e;
    }
    const Ls = new Float32Array(1);
    new Int32Array(Ls.buffer);
    Curve.create = function (t, e) {
      return console.log("THREE.Curve.create() has been deprecated"), t.prototype = Object.create(Curve.prototype), t.prototype.constructor = t, t.prototype.getPoint = e, t;
    }, Path.prototype.fromPoints = function (t) {
      return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(t);
    }, class GridHelper extends LineSegments {
      constructor(t = 10, e = 10, i = 4473924, n = 8947848) {
        i = new three_module_Color(i), n = new three_module_Color(n);
        const r = e / 2, o = t / e, s = t / 2, a = [], l = [];
        for (let t = 0, c = 0, h = -s; t <= e; t++, h += o) {
          a.push(-s, 0, h, s, 0, h), a.push(h, 0, -s, h, 0, s);
          const e = t === r ? i : n;
          e.toArray(l, c), c += 3, e.toArray(l, c), c += 3, e.toArray(l, c), c += 3, e.toArray(l, c), c += 3;
        }
        const c = new BufferGeometry;
        c.setAttribute("position", new Float32BufferAttribute(a, 3)), c.setAttribute("color", new Float32BufferAttribute(l, 3));
        super(c, new LineBasicMaterial({vertexColors: true, toneMapped: false})), this.type = "GridHelper";
      }
    }.prototype.setColors = function () {
      console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.");
    }, class SkeletonHelper extends LineSegments {
      constructor(t) {
        const e = Es(t), i = new BufferGeometry, n = [], r = [], o = new three_module_Color(0, 0, 1), s = new three_module_Color(0, 1, 0);
        for (let t = 0; t < e.length; t++) {
          const i = e[t];
          i.parent && i.parent.isBone && (n.push(0, 0, 0), n.push(0, 0, 0), r.push(o.r, o.g, o.b), r.push(s.r, s.g, s.b));
        }
        i.setAttribute("position", new Float32BufferAttribute(n, 3)), i.setAttribute("color", new Float32BufferAttribute(r, 3));
        super(i, new LineBasicMaterial({vertexColors: true, depthTest: false, depthWrite: false, toneMapped: false, transparent: true})), this.type = "SkeletonHelper", this.isSkeletonHelper = true, this.root = t, this.bones = e, this.matrix = t.matrixWorld, this.matrixAutoUpdate = false;
      }
      updateMatrixWorld(t) {
        const e = this.bones, i = this.geometry, n = i.getAttribute("position");
        Ts.copy(this.root.matrixWorld).invert();
        for (let t = 0, i = 0; t < e.length; t++) {
          const r = e[t];
          r.parent && r.parent.isBone && (Cs.multiplyMatrices(Ts, r.matrixWorld), As.setFromMatrixPosition(Cs), n.setXYZ(i, As.x, As.y, As.z), Cs.multiplyMatrices(Ts, r.parent.matrixWorld), As.setFromMatrixPosition(Cs), n.setXYZ(i + 1, As.x, As.y, As.z), i += 2);
        }
        i.getAttribute("position").needsUpdate = true, super.updateMatrixWorld(t);
      }
    }.prototype.update = function () {
      console.error("THREE.SkeletonHelper: update() no longer needs to be called.");
    }, Loader.prototype.extractUrlBase = function (t) {
      return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), LoaderUtils.extractUrlBase(t);
    }, Loader.Handlers = {add: function () {
      console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.");
    }, get: function () {
      console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.");
    }}, Box2.prototype.center = function (t) {
      return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(t);
    }, Box2.prototype.empty = function () {
      return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty();
    }, Box2.prototype.isIntersectionBox = function (t) {
      return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t);
    }, Box2.prototype.size = function (t) {
      return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(t);
    }, Box3.prototype.center = function (t) {
      return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(t);
    }, Box3.prototype.empty = function () {
      return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty();
    }, Box3.prototype.isIntersectionBox = function (t) {
      return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t);
    }, Box3.prototype.isIntersectionSphere = function (t) {
      return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t);
    }, Box3.prototype.size = function (t) {
      return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(t);
    }, Sphere.prototype.empty = function () {
      return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."), this.isEmpty();
    }, Frustum.prototype.setFromMatrix = function (t) {
      return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."), this.setFromProjectionMatrix(t);
    }, Matrix3.prototype.flattenToArrayOffset = function (t, e) {
      return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e);
    }, Matrix3.prototype.multiplyVector3 = function (t) {
      return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), t.applyMatrix3(this);
    }, Matrix3.prototype.multiplyVector3Array = function () {
      console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.");
    }, Matrix3.prototype.applyToBufferAttribute = function (t) {
      return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."), t.applyMatrix3(this);
    }, Matrix3.prototype.applyToVector3Array = function () {
      console.error("THREE.Matrix3: .applyToVector3Array() has been removed.");
    }, Matrix3.prototype.getInverse = function (t) {
      return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(t).invert();
    }, Matrix4.prototype.extractPosition = function (t) {
      return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(t);
    }, Matrix4.prototype.flattenToArrayOffset = function (t, e) {
      return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e);
    }, Matrix4.prototype.getPosition = function () {
      return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), (new three_module_Vector3).setFromMatrixColumn(this, 3);
    }, Matrix4.prototype.setRotationFromQuaternion = function (t) {
      return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(t);
    }, Matrix4.prototype.multiplyToArray = function () {
      console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
    }, Matrix4.prototype.multiplyVector3 = function (t) {
      return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this);
    }, Matrix4.prototype.multiplyVector4 = function (t) {
      return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this);
    }, Matrix4.prototype.multiplyVector3Array = function () {
      console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.");
    }, Matrix4.prototype.rotateAxis = function (t) {
      console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), t.transformDirection(this);
    }, Matrix4.prototype.crossVector = function (t) {
      return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this);
    }, Matrix4.prototype.translate = function () {
      console.error("THREE.Matrix4: .translate() has been removed.");
    }, Matrix4.prototype.rotateX = function () {
      console.error("THREE.Matrix4: .rotateX() has been removed.");
    }, Matrix4.prototype.rotateY = function () {
      console.error("THREE.Matrix4: .rotateY() has been removed.");
    }, Matrix4.prototype.rotateZ = function () {
      console.error("THREE.Matrix4: .rotateZ() has been removed.");
    }, Matrix4.prototype.rotateByAxis = function () {
      console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
    }, Matrix4.prototype.applyToBufferAttribute = function (t) {
      return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."), t.applyMatrix4(this);
    }, Matrix4.prototype.applyToVector3Array = function () {
      console.error("THREE.Matrix4: .applyToVector3Array() has been removed.");
    }, Matrix4.prototype.makeFrustum = function (t, e, i, n, r, o) {
      return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(t, e, n, i, r, o);
    }, Matrix4.prototype.getInverse = function (t) {
      return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(t).invert();
    }, Plane.prototype.isIntersectionLine = function (t) {
      return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(t);
    }, Quaternion.prototype.multiplyVector3 = function (t) {
      return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), t.applyQuaternion(this);
    }, Quaternion.prototype.inverse = function () {
      return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."), this.invert();
    }, Ray.prototype.isIntersectionBox = function (t) {
      return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t);
    }, Ray.prototype.isIntersectionPlane = function (t) {
      return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(t);
    }, Ray.prototype.isIntersectionSphere = function (t) {
      return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t);
    }, Triangle.prototype.area = function () {
      return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea();
    }, Triangle.prototype.barycoordFromPoint = function (t, e) {
      return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(t, e);
    }, Triangle.prototype.midpoint = function (t) {
      return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(t);
    }, Triangle.prototypenormal = function (t) {
      return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(t);
    }, Triangle.prototype.plane = function (t) {
      return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(t);
    }, Triangle.barycoordFromPoint = function (t, e, i, n, r) {
      return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), Triangle.getBarycoord(t, e, i, n, r);
    }, Triangle.normal = function (t, e, i, n) {
      return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), Triangle.getNormal(t, e, i, n);
    }, Shape.prototype.extractAllPoints = function (t) {
      return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(t);
    }, Shape.prototype.extrude = function (t) {
      return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new ExtrudeGeometry(this, t);
    }, Shape.prototype.makeGeometry = function (t) {
      return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new ShapeGeometry(this, t);
    }, Vector2.prototype.fromAttribute = function (t, e, i) {
      return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, i);
    }, Vector2.prototype.distanceToManhattan = function (t) {
      return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t);
    }, Vector2.prototype.lengthManhattan = function () {
      return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
    }, three_module_Vector3.prototype.setEulerFromRotationMatrix = function () {
      console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.");
    }, three_module_Vector3.prototype.setEulerFromQuaternion = function () {
      console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.");
    }, three_module_Vector3.prototype.getPositionFromMatrix = function (t) {
      return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(t);
    }, three_module_Vector3.prototype.getScaleFromMatrix = function (t) {
      return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(t);
    }, three_module_Vector3.prototype.getColumnFromMatrix = function (t, e) {
      return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(e, t);
    }, three_module_Vector3.prototype.applyProjection = function (t) {
      return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(t);
    }, three_module_Vector3.prototype.fromAttribute = function (t, e, i) {
      return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, i);
    }, three_module_Vector3.prototype.distanceToManhattan = function (t) {
      return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t);
    }, three_module_Vector3.prototype.lengthManhattan = function () {
      return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
    }, Vector4.prototype.fromAttribute = function (t, e, i) {
      return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, i);
    }, Vector4.prototype.lengthManhattan = function () {
      return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
    }, Object3D.prototype.getChildByName = function (t) {
      return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(t);
    }, Object3D.prototype.renderDepth = function () {
      console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.");
    }, Object3D.prototype.translate = function (t, e) {
      return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(e, t);
    }, Object3D.prototype.getWorldRotation = function () {
      console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.");
    }, Object3D.prototype.applyMatrix = function (t) {
      return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t);
    }, Object.defineProperties(Object3D.prototype, {eulerOrder: {get: function () {
      return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order;
    }, set: function (t) {
      console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = t;
    }}, useQuaternion: {get: function () {
      console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
    }, set: function () {
      console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
    }}}), Mesh.prototype.setDrawMode = function () {
      console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
    }, Object.defineProperties(Mesh.prototype, {drawMode: {get: function () {
      return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."), 0;
    }, set: function () {
      console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
    }}}), SkinnedMesh.prototype.initBones = function () {
      console.error("THREE.SkinnedMesh: initBones() has been removed.");
    }, PerspectiveCamera.prototype.setLens = function (t, e) {
      console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== e && (this.filmGauge = e), this.setFocalLength(t);
    }, Object.defineProperties(Light.prototype, {onlyShadow: {set: function () {
      console.warn("THREE.Light: .onlyShadow has been removed.");
    }}, shadowCameraFov: {set: function (t) {
      console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = t;
    }}, shadowCameraLeft: {set: function (t) {
      console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = t;
    }}, shadowCameraRight: {set: function (t) {
      console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = t;
    }}, shadowCameraTop: {set: function (t) {
      console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = t;
    }}, shadowCameraBottom: {set: function (t) {
      console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = t;
    }}, shadowCameraNear: {set: function (t) {
      console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = t;
    }}, shadowCameraFar: {set: function (t) {
      console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = t;
    }}, shadowCameraVisible: {set: function () {
      console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.");
    }}, shadowBias: {set: function (t) {
      console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = t;
    }}, shadowDarkness: {set: function () {
      console.warn("THREE.Light: .shadowDarkness has been removed.");
    }}, shadowMapWidth: {set: function (t) {
      console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = t;
    }}, shadowMapHeight: {set: function (t) {
      console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = t;
    }}}), Object.defineProperties(BufferAttribute.prototype, {length: {get: function () {
      return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length;
    }}, dynamic: {get: function () {
      return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.usage === W;
    }, set: function () {
      console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.setUsage(W);
    }}}), BufferAttribute.prototype.setDynamic = function (t) {
      return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(true === t ? W : H), this;
    }, BufferAttribute.prototype.copyIndicesArray = function () {
      console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.");
    }, BufferAttribute.prototype.setArray = function () {
      console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
    }, BufferGeometry.prototype.addIndex = function (t) {
      console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(t);
    }, BufferGeometry.prototype.addAttribute = function (t, e) {
      return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."), e && e.isBufferAttribute || e && e.isInterleavedBufferAttribute ? "index" === t ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(e), this) : this.setAttribute(t, e) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.setAttribute(t, new BufferAttribute(arguments[1], arguments[2])));
    }, BufferGeometry.prototype.addDrawCall = function (t, e, i) {
      void 0 !== i && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(t, e);
    }, BufferGeometry.prototype.clearDrawCalls = function () {
      console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups();
    }, BufferGeometry.prototype.computeOffsets = function () {
      console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
    }, BufferGeometry.prototype.removeAttribute = function (t) {
      return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."), this.deleteAttribute(t);
    }, BufferGeometry.prototype.applyMatrix = function (t) {
      return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t);
    }, Object.defineProperties(BufferGeometry.prototype, {drawcalls: {get: function () {
      return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups;
    }}, offsets: {get: function () {
      return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups;
    }}}), InterleavedBuffer.prototype.setDynamic = function (t) {
      return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(true === t ? W : H), this;
    }, InterleavedBuffer.prototype.setArray = function () {
      console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
    }, ExtrudeGeometry.prototype.getArrays = function () {
      console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.");
    }, ExtrudeGeometry.prototype.addShapeList = function () {
      console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.");
    }, ExtrudeGeometry.prototype.addShape = function () {
      console.error("THREE.ExtrudeGeometry: .addShape() has been removed.");
    }, Scene.prototype.dispose = function () {
      console.error("THREE.Scene: .dispose() has been removed.");
    }, Uniform.prototype.onUpdate = function () {
      return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this;
    }, Object.defineProperties(Material.prototype, {wrapAround: {get: function () {
      console.warn("THREE.Material: .wrapAround has been removed.");
    }, set: function () {
      console.warn("THREE.Material: .wrapAround has been removed.");
    }}, overdraw: {get: function () {
      console.warn("THREE.Material: .overdraw has been removed.");
    }, set: function () {
      console.warn("THREE.Material: .overdraw has been removed.");
    }}, wrapRGB: {get: function () {
      return console.warn("THREE.Material: .wrapRGB has been removed."), new three_module_Color;
    }}, shading: {get: function () {
      console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
    }, set: function (t) {
      console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === t;
    }}, stencilMask: {get: function () {
      return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask;
    }, set: function (t) {
      console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask = t;
    }}, vertexTangents: {get: function () {
      console.warn("THREE." + this.type + ": .vertexTangents has been removed.");
    }, set: function () {
      console.warn("THREE." + this.type + ": .vertexTangents has been removed.");
    }}}), Object.defineProperties(ShaderMaterial.prototype, {derivatives: {get: function () {
      return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives;
    }, set: function (t) {
      console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = t;
    }}}), Dr.prototype.clearTarget = function (t, e, i, n) {
      console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(t), this.clear(e, i, n);
    }, Dr.prototype.animate = function (t) {
      console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(t);
    }, Dr.prototype.getCurrentRenderTarget = function () {
      return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget();
    }, Dr.prototype.getMaxAnisotropy = function () {
      return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy();
    }, Dr.prototype.getPrecision = function () {
      return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision;
    }, Dr.prototype.resetGLState = function () {
      return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset();
    }, Dr.prototype.supportsFloatTextures = function () {
      return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float");
    }, Dr.prototype.supportsHalfFloatTextures = function () {
      return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float");
    }, Dr.prototype.supportsStandardDerivatives = function () {
      return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives");
    }, Dr.prototype.supportsCompressedTextureS3TC = function () {
      return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc");
    }, Dr.prototype.supportsCompressedTexturePVRTC = function () {
      return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc");
    }, Dr.prototype.supportsBlendMinMax = function () {
      return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax");
    }, Dr.prototype.supportsVertexTextures = function () {
      return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures;
    }, Dr.prototype.supportsInstancedArrays = function () {
      return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays");
    }, Dr.prototype.enableScissorTest = function (t) {
      console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(t);
    }, Dr.prototype.initMaterial = function () {
      console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
    }, Dr.prototype.addPrePlugin = function () {
      console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
    }, Dr.prototype.addPostPlugin = function () {
      console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
    }, Dr.prototype.updateShadowMap = function () {
      console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
    }, Dr.prototype.setFaceCulling = function () {
      console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.");
    }, Dr.prototype.allocTextureUnit = function () {
      console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.");
    }, Dr.prototype.setTexture = function () {
      console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
    }, Dr.prototype.setTexture2D = function () {
      console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.");
    }, Dr.prototype.setTextureCube = function () {
      console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.");
    }, Dr.prototype.getActiveMipMapLevel = function () {
      return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."), this.getActiveMipmapLevel();
    }, Object.defineProperties(Dr.prototype, {shadowMapEnabled: {get: function () {
      return this.shadowMap.enabled;
    }, set: function (t) {
      console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = t;
    }}, shadowMapType: {get: function () {
      return this.shadowMap.type;
    }, set: function (t) {
      console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = t;
    }}, shadowMapCullFace: {get: function () {
      console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
    }, set: function () {
      console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
    }}, context: {get: function () {
      return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."), this.getContext();
    }}, vr: {get: function () {
      return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"), this.xr;
    }}, gammaInput: {get: function () {
      return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."), false;
    }, set: function () {
      console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
    }}, gammaOutput: {get: function () {
      return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), false;
    }, set: function (t) {
      console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), this.outputEncoding = true === t ? G : N;
    }}, toneMappingWhitePoint: {get: function () {
      return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."), 1;
    }, set: function () {
      console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.");
    }}}), Object.defineProperties(Mr.prototype, {cullFace: {get: function () {
      console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
    }, set: function () {
      console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
    }}, renderReverseSided: {get: function () {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
    }, set: function () {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
    }}, renderSingleSided: {get: function () {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
    }, set: function () {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
    }}}), Object.defineProperties(WebGLRenderTarget.prototype, {wrapS: {get: function () {
      return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS;
    }, set: function (t) {
      console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = t;
    }}, wrapT: {get: function () {
      return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT;
    }, set: function (t) {
      console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = t;
    }}, magFilter: {get: function () {
      return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter;
    }, set: function (t) {
      console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = t;
    }}, minFilter: {get: function () {
      return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter;
    }, set: function (t) {
      console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = t;
    }}, anisotropy: {get: function () {
      return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy;
    }, set: function (t) {
      console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = t;
    }}, offset: {get: function () {
      return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset;
    }, set: function (t) {
      console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = t;
    }}, repeat: {get: function () {
      return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat;
    }, set: function (t) {
      console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = t;
    }}, format: {get: function () {
      return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format;
    }, set: function (t) {
      console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = t;
    }}, type: {get: function () {
      return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type;
    }, set: function (t) {
      console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = t;
    }}, generateMipmaps: {get: function () {
      return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps;
    }, set: function (t) {
      console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = t;
    }}}), Audio.prototype.load = function (t) {
      console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
      const e = this;
      return (new AudioLoader).load(t, function (t) {
        e.setBuffer(t);
      }), this;
    }, CubeCamera.prototype.updateCubeMap = function (t, e) {
      return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(t, e);
    }, CubeCamera.prototype.clear = function (t, e, i, n) {
      return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."), this.renderTarget.clear(t, e, i, n);
    }, ImageUtils.crossOrigin = void 0, ImageUtils.loadTexture = function (t, e, i, n) {
      console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
      const r = new TextureLoader;
      r.setCrossOrigin(this.crossOrigin);
      const o = r.load(t, i, void 0, n);
      return e && (o.mapping = e), o;
    }, ImageUtils.loadTextureCube = function (t, e, i, n) {
      console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
      const r = new CubeTextureLoader;
      r.setCrossOrigin(this.crossOrigin);
      const o = r.load(t, i, void 0, n);
      return e && (o.mapping = e), o;
    }, ImageUtils.loadCompressedTexture = function () {
      console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.");
    }, ImageUtils.loadCompressedTextureCube = function () {
      console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.");
    };
    "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {detail: {revision: "132"}})), "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = "132");
    class Color {
      constructor(t = 255, e = 255, i = 255) {
        this.setScalarRGB(t, e, i);
      }
      setScalarR(t) {
        return this._r = Math.round(t) || 0, this;
      }
      setScalarG(t) {
        return this._g = Math.round(t) || 0, this;
      }
      setScalarB(t) {
        return this._b = Math.round(t) || 0, this;
      }
      set r (t) {
        this.setScalarR(t);
      }
      set g (t) {
        this.setScalarG(t);
      }
      set b (t) {
        this.setScalarB(t);
      }
      get r() {
        return this._r;
      }
      get g() {
        return this._g;
      }
      get b() {
        return this._b;
      }
      setScalarRGB(t, e, i) {
        return this.setScalarR(t).setScalarG(e).setScalarB(i);
      }
      setScalar(t) {
        return this.setScalarR(t >> 16 & 255).setScalarG(t >> 8 & 255).setScalarB(255 & t);
      }
      getScalar() {
        return parseInt(`0x${Color.partOfRgbToHex(this.r)}${Color.partOfRgbToHex(this.g)}${Color.partOfRgbToHex(this.b)}}`, 16);
      }
      static partOfRgbToHex(t) {
        let e = Number(t).toString(16);
        return e.length < 2 && (e = "0" + e), e;
      }
      setHex(t) {
        t = t.replace("#", "");
        const e = parseInt(t, 16);
        return this.setScalarRGB(e >> 16 & 255, e >> 8 & 255, 255 & e);
      }
      getHex() {
        return `#${Color.partOfRgbToHex(this.r)}${Color.partOfRgbToHex(this.g)}${Color.partOfRgbToHex(this.b)}`;
      }
      setArray(t) {
        return this.setScalarRGB(t[0], t[1], t[2]);
      }
      addScalarR(t) {
        return this.setScalarR(this.r + t);
      }
      addScalarG(t) {
        return this.setScalarG(this.g + t);
      }
      addScalarB(t) {
        return this.setScalarB(this.b + t);
      }
      addScalar(t) {
        return this.addScalarR(t).addScalarG(t).addScalarB(t);
      }
      addR(t) {
        return this.addScalarR(t.r);
      }
      addG(t) {
        return this.addScalarG(t.g);
      }
      addB(t) {
        return this.addScalarB(t.b);
      }
      add(t) {
        return this.addR(t).addG(t).addB(t);
      }
      subtractScalarR(t) {
        return this.setScalarR(this.r - t);
      }
      subtractScalarG(t) {
        return this.setScalarG(this.g - t);
      }
      subtractScalarB(t) {
        return this.setScalarB(this.b - t);
      }
      subtractScalar(t) {
        return this.subtractScalarR(t).subtractScalarG(t).subtractScalarB(t);
      }
      subtractR(t) {
        return this.subtractScalarR(t.r);
      }
      subtractG(t) {
        return this.subtractScalarG(t.g);
      }
      subtractB(t) {
        return this.subtractScalarB(t.b);
      }
      subtract(t) {
        return this.subtractR(t).subtractG(t).subtractB(t);
      }
      multiplyScalarR(t) {
        return this.setScalarR(this.r * t);
      }
      multiplyScalarG(t) {
        return this.setScalarG(this.g * t);
      }
      multiplyScalarB(t) {
        return this.setScalarB(this.b * t);
      }
      multiplyScalar(t) {
        return this.multiplyScalarR(t).multiplyScalarG(t).multiplyScalarB(t);
      }
      multiplyR(t) {
        return this.multiplyScalarR(t.r);
      }
      multiplyG(t) {
        return this.multiplyScalarG(t.g);
      }
      multiplyB(t) {
        return this.multiplyScalarB(t.b);
      }
      multiply(t) {
        return this.multiplyR(t).multiplyG(t).multiplyB(t);
      }
      divideScalarR(t) {
        return this.setScalarR(this.r / t);
      }
      divideScalarG(t) {
        return this.setScalarG(this.g / t);
      }
      divideScalarB(t) {
        return this.setScalarB(this.b / t);
      }
      divideScalar(t) {
        return this.divideScalarR(t).divideScalarG(t).divideScalarB(t);
      }
      divideR(t) {
        return this.divideScalarR(t.r);
      }
      divideG(t) {
        return this.divideScalarG(t.g);
      }
      divideB(t) {
        return this.divideScalarB(t.b);
      }
      divide(t) {
        return this.divideR(t).divideG(t).divideB(t);
      }
      copy(t) {
        return this.setScalarRGB(t.r, t.g, t.b);
      }
      clone() {
        return new Color(this.r, this.g, this.b);
      }
      isEqualScalar(t) {
        return this.r === t && this.g === t && this.b === t;
      }
      isEqualTo(t) {
        return this.r === t.r && this.g === t.g && this.b === t.b;
      }
      toGrayScale() {
        const t = 0.58 * this.r + 0.17 * this.g + 0.8 * this.b;
        return this.setScalarR(t).setScalarG(t).setScalarB(t);
      }
      toThreeColor() {
        return new three_module_Color(this.r / 255, this.g / 255, this.b / 255);
      }
      static fromThreeColor(t) {
        return new Color(t.r, t.g, t.b).multiplyScalar(255);
      }
      static fromScalar(t) {
        return (new Color).setScalar(t);
      }
      static fromHex(t) {
        return (new Color).setHex(t);
      }
      static fromArray(t) {
        return (new Color).setArray(t);
      }
    }
    Color.WHITE = Color.fromScalar(16777215), Color.GRAY = Color.fromScalar(11184810), Color.RED = Color.fromScalar(16711680), Color.GREEN = Color.fromScalar(65280), Color.YELLOW = Color.fromScalar(16777045), Color.BLUE = Color.fromScalar(255), Color.AQUA = Color.fromScalar(5636095), Color.BLACK = Color.fromScalar(0);
    class Box2dUtils {
      static toBox2DValue(t) {
        return t / Box2dUtils.POSITION_SCALE;
      }
      static fromBox2DValue(t) {
        return t * Box2dUtils.POSITION_SCALE;
      }
      static getThreeRotationFromBox2d(t) {
        return ValueUtils.absAngle(t - Math.PI / 2);
      }
      static getBox2dRotationFromThree(t) {
        return ValueUtils.absAngle(t + Math.PI / 2);
      }
    }
    Box2dUtils.POSITION_SCALE = 64;
    var Ds = __webpack_require__(63);
    class AbstractVector2 {
      constructor(t = 0, e = 0) {
        this._x = 0, this._y = 0, this.x = t, this.y = e;
      }
      enableEvents() {
        this.events = new Events;
      }
      setScalarX(t) {
        let e = false;
        return this._x !== t && (e = true), this._x = t || 0, e && this.events && this.events.emit("change", {axis: "x"}), this;
      }
      setScalarY(t) {
        let e = false;
        return this._y !== t && (e = true), this._y = t || 0, e && this.events && this.events.emit("change", {axis: "y"}), this;
      }
      setScalar(t) {
        return this.setScalarX(t).setScalarY(t);
      }
      set x (t) {
        this.setScalarX(t);
      }
      set y (t) {
        this.setScalarY(t);
      }
      setX(t) {
        return this.setScalarX(t.x);
      }
      setY(t) {
        return this.setScalarY(t.y);
      }
      setXY(t) {
        return this.setScalarX(t.x).setScalarY(t.y);
      }
      setScalarXY(t, e) {
        return this.setScalarX(t).setScalarY(e);
      }
      set(t) {
        return this.setX(t).setY(t);
      }
      copy(t) {
        return this.set(t);
      }
      get x() {
        return this._x;
      }
      get y() {
        return this._y;
      }
      addScalarX(t) {
        return this.setScalarX(this.x + t);
      }
      addScalarY(t) {
        return this.setScalarY(this.y + t);
      }
      addScalar(t) {
        return this.addScalarX(t).addScalarY(t);
      }
      addX(t) {
        return this.addScalarX(t.x);
      }
      addY(t) {
        return this.addScalarY(t.y);
      }
      add(t) {
        return this.addX(t).addY(t);
      }
      smoothlyAddScalarX(t, e, i = 0.01) {
        return this.setScalarX(ValueUtils.smoothValue(t, this.x, e, i));
      }
      smoothlyAddScalarY(t, e, i = 0.01) {
        return this.setScalarY(ValueUtils.smoothValue(t, this.y, e, i));
      }
      smoothlyAddScalar(t, e, i = 0.01) {
        return this.smoothlyAddScalarX(t, e, i).smoothlyAddScalarY(t, e, i);
      }
      smoothlyAddX(t, e, i = 0.01) {
        return this.smoothlyAddScalarX(t.x, e, i);
      }
      smoothlyAddY(t, e, i = 0.01) {
        return this.smoothlyAddScalarY(t.y, e, i);
      }
      smoothlyAdd(t, e = 12) {
        return this.smoothlyAddX(t, e).smoothlyAddY(t, e);
      }
      subtractScalarX(t) {
        return this.setScalarX(this.x - t);
      }
      subtractScalarY(t) {
        return this.setScalarY(this.y - t);
      }
      subtractScalar(t) {
        return this.subtractScalarX(t).subtractScalarY(t);
      }
      subtractX(t) {
        return this.subtractScalarX(t.x);
      }
      subtractY(t) {
        return this.subtractScalarY(t.y);
      }
      subtract(t) {
        return this.subtractX(t).subtractY(t);
      }
      multiplyScalarX(t) {
        return this.setScalarX(this.x * t);
      }
      multiplyScalarY(t) {
        return this.setScalarY(this.y * t);
      }
      multiplyScalar(t) {
        return this.multiplyScalarX(t).multiplyScalarY(t);
      }
      multiplyX(t) {
        return this.multiplyScalarX(t.x);
      }
      multiplyY(t) {
        return this.multiplyScalarY(t.y);
      }
      multiply(t) {
        return this.multiplyX(t).multiplyY(t);
      }
      divideScalarX(t) {
        return this.setScalarX(this.x / t);
      }
      divideScalarY(t) {
        return this.setScalarY(this.y / t);
      }
      divideScalar(t) {
        return this.divideScalarX(t).divideScalarY(t);
      }
      divideX(t) {
        return this.divideScalarX(t.x);
      }
      divideY(t) {
        return this.divideScalarY(t.y);
      }
      divide(t) {
        return this.divideX(t).divideY(t);
      }
      invertX() {
        return this.multiplyScalarX(-1);
      }
      invertY() {
        return this.multiplyScalarY(-1);
      }
      invert() {
        return this.invertX().invertY();
      }
      normalize() {
        const t = this.length();
        return 0 !== t && this.divide(Vector2_Vector2.fromScalar(t)), this;
      }
      length() {
        return Math.sqrt(this.lengthSq());
      }
      lengthSq() {
        return this.x * this.x + this.y * this.y;
      }
      ceilX() {
        return this.setScalarX(Math.ceil(this.x));
      }
      ceilY() {
        return this.setScalarY(Math.ceil(this.y));
      }
      ceil() {
        return this.ceilX().ceilY();
      }
      floorX() {
        return this.setScalarX(Math.floor(this.x));
      }
      floorY() {
        return this.setScalarY(Math.floor(this.y));
      }
      floor() {
        return this.floorX().floorY();
      }
      roundX() {
        return this.setScalarX(Math.round(this.x));
      }
      roundY() {
        return this.setScalarY(Math.round(this.y));
      }
      round() {
        return this.roundX().roundY();
      }
      toFixedScalarX(t = 8) {
        return this.setScalarX(parseFloat(this.x.toFixed(t)));
      }
      toFixedScalarY(t = 8) {
        return this.setScalarY(parseFloat(this.y.toFixed(t)));
      }
      toFixedScalar(t = 8) {
        return this.toFixedScalarX(t).toFixedScalarY(t);
      }
      toFixedX(t) {
        return this.toFixedScalarX(t.x);
      }
      toFixedY(t) {
        return this.toFixedScalarY(t.y);
      }
      toFixed(t) {
        return this.toFixedX(t).toFixedY(t);
      }
      minX(t) {
        return this.setScalarX(Math.max(this.x, t));
      }
      minY(t) {
        return this.setScalarY(Math.max(this.y, t));
      }
      min(t) {
        return this.minX(t).minY(t);
      }
      getMin() {
        return Math.min(this.x, this.y);
      }
      maxX(t) {
        return this.setScalarX(Math.min(this.x, t));
      }
      maxY(t) {
        return this.setScalarY(Math.min(this.y, t));
      }
      max(t) {
        return this.maxX(t).maxY(t);
      }
      getMax() {
        return Math.max(this.x, this.y);
      }
      maxLimit(t) {
        return this.length() > t ? this.normalize().multiplyScalar(t) : this;
      }
      dot(t) {
        return this.x * t.x + this.y * t.y;
      }
      isEqualScalar(t) {
        return this.x === t && this.y === t;
      }
      isZero() {
        return this.isEqualScalar(0);
      }
      isEqualTo(t) {
        return this.x === t.x && this.y === t.y;
      }
      applyFromObject(t) {
        return false === ValueUtils.isUndefinedOrNull(t.x) && this.setScalarX(t.x), false === ValueUtils.isUndefinedOrNull(t.y) && this.setScalarY(t.y), false === ValueUtils.isUndefinedOrNull(t._x) && this.setScalarX(t._x), false === ValueUtils.isUndefinedOrNull(t._y) && this.setScalarY(t._y), this;
      }
      toString() {
        return `x: ${this.x}, y: ${this.y}`;
      }
      toArray() {
        return [this.x, this.y];
      }
      toObject() {
        return {x: this.x, y: this.y};
      }
      toBox2dVec() {
        return new Ds.Common.Math.b2Vec2(Box2dUtils.toBox2DValue(this.x), Box2dUtils.toBox2DValue(this.y));
      }
      toThreeVector3(t = 0) {
        return new three_module_Vector3(this.x, this.y, t);
      }
      toThreeVector2() {
        return new Vector2(this.x, this.y);
      }
    }
    class Vector3 extends AbstractVector2 {
      constructor(t = 0, e = 0, i = 0) {
        super(t, e), this._z = 0, this.z = i;
      }
      setScalarZ(t) {
        let e = false;
        return this._z !== t && (e = true), this._z = t || 0, e && this.events && this.events.emit("change", {axis: "z"}), this;
      }
      setScalar(t) {
        return this.setScalarXYZ(t, t, t);
      }
      set x (t) {
        this.setScalarX(t);
      }
      set y (t) {
        this.setScalarY(t);
      }
      set z (t) {
        this.setScalarZ(t);
      }
      setScalarXYZ(t, e, i) {
        return this.setScalarX(t).setScalarY(e).setScalarZ(i);
      }
      set(t) {
        return this.setX(t).setY(t).setZ(t);
      }
      copy(t) {
        return this.set(t);
      }
      setZ(t) {
        return this.setScalarZ(t.z);
      }
      get x() {
        return super.x;
      }
      get y() {
        return super.y;
      }
      get z() {
        return this._z;
      }
      addScalarZ(t) {
        return this.setScalarZ(this.z + t);
      }
      addScalar(t) {
        return this.addScalarX(t).addScalarY(t).addScalarZ(t);
      }
      addZ(t) {
        return this.addScalarZ(t.z);
      }
      add(t) {
        return this.addX(t).addY(t).addZ(t);
      }
      smoothlyAddScalarZ(t, e, i = 0.01) {
        return this.setScalarZ(ValueUtils.smoothValue(t, this.z, e, i));
      }
      smoothlyAddScalar(t, e) {
        return this.smoothlyAddScalarX(t, e).smoothlyAddScalarY(t, e).smoothlyAddScalarZ(t, e);
      }
      smoothlyAddZ(t, e, i = 0.01) {
        return this.smoothlyAddScalarZ(t.z, e, i);
      }
      smoothlyAdd(t, e = 12, i = 0.01) {
        return this.smoothlyAddX(t, e, i).smoothlyAddY(t, e, i).smoothlyAddZ(t, e, i);
      }
      subtractScalarZ(t) {
        return this.setScalarZ(this.z - t);
      }
      subtractScalar(t) {
        return this.subtractScalarX(t).subtractScalarY(t).subtractScalarZ(t);
      }
      subtractZ(t) {
        return this.subtractScalarZ(t.z);
      }
      subtract(t) {
        return this.subtractX(t).subtractY(t).subtractZ(t);
      }
      multiplyScalarZ(t) {
        return this.setScalarZ(this.z * t);
      }
      multiplyScalar(t) {
        return this.multiplyScalarX(t).multiplyScalarY(t).multiplyScalarZ(t);
      }
      multiplyZ(t) {
        return this.multiplyScalarZ(t.z);
      }
      multiply(t) {
        return this.multiplyX(t).multiplyY(t).multiplyZ(t);
      }
      divideScalarZ(t) {
        return this.setScalarZ(this.z / t);
      }
      divideScalar(t) {
        return this.divideScalarX(t).divideScalarY(t).divideScalarZ(t);
      }
      divideZ(t) {
        return this.divideScalarZ(t.z);
      }
      divide(t) {
        return this.divideX(t).divideY(t).divideZ(t);
      }
      to(t) {
        return t.clone().subtract(this);
      }
      invertZ() {
        return this.multiplyScalarZ(-1);
      }
      invert() {
        return this.invertX().invertY().invertZ();
      }
      lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z;
      }
      length() {
        return Math.sqrt(this.lengthSq());
      }
      normalize() {
        let t = this.length();
        return 0 !== t && this.divide(new Vector3(t, t, t)), this;
      }
      ceilZ() {
        return this.setScalarZ(Math.ceil(this.z));
      }
      ceil() {
        return this.ceilX().ceilY().ceilZ();
      }
      floorZ() {
        return this.setScalarZ(Math.floor(this.z));
      }
      floor() {
        return this.floorX().floorY().floorZ();
      }
      roundZ() {
        return this.setScalarZ(Math.round(this.z));
      }
      round() {
        return this.roundX().roundY().roundZ();
      }
      toFixedScalarZ(t = 8) {
        return this.setScalarZ(parseFloat(this.z.toFixed(t)));
      }
      toFixedScalar(t = 8) {
        return this.toFixedScalarX(t).toFixedScalarY(t).toFixedScalarZ(t);
      }
      toFixedZ(t) {
        return this.toFixedScalarZ(t.z);
      }
      toFixed(t) {
        return this.toFixedX(t).toFixedY(t).toFixedZ(t);
      }
      minZ(t) {
        return this.setScalarZ(Math.max(this.z, t));
      }
      min(t) {
        return this.minX(t).minY(t).minZ(t);
      }
      getMin() {
        return Math.min(this.x, this.y, this.z);
      }
      maxZ(t) {
        return this.setScalarZ(Math.min(this.z, t));
      }
      max(t) {
        return this.maxX(t).maxY(t).maxZ(t);
      }
      getMax() {
        return Math.max(this.x, this.y, this.z);
      }
      clone() {
        return new Vector3(this.x, this.y, this.z);
      }
      dot(t) {
        return this.x * t.x + this.y * t.y + this.z * t.z;
      }
      isEqualScalar(t) {
        return this.x === t && this.y === t && this.z === t;
      }
      isZero() {
        return this.isEqualScalar(0);
      }
      isEqualTo(t) {
        return this.x === t.x && this.y === t.y && this.z === t.z;
      }
      applyFromObject(t) {
        return super.applyFromObject(t), false === ValueUtils.isUndefinedOrNull(t.z) && this.setScalarZ(t.z), false === ValueUtils.isUndefinedOrNull(t._z) && this.setScalarZ(t._z), this;
      }
      static random(t = 0, e = 1) {
        return new Vector3(Math.floor(Randomize.getRandomFloat(t, e)), Math.floor(Randomize.getRandomFloat(t, e)), Math.floor(Randomize.getRandomFloat(t, e)));
      }
      randomSubVector() {
        return this.clone().normalize().multiplyScalar(Randomize.getRandomFloat(0, this.length()));
      }
      toString() {
        return `x: ${this.x}, y: ${this.y}, z: ${this.z}`;
      }
      toArray() {
        return [this.x, this.y, this.z];
      }
      toObject() {
        return {x: this.x, y: this.y, z: this.z};
      }
      toThreeEuler() {
        return new Euler(this.x, this.y, this.z);
      }
      toThreeQuaternion() {
        return (new Quaternion).setFromEuler(this.toThreeEuler());
      }
      toThreeVector3() {
        return new three_module_Vector3(this.x, this.y, this.z);
      }
      toVector2() {
        return new Vector2_Vector2(this.x, this.y);
      }
      static fromThreeVector3(t) {
        return new Vector3(t.x, t.y, t.z);
      }
      static fromVector2(t) {
        return new Vector3(t.x, t.y);
      }
      static fromThreeVector2(t) {
        return new Vector3(t.x, t.y);
      }
      static fromThreeEuler(t) {
        return new Vector3(t.x, t.y, t.z);
      }
      static fromThreeQuaternion(t) {
        return Vector3.fromThreeEuler((new Euler).setFromQuaternion(t));
      }
      static fromArray(t) {
        return new Vector3(t[0] || 0, t[1] || 0, t[2] || 0);
      }
      static fromObject(t) {
        return void 0 === t ? new Vector3 : ValueUtils.isUndefinedOrNull(t.x) && ValueUtils.isUndefinedOrNull(t.y) && ValueUtils.isUndefinedOrNull(t.z) ? new Vector3(t._x, t._y, t._z) : new Vector3(t.x, t.y, t.z);
      }
      static fromScalar(t) {
        return new Vector3(t, t, t);
      }
    }
    class Vector2_Vector2 extends AbstractVector2 {
      set x (t) {
        this.setScalarX(t);
      }
      set y (t) {
        this.setScalarY(t);
      }
      get x() {
        return super.x;
      }
      get y() {
        return super.y;
      }
      clone() {
        return new Vector2_Vector2(this.x, this.y);
      }
      horizontalAngle() {
        return Math.atan2(this.y, this.x);
      }
      horizontalAngleDeg() {
        return ValueUtils.radianToDegrees(this.horizontalAngle());
      }
      verticalAngle() {
        return Math.atan2(this.x, this.y);
      }
      verticalAngleDeg() {
        return ValueUtils.radianToDegrees(this.verticalAngle());
      }
      angle() {
        return this.horizontalAngle();
      }
      angleDeg() {
        return this.horizontalAngleDeg();
      }
      direction() {
        return this.horizontalAngle();
      }
      rotate(t) {
        const e = Math.cos(t), i = Math.sin(t), n = this.x * e - this.y * i, r = this.x * i + this.y * e;
        return this.setScalarX(n).setScalarY(r);
      }
      rotateDeg(t) {
        return this.rotate(ValueUtils.degreesToRadian(t));
      }
      rotateTo(t) {
        return this.rotate(t - this.angle());
      }
      rotateToDeg(t) {
        return this.rotateTo(ValueUtils.degreesToRadian(t));
      }
      rotateBy(t) {
        return this.rotate(this.angle() + t);
      }
      rotateByDeg(t) {
        return this.rotateBy(ValueUtils.degreesToRadian(t));
      }
      distanceX(t) {
        return this.x - t.y;
      }
      distanceY(t) {
        return this.y - t.y;
      }
      distance(t) {
        return Math.sqrt(this.distanceSq(t));
      }
      distanceSq(t) {
        const e = this.distanceX(t), i = this.distanceY(t);
        return e * e + i * i;
      }
      static to2dProjection(t, e) {
        const i = document.documentElement.clientWidth / 2, n = document.documentElement.clientHeight / 2, r = new three_module_Vector3;
        return r.setFromMatrixPosition(t.matrixWorld).project(e), r.x = r.x * i + i, r.y = -r.y * n + n, new Vector2_Vector2(r.x, r.y);
      }
      to(t) {
        return this.copy(t.clone().subtract(this));
      }
      static random(t = 0, e = 1) {
        return new Vector2_Vector2(Math.floor(Randomize.getRandomFloat(t, e)), Math.floor(Randomize.getRandomFloat(t, e)));
      }
      randomSubVector() {
        return this.clone().normalize().multiplyScalar(Randomize.getRandomFloat(0, this.length()));
      }
      isNumber() {
        return ValueUtils.isNumber(this.x) && ValueUtils.isNumber(this.y);
      }
      toVector3(t = 0) {
        return new Vector3(this.x, this.y, t);
      }
      static fromBox2dVec(t) {
        return new Vector2_Vector2(Box2dUtils.fromBox2DValue(t.x), Box2dUtils.fromBox2DValue(t.y));
      }
      static fromThreeVector3(t) {
        return new Vector2_Vector2(t.x, t.y);
      }
      static fromVector3(t) {
        return new Vector2_Vector2(t.x, t.y);
      }
      static fromThreeVector2(t) {
        return new Vector2_Vector2(t.x, t.y);
      }
      static fromThreeEuler(t) {
        return new Vector2_Vector2(t.x, t.y);
      }
      static fromArray(t) {
        return new Vector2_Vector2(t[0], t[1]);
      }
      static fromObject(t) {
        return void 0 === t ? new Vector2_Vector2 : ValueUtils.isUndefinedOrNull(t.x) && ValueUtils.isUndefinedOrNull(t.y) ? new Vector2_Vector2(t._x, t._y) : new Vector2_Vector2(t.x, t.y);
      }
      static fromScalar(t) {
        return new Vector2_Vector2(t, t);
      }
    }
    Vector2_Vector2.ZERO = new Vector2_Vector2(0, 0), Vector2_Vector2.UP = new Vector2_Vector2(0, 1), Vector2_Vector2.DOWN = new Vector2_Vector2(0, -1), Vector2_Vector2.LEFT = new Vector2_Vector2(-1, 0), Vector2_Vector2.RIGHT = new Vector2_Vector2(1, 0), Vector2_Vector2.UP_RIGHT = new Vector2_Vector2(1, 1), Vector2_Vector2.UP_LEFT = new Vector2_Vector2(-1, 1), Vector2_Vector2.DOWN_RIGHT = new Vector2_Vector2(1, -1), Vector2_Vector2.DOWN_LEFT = new Vector2_Vector2(-1, -1), Vector2_Vector2.IDENTITY = new Vector2_Vector2(1, 1);
    class Randomize {
      static getRandomColor(t = 0, e = 0, i = 0, n = 255, r = 255, o = 255) {
        return new Color(Randomize.getRandomInt(t, n), Randomize.getRandomInt(e, r), Randomize.getRandomInt(i, o));
      }
      static getRandomColorScalar(t = 0, e = 0, i = 0, n = 255, r = 255, o = 255) {
        let s = 0;
        return s |= (255 & Randomize.getRandomInt(t, n)) << 0, s |= (255 & Randomize.getRandomInt(e, r)) << 8, s |= (255 & Randomize.getRandomInt(i, o)) << 16, s;
      }
      static getRandomInt(t = 0, e = 1) {
        return e++, Math.floor(Randomize.getRandomFloat(t, e));
      }
      static getRandomFloat(t = 0, e = 1) {
        return e--, Math.random() * (e - t + 1) + t;
      }
      static getRandomVector2(t = Vector2_Vector2.fromScalar(-1), e = Vector2_Vector2.fromScalar(1)) {
        return new Vector2_Vector2(Randomize.getRandomFloat(t.x, e.x), Randomize.getRandomFloat(t.y, e.y));
      }
      static getRandomVector2Scalar(t = 0, e = 1) {
        return Vector2_Vector2.fromObject({x: Randomize.getRandomFloat(t, e), y: Randomize.getRandomFloat(t, e)});
      }
      static getRandomVector3(t = Vector3.fromScalar(-1), e = Vector3.fromScalar(1)) {
        return new Vector3(Randomize.getRandomFloat(t.x, e.x), Randomize.getRandomFloat(t.y, e.y), Randomize.getRandomFloat(t.z, e.z));
      }
      static getRandomVector3Scalar(t = 0, e = 1) {
        return new Vector3(Randomize.getRandomFloat(t, e), Randomize.getRandomFloat(t, e), Randomize.getRandomFloat(t, e));
      }
      static getRandomFromArray(t) {
        return t[Randomize.getRandomInt(0, t.length - 1)];
      }
      static getRandomFromObject(t) {
        let e = Object.keys(t);
        return t[e[Randomize.getRandomInt(0, e.length - 1)]];
      }
      static getUuid() {
        return Math.random().toString(36).substr(2, 9);
      }
      static getRandomAngle() {
        return Randomize.getRandomFloat(0, 2 * Math.PI);
      }
      static getPositionAround(t, e) {
        let i = t.clone();
        return i.x = Randomize.getRandomInt(i.x - e, i.x + e), i.y = Randomize.getRandomInt(i.y - e, i.y + e), i;
      }
      static shuffleArray(t) {
        let e, i, n = t.length;
        for (; 0 !== n;) i = Math.floor(Math.random() * n), n -= 1, e = t[n], t[n] = t[i], t[i] = e;
        return t;
      }
    }
    class Listener {
      constructor(t, e) {
        this._uuid = Randomize.getUuid(), this._enabled = true, this._priority = Listener.DEFAULT_PRIORITY, this._executedTimes = 0, this._alive = true, this._event = t, this._func = e;
      }
      execute(t) {
        false !== this._alive && (this._func(t), this._limit && ++this._executedTimes >= this._limit && (this._alive = false));
      }
      isAlive() {
        return this._alive;
      }
      setPriority(t) {
        return this._priority = t, this._event.setNeedSort(true), this;
      }
      getPriority() {
        return this._priority;
      }
      setLimit(t) {
        return this._limit = t, this;
      }
      getLimit() {
        return this._limit;
      }
      getUuid() {
        return this._uuid;
      }
      getFunc() {
        return this._func;
      }
      getEvent() {
        return this._event;
      }
      enable() {
        this.isDisabled() && (this.getEvent().addListener(this), this._enabled = true);
      }
      disable() {
        this.isEnabled() && (this.getEvent().off(this), this._enabled = false);
      }
      isEnabled() {
        return this._enabled;
      }
      isDisabled() {
        return false === this._enabled;
      }
      isListener() {
        return true;
      }
      destroy() {
        this.getEvent().off(this), this._event = null, this._func = null;
      }
    }
    Listener.DEFAULT_PRIORITY = 0;
    class Event {
      constructor(t) {
        this._enabled = true, this._listeners = {}, this._data = {}, this._paused = false, this._stopped = false, this._needSort = false, this._name = t;
      }
      on(t) {
        return this.addListener(new Listener(this, t));
      }
      addListener(t) {
        return this._listeners[t.getUuid()] = t, t.getPriority() !== Listener.DEFAULT_PRIORITY && this.setNeedSort(true), t;
      }
      once(t) {
        return this.on(t).setLimit(1);
      }
      off(t) {
        this.hasListener(t) && delete this._listeners[t.getUuid()];
      }
      offFunc(t) {
        const e = Object.values(this._listeners).find(e => e.getFunc() === t);
        e && this.off(e);
      }
      execute(t = {}) {
        this._data = t, this._needSort && this.sortListeners(), this.executeListeners();
      }
      executeListeners() {
        for (const t in this._listeners) {
          if (this._currentListener = this._listeners[t], this.isPaused() || this.isStopped()) return void (this._stopped = false);
          if (this._pausedOnListener) this._currentListener === this._pausedOnListener && (this._pausedOnListener = null); else {
            if (this.isDisabled()) return;
            false !== this._currentListener.isAlive() ? this._currentListener.execute(this._data) : this.off(this._currentListener);
          }
        }
      }
      enable() {
        this._enabled = true;
      }
      disable() {
        this._enabled = false;
      }
      isEnabled() {
        return this._enabled;
      }
      isDisabled() {
        return false === this.isEnabled();
      }
      pause() {
        this.isPaused() || (this._paused = true, this._pausedOnListener = this._currentListener);
      }
      isPaused() {
        return this._paused;
      }
      resume() {
        false !== this.isPaused() && (this._paused = false, this.executeListeners());
      }
      stop() {
        this._stopped = true;
      }
      isStopped() {
        return this._stopped;
      }
      setNeedSort(t) {
        this._needSort = t;
      }
      sortListeners() {
        this.setNeedSort(false);
        const t = {};
        Object.keys(this._listeners).sort((t, e) => this._listeners[e].getPriority() - this._listeners[t].getPriority()).forEach(e => t[e] = this._listeners[e]), this._listeners = t;
      }
      hasListener(t) {
        return this._listeners.hasOwnProperty(t.getUuid());
      }
      getListenersCount() {
        return Object.keys(this._listeners).length;
      }
      getName() {
        return this._name;
      }
      destroy() {
        this._data = {}, this._listeners = {};
      }
    }
    class Events {
      constructor() {
        this._events = {};
      }
      emit(t, e = {}) {
        this.getEvent(t).execute(e);
      }
      on(t, e) {
        return this.getEvent(t).on(e);
      }
      off(t, e) {
        return this.getEvent(t).offFunc(e);
      }
      once(t, e) {
        return this.getEvent(t).once(e);
      }
      getEvent(t) {
        return this.hasnt(t) && (this._events[t] = new Event(t)), this._events[t];
      }
      hasnt(t) {
        return false === this._events.hasOwnProperty(t);
      }
      destroy() {
        for (const t in this._events) this._events[t].destroy();
        this._events = {};
      }
    }
    class ObjectTreeKeyMapper {
      constructor(t = {}, e = 0) {
        this.nameIntMap = {}, this.version = 0, this.intNameMap = t, this.version = e;
        for (let t in this.intNameMap) this.nameIntMap[this.intNameMap[t]] = t;
      }
      mapString(t) {
        let e = this.nameIntMap[t];
        return e || t;
      }
      unmapString(t) {
        let e = this.intNameMap[t];
        return e || t;
      }
      map(t) {
        return this.doMapUnMapJsonTree(t, false);
      }
      unmap(t) {
        return this.doMapUnMapJsonTree(t, true);
      }
      doMapUnMapString(t, e) {
        return e ? this.unmapString(t) : this.mapString(t);
      }
      doMapUnMapJsonTree(t, e) {
        if (!t) return t;
        if (t.constructor === String) return this.doMapUnMapString(t, e);
        if (t.constructor === Object) {
          let i = {};
          for (let n in t) i[this.doMapUnMapString(n, e)] = this.doMapUnMapJsonTree(t[n], e);
          return i;
        }
        if (t.constructor === Array) {
          let i = [];
          for (let n in t) i.push(this.doMapUnMapJsonTree(t[n], e));
          return i;
        }
        return t;
      }
    }
    var Rs = __webpack_require__(108);
    let Bs = __webpack_require__(797), Ps = __webpack_require__(658);
    class SocketEventEmitter {
      constructor() {
        this.socket = null, this.callbacksMap = [], this.mapper = null, this.skipMappingPackets = {packet_field_map: true}, this.on("packet_field_map", t => this.onPacketFieldMap(t));
      }
      onPacketFieldMap(t) {
        this.mapper = new ObjectTreeKeyMapper(t.m, t.v);
      }
      runCallback(t, e) {
        let i = this.callbacksMap[t];
        return !!i && (i(e), true);
      }
      connect(t, e) {
        if (this.socket && this.socket.socket && (this.socket.socket.connected || this.socket.socket.connecting)) return;
        return e = Object.assign({secure: false, transports: ["websocket", "xhr-polling", "jsonp-polling"], "reconnection delay": 2e3, "force new connection": true}, e), this.socket = Bs.connect(t, e), this.setListeners(), this.socket;
      }
      setListeners() {
        this.socket.on("connecting", t => this.runCallback("connecting", t)), this.socket.on("connect", t => {
          this.mapper = new ObjectTreeKeyMapper, this.runCallback("connect", t);
        }), this.socket.on("disconnect", t => this.runCallback("disconnect", t)), this.socket.on("reconnecting", t => this.runCallback("reconnecting", t)), this.socket.on("reconnect", t => {
          this.mapper = new ObjectTreeKeyMapper, this.runCallback("reconnect", t);
        }), this.socket.on("connect_failed", t => this.runCallback("connect_failed", t)), this.socket.on("reconnect_failed", t => this.runCallback("reconnect_failed", t)), this.socket.on("error", t => this.runCallback("error", t)), this.socket.on("message", t => {
          let e = this.decompressPackage(t);
          this.runCallback(e.id, e.data) || this.runCallback("message", e);
        });
      }
      disconnect() {
        this.socket && this.socket.socket && this.socket.socket.connected && this.socket.disconnect();
      }
      on(t, e) {
        this.callbacksMap[t] = e;
      }
      emit(t, e = {}) {
        if (!this.socket || !this.socket.socket.connected || !this.mapper) return false;
        try {
          let i = this.compressPackage({id: t, data: e});
          this.socket.send(i);
        } catch (t) {
          console.warn("ERROR: Can't compress and send packet", t);
        }
      }
      compressPackage(t) {
        let e = {id: t.id, v: this.mapper.version, data: this.mapper.map(t.data)};
        return Ps.encode(Rs.encode(e));
      }
      decompressPackage(t) {
        let e = Rs.decode(new Uint8Array(Ps.decode(t)));
        return this.skipMappingPackets[e.id] || (e.data = this.mapper.unmap(e.data)), e;
      }
    }
    class SocketForWorker {
      constructor(t, e) {
        this.packets = [], this._forcedPackets = {ping: true}, this._mode = t, "worker" === this._mode ? this.worker = e : "main" === this._mode && (this.events = new Events), this.socket = new SocketEventEmitter, this.setListeners();
      }
      setListeners() {
        this.socket.on("connecting", t => this.onConnecting(t)), this.socket.on("connect", () => this.onConnect()), this.socket.on("message", t => this.onMessage(t)), this.socket.on("disconnect", t => this.onDisconnect(t)), this.socket.on("reconnecting", t => this.onReconnecting(t)), this.socket.on("reconnect", t => this.onReconnect(t)), this.socket.on("connect_failed", t => this.onConnectFailed(t)), this.socket.on("reconnect_failed", t => this.onReconnectFailed(t)), this.socket.on("error", t => this.onError(t));
      }
      onConnecting(t) {
        this.log(`connecting to ${this.getAddress()}`), this.addEvent("socketConnecting", t);
      }
      onConnect() {
        this.log(`connected to ${this.getAddress()}`), this.addEvent("socketConnect", this.getAddress());
      }
      onDisconnect(t) {
        const e = {closeSessionCode: this._closeSessionCode, booted: "booted" === t};
        this.log(`disconnected from ${this.getAddress()}`, e), this.addEvent("socketDisconnect", e);
      }
      getAddress() {
        return `${this.socket.socket.socket.options.secure ? "wss" : "ws"}://${this.socket.socket.socket.options.host}:${this.socket.socket.socket.options.port}`;
      }
      onMessage(t) {
        "close_session" === t.id && (this._closeSessionCode = t.data.code), this._forcedPackets.hasOwnProperty(t.id) ? "main" === this._mode ? this.events.emit("packets", [{type: "packet", data: t}]) : this.worker.postMessage([{type: "packet", data: t}]) : this.addPacket({type: "packet", data: t});
      }
      onReconnecting(t) {
        this.log(`reconnecting to ${this.getAddress()}`, t), this.addEvent("socketReconnecting", t);
      }
      onReconnect(t) {
        this.log(`reconnect to ${this.getAddress()}`, t), this.socket.mapper = new ObjectTreeKeyMapper, this.addEvent("socketReconnect", t);
      }
      onConnectFailed(t) {
        this.log(`failed to connect to ${this.getAddress()}`, t), this.addEvent("socketConnectFailed", t);
      }
      onReconnectFailed(t) {
        this.log(`failed to reconnect to ${this.getAddress()}`, t), this.addEvent("socketReconnectFailed", t);
      }
      onError(t) {
        throw this.log(`error in ${this.getAddress()}`, t), this.addEvent("socketError", t), t;
      }
      connectToServer(t, e) {
        this.socket.connect(t, e);
      }
      emit(t, e = {}) {
        this.socket.emit(t, e);
      }
      addPacket(t) {
        this.packets.push(t), "main" === this._mode && (this.events.emit("packets", this.packets), this.packets = []);
      }
      addEvent(t, e) {
        this.addPacket({type: "event", data: {id: t, data: e}});
      }
      sendPackets() {
        if (0 !== this.packets.length) {
          try {
            this.worker.postMessage(this.packets);
          } catch (t) {
            console.error(t);
          }
          this.packets = [];
        }
      }
      log(...t) {
        t.unshift("<b>[Socket]</b> "), Logger.log.call(Logger, ...t);
      }
    }
    const Is = self;
    let Vs;
    Is.onmessage = t => {
      const e = t.data;
      if (0 !== e.length) for (const t in e) {
        const i = e[t];
        switch (i.name) {
          case "initialize":
            Vs = new SocketForWorker("worker", Is);
            break;
          case "connect":
            Vs.connectToServer(i.data.url, i.data.options);
            break;
          case "disconnect":
            Vs.socket.disconnect();
            break;
          case "emit":
            Vs.emit(i.data.packageName, i.data.data);
            break;
          case "getPackets":
            Vs.sendPackets();
        }
      }
    };
  })();
})();
