(() => {
  "use strict";
  var t = {63: t => {
    var e = {};
    !function (t, e) {
      function i() {}
      t.inherit = function (t, e) {
        var n = t;
        i.prototype = e.prototype, t.prototype = new i, t.prototype.constructor = n;
      }, t.generateCallback = function (t, e) {
        return function () {
          e.apply(t, arguments);
        };
      }, t.NVector = function (t) {
        t === e && (t = 0);
        for (var i = new Array(t || 0), n = 0; n < t; ++n) i[n] = 0;
        return i;
      }, t.is = function (t, i) {
        return null !== t && (i instanceof Function && t instanceof i || !(t.constructor.__implements == e || !t.constructor.__implements[i]));
      }, t.parseUInt = function (t) {
        return Math.abs(parseInt(t));
      };
    }(e);
    var i, n, r, o, s, a, l, c, h, u, m, p, d, f, _, y, g, x, v, b, w, S, M, C, A, T, E, L, D, V, B, R, P, I, F, G, N, z, O, U, k = Array, H = e.NVector;
    for (void 0 === e && (e = {}), void 0 === e.Collision && (e.Collision = {}), void 0 === e.Collision.Shapes && (e.Collision.Shapes = {}), void 0 === e.Common && (e.Common = {}), void 0 === e.Common.Math && (e.Common.Math = {}), void 0 === e.Dynamics && (e.Dynamics = {}), void 0 === e.Dynamics.Contacts && (e.Dynamics.Contacts = {}), void 0 === e.Dynamics.Controllers && (e.Dynamics.Controllers = {}), void 0 === e.Dynamics.Joints && (e.Dynamics.Joints = {}), e.Collision.IBroadPhase = "Box2D.Collision.IBroadPhase", e.Collision.b2AABB = function t() {
      t.b2AABB.apply(this, arguments);
    }, e.Collision.b2Bound = function t() {
      t.b2Bound.apply(this, arguments);
    }, e.Collision.b2BoundValues = function t() {
      t.b2BoundValues.apply(this, arguments), this.constructor === t && this.b2BoundValues.apply(this, arguments);
    }, e.Collision.b2Collision = function t() {
      t.b2Collision.apply(this, arguments);
    }, e.Collision.b2ContactID = function t() {
      t.b2ContactID.apply(this, arguments), this.constructor === t && this.b2ContactID.apply(this, arguments);
    }, e.Collision.b2ContactPoint = function t() {
      t.b2ContactPoint.apply(this, arguments);
    }, e.Collision.b2Distance = function t() {
      t.b2Distance.apply(this, arguments);
    }, e.Collision.b2DistanceInput = function t() {
      t.b2DistanceInput.apply(this, arguments);
    }, e.Collision.b2DistanceOutput = function t() {
      t.b2DistanceOutput.apply(this, arguments);
    }, e.Collision.b2DistanceProxy = function t() {
      t.b2DistanceProxy.apply(this, arguments);
    }, e.Collision.b2DynamicTree = function t() {
      t.b2DynamicTree.apply(this, arguments), this.constructor === t && this.b2DynamicTree.apply(this, arguments);
    }, e.Collision.b2DynamicTreeBroadPhase = function t() {
      t.b2DynamicTreeBroadPhase.apply(this, arguments);
    }, e.Collision.b2DynamicTreeNode = function t() {
      t.b2DynamicTreeNode.apply(this, arguments);
    }, e.Collision.b2DynamicTreePair = function t() {
      t.b2DynamicTreePair.apply(this, arguments);
    }, e.Collision.b2Manifold = function t() {
      t.b2Manifold.apply(this, arguments), this.constructor === t && this.b2Manifold.apply(this, arguments);
    }, e.Collision.b2ManifoldPoint = function t() {
      t.b2ManifoldPoint.apply(this, arguments), this.constructor === t && this.b2ManifoldPoint.apply(this, arguments);
    }, e.Collision.b2Point = function t() {
      t.b2Point.apply(this, arguments);
    }, e.Collision.b2RayCastInput = function t() {
      t.b2RayCastInput.apply(this, arguments), this.constructor === t && this.b2RayCastInput.apply(this, arguments);
    }, e.Collision.b2RayCastOutput = function t() {
      t.b2RayCastOutput.apply(this, arguments);
    }, e.Collision.b2Segment = function t() {
      t.b2Segment.apply(this, arguments);
    }, e.Collision.b2SeparationFunction = function t() {
      t.b2SeparationFunction.apply(this, arguments);
    }, e.Collision.b2Simplex = function t() {
      t.b2Simplex.apply(this, arguments), this.constructor === t && this.b2Simplex.apply(this, arguments);
    }, e.Collision.b2SimplexCache = function t() {
      t.b2SimplexCache.apply(this, arguments);
    }, e.Collision.b2SimplexVertex = function t() {
      t.b2SimplexVertex.apply(this, arguments);
    }, e.Collision.b2TimeOfImpact = function t() {
      t.b2TimeOfImpact.apply(this, arguments);
    }, e.Collision.b2TOIInput = function t() {
      t.b2TOIInput.apply(this, arguments);
    }, e.Collision.b2WorldManifold = function t() {
      t.b2WorldManifold.apply(this, arguments), this.constructor === t && this.b2WorldManifold.apply(this, arguments);
    }, e.Collision.ClipVertex = function t() {
      t.ClipVertex.apply(this, arguments);
    }, e.Collision.Features = function t() {
      t.Features.apply(this, arguments);
    }, e.Collision.Shapes.b2CircleShape = function t() {
      t.b2CircleShape.apply(this, arguments), this.constructor === t && this.b2CircleShape.apply(this, arguments);
    }, e.Collision.Shapes.b2EdgeChainDef = function t() {
      t.b2EdgeChainDef.apply(this, arguments), this.constructor === t && this.b2EdgeChainDef.apply(this, arguments);
    }, e.Collision.Shapes.b2EdgeShape = function t() {
      t.b2EdgeShape.apply(this, arguments), this.constructor === t && this.b2EdgeShape.apply(this, arguments);
    }, e.Collision.Shapes.b2MassData = function t() {
      t.b2MassData.apply(this, arguments);
    }, e.Collision.Shapes.b2PolygonShape = function t() {
      t.b2PolygonShape.apply(this, arguments), this.constructor === t && this.b2PolygonShape.apply(this, arguments);
    }, e.Collision.Shapes.b2Shape = function t() {
      t.b2Shape.apply(this, arguments), this.constructor === t && this.b2Shape.apply(this, arguments);
    }, e.Common.b2internal = "Box2D.Common.b2internal", e.Common.b2Color = function t() {
      t.b2Color.apply(this, arguments), this.constructor === t && this.b2Color.apply(this, arguments);
    }, e.Common.b2Settings = function t() {
      t.b2Settings.apply(this, arguments);
    }, e.Common.Math.b2Mat22 = function t() {
      t.b2Mat22.apply(this, arguments), this.constructor === t && this.b2Mat22.apply(this, arguments);
    }, e.Common.Math.b2Mat33 = function t() {
      t.b2Mat33.apply(this, arguments), this.constructor === t && this.b2Mat33.apply(this, arguments);
    }, e.Common.Math.b2Math = function t() {
      t.b2Math.apply(this, arguments);
    }, e.Common.Math.b2Sweep = function t() {
      t.b2Sweep.apply(this, arguments);
    }, e.Common.Math.b2Transform = function t() {
      t.b2Transform.apply(this, arguments), this.constructor === t && this.b2Transform.apply(this, arguments);
    }, e.Common.Math.b2Vec2 = function t() {
      t.b2Vec2.apply(this, arguments), this.constructor === t && this.b2Vec2.apply(this, arguments);
    }, e.Common.Math.b2Vec3 = function t() {
      t.b2Vec3.apply(this, arguments), this.constructor === t && this.b2Vec3.apply(this, arguments);
    }, e.Dynamics.b2Body = function t() {
      t.b2Body.apply(this, arguments), this.constructor === t && this.b2Body.apply(this, arguments);
    }, e.Dynamics.b2BodyDef = function t() {
      t.b2BodyDef.apply(this, arguments), this.constructor === t && this.b2BodyDef.apply(this, arguments);
    }, e.Dynamics.b2ContactFilter = function t() {
      t.b2ContactFilter.apply(this, arguments);
    }, e.Dynamics.b2ContactImpulse = function t() {
      t.b2ContactImpulse.apply(this, arguments);
    }, e.Dynamics.b2ContactListener = function t() {
      t.b2ContactListener.apply(this, arguments);
    }, e.Dynamics.b2ContactManager = function t() {
      t.b2ContactManager.apply(this, arguments), this.constructor === t && this.b2ContactManager.apply(this, arguments);
    }, e.Dynamics.b2DebugDraw = function t() {
      t.b2DebugDraw.apply(this, arguments), this.constructor === t && this.b2DebugDraw.apply(this, arguments);
    }, e.Dynamics.b2DestructionListener = function t() {
      t.b2DestructionListener.apply(this, arguments);
    }, e.Dynamics.b2FilterData = function t() {
      t.b2FilterData.apply(this, arguments);
    }, e.Dynamics.b2Fixture = function t() {
      t.b2Fixture.apply(this, arguments), this.constructor === t && this.b2Fixture.apply(this, arguments);
    }, e.Dynamics.b2FixtureDef = function t() {
      t.b2FixtureDef.apply(this, arguments), this.constructor === t && this.b2FixtureDef.apply(this, arguments);
    }, e.Dynamics.b2Island = function t() {
      t.b2Island.apply(this, arguments), this.constructor === t && this.b2Island.apply(this, arguments);
    }, e.Dynamics.b2TimeStep = function t() {
      t.b2TimeStep.apply(this, arguments);
    }, e.Dynamics.b2World = function t() {
      t.b2World.apply(this, arguments), this.constructor === t && this.b2World.apply(this, arguments);
    }, e.Dynamics.Contacts.b2CircleContact = function t() {
      t.b2CircleContact.apply(this, arguments);
    }, e.Dynamics.Contacts.b2Contact = function t() {
      t.b2Contact.apply(this, arguments), this.constructor === t && this.b2Contact.apply(this, arguments);
    }, e.Dynamics.Contacts.b2ContactConstraint = function t() {
      t.b2ContactConstraint.apply(this, arguments), this.constructor === t && this.b2ContactConstraint.apply(this, arguments);
    }, e.Dynamics.Contacts.b2ContactConstraintPoint = function t() {
      t.b2ContactConstraintPoint.apply(this, arguments);
    }, e.Dynamics.Contacts.b2ContactEdge = function t() {
      t.b2ContactEdge.apply(this, arguments);
    }, e.Dynamics.Contacts.b2ContactFactory = function t() {
      t.b2ContactFactory.apply(this, arguments), this.constructor === t && this.b2ContactFactory.apply(this, arguments);
    }, e.Dynamics.Contacts.b2ContactRegister = function t() {
      t.b2ContactRegister.apply(this, arguments);
    }, e.Dynamics.Contacts.b2ContactResult = function t() {
      t.b2ContactResult.apply(this, arguments);
    }, e.Dynamics.Contacts.b2ContactSolver = function t() {
      t.b2ContactSolver.apply(this, arguments), this.constructor === t && this.b2ContactSolver.apply(this, arguments);
    }, e.Dynamics.Contacts.b2EdgeAndCircleContact = function t() {
      t.b2EdgeAndCircleContact.apply(this, arguments);
    }, e.Dynamics.Contacts.b2NullContact = function t() {
      t.b2NullContact.apply(this, arguments), this.constructor === t && this.b2NullContact.apply(this, arguments);
    }, e.Dynamics.Contacts.b2PolyAndCircleContact = function t() {
      t.b2PolyAndCircleContact.apply(this, arguments);
    }, e.Dynamics.Contacts.b2PolyAndEdgeContact = function t() {
      t.b2PolyAndEdgeContact.apply(this, arguments);
    }, e.Dynamics.Contacts.b2PolygonContact = function t() {
      t.b2PolygonContact.apply(this, arguments);
    }, e.Dynamics.Contacts.b2PositionSolverManifold = function t() {
      t.b2PositionSolverManifold.apply(this, arguments), this.constructor === t && this.b2PositionSolverManifold.apply(this, arguments);
    }, e.Dynamics.Controllers.b2BuoyancyController = function t() {
      t.b2BuoyancyController.apply(this, arguments);
    }, e.Dynamics.Controllers.b2ConstantAccelController = function t() {
      t.b2ConstantAccelController.apply(this, arguments);
    }, e.Dynamics.Controllers.b2ConstantForceController = function t() {
      t.b2ConstantForceController.apply(this, arguments);
    }, e.Dynamics.Controllers.b2Controller = function t() {
      t.b2Controller.apply(this, arguments);
    }, e.Dynamics.Controllers.b2ControllerEdge = function t() {
      t.b2ControllerEdge.apply(this, arguments);
    }, e.Dynamics.Controllers.b2GravityController = function t() {
      t.b2GravityController.apply(this, arguments);
    }, e.Dynamics.Controllers.b2TensorDampingController = function t() {
      t.b2TensorDampingController.apply(this, arguments);
    }, e.Dynamics.Joints.b2DistanceJoint = function t() {
      t.b2DistanceJoint.apply(this, arguments), this.constructor === t && this.b2DistanceJoint.apply(this, arguments);
    }, e.Dynamics.Joints.b2DistanceJointDef = function t() {
      t.b2DistanceJointDef.apply(this, arguments), this.constructor === t && this.b2DistanceJointDef.apply(this, arguments);
    }, e.Dynamics.Joints.b2FrictionJoint = function t() {
      t.b2FrictionJoint.apply(this, arguments), this.constructor === t && this.b2FrictionJoint.apply(this, arguments);
    }, e.Dynamics.Joints.b2FrictionJointDef = function t() {
      t.b2FrictionJointDef.apply(this, arguments), this.constructor === t && this.b2FrictionJointDef.apply(this, arguments);
    }, e.Dynamics.Joints.b2GearJoint = function t() {
      t.b2GearJoint.apply(this, arguments), this.constructor === t && this.b2GearJoint.apply(this, arguments);
    }, e.Dynamics.Joints.b2GearJointDef = function t() {
      t.b2GearJointDef.apply(this, arguments), this.constructor === t && this.b2GearJointDef.apply(this, arguments);
    }, e.Dynamics.Joints.b2Jacobian = function t() {
      t.b2Jacobian.apply(this, arguments);
    }, e.Dynamics.Joints.b2Joint = function t() {
      t.b2Joint.apply(this, arguments), this.constructor === t && this.b2Joint.apply(this, arguments);
    }, e.Dynamics.Joints.b2JointDef = function t() {
      t.b2JointDef.apply(this, arguments), this.constructor === t && this.b2JointDef.apply(this, arguments);
    }, e.Dynamics.Joints.b2JointEdge = function t() {
      t.b2JointEdge.apply(this, arguments);
    }, e.Dynamics.Joints.b2LineJoint = function t() {
      t.b2LineJoint.apply(this, arguments), this.constructor === t && this.b2LineJoint.apply(this, arguments);
    }, e.Dynamics.Joints.b2LineJointDef = function t() {
      t.b2LineJointDef.apply(this, arguments), this.constructor === t && this.b2LineJointDef.apply(this, arguments);
    }, e.Dynamics.Joints.b2MouseJoint = function t() {
      t.b2MouseJoint.apply(this, arguments), this.constructor === t && this.b2MouseJoint.apply(this, arguments);
    }, e.Dynamics.Joints.b2MouseJointDef = function t() {
      t.b2MouseJointDef.apply(this, arguments), this.constructor === t && this.b2MouseJointDef.apply(this, arguments);
    }, e.Dynamics.Joints.b2PrismaticJoint = function t() {
      t.b2PrismaticJoint.apply(this, arguments), this.constructor === t && this.b2PrismaticJoint.apply(this, arguments);
    }, e.Dynamics.Joints.b2PrismaticJointDef = function t() {
      t.b2PrismaticJointDef.apply(this, arguments), this.constructor === t && this.b2PrismaticJointDef.apply(this, arguments);
    }, e.Dynamics.Joints.b2PulleyJoint = function t() {
      t.b2PulleyJoint.apply(this, arguments), this.constructor === t && this.b2PulleyJoint.apply(this, arguments);
    }, e.Dynamics.Joints.b2PulleyJointDef = function t() {
      t.b2PulleyJointDef.apply(this, arguments), this.constructor === t && this.b2PulleyJointDef.apply(this, arguments);
    }, e.Dynamics.Joints.b2RevoluteJoint = function t() {
      t.b2RevoluteJoint.apply(this, arguments), this.constructor === t && this.b2RevoluteJoint.apply(this, arguments);
    }, e.Dynamics.Joints.b2RevoluteJointDef = function t() {
      t.b2RevoluteJointDef.apply(this, arguments), this.constructor === t && this.b2RevoluteJointDef.apply(this, arguments);
    }, e.Dynamics.Joints.b2WeldJoint = function t() {
      t.b2WeldJoint.apply(this, arguments), this.constructor === t && this.b2WeldJoint.apply(this, arguments);
    }, e.Dynamics.Joints.b2WeldJointDef = function t() {
      t.b2WeldJointDef.apply(this, arguments), this.constructor === t && this.b2WeldJointDef.apply(this, arguments);
    }, e.postDefs = [], i = e.Collision.Shapes.b2CircleShape, e.Collision.Shapes.b2EdgeChainDef, e.Collision.Shapes.b2EdgeShape, e.Collision.Shapes.b2MassData, n = e.Collision.Shapes.b2PolygonShape, r = e.Collision.Shapes.b2Shape, e.Common.b2Color, e.Common.b2internal, o = e.Common.b2Settings, e.Common.Math.b2Mat22, e.Common.Math.b2Mat33, s = e.Common.Math.b2Math, a = e.Common.Math.b2Sweep, l = e.Common.Math.b2Transform, c = e.Common.Math.b2Vec2, e.Common.Math.b2Vec3, h = e.Collision.b2AABB, u = e.Collision.b2Bound, m = e.Collision.b2BoundValues, p = e.Collision.b2Collision, d = e.Collision.b2ContactID, f = e.Collision.b2ContactPoint, _ = e.Collision.b2Distance, y = e.Collision.b2DistanceInput, g = e.Collision.b2DistanceOutput, x = e.Collision.b2DistanceProxy, v = e.Collision.b2DynamicTree, b = e.Collision.b2DynamicTreeBroadPhase, w = e.Collision.b2DynamicTreeNode, S = e.Collision.b2DynamicTreePair, M = e.Collision.b2Manifold, C = e.Collision.b2ManifoldPoint, A = e.Collision.b2Point, T = e.Collision.b2RayCastInput, E = e.Collision.b2RayCastOutput, L = e.Collision.b2Segment, D = e.Collision.b2SeparationFunction, V = e.Collision.b2Simplex, B = e.Collision.b2SimplexCache, R = e.Collision.b2SimplexVertex, P = e.Collision.b2TimeOfImpact, I = e.Collision.b2TOIInput, F = e.Collision.b2WorldManifold, G = e.Collision.ClipVertex, N = e.Collision.Features, z = e.Collision.IBroadPhase, h.b2AABB = function () {
      this.lowerBound = new c, this.upperBound = new c;
    }, h.prototype.IsValid = function () {
      var t = this.upperBound.x - this.lowerBound.x, e = this.upperBound.y - this.lowerBound.y, i = t >= 0 && e >= 0;
      return i = i && this.lowerBound.IsValid() && this.upperBound.IsValid();
    }, h.prototype.GetCenter = function () {
      return new c((this.lowerBound.x + this.upperBound.x) / 2, (this.lowerBound.y + this.upperBound.y) / 2);
    }, h.prototype.GetExtents = function () {
      return new c((this.upperBound.x - this.lowerBound.x) / 2, (this.upperBound.y - this.lowerBound.y) / 2);
    }, h.prototype.Contains = function (t) {
      var e = true;
      return e = (e = (e = (e = e && this.lowerBound.x <= t.lowerBound.x) && this.lowerBound.y <= t.lowerBound.y) && t.upperBound.x <= this.upperBound.x) && t.upperBound.y <= this.upperBound.y;
    }, h.prototype.RayCast = function (t, e) {
      var i = -Number.MAX_VALUE, n = Number.MAX_VALUE, r = e.p1.x, o = e.p1.y, s = e.p2.x - e.p1.x, a = e.p2.y - e.p1.y, l = Math.abs(s), c = Math.abs(a), h = t.normal, u = 0, m = 0, p = 0, d = 0, f = 0;
      if (l < Number.MIN_VALUE) {
        if (r < this.lowerBound.x || this.upperBound.x < r) return false;
      } else if (u = 1 / s, f = -1, (m = (this.lowerBound.x - r) * u) > (p = (this.upperBound.x - r) * u) && (d = m, m = p, p = d, f = 1), m > i && (h.x = f, h.y = 0, i = m), i > (n = Math.min(n, p))) return false;
      if (c < Number.MIN_VALUE) {
        if (o < this.lowerBound.y || this.upperBound.y < o) return false;
      } else if (u = 1 / a, f = -1, (m = (this.lowerBound.y - o) * u) > (p = (this.upperBound.y - o) * u) && (d = m, m = p, p = d, f = 1), m > i && (h.y = f, h.x = 0, i = m), i > (n = Math.min(n, p))) return false;
      return t.fraction = i, true;
    }, h.prototype.TestOverlap = function (t) {
      var e = t.lowerBound.x - this.upperBound.x, i = t.lowerBound.y - this.upperBound.y, n = this.lowerBound.x - t.upperBound.x, r = this.lowerBound.y - t.upperBound.y;
      return !(e > 0 || i > 0 || n > 0 || r > 0);
    }, h.Combine = function (t, e) {
      var i = new h;
      return i.Combine(t, e), i;
    }, h.prototype.Combine = function (t, e) {
      this.lowerBound.x = Math.min(t.lowerBound.x, e.lowerBound.x), this.lowerBound.y = Math.min(t.lowerBound.y, e.lowerBound.y), this.upperBound.x = Math.max(t.upperBound.x, e.upperBound.x), this.upperBound.y = Math.max(t.upperBound.y, e.upperBound.y);
    }, u.b2Bound = function () {}, u.prototype.IsLower = function () {
      return 0 == (1 & this.value);
    }, u.prototype.IsUpper = function () {
      return 1 == (1 & this.value);
    }, u.prototype.Swap = function (t) {
      var e = this.value, i = this.proxy, n = this.stabbingCount;
      this.value = t.value, this.proxy = t.proxy, this.stabbingCount = t.stabbingCount, t.value = e, t.proxy = i, t.stabbingCount = n;
    }, m.b2BoundValues = function () {}, m.prototype.b2BoundValues = function () {
      this.lowerValues = new H, this.lowerValues[0] = 0, this.lowerValues[1] = 0, this.upperValues = new H, this.upperValues[0] = 0, this.upperValues[1] = 0;
    }, p.b2Collision = function () {}, p.ClipSegmentToLine = function (t, e, i, n) {
      var r;
      void 0 === n && (n = 0);
      var o = 0, s = (r = e[0]).v, a = (r = e[1]).v, l = i.x * s.x + i.y * s.y - n, c = i.x * a.x + i.y * a.y - n;
      if (l <= 0 && t[o++].Set(e[0]), c <= 0 && t[o++].Set(e[1]), l * c < 0) {
        var h, u = l / (l - c), m = (r = t[o]).v;
        m.x = s.x + u * (a.x - s.x), m.y = s.y + u * (a.y - s.y), r = t[o], l > 0 ? (h = e[0], r.id = h.id) : (h = e[1], r.id = h.id), ++o;
      }
      return o;
    }, p.EdgeSeparation = function (t, e, i, n, r) {
      void 0 === i && (i = 0), parseInt(t.m_vertexCount);
      var o, s, a = t.m_vertices, l = t.m_normals, c = parseInt(n.m_vertexCount), h = n.m_vertices;
      o = e.R, s = l[i];
      for (var u = o.col1.x * s.x + o.col2.x * s.y, m = o.col1.y * s.x + o.col2.y * s.y, p = (o = r.R).col1.x * u + o.col1.y * m, d = o.col2.x * u + o.col2.y * m, f = 0, _ = Number.MAX_VALUE, y = 0; y < c; ++y) {
        var g = (s = h[y]).x * p + s.y * d;
        g < _ && (_ = g, f = y);
      }
      s = a[i], o = e.R;
      var x = e.position.x + (o.col1.x * s.x + o.col2.x * s.y), v = e.position.y + (o.col1.y * s.x + o.col2.y * s.y);
      s = h[f], o = r.R;
      var b = r.position.x + (o.col1.x * s.x + o.col2.x * s.y), w = r.position.y + (o.col1.y * s.x + o.col2.y * s.y);
      return (b -= x) * u + (w -= v) * m;
    }, p.FindMaxSeparation = function (t, e, i, n, r) {
      var o, s, a = parseInt(e.m_vertexCount), l = e.m_normals;
      s = r.R, o = n.m_centroid;
      var c = r.position.x + (s.col1.x * o.x + s.col2.x * o.y), h = r.position.y + (s.col1.y * o.x + s.col2.y * o.y);
      s = i.R, o = e.m_centroid, c -= i.position.x + (s.col1.x * o.x + s.col2.x * o.y), h -= i.position.y + (s.col1.y * o.x + s.col2.y * o.y);
      for (var u = c * i.R.col1.x + h * i.R.col1.y, m = c * i.R.col2.x + h * i.R.col2.y, d = 0, f = -Number.MAX_VALUE, _ = 0; _ < a; ++_) {
        var y = (o = l[_]).x * u + o.y * m;
        y > f && (f = y, d = _);
      }
      var g = p.EdgeSeparation(e, i, d, n, r), x = parseInt(d - 1 >= 0 ? d - 1 : a - 1), v = p.EdgeSeparation(e, i, x, n, r), b = parseInt(d + 1 < a ? d + 1 : 0), w = p.EdgeSeparation(e, i, b, n, r), S = 0, M = 0, C = 0;
      if (v > g && v > w) C = -1, S = x, M = v; else {
        if (!(w > g)) return t[0] = d, g;
        C = 1, S = b, M = w;
      }
      for (; d = -1 == C ? S - 1 >= 0 ? S - 1 : a - 1 : S + 1 < a ? S + 1 : 0, (g = p.EdgeSeparation(e, i, d, n, r)) > M;) S = d, M = g;
      return t[0] = S, M;
    }, p.FindIncidentEdge = function (t, e, i, n, r, o) {
      void 0 === n && (n = 0), parseInt(e.m_vertexCount);
      var s, a, l = e.m_normals, c = parseInt(r.m_vertexCount), h = r.m_vertices, u = r.m_normals;
      s = i.R, a = l[n];
      var m = s.col1.x * a.x + s.col2.x * a.y, p = s.col1.y * a.x + s.col2.y * a.y, d = (s = o.R).col1.x * m + s.col1.y * p;
      p = s.col2.x * m + s.col2.y * p, m = d;
      for (var f, _ = 0, y = Number.MAX_VALUE, g = 0; g < c; ++g) {
        var x = m * (a = u[g]).x + p * a.y;
        x < y && (y = x, _ = g);
      }
      var v = parseInt(_), b = parseInt(v + 1 < c ? v + 1 : 0);
      f = t[0], a = h[v], s = o.R, f.v.x = o.position.x + (s.col1.x * a.x + s.col2.x * a.y), f.v.y = o.position.y + (s.col1.y * a.x + s.col2.y * a.y), f.id.features.referenceEdge = n, f.id.features.incidentEdge = v, f.id.features.incidentVertex = 0, f = t[1], a = h[b], s = o.R, f.v.x = o.position.x + (s.col1.x * a.x + s.col2.x * a.y), f.v.y = o.position.y + (s.col1.y * a.x + s.col2.y * a.y), f.id.features.referenceEdge = n, f.id.features.incidentEdge = b, f.id.features.incidentVertex = 1;
    }, p.MakeClipPointVector = function () {
      var t = new k(2);
      return t[0] = new G, t[1] = new G, t;
    }, p.CollidePolygons = function (t, e, i, n, r) {
      var s;
      t.m_pointCount = 0;
      var a = e.m_radius + n.m_radius, l = 0;
      p.s_edgeAO[0] = l;
      var c = p.FindMaxSeparation(p.s_edgeAO, e, i, n, r);
      if (l = p.s_edgeAO[0], !(c > a)) {
        var h = 0;
        p.s_edgeBO[0] = h;
        var u = p.FindMaxSeparation(p.s_edgeBO, n, r, e, i);
        if (h = p.s_edgeBO[0], !(u > a)) {
          var m, d, f, _, y, g = 0, x = 0;
          u > 0.98 * c + 0.001 ? (m = n, d = e, f = r, _ = i, g = h, t.m_type = M.e_faceB, x = 1) : (m = e, d = n, f = i, _ = r, g = l, t.m_type = M.e_faceA, x = 0);
          var v = p.s_incidentEdge;
          p.FindIncidentEdge(v, m, f, g, d, _);
          var b, w = parseInt(m.m_vertexCount), S = m.m_vertices, C = S[g];
          b = g + 1 < w ? S[parseInt(g + 1)] : S[0];
          var A = p.s_localTangent;
          A.Set(b.x - C.x, b.y - C.y), A.Normalize();
          var T = p.s_localNormal;
          T.x = A.y, T.y = -A.x;
          var E = p.s_planePoint;
          E.Set(0.5 * (C.x + b.x), 0.5 * (C.y + b.y));
          var L = p.s_tangent;
          y = f.R, L.x = y.col1.x * A.x + y.col2.x * A.y, L.y = y.col1.y * A.x + y.col2.y * A.y;
          var D = p.s_tangent2;
          D.x = -L.x, D.y = -L.y;
          var V = p.s_normal;
          V.x = L.y, V.y = -L.x;
          var B = p.s_v11, R = p.s_v12;
          B.x = f.position.x + (y.col1.x * C.x + y.col2.x * C.y), B.y = f.position.y + (y.col1.y * C.x + y.col2.y * C.y), R.x = f.position.x + (y.col1.x * b.x + y.col2.x * b.y), R.y = f.position.y + (y.col1.y * b.x + y.col2.y * b.y);
          var P = V.x * B.x + V.y * B.y, I = -L.x * B.x - L.y * B.y + a, F = L.x * R.x + L.y * R.y + a, G = p.s_clipPoints1, N = p.s_clipPoints2;
          if (!(p.ClipSegmentToLine(G, v, D, I) < 2 || p.ClipSegmentToLine(N, G, L, F) < 2)) {
            t.m_localPlaneNormal.SetV(T), t.m_localPoint.SetV(E);
            for (var z = 0, O = 0; O < o.b2_maxManifoldPoints; ++O) if (s = N[O], V.x * s.v.x + V.y * s.v.y - P <= a) {
              var U = t.m_points[z];
              y = _.R;
              var k = s.v.x - _.position.x, H = s.v.y - _.position.y;
              U.m_localPoint.x = k * y.col1.x + H * y.col1.y, U.m_localPoint.y = k * y.col2.x + H * y.col2.y, U.m_id.Set(s.id), U.m_id.features.flip = x, ++z;
            }
            t.m_pointCount = z;
          }
        }
      }
    }, p.CollideCircles = function (t, e, i, n, r) {
      var o, s;
      t.m_pointCount = 0, o = i.R, s = e.m_p;
      var a = i.position.x + (o.col1.x * s.x + o.col2.x * s.y), l = i.position.y + (o.col1.y * s.x + o.col2.y * s.y);
      o = r.R, s = n.m_p;
      var c = r.position.x + (o.col1.x * s.x + o.col2.x * s.y) - a, h = r.position.y + (o.col1.y * s.x + o.col2.y * s.y) - l, u = c * c + h * h, m = e.m_radius + n.m_radius;
      u > m * m || (t.m_type = M.e_circles, t.m_localPoint.SetV(e.m_p), t.m_localPlaneNormal.SetZero(), t.m_pointCount = 1, t.m_points[0].m_localPoint.SetV(n.m_p), t.m_points[0].m_id.key = 0);
    }, p.CollidePolygonAndCircle = function (t, e, i, n, r) {
      t.m_pointCount = 0;
      var o, s, a = 0, l = 0;
      s = r.R, o = n.m_p;
      var c = r.position.x + (s.col1.x * o.x + s.col2.x * o.y), h = r.position.y + (s.col1.y * o.x + s.col2.y * o.y);
      a = c - i.position.x, l = h - i.position.y;
      for (var u = a * (s = i.R).col1.x + l * s.col1.y, m = a * s.col2.x + l * s.col2.y, p = 0, d = -Number.MAX_VALUE, f = e.m_radius + n.m_radius, _ = parseInt(e.m_vertexCount), y = e.m_vertices, g = e.m_normals, x = 0; x < _; ++x) {
        a = u - (o = y[x]).x, l = m - o.y;
        var v = (o = g[x]).x * a + o.y * l;
        if (v > f) return;
        v > d && (d = v, p = x);
      }
      var b = parseInt(p), w = parseInt(b + 1 < _ ? b + 1 : 0), S = y[b], C = y[w];
      if (d < Number.MIN_VALUE) return t.m_pointCount = 1, t.m_type = M.e_faceA, t.m_localPlaneNormal.SetV(g[p]), t.m_localPoint.x = 0.5 * (S.x + C.x), t.m_localPoint.y = 0.5 * (S.y + C.y), t.m_points[0].m_localPoint.SetV(n.m_p), void (t.m_points[0].m_id.key = 0);
      var A = (u - S.x) * (C.x - S.x) + (m - S.y) * (C.y - S.y), T = (u - C.x) * (S.x - C.x) + (m - C.y) * (S.y - C.y);
      if (A <= 0) {
        if ((u - S.x) * (u - S.x) + (m - S.y) * (m - S.y) > f * f) return;
        t.m_pointCount = 1, t.m_type = M.e_faceA, t.m_localPlaneNormal.x = u - S.x, t.m_localPlaneNormal.y = m - S.y, t.m_localPlaneNormal.Normalize(), t.m_localPoint.SetV(S), t.m_points[0].m_localPoint.SetV(n.m_p), t.m_points[0].m_id.key = 0;
      } else if (T <= 0) {
        if ((u - C.x) * (u - C.x) + (m - C.y) * (m - C.y) > f * f) return;
        t.m_pointCount = 1, t.m_type = M.e_faceA, t.m_localPlaneNormal.x = u - C.x, t.m_localPlaneNormal.y = m - C.y, t.m_localPlaneNormal.Normalize(), t.m_localPoint.SetV(C), t.m_points[0].m_localPoint.SetV(n.m_p), t.m_points[0].m_id.key = 0;
      } else {
        var E = 0.5 * (S.x + C.x), L = 0.5 * (S.y + C.y);
        if ((d = (u - E) * g[b].x + (m - L) * g[b].y) > f) return;
        t.m_pointCount = 1, t.m_type = M.e_faceA, t.m_localPlaneNormal.x = g[b].x, t.m_localPlaneNormal.y = g[b].y, t.m_localPlaneNormal.Normalize(), t.m_localPoint.Set(E, L), t.m_points[0].m_localPoint.SetV(n.m_p), t.m_points[0].m_id.key = 0;
      }
    }, p.TestOverlap = function (t, e) {
      var i = e.lowerBound, n = t.upperBound, r = i.x - n.x, o = i.y - n.y;
      i = t.lowerBound, n = e.upperBound;
      var s = i.x - n.x, a = i.y - n.y;
      return !(r > 0 || o > 0 || s > 0 || a > 0);
    }, e.postDefs.push(function () {
      e.Collision.b2Collision.s_incidentEdge = p.MakeClipPointVector(), e.Collision.b2Collision.s_clipPoints1 = p.MakeClipPointVector(), e.Collision.b2Collision.s_clipPoints2 = p.MakeClipPointVector(), e.Collision.b2Collision.s_edgeAO = new H(1), e.Collision.b2Collision.s_edgeBO = new H(1), e.Collision.b2Collision.s_localTangent = new c, e.Collision.b2Collision.s_localNormal = new c, e.Collision.b2Collision.s_planePoint = new c, e.Collision.b2Collision.s_normal = new c, e.Collision.b2Collision.s_tangent = new c, e.Collision.b2Collision.s_tangent2 = new c, e.Collision.b2Collision.s_v11 = new c, e.Collision.b2Collision.s_v12 = new c, e.Collision.b2Collision.b2CollidePolyTempVec = new c, e.Collision.b2Collision.b2_nullFeature = 255;
    }), d.b2ContactID = function () {
      this.features = new N;
    }, d.prototype.b2ContactID = function () {
      this.features._m_id = this;
    }, d.prototype.Set = function (t) {
      this.key = t._key;
    }, d.prototype.Copy = function () {
      var t = new d;
      return t.key = this.key, t;
    }, Object.defineProperty(d.prototype, "key", {enumerable: false, configurable: true, get: function () {
      return this._key;
    }}), Object.defineProperty(d.prototype, "key", {enumerable: false, configurable: true, set: function (t) {
      void 0 === t && (t = 0), this._key = t, this.features._referenceEdge = 255 & this._key, this.features._incidentEdge = (65280 & this._key) >> 8 & 255, this.features._incidentVertex = (16711680 & this._key) >> 16 & 255, this.features._flip = (4278190080 & this._key) >> 24 & 255;
    }}), f.b2ContactPoint = function () {
      this.position = new c, this.velocity = new c, this.normal = new c, this.id = new d;
    }, _.b2Distance = function () {}, _.Distance = function (t, e, i) {
      ++_.b2_gjkCalls;
      var n = i.proxyA, r = i.proxyB, a = i.transformA, l = i.transformB, h = _.s_simplex;
      h.ReadCache(e, n, a, r, l);
      for (var u, m = h.m_vertices, p = _.s_saveA, d = _.s_saveB, f = 0, y = (h.GetClosestPoint().LengthSquared(), 0), g = 0; g < 20;) {
        for (f = h.m_count, y = 0; y < f; y++) p[y] = m[y].indexA, d[y] = m[y].indexB;
        switch (h.m_count) {
          case 1:
            break;
          case 2:
            h.Solve2();
            break;
          case 3:
            h.Solve3();
            break;
          default:
            o.b2Assert(false);
        }
        if (3 == h.m_count) break;
        (u = h.GetClosestPoint()).LengthSquared();
        var x = h.GetSearchDirection();
        if (x.LengthSquared() < Number.MIN_VALUE * Number.MIN_VALUE) break;
        var v = m[h.m_count];
        v.indexA = n.GetSupport(s.MulTMV(a.R, x.GetNegative())), v.wA = s.MulX(a, n.GetVertex(v.indexA)), v.indexB = r.GetSupport(s.MulTMV(l.R, x)), v.wB = s.MulX(l, r.GetVertex(v.indexB)), v.w = s.SubtractVV(v.wB, v.wA), ++g, ++_.b2_gjkIters;
        var b = false;
        for (y = 0; y < f; y++) if (v.indexA == p[y] && v.indexB == d[y]) {
          b = true;
          break;
        }
        if (b) break;
        ++h.m_count;
      }
      if (_.b2_gjkMaxIters = s.Max(_.b2_gjkMaxIters, g), h.GetWitnessPoints(t.pointA, t.pointB), t.distance = s.SubtractVV(t.pointA, t.pointB).Length(), t.iterations = g, h.WriteCache(e), i.useRadii) {
        var w = n.m_radius, S = r.m_radius;
        if (t.distance > w + S && t.distance > Number.MIN_VALUE) {
          t.distance -= w + S;
          var M = s.SubtractVV(t.pointB, t.pointA);
          M.Normalize(), t.pointA.x += w * M.x, t.pointA.y += w * M.y, t.pointB.x -= S * M.x, t.pointB.y -= S * M.y;
        } else (u = new c).x = 0.5 * (t.pointA.x + t.pointB.x), u.y = 0.5 * (t.pointA.y + t.pointB.y), t.pointA.x = t.pointB.x = u.x, t.pointA.y = t.pointB.y = u.y, t.distance = 0;
      }
    }, e.postDefs.push(function () {
      e.Collision.b2Distance.s_simplex = new V, e.Collision.b2Distance.s_saveA = new H(3), e.Collision.b2Distance.s_saveB = new H(3);
    }), y.b2DistanceInput = function () {}, g.b2DistanceOutput = function () {
      this.pointA = new c, this.pointB = new c;
    }, x.b2DistanceProxy = function () {}, x.prototype.Set = function (t) {
      switch (t.GetType()) {
        case r.e_circleShape:
          var e = t instanceof i ? t : null;
          this.m_vertices = new k(1, true), this.m_vertices[0] = e.m_p, this.m_count = 1, this.m_radius = e.m_radius;
          break;
        case r.e_polygonShape:
          var s = t instanceof n ? t : null;
          this.m_vertices = s.m_vertices, this.m_count = s.m_vertexCount, this.m_radius = s.m_radius;
          break;
        default:
          o.b2Assert(false);
      }
    }, x.prototype.GetSupport = function (t) {
      for (var e = 0, i = this.m_vertices[0].x * t.x + this.m_vertices[0].y * t.y, n = 1; n < this.m_count; ++n) {
        var r = this.m_vertices[n].x * t.x + this.m_vertices[n].y * t.y;
        r > i && (e = n, i = r);
      }
      return e;
    }, x.prototype.GetSupportVertex = function (t) {
      for (var e = 0, i = this.m_vertices[0].x * t.x + this.m_vertices[0].y * t.y, n = 1; n < this.m_count; ++n) {
        var r = this.m_vertices[n].x * t.x + this.m_vertices[n].y * t.y;
        r > i && (e = n, i = r);
      }
      return this.m_vertices[e];
    }, x.prototype.GetVertexCount = function () {
      return this.m_count;
    }, x.prototype.GetVertex = function (t) {
      return void 0 === t && (t = 0), o.b2Assert(0 <= t && t < this.m_count), this.m_vertices[t];
    }, v.b2DynamicTree = function () {}, v.prototype.b2DynamicTree = function () {
      this.m_root = null, this.m_freeList = null, this.m_path = 0, this.m_insertionCount = 0;
    }, v.prototype.CreateProxy = function (t, e) {
      var i = this.AllocateNode(), n = o.b2_aabbExtension, r = o.b2_aabbExtension;
      return i.aabb.lowerBound.x = t.lowerBound.x - n, i.aabb.lowerBound.y = t.lowerBound.y - r, i.aabb.upperBound.x = t.upperBound.x + n, i.aabb.upperBound.y = t.upperBound.y + r, i.userData = e, this.InsertLeaf(i), i;
    }, v.prototype.DestroyProxy = function (t) {
      this.RemoveLeaf(t), this.FreeNode(t);
    }, v.prototype.MoveProxy = function (t, e, i) {
      if (o.b2Assert(t.IsLeaf()), t.aabb.Contains(e)) return false;
      this.RemoveLeaf(t);
      var n = o.b2_aabbExtension + o.b2_aabbMultiplier * (i.x > 0 ? i.x : -i.x), r = o.b2_aabbExtension + o.b2_aabbMultiplier * (i.y > 0 ? i.y : -i.y);
      return t.aabb.lowerBound.x = e.lowerBound.x - n, t.aabb.lowerBound.y = e.lowerBound.y - r, t.aabb.upperBound.x = e.upperBound.x + n, t.aabb.upperBound.y = e.upperBound.y + r, this.InsertLeaf(t), true;
    }, v.prototype.Rebalance = function (t) {
      if (void 0 === t && (t = 0), null != this.m_root) for (var e = 0; e < t; e++) {
        for (var i = this.m_root, n = 0; 0 == i.IsLeaf();) i = this.m_path >> n & 1 ? i.child2 : i.child1, n = n + 1 & 31;
        ++this.m_path, this.RemoveLeaf(i), this.InsertLeaf(i);
      }
    }, v.prototype.GetFatAABB = function (t) {
      return t.aabb;
    }, v.prototype.GetUserData = function (t) {
      return t.userData;
    }, v.prototype.Query = function (t, e) {
      if (null != this.m_root) {
        var i = new k, n = 0;
        for (i[n++] = this.m_root; n > 0;) {
          var r = i[--n];
          if (r.aabb.TestOverlap(e)) if (r.IsLeaf()) {
            if (!t(r)) return;
          } else i[n++] = r.child1, i[n++] = r.child2;
        }
      }
    }, v.prototype.RayCast = function (t, e) {
      if (null != this.m_root) {
        var i = e.p1, n = e.p2, r = s.SubtractVV(i, n);
        r.Normalize();
        var o = s.CrossFV(1, r), a = s.AbsV(o), l = e.maxFraction, c = new h, u = 0, m = 0;
        u = i.x + l * (n.x - i.x), m = i.y + l * (n.y - i.y), c.lowerBound.x = Math.min(i.x, u), c.lowerBound.y = Math.min(i.y, m), c.upperBound.x = Math.max(i.x, u), c.upperBound.y = Math.max(i.y, m);
        var p = new k, d = 0;
        for (p[d++] = this.m_root; d > 0;) {
          var f = p[--d];
          if (0 != f.aabb.TestOverlap(c)) {
            var _ = f.aabb.GetCenter(), y = f.aabb.GetExtents();
            if (!(Math.abs(o.x * (i.x - _.x) + o.y * (i.y - _.y)) - a.x * y.x - a.y * y.y > 0)) if (f.IsLeaf()) {
              var g = new T;
              if (g.p1 = e.p1, g.p2 = e.p2, g.maxFraction = e.maxFraction, 0 == (l = t(g, f))) return;
              l > 0 && (u = i.x + l * (n.x - i.x), m = i.y + l * (n.y - i.y), c.lowerBound.x = Math.min(i.x, u), c.lowerBound.y = Math.min(i.y, m), c.upperBound.x = Math.max(i.x, u), c.upperBound.y = Math.max(i.y, m));
            } else p[d++] = f.child1, p[d++] = f.child2;
          }
        }
      }
    }, v.prototype.AllocateNode = function () {
      if (this.m_freeList) {
        var t = this.m_freeList;
        return this.m_freeList = t.parent, t.parent = null, t.child1 = null, t.child2 = null, t;
      }
      return new w;
    }, v.prototype.FreeNode = function (t) {
      t.parent = this.m_freeList, this.m_freeList = t;
    }, v.prototype.InsertLeaf = function (t) {
      if (++this.m_insertionCount, null == this.m_root) return this.m_root = t, void (this.m_root.parent = null);
      var e = t.aabb.GetCenter(), i = this.m_root;
      if (0 == i.IsLeaf()) do {
        var n = i.child1, r = i.child2;
        i = Math.abs((n.aabb.lowerBound.x + n.aabb.upperBound.x) / 2 - e.x) + Math.abs((n.aabb.lowerBound.y + n.aabb.upperBound.y) / 2 - e.y) < Math.abs((r.aabb.lowerBound.x + r.aabb.upperBound.x) / 2 - e.x) + Math.abs((r.aabb.lowerBound.y + r.aabb.upperBound.y) / 2 - e.y) ? n : r;
      } while (0 == i.IsLeaf());
      var o = i.parent, s = this.AllocateNode();
      if (s.parent = o, s.userData = null, s.aabb.Combine(t.aabb, i.aabb), o) {
        i.parent.child1 == i ? o.child1 = s : o.child2 = s, s.child1 = i, s.child2 = t, i.parent = s, t.parent = s;
        do {
          if (o.aabb.Contains(s.aabb)) break;
          o.aabb.Combine(o.child1.aabb, o.child2.aabb), s = o, o = o.parent;
        } while (o);
      } else s.child1 = i, s.child2 = t, i.parent = s, t.parent = s, this.m_root = s;
    }, v.prototype.RemoveLeaf = function (t) {
      if (t != this.m_root) {
        var e, i = t.parent, n = i.parent;
        if (e = i.child1 == t ? i.child2 : i.child1, n) for (n.child1 == i ? n.child1 = e : n.child2 = e, e.parent = n, this.FreeNode(i); n;) {
          var r = n.aabb;
          if (n.aabb = h.Combine(n.child1.aabb, n.child2.aabb), r.Contains(n.aabb)) break;
          n = n.parent;
        } else this.m_root = e, e.parent = null, this.FreeNode(i);
      } else this.m_root = null;
    }, b.b2DynamicTreeBroadPhase = function () {
      this.m_tree = new v, this.m_moveBuffer = new k, this.m_pairBuffer = new k, this.m_pairCount = 0;
    }, b.prototype.CreateProxy = function (t, e) {
      var i = this.m_tree.CreateProxy(t, e);
      return ++this.m_proxyCount, this.BufferMove(i), i;
    }, b.prototype.DestroyProxy = function (t) {
      this.UnBufferMove(t), --this.m_proxyCount, this.m_tree.DestroyProxy(t);
    }, b.prototype.MoveProxy = function (t, e, i) {
      this.m_tree.MoveProxy(t, e, i) && this.BufferMove(t);
    }, b.prototype.TestOverlap = function (t, e) {
      var i = this.m_tree.GetFatAABB(t), n = this.m_tree.GetFatAABB(e);
      return i.TestOverlap(n);
    }, b.prototype.GetUserData = function (t) {
      return this.m_tree.GetUserData(t);
    }, b.prototype.GetFatAABB = function (t) {
      return this.m_tree.GetFatAABB(t);
    }, b.prototype.GetProxyCount = function () {
      return this.m_proxyCount;
    }, b.prototype.UpdatePairs = function (t) {
      var e = this;
      e.m_pairCount = 0;
      var i, n = 0;
      function r(t) {
        if (t == i) return true;
        e.m_pairCount == e.m_pairBuffer.length && (e.m_pairBuffer[e.m_pairCount] = new S);
        var n = e.m_pairBuffer[e.m_pairCount];
        return n.proxyA = t < i ? t : i, n.proxyB = t >= i ? t : i, ++e.m_pairCount, true;
      }
      for (n = 0; n < e.m_moveBuffer.length; ++n) {
        i = e.m_moveBuffer[n];
        var o = e.m_tree.GetFatAABB(i);
        e.m_tree.Query(r, o);
      }
      for (e.m_moveBuffer.length = 0, n = 0; n < e.m_pairCount;) {
        var s = e.m_pairBuffer[n];
        for (t(e.m_tree.GetUserData(s.proxyA), e.m_tree.GetUserData(s.proxyB)), ++n; n < e.m_pairCount;) {
          var a = e.m_pairBuffer[n];
          if (a.proxyA != s.proxyA || a.proxyB != s.proxyB) break;
          ++n;
        }
      }
    }, b.prototype.Query = function (t, e) {
      this.m_tree.Query(t, e);
    }, b.prototype.RayCast = function (t, e) {
      this.m_tree.RayCast(t, e);
    }, b.prototype.Validate = function () {}, b.prototype.Rebalance = function (t) {
      void 0 === t && (t = 0), this.m_tree.Rebalance(t);
    }, b.prototype.BufferMove = function (t) {
      this.m_moveBuffer[this.m_moveBuffer.length] = t;
    }, b.prototype.UnBufferMove = function (t) {
      var e = parseInt(this.m_moveBuffer.indexOf(t));
      this.m_moveBuffer.splice(e, 1);
    }, b.prototype.ComparePairs = function (t, e) {
      return 0;
    }, b.__implements = {}, b.__implements[z] = true, w.b2DynamicTreeNode = function () {
      this.aabb = new h;
    }, w.prototype.IsLeaf = function () {
      return null == this.child1;
    }, S.b2DynamicTreePair = function () {}, M.b2Manifold = function () {
      this.m_pointCount = 0;
    }, M.prototype.b2Manifold = function () {
      this.m_points = new k(o.b2_maxManifoldPoints);
      for (var t = 0; t < o.b2_maxManifoldPoints; t++) this.m_points[t] = new C;
      this.m_localPlaneNormal = new c, this.m_localPoint = new c;
    }, M.prototype.Reset = function () {
      for (var t = 0; t < o.b2_maxManifoldPoints; t++) (this.m_points[t] instanceof C ? this.m_points[t] : null).Reset();
      this.m_localPlaneNormal.SetZero(), this.m_localPoint.SetZero(), this.m_type = 0, this.m_pointCount = 0;
    }, M.prototype.Set = function (t) {
      this.m_pointCount = t.m_pointCount;
      for (var e = 0; e < o.b2_maxManifoldPoints; e++) (this.m_points[e] instanceof C ? this.m_points[e] : null).Set(t.m_points[e]);
      this.m_localPlaneNormal.SetV(t.m_localPlaneNormal), this.m_localPoint.SetV(t.m_localPoint), this.m_type = t.m_type;
    }, M.prototype.Copy = function () {
      var t = new M;
      return t.Set(this), t;
    }, e.postDefs.push(function () {
      e.Collision.b2Manifold.e_circles = 1, e.Collision.b2Manifold.e_faceA = 2, e.Collision.b2Manifold.e_faceB = 4;
    }), C.b2ManifoldPoint = function () {
      this.m_localPoint = new c, this.m_id = new d;
    }, C.prototype.b2ManifoldPoint = function () {
      this.Reset();
    }, C.prototype.Reset = function () {
      this.m_localPoint.SetZero(), this.m_normalImpulse = 0, this.m_tangentImpulse = 0, this.m_id.key = 0;
    }, C.prototype.Set = function (t) {
      this.m_localPoint.SetV(t.m_localPoint), this.m_normalImpulse = t.m_normalImpulse, this.m_tangentImpulse = t.m_tangentImpulse, this.m_id.Set(t.m_id);
    }, A.b2Point = function () {
      this.p = new c;
    }, A.prototype.Support = function (t, e, i) {
      return void 0 === e && (e = 0), void 0 === i && (i = 0), this.p;
    }, A.prototype.GetFirstVertex = function (t) {
      return this.p;
    }, T.b2RayCastInput = function () {
      this.p1 = new c, this.p2 = new c;
    }, T.prototype.b2RayCastInput = function (t, e, i) {
      void 0 === t && (t = null), void 0 === e && (e = null), void 0 === i && (i = 1), t && this.p1.SetV(t), e && this.p2.SetV(e), this.maxFraction = i;
    }, E.b2RayCastOutput = function () {
      this.normal = new c;
    }, L.b2Segment = function () {
      this.p1 = new c, this.p2 = new c;
    }, L.prototype.TestSegment = function (t, e, i, n) {
      void 0 === n && (n = 0);
      var r = i.p1, o = i.p2.x - r.x, s = i.p2.y - r.y, a = this.p2.x - this.p1.x, l = this.p2.y - this.p1.y, c = -a, h = 100 * Number.MIN_VALUE, u = -(o * l + s * c);
      if (u > h) {
        var m = r.x - this.p1.x, p = r.y - this.p1.y, d = m * l + p * c;
        if (0 <= d && d <= n * u) {
          var f = -o * p + s * m;
          if (-h * u <= f && f <= u * (1 + h)) {
            d /= u;
            var _ = Math.sqrt(l * l + c * c);
            return l /= _, c /= _, t[0] = d, e.Set(l, c), true;
          }
        }
      }
      return false;
    }, L.prototype.Extend = function (t) {
      this.ExtendForward(t), this.ExtendBackward(t);
    }, L.prototype.ExtendForward = function (t) {
      var e = this.p2.x - this.p1.x, i = this.p2.y - this.p1.y, n = Math.min(e > 0 ? (t.upperBound.x - this.p1.x) / e : e < 0 ? (t.lowerBound.x - this.p1.x) / e : Number.POSITIVE_INFINITY, i > 0 ? (t.upperBound.y - this.p1.y) / i : i < 0 ? (t.lowerBound.y - this.p1.y) / i : Number.POSITIVE_INFINITY);
      this.p2.x = this.p1.x + e * n, this.p2.y = this.p1.y + i * n;
    }, L.prototype.ExtendBackward = function (t) {
      var e = -this.p2.x + this.p1.x, i = -this.p2.y + this.p1.y, n = Math.min(e > 0 ? (t.upperBound.x - this.p2.x) / e : e < 0 ? (t.lowerBound.x - this.p2.x) / e : Number.POSITIVE_INFINITY, i > 0 ? (t.upperBound.y - this.p2.y) / i : i < 0 ? (t.lowerBound.y - this.p2.y) / i : Number.POSITIVE_INFINITY);
      this.p1.x = this.p2.x + e * n, this.p1.y = this.p2.y + i * n;
    }, D.b2SeparationFunction = function () {
      this.m_localPoint = new c, this.m_axis = new c;
    }, D.prototype.Initialize = function (t, e, i, n, r) {
      this.m_proxyA = e, this.m_proxyB = n;
      var a, l, h, u, m, p, d = parseInt(t.count);
      o.b2Assert(0 < d && d < 3);
      var f, _, y = 0, g = 0, x = 0, v = 0, b = 0, w = 0, S = 0;
      if (1 == d) this.m_type = D.e_points, a = this.m_proxyA.GetVertex(t.indexA[0]), u = this.m_proxyB.GetVertex(t.indexB[0]), _ = a, f = i.R, y = i.position.x + (f.col1.x * _.x + f.col2.x * _.y), g = i.position.y + (f.col1.y * _.x + f.col2.y * _.y), _ = u, f = r.R, x = r.position.x + (f.col1.x * _.x + f.col2.x * _.y), v = r.position.y + (f.col1.y * _.x + f.col2.y * _.y), this.m_axis.x = x - y, this.m_axis.y = v - g, this.m_axis.Normalize(); else if (t.indexB[0] == t.indexB[1]) this.m_type = D.e_faceA, l = this.m_proxyA.GetVertex(t.indexA[0]), h = this.m_proxyA.GetVertex(t.indexA[1]), u = this.m_proxyB.GetVertex(t.indexB[0]), this.m_localPoint.x = 0.5 * (l.x + h.x), this.m_localPoint.y = 0.5 * (l.y + h.y), this.m_axis = s.CrossVF(s.SubtractVV(h, l), 1), this.m_axis.Normalize(), _ = this.m_axis, b = (f = i.R).col1.x * _.x + f.col2.x * _.y, w = f.col1.y * _.x + f.col2.y * _.y, _ = this.m_localPoint, f = i.R, y = i.position.x + (f.col1.x * _.x + f.col2.x * _.y), g = i.position.y + (f.col1.y * _.x + f.col2.y * _.y), _ = u, f = r.R, (S = ((x = r.position.x + (f.col1.x * _.x + f.col2.x * _.y)) - y) * b + ((v = r.position.y + (f.col1.y * _.x + f.col2.y * _.y)) - g) * w) < 0 && this.m_axis.NegativeSelf(); else if (t.indexA[0] == t.indexA[0]) this.m_type = D.e_faceB, m = this.m_proxyB.GetVertex(t.indexB[0]), p = this.m_proxyB.GetVertex(t.indexB[1]), a = this.m_proxyA.GetVertex(t.indexA[0]), this.m_localPoint.x = 0.5 * (m.x + p.x), this.m_localPoint.y = 0.5 * (m.y + p.y), this.m_axis = s.CrossVF(s.SubtractVV(p, m), 1), this.m_axis.Normalize(), _ = this.m_axis, b = (f = r.R).col1.x * _.x + f.col2.x * _.y, w = f.col1.y * _.x + f.col2.y * _.y, _ = this.m_localPoint, f = r.R, x = r.position.x + (f.col1.x * _.x + f.col2.x * _.y), v = r.position.y + (f.col1.y * _.x + f.col2.y * _.y), _ = a, f = i.R, (S = ((y = i.position.x + (f.col1.x * _.x + f.col2.x * _.y)) - x) * b + ((g = i.position.y + (f.col1.y * _.x + f.col2.y * _.y)) - v) * w) < 0 && this.m_axis.NegativeSelf(); else {
        l = this.m_proxyA.GetVertex(t.indexA[0]), h = this.m_proxyA.GetVertex(t.indexA[1]), m = this.m_proxyB.GetVertex(t.indexB[0]), p = this.m_proxyB.GetVertex(t.indexB[1]), s.MulX(i, a);
        var M = s.MulMV(i.R, s.SubtractVV(h, l)), C = (s.MulX(r, u), s.MulMV(r.R, s.SubtractVV(p, m))), A = M.x * M.x + M.y * M.y, T = C.x * C.x + C.y * C.y, E = s.SubtractVV(C, M), L = M.x * E.x + M.y * E.y, V = C.x * E.x + C.y * E.y, B = M.x * C.x + M.y * C.y, R = A * T - B * B;
        S = 0, 0 != R && (S = s.Clamp((B * V - L * T) / R, 0, 1));
        var P = (B * S + V) / T;
        P < 0 && (P = 0, S = s.Clamp((B - L) / A, 0, 1)), (a = new c).x = l.x + S * (h.x - l.x), a.y = l.y + S * (h.y - l.y), (u = new c).x = m.x + S * (p.x - m.x), u.y = m.y + S * (p.y - m.y), 0 == S || 1 == S ? (this.m_type = D.e_faceB, this.m_axis = s.CrossVF(s.SubtractVV(p, m), 1), this.m_axis.Normalize(), this.m_localPoint = u, _ = this.m_axis, b = (f = r.R).col1.x * _.x + f.col2.x * _.y, w = f.col1.y * _.x + f.col2.y * _.y, _ = this.m_localPoint, f = r.R, x = r.position.x + (f.col1.x * _.x + f.col2.x * _.y), v = r.position.y + (f.col1.y * _.x + f.col2.y * _.y), _ = a, f = i.R, y = i.position.x + (f.col1.x * _.x + f.col2.x * _.y), g = i.position.y + (f.col1.y * _.x + f.col2.y * _.y), S < 0 && this.m_axis.NegativeSelf()) : (this.m_type = D.e_faceA, this.m_axis = s.CrossVF(s.SubtractVV(h, l), 1), this.m_localPoint = a, _ = this.m_axis, b = (f = i.R).col1.x * _.x + f.col2.x * _.y, w = f.col1.y * _.x + f.col2.y * _.y, _ = this.m_localPoint, f = i.R, y = i.position.x + (f.col1.x * _.x + f.col2.x * _.y), g = i.position.y + (f.col1.y * _.x + f.col2.y * _.y), _ = u, f = r.R, x = r.position.x + (f.col1.x * _.x + f.col2.x * _.y), v = r.position.y + (f.col1.y * _.x + f.col2.y * _.y), S < 0 && this.m_axis.NegativeSelf());
      }
    }, D.prototype.Evaluate = function (t, e) {
      var i, n, r, a, l, c, h;
      switch (this.m_type) {
        case D.e_points:
          return i = s.MulTMV(t.R, this.m_axis), n = s.MulTMV(e.R, this.m_axis.GetNegative()), r = this.m_proxyA.GetSupportVertex(i), a = this.m_proxyB.GetSupportVertex(n), l = s.MulX(t, r), ((c = s.MulX(e, a)).x - l.x) * this.m_axis.x + (c.y - l.y) * this.m_axis.y;
        case D.e_faceA:
          return h = s.MulMV(t.R, this.m_axis), l = s.MulX(t, this.m_localPoint), n = s.MulTMV(e.R, h.GetNegative()), a = this.m_proxyB.GetSupportVertex(n), ((c = s.MulX(e, a)).x - l.x) * h.x + (c.y - l.y) * h.y;
        case D.e_faceB:
          return h = s.MulMV(e.R, this.m_axis), c = s.MulX(e, this.m_localPoint), i = s.MulTMV(t.R, h.GetNegative()), r = this.m_proxyA.GetSupportVertex(i), ((l = s.MulX(t, r)).x - c.x) * h.x + (l.y - c.y) * h.y;
        default:
          return o.b2Assert(false), 0;
      }
    }, e.postDefs.push(function () {
      e.Collision.b2SeparationFunction.e_points = 1, e.Collision.b2SeparationFunction.e_faceA = 2, e.Collision.b2SeparationFunction.e_faceB = 4;
    }), V.b2Simplex = function () {
      this.m_v1 = new R, this.m_v2 = new R, this.m_v3 = new R, this.m_vertices = new k(3);
    }, V.prototype.b2Simplex = function () {
      this.m_vertices[0] = this.m_v1, this.m_vertices[1] = this.m_v2, this.m_vertices[2] = this.m_v3;
    }, V.prototype.ReadCache = function (t, e, i, n, r) {
      var a, l;
      o.b2Assert(0 <= t.count && t.count <= 3), this.m_count = t.count;
      for (var c = this.m_vertices, h = 0; h < this.m_count; h++) {
        var u = c[h];
        u.indexA = t.indexA[h], u.indexB = t.indexB[h], a = e.GetVertex(u.indexA), l = n.GetVertex(u.indexB), u.wA = s.MulX(i, a), u.wB = s.MulX(r, l), u.w = s.SubtractVV(u.wB, u.wA), u.a = 0;
      }
      if (this.m_count > 1) {
        var m = t.metric, p = this.GetMetric();
        (p < 0.5 * m || 2 * m < p || p < Number.MIN_VALUE) && (this.m_count = 0);
      }
      0 == this.m_count && ((u = c[0]).indexA = 0, u.indexB = 0, a = e.GetVertex(0), l = n.GetVertex(0), u.wA = s.MulX(i, a), u.wB = s.MulX(r, l), u.w = s.SubtractVV(u.wB, u.wA), this.m_count = 1);
    }, V.prototype.WriteCache = function (t) {
      t.metric = this.GetMetric(), t.count = e.parseUInt(this.m_count);
      for (var i = this.m_vertices, n = 0; n < this.m_count; n++) t.indexA[n] = e.parseUInt(i[n].indexA), t.indexB[n] = e.parseUInt(i[n].indexB);
    }, V.prototype.GetSearchDirection = function () {
      switch (this.m_count) {
        case 1:
          return this.m_v1.w.GetNegative();
        case 2:
          var t = s.SubtractVV(this.m_v2.w, this.m_v1.w);
          return s.CrossVV(t, this.m_v1.w.GetNegative()) > 0 ? s.CrossFV(1, t) : s.CrossVF(t, 1);
        default:
          return o.b2Assert(false), new c;
      }
    }, V.prototype.GetClosestPoint = function () {
      switch (this.m_count) {
        case 0:
          return o.b2Assert(false), new c;
        case 1:
          return this.m_v1.w;
        case 2:
          return new c(this.m_v1.a * this.m_v1.w.x + this.m_v2.a * this.m_v2.w.x, this.m_v1.a * this.m_v1.w.y + this.m_v2.a * this.m_v2.w.y);
        default:
          return o.b2Assert(false), new c;
      }
    }, V.prototype.GetWitnessPoints = function (t, e) {
      switch (this.m_count) {
        case 0:
          o.b2Assert(false);
          break;
        case 1:
          t.SetV(this.m_v1.wA), e.SetV(this.m_v1.wB);
          break;
        case 2:
          t.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x, t.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y, e.x = this.m_v1.a * this.m_v1.wB.x + this.m_v2.a * this.m_v2.wB.x, e.y = this.m_v1.a * this.m_v1.wB.y + this.m_v2.a * this.m_v2.wB.y;
          break;
        case 3:
          e.x = t.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x + this.m_v3.a * this.m_v3.wA.x, e.y = t.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y + this.m_v3.a * this.m_v3.wA.y;
          break;
        default:
          o.b2Assert(false);
      }
    }, V.prototype.GetMetric = function () {
      switch (this.m_count) {
        case 0:
          return o.b2Assert(false), 0;
        case 1:
          return 0;
        case 2:
          return s.SubtractVV(this.m_v1.w, this.m_v2.w).Length();
        case 3:
          return s.CrossVV(s.SubtractVV(this.m_v2.w, this.m_v1.w), s.SubtractVV(this.m_v3.w, this.m_v1.w));
        default:
          return o.b2Assert(false), 0;
      }
    }, V.prototype.Solve2 = function () {
      var t = this.m_v1.w, e = this.m_v2.w, i = s.SubtractVV(e, t), n = -(t.x * i.x + t.y * i.y);
      if (n <= 0) return this.m_v1.a = 1, void (this.m_count = 1);
      var r = e.x * i.x + e.y * i.y;
      if (r <= 0) return this.m_v2.a = 1, this.m_count = 1, void this.m_v1.Set(this.m_v2);
      var o = 1 / (r + n);
      this.m_v1.a = r * o, this.m_v2.a = n * o, this.m_count = 2;
    }, V.prototype.Solve3 = function () {
      var t = this.m_v1.w, e = this.m_v2.w, i = this.m_v3.w, n = s.SubtractVV(e, t), r = s.Dot(t, n), o = s.Dot(e, n), a = -r, l = s.SubtractVV(i, t), c = s.Dot(t, l), h = s.Dot(i, l), u = -c, m = s.SubtractVV(i, e), p = s.Dot(e, m), d = s.Dot(i, m), f = -p, _ = s.CrossVV(n, l), y = _ * s.CrossVV(e, i), g = _ * s.CrossVV(i, t), x = _ * s.CrossVV(t, e);
      if (a <= 0 && u <= 0) return this.m_v1.a = 1, void (this.m_count = 1);
      if (o > 0 && a > 0 && x <= 0) {
        var v = 1 / (o + a);
        return this.m_v1.a = o * v, this.m_v2.a = a * v, void (this.m_count = 2);
      }
      if (h > 0 && u > 0 && g <= 0) {
        var b = 1 / (h + u);
        return this.m_v1.a = h * b, this.m_v3.a = u * b, this.m_count = 2, void this.m_v2.Set(this.m_v3);
      }
      if (o <= 0 && f <= 0) return this.m_v2.a = 1, this.m_count = 1, void this.m_v1.Set(this.m_v2);
      if (h <= 0 && d <= 0) return this.m_v3.a = 1, this.m_count = 1, void this.m_v1.Set(this.m_v3);
      if (d > 0 && f > 0 && y <= 0) {
        var w = 1 / (d + f);
        return this.m_v2.a = d * w, this.m_v3.a = f * w, this.m_count = 2, void this.m_v1.Set(this.m_v3);
      }
      var S = 1 / (y + g + x);
      this.m_v1.a = y * S, this.m_v2.a = g * S, this.m_v3.a = x * S, this.m_count = 3;
    }, B.b2SimplexCache = function () {
      this.indexA = new H(3), this.indexB = new H(3);
    }, R.b2SimplexVertex = function () {}, R.prototype.Set = function (t) {
      this.wA.SetV(t.wA), this.wB.SetV(t.wB), this.w.SetV(t.w), this.a = t.a, this.indexA = t.indexA, this.indexB = t.indexB;
    }, P.b2TimeOfImpact = function () {}, P.TimeOfImpact = function (t) {
      ++P.b2_toiCalls;
      var e = t.proxyA, i = t.proxyB, n = t.sweepA, r = t.sweepB;
      o.b2Assert(n.t0 == r.t0), o.b2Assert(1 - n.t0 > Number.MIN_VALUE);
      var a = e.m_radius + i.m_radius, l = t.tolerance, c = 0, h = 0, u = 0;
      for (P.s_cache.count = 0, P.s_distanceInput.useRadii = false;;) {
        if (n.GetTransform(P.s_xfA, c), r.GetTransform(P.s_xfB, c), P.s_distanceInput.proxyA = e, P.s_distanceInput.proxyB = i, P.s_distanceInput.transformA = P.s_xfA, P.s_distanceInput.transformB = P.s_xfB, _.Distance(P.s_distanceOutput, P.s_cache, P.s_distanceInput), P.s_distanceOutput.distance <= 0) {
          c = 1;
          break;
        }
        P.s_fcn.Initialize(P.s_cache, e, P.s_xfA, i, P.s_xfB);
        var m = P.s_fcn.Evaluate(P.s_xfA, P.s_xfB);
        if (m <= 0) {
          c = 1;
          break;
        }
        if (0 == h && (u = m > a ? s.Max(a - l, 0.75 * a) : s.Max(m - l, 0.02 * a)), m - u < 0.5 * l) {
          if (0 == h) {
            c = 1;
            break;
          }
          break;
        }
        var p = c, d = c, f = 1, y = m;
        n.GetTransform(P.s_xfA, f), r.GetTransform(P.s_xfB, f);
        var g = P.s_fcn.Evaluate(P.s_xfA, P.s_xfB);
        if (g >= u) {
          c = 1;
          break;
        }
        for (var x = 0;;) {
          var v = 0;
          v = 1 & x ? d + (u - y) * (f - d) / (g - y) : 0.5 * (d + f), n.GetTransform(P.s_xfA, v), r.GetTransform(P.s_xfB, v);
          var b = P.s_fcn.Evaluate(P.s_xfA, P.s_xfB);
          if (s.Abs(b - u) < 0.025 * l) {
            p = v;
            break;
          }
          if (b > u ? (d = v, y = b) : (f = v, g = b), ++x, ++P.b2_toiRootIters, 50 == x) break;
        }
        if (P.b2_toiMaxRootIters = s.Max(P.b2_toiMaxRootIters, x), p < (1 + 100 * Number.MIN_VALUE) * c) break;
        if (c = p, h++, ++P.b2_toiIters, 1e3 == h) break;
      }
      return P.b2_toiMaxIters = s.Max(P.b2_toiMaxIters, h), c;
    }, e.postDefs.push(function () {
      e.Collision.b2TimeOfImpact.b2_toiCalls = 0, e.Collision.b2TimeOfImpact.b2_toiIters = 0, e.Collision.b2TimeOfImpact.b2_toiMaxIters = 0, e.Collision.b2TimeOfImpact.b2_toiRootIters = 0, e.Collision.b2TimeOfImpact.b2_toiMaxRootIters = 0, e.Collision.b2TimeOfImpact.s_cache = new B, e.Collision.b2TimeOfImpact.s_distanceInput = new y, e.Collision.b2TimeOfImpact.s_xfA = new l, e.Collision.b2TimeOfImpact.s_xfB = new l, e.Collision.b2TimeOfImpact.s_fcn = new D, e.Collision.b2TimeOfImpact.s_distanceOutput = new g;
    }), I.b2TOIInput = function () {
      this.proxyA = new x, this.proxyB = new x, this.sweepA = new a, this.sweepB = new a;
    }, F.b2WorldManifold = function () {
      this.m_normal = new c;
    }, F.prototype.b2WorldManifold = function () {
      this.m_points = new k(o.b2_maxManifoldPoints);
      for (var t = 0; t < o.b2_maxManifoldPoints; t++) this.m_points[t] = new c;
    }, F.prototype.Initialize = function (t, e, i, n, r) {
      if (void 0 === i && (i = 0), void 0 === r && (r = 0), 0 != t.m_pointCount) {
        var o, s, a = 0, l = 0, c = 0, h = 0, u = 0, m = 0, p = 0;
        switch (t.m_type) {
          case M.e_circles:
            s = e.R, o = t.m_localPoint;
            var d = e.position.x + s.col1.x * o.x + s.col2.x * o.y, f = e.position.y + s.col1.y * o.x + s.col2.y * o.y;
            s = n.R, o = t.m_points[0].m_localPoint;
            var _ = n.position.x + s.col1.x * o.x + s.col2.x * o.y, y = n.position.y + s.col1.y * o.x + s.col2.y * o.y, g = _ - d, x = y - f, v = g * g + x * x;
            if (v > Number.MIN_VALUE * Number.MIN_VALUE) {
              var b = Math.sqrt(v);
              this.m_normal.x = g / b, this.m_normal.y = x / b;
            } else this.m_normal.x = 1, this.m_normal.y = 0;
            var w = d + i * this.m_normal.x, S = f + i * this.m_normal.y, C = _ - r * this.m_normal.x, A = y - r * this.m_normal.y;
            this.m_points[0].x = 0.5 * (w + C), this.m_points[0].y = 0.5 * (S + A);
            break;
          case M.e_faceA:
            for (s = e.R, o = t.m_localPlaneNormal, l = s.col1.x * o.x + s.col2.x * o.y, c = s.col1.y * o.x + s.col2.y * o.y, s = e.R, o = t.m_localPoint, h = e.position.x + s.col1.x * o.x + s.col2.x * o.y, u = e.position.y + s.col1.y * o.x + s.col2.y * o.y, this.m_normal.x = l, this.m_normal.y = c, a = 0; a < t.m_pointCount; a++) s = n.R, o = t.m_points[a].m_localPoint, m = n.position.x + s.col1.x * o.x + s.col2.x * o.y, p = n.position.y + s.col1.y * o.x + s.col2.y * o.y, this.m_points[a].x = m + 0.5 * (i - (m - h) * l - (p - u) * c - r) * l, this.m_points[a].y = p + 0.5 * (i - (m - h) * l - (p - u) * c - r) * c;
            break;
          case M.e_faceB:
            for (s = n.R, o = t.m_localPlaneNormal, l = s.col1.x * o.x + s.col2.x * o.y, c = s.col1.y * o.x + s.col2.y * o.y, s = n.R, o = t.m_localPoint, h = n.position.x + s.col1.x * o.x + s.col2.x * o.y, u = n.position.y + s.col1.y * o.x + s.col2.y * o.y, this.m_normal.x = -l, this.m_normal.y = -c, a = 0; a < t.m_pointCount; a++) s = e.R, o = t.m_points[a].m_localPoint, m = e.position.x + s.col1.x * o.x + s.col2.x * o.y, p = e.position.y + s.col1.y * o.x + s.col2.y * o.y, this.m_points[a].x = m + 0.5 * (r - (m - h) * l - (p - u) * c - i) * l, this.m_points[a].y = p + 0.5 * (r - (m - h) * l - (p - u) * c - i) * c;
        }
      }
    }, G.ClipVertex = function () {
      this.v = new c, this.id = new d;
    }, G.prototype.Set = function (t) {
      this.v.SetV(t.v), this.id.Set(t.id);
    }, N.Features = function () {}, Object.defineProperty(N.prototype, "referenceEdge", {enumerable: false, configurable: true, get: function () {
      return this._referenceEdge;
    }}), Object.defineProperty(N.prototype, "referenceEdge", {enumerable: false, configurable: true, set: function (t) {
      void 0 === t && (t = 0), this._referenceEdge = t, this._m_id._key = 4294967040 & this._m_id._key | 255 & this._referenceEdge;
    }}), Object.defineProperty(N.prototype, "incidentEdge", {enumerable: false, configurable: true, get: function () {
      return this._incidentEdge;
    }}), Object.defineProperty(N.prototype, "incidentEdge", {enumerable: false, configurable: true, set: function (t) {
      void 0 === t && (t = 0), this._incidentEdge = t, this._m_id._key = 4294902015 & this._m_id._key | this._incidentEdge << 8 & 65280;
    }}), Object.defineProperty(N.prototype, "incidentVertex", {enumerable: false, configurable: true, get: function () {
      return this._incidentVertex;
    }}), Object.defineProperty(N.prototype, "incidentVertex", {enumerable: false, configurable: true, set: function (t) {
      void 0 === t && (t = 0), this._incidentVertex = t, this._m_id._key = 4278255615 & this._m_id._key | this._incidentVertex << 16 & 16711680;
    }}), Object.defineProperty(N.prototype, "flip", {enumerable: false, configurable: true, get: function () {
      return this._flip;
    }}), Object.defineProperty(N.prototype, "flip", {enumerable: false, configurable: true, set: function (t) {
      void 0 === t && (t = 0), this._flip = t, this._m_id._key = 16777215 & this._m_id._key | this._flip << 24 & 4278190080;
    }}), function () {
      e.Common.b2Color, e.Common.b2internal;
      var t = e.Common.b2Settings, i = e.Collision.Shapes.b2CircleShape, n = e.Collision.Shapes.b2EdgeChainDef, r = e.Collision.Shapes.b2EdgeShape, o = e.Collision.Shapes.b2MassData, s = e.Collision.Shapes.b2PolygonShape, a = e.Collision.Shapes.b2Shape, l = e.Common.Math.b2Mat22, c = (e.Common.Math.b2Mat33, e.Common.Math.b2Math), h = (e.Common.Math.b2Sweep, e.Common.Math.b2Transform), u = e.Common.Math.b2Vec2, m = (e.Common.Math.b2Vec3, e.Dynamics.b2Body, e.Dynamics.b2BodyDef, e.Dynamics.b2ContactFilter, e.Dynamics.b2ContactImpulse, e.Dynamics.b2ContactListener, e.Dynamics.b2ContactManager, e.Dynamics.b2DebugDraw, e.Dynamics.b2DestructionListener, e.Dynamics.b2FilterData, e.Dynamics.b2Fixture, e.Dynamics.b2FixtureDef, e.Dynamics.b2Island, e.Dynamics.b2TimeStep, e.Dynamics.b2World, e.Collision.b2AABB, e.Collision.b2Bound, e.Collision.b2BoundValues, e.Collision.b2Collision, e.Collision.b2ContactID, e.Collision.b2ContactPoint, e.Collision.b2Distance), p = e.Collision.b2DistanceInput, d = e.Collision.b2DistanceOutput, f = e.Collision.b2DistanceProxy, _ = (e.Collision.b2DynamicTree, e.Collision.b2DynamicTreeBroadPhase, e.Collision.b2DynamicTreeNode, e.Collision.b2DynamicTreePair, e.Collision.b2Manifold, e.Collision.b2ManifoldPoint, e.Collision.b2Point, e.Collision.b2RayCastInput, e.Collision.b2RayCastOutput, e.Collision.b2Segment, e.Collision.b2SeparationFunction, e.Collision.b2Simplex, e.Collision.b2SimplexCache);
      e.Collision.b2SimplexVertex, e.Collision.b2TimeOfImpact, e.Collision.b2TOIInput, e.Collision.b2WorldManifold, e.Collision.ClipVertex, e.Collision.Features, e.Collision.IBroadPhase;
      e.inherit(i, e.Collision.Shapes.b2Shape), i.prototype.__super = e.Collision.Shapes.b2Shape.prototype, i.b2CircleShape = function () {
        e.Collision.Shapes.b2Shape.b2Shape.apply(this, arguments), this.m_p = new u;
      }, i.prototype.Copy = function () {
        var t = new i;
        return t.Set(this), t;
      }, i.prototype.Set = function (t) {
        if (this.__super.Set.call(this, t), e.is(t, i)) {
          var n = t instanceof i ? t : null;
          this.m_p.SetV(n.m_p);
        }
      }, i.prototype.TestPoint = function (t, e) {
        var i = t.R, n = t.position.x + (i.col1.x * this.m_p.x + i.col2.x * this.m_p.y), r = t.position.y + (i.col1.y * this.m_p.x + i.col2.y * this.m_p.y);
        return (n = e.x - n) * n + (r = e.y - r) * r <= this.m_radius * this.m_radius;
      }, i.prototype.RayCast = function (t, e, i) {
        var n = i.R, r = i.position.x + (n.col1.x * this.m_p.x + n.col2.x * this.m_p.y), o = i.position.y + (n.col1.y * this.m_p.x + n.col2.y * this.m_p.y), s = e.p1.x - r, a = e.p1.y - o, l = s * s + a * a - this.m_radius * this.m_radius, c = e.p2.x - e.p1.x, h = e.p2.y - e.p1.y, u = s * c + a * h, m = c * c + h * h, p = u * u - m * l;
        if (p < 0 || m < Number.MIN_VALUE) return false;
        var d = -(u + Math.sqrt(p));
        return 0 <= d && d <= e.maxFraction * m && (d /= m, t.fraction = d, t.normal.x = s + d * c, t.normal.y = a + d * h, t.normal.Normalize(), true);
      }, i.prototype.ComputeAABB = function (t, e) {
        var i = e.R, n = e.position.x + (i.col1.x * this.m_p.x + i.col2.x * this.m_p.y), r = e.position.y + (i.col1.y * this.m_p.x + i.col2.y * this.m_p.y);
        t.lowerBound.Set(n - this.m_radius, r - this.m_radius), t.upperBound.Set(n + this.m_radius, r + this.m_radius);
      }, i.prototype.ComputeMass = function (e, i) {
        void 0 === i && (i = 0), e.mass = i * t.b2_pi * this.m_radius * this.m_radius, e.center.SetV(this.m_p), e.I = e.mass * (0.5 * this.m_radius * this.m_radius + (this.m_p.x * this.m_p.x + this.m_p.y * this.m_p.y));
      }, i.prototype.ComputeSubmergedArea = function (t, e, i, n) {
        void 0 === e && (e = 0);
        var r = c.MulX(i, this.m_p), o = -(c.Dot(t, r) - e);
        if (o < -this.m_radius + Number.MIN_VALUE) return 0;
        if (o > this.m_radius) return n.SetV(r), Math.PI * this.m_radius * this.m_radius;
        var s = this.m_radius * this.m_radius, a = o * o, l = s * (Math.asin(o / this.m_radius) + Math.PI / 2) + o * Math.sqrt(s - a), h = -0.6666666666666666 * Math.pow(s - a, 1.5) / l;
        return n.x = r.x + t.x * h, n.y = r.y + t.y * h, l;
      }, i.prototype.GetLocalPosition = function () {
        return this.m_p;
      }, i.prototype.SetLocalPosition = function (t) {
        this.m_p.SetV(t);
      }, i.prototype.GetRadius = function () {
        return this.m_radius;
      }, i.prototype.SetRadius = function (t) {
        void 0 === t && (t = 0), this.m_radius = t;
      }, i.prototype.b2CircleShape = function (t) {
        void 0 === t && (t = 0), this.__super.b2Shape.call(this), this.m_type = a.e_circleShape, this.m_radius = t;
      }, n.b2EdgeChainDef = function () {}, n.prototype.b2EdgeChainDef = function () {
        this.vertexCount = 0, this.isALoop = true, this.vertices = [];
      }, e.inherit(r, e.Collision.Shapes.b2Shape), r.prototype.__super = e.Collision.Shapes.b2Shape.prototype, r.b2EdgeShape = function () {
        e.Collision.Shapes.b2Shape.b2Shape.apply(this, arguments), this.s_supportVec = new u, this.m_v1 = new u, this.m_v2 = new u, this.m_coreV1 = new u, this.m_coreV2 = new u, this.m_normal = new u, this.m_direction = new u, this.m_cornerDir1 = new u, this.m_cornerDir2 = new u;
      }, r.prototype.TestPoint = function (t, e) {
        return false;
      }, r.prototype.RayCast = function (t, e, i) {
        var n, r = e.p2.x - e.p1.x, o = e.p2.y - e.p1.y;
        n = i.R;
        var s = i.position.x + (n.col1.x * this.m_v1.x + n.col2.x * this.m_v1.y), a = i.position.y + (n.col1.y * this.m_v1.x + n.col2.y * this.m_v1.y), l = i.position.y + (n.col1.y * this.m_v2.x + n.col2.y * this.m_v2.y) - a, c = -(i.position.x + (n.col1.x * this.m_v2.x + n.col2.x * this.m_v2.y) - s), h = 100 * Number.MIN_VALUE, u = -(r * l + o * c);
        if (u > h) {
          var m = e.p1.x - s, p = e.p1.y - a, d = m * l + p * c;
          if (0 <= d && d <= e.maxFraction * u) {
            var f = -r * p + o * m;
            if (-h * u <= f && f <= u * (1 + h)) {
              d /= u, t.fraction = d;
              var _ = Math.sqrt(l * l + c * c);
              return t.normal.x = l / _, t.normal.y = c / _, true;
            }
          }
        }
        return false;
      }, r.prototype.ComputeAABB = function (t, e) {
        var i = e.R, n = e.position.x + (i.col1.x * this.m_v1.x + i.col2.x * this.m_v1.y), r = e.position.y + (i.col1.y * this.m_v1.x + i.col2.y * this.m_v1.y), o = e.position.x + (i.col1.x * this.m_v2.x + i.col2.x * this.m_v2.y), s = e.position.y + (i.col1.y * this.m_v2.x + i.col2.y * this.m_v2.y);
        n < o ? (t.lowerBound.x = n, t.upperBound.x = o) : (t.lowerBound.x = o, t.upperBound.x = n), r < s ? (t.lowerBound.y = r, t.upperBound.y = s) : (t.lowerBound.y = s, t.upperBound.y = r);
      }, r.prototype.ComputeMass = function (t, e) {
        void 0 === e && (e = 0), t.mass = 0, t.center.SetV(this.m_v1), t.I = 0;
      }, r.prototype.ComputeSubmergedArea = function (t, e, i, n) {
        void 0 === e && (e = 0);
        var r = new u(t.x * e, t.y * e), o = c.MulX(i, this.m_v1), s = c.MulX(i, this.m_v2), a = c.Dot(t, o) - e, l = c.Dot(t, s) - e;
        if (a > 0) {
          if (l > 0) return 0;
          o.x = -l / (a - l) * o.x + a / (a - l) * s.x, o.y = -l / (a - l) * o.y + a / (a - l) * s.y;
        } else l > 0 && (s.x = -l / (a - l) * o.x + a / (a - l) * s.x, s.y = -l / (a - l) * o.y + a / (a - l) * s.y);
        return n.x = (r.x + o.x + s.x) / 3, n.y = (r.y + o.y + s.y) / 3, 0.5 * ((o.x - r.x) * (s.y - r.y) - (o.y - r.y) * (s.x - r.x));
      }, r.prototype.GetLength = function () {
        return this.m_length;
      }, r.prototype.GetVertex1 = function () {
        return this.m_v1;
      }, r.prototype.GetVertex2 = function () {
        return this.m_v2;
      }, r.prototype.GetCoreVertex1 = function () {
        return this.m_coreV1;
      }, r.prototype.GetCoreVertex2 = function () {
        return this.m_coreV2;
      }, r.prototype.GetNormalVector = function () {
        return this.m_normal;
      }, r.prototype.GetDirectionVector = function () {
        return this.m_direction;
      }, r.prototype.GetCorner1Vector = function () {
        return this.m_cornerDir1;
      }, r.prototype.GetCorner2Vector = function () {
        return this.m_cornerDir2;
      }, r.prototype.Corner1IsConvex = function () {
        return this.m_cornerConvex1;
      }, r.prototype.Corner2IsConvex = function () {
        return this.m_cornerConvex2;
      }, r.prototype.GetFirstVertex = function (t) {
        var e = t.R;
        return new u(t.position.x + (e.col1.x * this.m_coreV1.x + e.col2.x * this.m_coreV1.y), t.position.y + (e.col1.y * this.m_coreV1.x + e.col2.y * this.m_coreV1.y));
      }, r.prototype.GetNextEdge = function () {
        return this.m_nextEdge;
      }, r.prototype.GetPrevEdge = function () {
        return this.m_prevEdge;
      }, r.prototype.Support = function (t, e, i) {
        void 0 === e && (e = 0), void 0 === i && (i = 0);
        var n = t.R, r = t.position.x + (n.col1.x * this.m_coreV1.x + n.col2.x * this.m_coreV1.y), o = t.position.y + (n.col1.y * this.m_coreV1.x + n.col2.y * this.m_coreV1.y), s = t.position.x + (n.col1.x * this.m_coreV2.x + n.col2.x * this.m_coreV2.y), a = t.position.y + (n.col1.y * this.m_coreV2.x + n.col2.y * this.m_coreV2.y);
        return r * e + o * i > s * e + a * i ? (this.s_supportVec.x = r, this.s_supportVec.y = o) : (this.s_supportVec.x = s, this.s_supportVec.y = a), this.s_supportVec;
      }, r.prototype.b2EdgeShape = function (e, i) {
        this.__super.b2Shape.call(this), this.m_type = a.e_edgeShape, this.m_prevEdge = null, this.m_nextEdge = null, this.m_v1 = e, this.m_v2 = i, this.m_direction.Set(this.m_v2.x - this.m_v1.x, this.m_v2.y - this.m_v1.y), this.m_length = this.m_direction.Normalize(), this.m_normal.Set(this.m_direction.y, -this.m_direction.x), this.m_coreV1.Set(-t.b2_toiSlop * (this.m_normal.x - this.m_direction.x) + this.m_v1.x, -t.b2_toiSlop * (this.m_normal.y - this.m_direction.y) + this.m_v1.y), this.m_coreV2.Set(-t.b2_toiSlop * (this.m_normal.x + this.m_direction.x) + this.m_v2.x, -t.b2_toiSlop * (this.m_normal.y + this.m_direction.y) + this.m_v2.y), this.m_cornerDir1 = this.m_normal, this.m_cornerDir2.Set(-this.m_normal.x, -this.m_normal.y);
      }, r.prototype.SetPrevEdge = function (t, e, i, n) {
        this.m_prevEdge = t, this.m_coreV1 = e, this.m_cornerDir1 = i, this.m_cornerConvex1 = n;
      }, r.prototype.SetNextEdge = function (t, e, i, n) {
        this.m_nextEdge = t, this.m_coreV2 = e, this.m_cornerDir2 = i, this.m_cornerConvex2 = n;
      }, o.b2MassData = function () {
        this.mass = 0, this.center = new u(0, 0), this.I = 0;
      }, e.inherit(s, e.Collision.Shapes.b2Shape), s.prototype.__super = e.Collision.Shapes.b2Shape.prototype, s.b2PolygonShape = function () {
        e.Collision.Shapes.b2Shape.b2Shape.apply(this, arguments);
      }, s.prototype.Copy = function () {
        var t = new s;
        return t.Set(this), t;
      }, s.prototype.Set = function (t) {
        if (this.__super.Set.call(this, t), e.is(t, s)) {
          var i = t instanceof s ? t : null;
          this.m_centroid.SetV(i.m_centroid), this.m_vertexCount = i.m_vertexCount, this.Reserve(this.m_vertexCount);
          for (var n = 0; n < this.m_vertexCount; n++) this.m_vertices[n].SetV(i.m_vertices[n]), this.m_normals[n].SetV(i.m_normals[n]);
        }
      }, s.prototype.SetAsArray = function (t, e) {
        void 0 === e && (e = 0);
        var i, n = new k, r = 0;
        for (r = 0; r < t.length; ++r) i = t[r], n.push(i);
        this.SetAsVector(n, e);
      }, s.AsArray = function (t, e) {
        void 0 === e && (e = 0);
        var i = new s;
        return i.SetAsArray(t, e), i;
      }, s.prototype.SetAsVector = function (e, i) {
        void 0 === i && (i = 0), 0 == i && (i = e.length), t.b2Assert(2 <= i), this.m_vertexCount = i, this.Reserve(i);
        var n = 0;
        for (n = 0; n < this.m_vertexCount; n++) this.m_vertices[n].SetV(e[n]);
        for (n = 0; n < this.m_vertexCount; ++n) {
          var r = parseInt(n), o = parseInt(n + 1 < this.m_vertexCount ? n + 1 : 0), a = c.SubtractVV(this.m_vertices[o], this.m_vertices[r]);
          t.b2Assert(a.LengthSquared() > Number.MIN_VALUE), this.m_normals[n].SetV(c.CrossVF(a, 1)), this.m_normals[n].Normalize();
        }
        this.m_centroid = s.ComputeCentroid(this.m_vertices, this.m_vertexCount);
      }, s.AsVector = function (t, e) {
        void 0 === e && (e = 0);
        var i = new s;
        return i.SetAsVector(t, e), i;
      }, s.prototype.SetAsBox = function (t, e) {
        void 0 === t && (t = 0), void 0 === e && (e = 0), this.m_vertexCount = 4, this.Reserve(4), this.m_vertices[0].Set(-t, -e), this.m_vertices[1].Set(t, -e), this.m_vertices[2].Set(t, e), this.m_vertices[3].Set(-t, e), this.m_normals[0].Set(0, -1), this.m_normals[1].Set(1, 0), this.m_normals[2].Set(0, 1), this.m_normals[3].Set(-1, 0), this.m_centroid.SetZero();
      }, s.AsBox = function (t, e) {
        void 0 === t && (t = 0), void 0 === e && (e = 0);
        var i = new s;
        return i.SetAsBox(t, e), i;
      }, s.prototype.SetAsOrientedBox = function (t, e, i, n) {
        void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = null), void 0 === n && (n = 0), this.m_vertexCount = 4, this.Reserve(4), this.m_vertices[0].Set(-t, -e), this.m_vertices[1].Set(t, -e), this.m_vertices[2].Set(t, e), this.m_vertices[3].Set(-t, e), this.m_normals[0].Set(0, -1), this.m_normals[1].Set(1, 0), this.m_normals[2].Set(0, 1), this.m_normals[3].Set(-1, 0), this.m_centroid = i;
        var r = new h;
        r.position = i, r.R.Set(n);
        for (var o = 0; o < this.m_vertexCount; ++o) this.m_vertices[o] = c.MulX(r, this.m_vertices[o]), this.m_normals[o] = c.MulMV(r.R, this.m_normals[o]);
      }, s.AsOrientedBox = function (t, e, i, n) {
        void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = null), void 0 === n && (n = 0);
        var r = new s;
        return r.SetAsOrientedBox(t, e, i, n), r;
      }, s.prototype.SetAsEdge = function (t, e) {
        this.m_vertexCount = 2, this.Reserve(2), this.m_vertices[0].SetV(t), this.m_vertices[1].SetV(e), this.m_centroid.x = 0.5 * (t.x + e.x), this.m_centroid.y = 0.5 * (t.y + e.y), this.m_normals[0] = c.CrossVF(c.SubtractVV(e, t), 1), this.m_normals[0].Normalize(), this.m_normals[1].x = -this.m_normals[0].x, this.m_normals[1].y = -this.m_normals[0].y;
      }, s.AsEdge = function (t, e) {
        var i = new s;
        return i.SetAsEdge(t, e), i;
      }, s.prototype.TestPoint = function (t, e) {
        for (var i, n = t.R, r = e.x - t.position.x, o = e.y - t.position.y, s = r * n.col1.x + o * n.col1.y, a = r * n.col2.x + o * n.col2.y, l = 0; l < this.m_vertexCount; ++l) {
          if (r = s - (i = this.m_vertices[l]).x, o = a - i.y, (i = this.m_normals[l]).x * r + i.y * o > 0) return false;
        }
        return true;
      }, s.prototype.RayCast = function (t, e, i) {
        var n, r, o = 0, s = e.maxFraction, a = 0, l = 0;
        a = e.p1.x - i.position.x, l = e.p1.y - i.position.y;
        var c = a * (n = i.R).col1.x + l * n.col1.y, h = a * n.col2.x + l * n.col2.y;
        a = e.p2.x - i.position.x, l = e.p2.y - i.position.y;
        for (var u = a * (n = i.R).col1.x + l * n.col1.y - c, m = a * n.col2.x + l * n.col2.y - h, p = parseInt(-1), d = 0; d < this.m_vertexCount; ++d) {
          a = (r = this.m_vertices[d]).x - c, l = r.y - h;
          var f = (r = this.m_normals[d]).x * a + r.y * l, _ = r.x * u + r.y * m;
          if (0 == _) {
            if (f < 0) return false;
          } else _ < 0 && f < o * _ ? (o = f / _, p = d) : _ > 0 && f < s * _ && (s = f / _);
          if (s < o - Number.MIN_VALUE) return false;
        }
        return p >= 0 && (t.fraction = o, n = i.R, r = this.m_normals[p], t.normal.x = n.col1.x * r.x + n.col2.x * r.y, t.normal.y = n.col1.y * r.x + n.col2.y * r.y, true);
      }, s.prototype.ComputeAABB = function (t, e) {
        for (var i = e.R, n = this.m_vertices[0], r = e.position.x + (i.col1.x * n.x + i.col2.x * n.y), o = e.position.y + (i.col1.y * n.x + i.col2.y * n.y), s = r, a = o, l = 1; l < this.m_vertexCount; ++l) {
          n = this.m_vertices[l];
          var c = e.position.x + (i.col1.x * n.x + i.col2.x * n.y), h = e.position.y + (i.col1.y * n.x + i.col2.y * n.y);
          r = r < c ? r : c, o = o < h ? o : h, s = s > c ? s : c, a = a > h ? a : h;
        }
        t.lowerBound.x = r - this.m_radius, t.lowerBound.y = o - this.m_radius, t.upperBound.x = s + this.m_radius, t.upperBound.y = a + this.m_radius;
      }, s.prototype.ComputeMass = function (t, e) {
        if (void 0 === e && (e = 0), 2 == this.m_vertexCount) return t.center.x = 0.5 * (this.m_vertices[0].x + this.m_vertices[1].x), t.center.y = 0.5 * (this.m_vertices[0].y + this.m_vertices[1].y), t.mass = 0, void (t.I = 0);
        for (var i = 0, n = 0, r = 0, o = 0, s = 0.3333333333333333, a = 0; a < this.m_vertexCount; ++a) {
          var l = this.m_vertices[a], c = a + 1 < this.m_vertexCount ? this.m_vertices[parseInt(a + 1)] : this.m_vertices[0], h = l.x - 0, u = l.y - 0, m = c.x - 0, p = c.y - 0, d = h * p - u * m, f = 0.5 * d;
          r += f, i += f * s * (0 + l.x + c.x), n += f * s * (0 + l.y + c.y);
          o += d * (s * (0.25 * (h * h + m * h + m * m) + (0 * h + 0 * m)) + 0 + (s * (0.25 * (u * u + p * u + p * p) + (0 * u + 0 * p)) + 0));
        }
        t.mass = e * r, i *= 1 / r, n *= 1 / r, t.center.Set(i, n), t.I = e * o;
      }, s.prototype.ComputeSubmergedArea = function (t, e, i, n) {
        void 0 === e && (e = 0);
        var r = c.MulTMV(i.R, t), s = e - c.Dot(t, i.position), a = new H, l = 0, h = parseInt(-1), m = parseInt(-1), p = false, d = 0;
        for (d = 0; d < this.m_vertexCount; ++d) {
          a[d] = c.Dot(r, this.m_vertices[d]) - s;
          var f = a[d] < -Number.MIN_VALUE;
          d > 0 && (f ? p || (h = d - 1, l++) : p && (m = d - 1, l++)), p = f;
        }
        switch (l) {
          case 0:
            if (p) {
              var _ = new o;
              return this.ComputeMass(_, 1), n.SetV(c.MulX(i, _.center)), _.mass;
            }
            return 0;
          case 1:
            -1 == h ? h = this.m_vertexCount - 1 : m = this.m_vertexCount - 1;
        }
        var y, g = parseInt((h + 1) % this.m_vertexCount), x = parseInt((m + 1) % this.m_vertexCount), v = (0 - a[h]) / (a[g] - a[h]), b = (0 - a[m]) / (a[x] - a[m]), w = new u(this.m_vertices[h].x * (1 - v) + this.m_vertices[g].x * v, this.m_vertices[h].y * (1 - v) + this.m_vertices[g].y * v), S = new u(this.m_vertices[m].x * (1 - b) + this.m_vertices[x].x * b, this.m_vertices[m].y * (1 - b) + this.m_vertices[x].y * b), M = 0, C = new u, A = this.m_vertices[g];
        for (d = g; d != x;) {
          y = (d = (d + 1) % this.m_vertexCount) == x ? S : this.m_vertices[d];
          var T = 0.5 * ((A.x - w.x) * (y.y - w.y) - (A.y - w.y) * (y.x - w.x));
          M += T, C.x += T * (w.x + A.x + y.x) / 3, C.y += T * (w.y + A.y + y.y) / 3, A = y;
        }
        return C.Multiply(1 / M), n.SetV(c.MulX(i, C)), M;
      }, s.prototype.GetVertexCount = function () {
        return this.m_vertexCount;
      }, s.prototype.GetVertices = function () {
        return this.m_vertices;
      }, s.prototype.GetNormals = function () {
        return this.m_normals;
      }, s.prototype.GetSupport = function (t) {
        for (var e = 0, i = this.m_vertices[0].x * t.x + this.m_vertices[0].y * t.y, n = 1; n < this.m_vertexCount; ++n) {
          var r = this.m_vertices[n].x * t.x + this.m_vertices[n].y * t.y;
          r > i && (e = n, i = r);
        }
        return e;
      }, s.prototype.GetSupportVertex = function (t) {
        for (var e = 0, i = this.m_vertices[0].x * t.x + this.m_vertices[0].y * t.y, n = 1; n < this.m_vertexCount; ++n) {
          var r = this.m_vertices[n].x * t.x + this.m_vertices[n].y * t.y;
          r > i && (e = n, i = r);
        }
        return this.m_vertices[e];
      }, s.prototype.Validate = function () {
        return false;
      }, s.prototype.b2PolygonShape = function () {
        this.__super.b2Shape.call(this), this.m_type = a.e_polygonShape, this.m_centroid = new u, this.m_vertices = new k, this.m_normals = new k;
      }, s.prototype.Reserve = function (t) {
        void 0 === t && (t = 0);
        for (var e = parseInt(this.m_vertices.length); e < t; e++) this.m_vertices[e] = new u, this.m_normals[e] = new u;
      }, s.ComputeCentroid = function (t, e) {
        void 0 === e && (e = 0);
        for (var i = new u, n = 0, r = 0.3333333333333333, o = 0; o < e; ++o) {
          var s = t[o], a = o + 1 < e ? t[parseInt(o + 1)] : t[0], l = s.x - 0, c = s.y - 0, h = a.x - 0, m = 0.5 * (l * (a.y - 0) - c * h);
          n += m, i.x += m * r * (0 + s.x + a.x), i.y += m * r * (0 + s.y + a.y);
        }
        return i.x *= 1 / n, i.y *= 1 / n, i;
      }, s.ComputeOBB = function (t, e, i) {
        void 0 === i && (i = 0);
        var n = 0, r = new k(i + 1);
        for (n = 0; n < i; ++n) r[n] = e[n];
        r[i] = r[0];
        var o = Number.MAX_VALUE;
        for (n = 1; n <= i; ++n) {
          for (var s = r[parseInt(n - 1)], a = r[n].x - s.x, l = r[n].y - s.y, c = Math.sqrt(a * a + l * l), h = -(l /= c), u = a /= c, m = Number.MAX_VALUE, p = Number.MAX_VALUE, d = -Number.MAX_VALUE, f = -Number.MAX_VALUE, _ = 0; _ < i; ++_) {
            var y = r[_].x - s.x, g = r[_].y - s.y, x = a * y + l * g, v = h * y + u * g;
            x < m && (m = x), v < p && (p = v), x > d && (d = x), v > f && (f = v);
          }
          var b = (d - m) * (f - p);
          if (b < 0.95 * o) {
            o = b, t.R.col1.x = a, t.R.col1.y = l, t.R.col2.x = h, t.R.col2.y = u;
            var w = 0.5 * (m + d), S = 0.5 * (p + f), M = t.R;
            t.center.x = s.x + (M.col1.x * w + M.col2.x * S), t.center.y = s.y + (M.col1.y * w + M.col2.y * S), t.extents.x = 0.5 * (d - m), t.extents.y = 0.5 * (f - p);
          }
        }
      }, e.postDefs.push(function () {
        e.Collision.Shapes.b2PolygonShape.s_mat = new l;
      }), a.b2Shape = function () {}, a.prototype.Copy = function () {
        return null;
      }, a.prototype.Set = function (t) {
        this.m_radius = t.m_radius;
      }, a.prototype.GetType = function () {
        return this.m_type;
      }, a.prototype.TestPoint = function (t, e) {
        return false;
      }, a.prototype.RayCast = function (t, e, i) {
        return false;
      }, a.prototype.ComputeAABB = function (t, e) {}, a.prototype.ComputeMass = function (t, e) {
        void 0 === e && (e = 0);
      }, a.prototype.ComputeSubmergedArea = function (t, e, i, n) {
        return void 0 === e && (e = 0), 0;
      }, a.TestOverlap = function (t, e, i, n) {
        var r = new p;
        r.proxyA = new f, r.proxyA.Set(t), r.proxyB = new f, r.proxyB.Set(i), r.transformA = e, r.transformB = n, r.useRadii = true;
        var o = new _;
        o.count = 0;
        var s = new d;
        return m.Distance(s, o, r), s.distance < 10 * Number.MIN_VALUE;
      }, a.prototype.b2Shape = function () {
        this.m_type = a.e_unknownShape, this.m_radius = t.b2_linearSlop;
      }, e.postDefs.push(function () {
        e.Collision.Shapes.b2Shape.e_unknownShape = parseInt(-1), e.Collision.Shapes.b2Shape.e_circleShape = 0, e.Collision.Shapes.b2Shape.e_polygonShape = 1, e.Collision.Shapes.b2Shape.e_edgeShape = 2, e.Collision.Shapes.b2Shape.e_shapeTypeCount = 3, e.Collision.Shapes.b2Shape.e_hitCollide = 1, e.Collision.Shapes.b2Shape.e_missCollide = 0, e.Collision.Shapes.b2Shape.e_startsInsideCollide = parseInt(-1);
      });
    }(), function () {
      var t = e.Common.b2Color, i = (e.Common.b2internal, e.Common.b2Settings), n = (e.Common.Math.b2Mat22, e.Common.Math.b2Mat33, e.Common.Math.b2Math);
      e.Common.Math.b2Sweep, e.Common.Math.b2Transform, e.Common.Math.b2Vec2, e.Common.Math.b2Vec3;
      t.b2Color = function () {
        this._r = 0, this._g = 0, this._b = 0;
      }, t.prototype.b2Color = function (t, i, r) {
        void 0 === t && (t = 0), void 0 === i && (i = 0), void 0 === r && (r = 0), this._r = e.parseUInt(255 * n.Clamp(t, 0, 1)), this._g = e.parseUInt(255 * n.Clamp(i, 0, 1)), this._b = e.parseUInt(255 * n.Clamp(r, 0, 1));
      }, t.prototype.Set = function (t, i, r) {
        void 0 === t && (t = 0), void 0 === i && (i = 0), void 0 === r && (r = 0), this._r = e.parseUInt(255 * n.Clamp(t, 0, 1)), this._g = e.parseUInt(255 * n.Clamp(i, 0, 1)), this._b = e.parseUInt(255 * n.Clamp(r, 0, 1));
      }, Object.defineProperty(t.prototype, "r", {enumerable: false, configurable: true, set: function (t) {
        void 0 === t && (t = 0), this._r = e.parseUInt(255 * n.Clamp(t, 0, 1));
      }}), Object.defineProperty(t.prototype, "g", {enumerable: false, configurable: true, set: function (t) {
        void 0 === t && (t = 0), this._g = e.parseUInt(255 * n.Clamp(t, 0, 1));
      }}), Object.defineProperty(t.prototype, "b", {enumerable: false, configurable: true, set: function (t) {
        void 0 === t && (t = 0), this._b = e.parseUInt(255 * n.Clamp(t, 0, 1));
      }}), Object.defineProperty(t.prototype, "color", {enumerable: false, configurable: true, get: function () {
        return this._r << 16 | this._g << 8 | this._b;
      }}), i.b2Settings = function () {}, i.b2MixFriction = function (t, e) {
        return void 0 === t && (t = 0), void 0 === e && (e = 0), Math.sqrt(t * e);
      }, i.b2MixRestitution = function (t, e) {
        return void 0 === t && (t = 0), void 0 === e && (e = 0), t > e ? t : e;
      }, i.b2Assert = function (t) {
        if (!t) throw "Assertion Failed";
      }, e.postDefs.push(function () {
        e.Common.b2Settings.VERSION = "2.1alpha", e.Common.b2Settings.USHRT_MAX = 65535, e.Common.b2Settings.b2_pi = Math.PI, e.Common.b2Settings.b2_maxManifoldPoints = 2, e.Common.b2Settings.b2_aabbExtension = 0.1, e.Common.b2Settings.b2_aabbMultiplier = 2, e.Common.b2Settings.b2_polygonRadius = 2 * i.b2_linearSlop, e.Common.b2Settings.b2_linearSlop = 0.005, e.Common.b2Settings.b2_angularSlop = 0.011111111111111112 * i.b2_pi, e.Common.b2Settings.b2_toiSlop = 8 * i.b2_linearSlop, e.Common.b2Settings.b2_maxTOIContactsPerIsland = 32, e.Common.b2Settings.b2_maxTOIJointsPerIsland = 32, e.Common.b2Settings.b2_velocityThreshold = 1, e.Common.b2Settings.b2_maxLinearCorrection = 0.2, e.Common.b2Settings.b2_maxAngularCorrection = 0.044444444444444446 * i.b2_pi, e.Common.b2Settings.b2_maxTranslation = 2, e.Common.b2Settings.b2_maxTranslationSquared = i.b2_maxTranslation * i.b2_maxTranslation, e.Common.b2Settings.b2_maxRotation = 0.5 * i.b2_pi, e.Common.b2Settings.b2_maxRotationSquared = i.b2_maxRotation * i.b2_maxRotation, e.Common.b2Settings.b2_contactBaumgarte = 0.2, e.Common.b2Settings.b2_timeToSleep = 0.5, e.Common.b2Settings.b2_linearSleepTolerance = 0.01, e.Common.b2Settings.b2_angularSleepTolerance = 0.011111111111111112 * i.b2_pi;
      });
    }(), function () {
      e.Collision.b2AABB, e.Common.b2Color, e.Common.b2internal, e.Common.b2Settings;
      var t = e.Common.Math.b2Mat22, i = e.Common.Math.b2Mat33, n = e.Common.Math.b2Math, r = e.Common.Math.b2Sweep, o = e.Common.Math.b2Transform, s = e.Common.Math.b2Vec2, a = e.Common.Math.b2Vec3;
      t.b2Mat22 = function () {
        this.col1 = new s, this.col2 = new s;
      }, t.prototype.b2Mat22 = function () {
        this.SetIdentity();
      }, t.FromAngle = function (e) {
        void 0 === e && (e = 0);
        var i = new t;
        return i.Set(e), i;
      }, t.FromVV = function (e, i) {
        var n = new t;
        return n.SetVV(e, i), n;
      }, t.prototype.Set = function (t) {
        void 0 === t && (t = 0);
        var e = Math.cos(t), i = Math.sin(t);
        this.col1.x = e, this.col2.x = -i, this.col1.y = i, this.col2.y = e;
      }, t.prototype.SetVV = function (t, e) {
        this.col1.SetV(t), this.col2.SetV(e);
      }, t.prototype.Copy = function () {
        var e = new t;
        return e.SetM(this), e;
      }, t.prototype.SetM = function (t) {
        this.col1.SetV(t.col1), this.col2.SetV(t.col2);
      }, t.prototype.AddM = function (t) {
        this.col1.x += t.col1.x, this.col1.y += t.col1.y, this.col2.x += t.col2.x, this.col2.y += t.col2.y;
      }, t.prototype.SetIdentity = function () {
        this.col1.x = 1, this.col2.x = 0, this.col1.y = 0, this.col2.y = 1;
      }, t.prototype.SetZero = function () {
        this.col1.x = 0, this.col2.x = 0, this.col1.y = 0, this.col2.y = 0;
      }, t.prototype.GetAngle = function () {
        return Math.atan2(this.col1.y, this.col1.x);
      }, t.prototype.GetInverse = function (t) {
        var e = this.col1.x, i = this.col2.x, n = this.col1.y, r = this.col2.y, o = e * r - i * n;
        return 0 != o && (o = 1 / o), t.col1.x = o * r, t.col2.x = -o * i, t.col1.y = -o * n, t.col2.y = o * e, t;
      }, t.prototype.Solve = function (t, e, i) {
        void 0 === e && (e = 0), void 0 === i && (i = 0);
        var n = this.col1.x, r = this.col2.x, o = this.col1.y, s = this.col2.y, a = n * s - r * o;
        return 0 != a && (a = 1 / a), t.x = a * (s * e - r * i), t.y = a * (n * i - o * e), t;
      }, t.prototype.Abs = function () {
        this.col1.Abs(), this.col2.Abs();
      }, i.b2Mat33 = function () {
        this.col1 = new a, this.col2 = new a, this.col3 = new a;
      }, i.prototype.b2Mat33 = function (t, e, i) {
        void 0 === t && (t = null), void 0 === e && (e = null), void 0 === i && (i = null), t || e || i ? (this.col1.SetV(t), this.col2.SetV(e), this.col3.SetV(i)) : (this.col1.SetZero(), this.col2.SetZero(), this.col3.SetZero());
      }, i.prototype.SetVVV = function (t, e, i) {
        this.col1.SetV(t), this.col2.SetV(e), this.col3.SetV(i);
      }, i.prototype.Copy = function () {
        return new i(this.col1, this.col2, this.col3);
      }, i.prototype.SetM = function (t) {
        this.col1.SetV(t.col1), this.col2.SetV(t.col2), this.col3.SetV(t.col3);
      }, i.prototype.AddM = function (t) {
        this.col1.x += t.col1.x, this.col1.y += t.col1.y, this.col1.z += t.col1.z, this.col2.x += t.col2.x, this.col2.y += t.col2.y, this.col2.z += t.col2.z, this.col3.x += t.col3.x, this.col3.y += t.col3.y, this.col3.z += t.col3.z;
      }, i.prototype.SetIdentity = function () {
        this.col1.x = 1, this.col2.x = 0, this.col3.x = 0, this.col1.y = 0, this.col2.y = 1, this.col3.y = 0, this.col1.z = 0, this.col2.z = 0, this.col3.z = 1;
      }, i.prototype.SetZero = function () {
        this.col1.x = 0, this.col2.x = 0, this.col3.x = 0, this.col1.y = 0, this.col2.y = 0, this.col3.y = 0, this.col1.z = 0, this.col2.z = 0, this.col3.z = 0;
      }, i.prototype.Solve22 = function (t, e, i) {
        void 0 === e && (e = 0), void 0 === i && (i = 0);
        var n = this.col1.x, r = this.col2.x, o = this.col1.y, s = this.col2.y, a = n * s - r * o;
        return 0 != a && (a = 1 / a), t.x = a * (s * e - r * i), t.y = a * (n * i - o * e), t;
      }, i.prototype.Solve33 = function (t, e, i, n) {
        void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 0);
        var r = this.col1.x, o = this.col1.y, s = this.col1.z, a = this.col2.x, l = this.col2.y, c = this.col2.z, h = this.col3.x, u = this.col3.y, m = this.col3.z, p = r * (l * m - c * u) + o * (c * h - a * m) + s * (a * u - l * h);
        return 0 != p && (p = 1 / p), t.x = p * (e * (l * m - c * u) + i * (c * h - a * m) + n * (a * u - l * h)), t.y = p * (r * (i * m - n * u) + o * (n * h - e * m) + s * (e * u - i * h)), t.z = p * (r * (l * n - c * i) + o * (c * e - a * n) + s * (a * i - l * e)), t;
      }, n.b2Math = function () {}, n.IsValid = function (t) {
        return void 0 === t && (t = 0), isFinite(t);
      }, n.Dot = function (t, e) {
        return t.x * e.x + t.y * e.y;
      }, n.CrossVV = function (t, e) {
        return t.x * e.y - t.y * e.x;
      }, n.CrossVF = function (t, e) {
        return void 0 === e && (e = 0), new s(e * t.y, -e * t.x);
      }, n.CrossFV = function (t, e) {
        return void 0 === t && (t = 0), new s(-t * e.y, t * e.x);
      }, n.MulMV = function (t, e) {
        return new s(t.col1.x * e.x + t.col2.x * e.y, t.col1.y * e.x + t.col2.y * e.y);
      }, n.MulTMV = function (t, e) {
        return new s(n.Dot(e, t.col1), n.Dot(e, t.col2));
      }, n.MulX = function (t, e) {
        var i = n.MulMV(t.R, e);
        return i.x += t.position.x, i.y += t.position.y, i;
      }, n.MulXT = function (t, e) {
        var i = n.SubtractVV(e, t.position), r = i.x * t.R.col1.x + i.y * t.R.col1.y;
        return i.y = i.x * t.R.col2.x + i.y * t.R.col2.y, i.x = r, i;
      }, n.AddVV = function (t, e) {
        return new s(t.x + e.x, t.y + e.y);
      }, n.SubtractVV = function (t, e) {
        return new s(t.x - e.x, t.y - e.y);
      }, n.Distance = function (t, e) {
        var i = t.x - e.x, n = t.y - e.y;
        return Math.sqrt(i * i + n * n);
      }, n.DistanceSquared = function (t, e) {
        var i = t.x - e.x, n = t.y - e.y;
        return i * i + n * n;
      }, n.MulFV = function (t, e) {
        return void 0 === t && (t = 0), new s(t * e.x, t * e.y);
      }, n.AddMM = function (e, i) {
        return t.FromVV(n.AddVV(e.col1, i.col1), n.AddVV(e.col2, i.col2));
      }, n.MulMM = function (e, i) {
        return t.FromVV(n.MulMV(e, i.col1), n.MulMV(e, i.col2));
      }, n.MulTMM = function (e, i) {
        var r = new s(n.Dot(e.col1, i.col1), n.Dot(e.col2, i.col1)), o = new s(n.Dot(e.col1, i.col2), n.Dot(e.col2, i.col2));
        return t.FromVV(r, o);
      }, n.Abs = function (t) {
        return void 0 === t && (t = 0), t > 0 ? t : -t;
      }, n.AbsV = function (t) {
        return new s(n.Abs(t.x), n.Abs(t.y));
      }, n.AbsM = function (e) {
        return t.FromVV(n.AbsV(e.col1), n.AbsV(e.col2));
      }, n.Min = function (t, e) {
        return void 0 === t && (t = 0), void 0 === e && (e = 0), t < e ? t : e;
      }, n.MinV = function (t, e) {
        return new s(n.Min(t.x, e.x), n.Min(t.y, e.y));
      }, n.Max = function (t, e) {
        return void 0 === t && (t = 0), void 0 === e && (e = 0), t > e ? t : e;
      }, n.MaxV = function (t, e) {
        return new s(n.Max(t.x, e.x), n.Max(t.y, e.y));
      }, n.Clamp = function (t, e, i) {
        return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), t < e ? e : t > i ? i : t;
      }, n.ClampV = function (t, e, i) {
        return n.MaxV(e, n.MinV(t, i));
      }, n.Swap = function (t, e) {
        var i = t[0];
        t[0] = e[0], e[0] = i;
      }, n.Random = function () {
        return 2 * Math.random() - 1;
      }, n.RandomRange = function (t, e) {
        void 0 === t && (t = 0), void 0 === e && (e = 0);
        var i = Math.random();
        return i = (e - t) * i + t;
      }, n.NextPowerOfTwo = function (t) {
        return void 0 === t && (t = 0), t |= t >> 1 & 2147483647, t |= t >> 2 & 1073741823, t |= t >> 4 & 268435455, t |= t >> 8 & 16777215, (t |= t >> 16 & 65535) + 1;
      }, n.IsPowerOfTwo = function (t) {
        return void 0 === t && (t = 0), t > 0 && 0 == (t & t - 1);
      }, e.postDefs.push(function () {
        e.Common.Math.b2Math.b2Vec2_zero = new s(0, 0), e.Common.Math.b2Math.b2Mat22_identity = t.FromVV(new s(1, 0), new s(0, 1)), e.Common.Math.b2Math.b2Transform_identity = new o(n.b2Vec2_zero, n.b2Mat22_identity);
      }), r.b2Sweep = function () {
        this.localCenter = new s, this.c0 = new s, this.c = new s;
      }, r.prototype.Set = function (t) {
        this.localCenter.SetV(t.localCenter), this.c0.SetV(t.c0), this.c.SetV(t.c), this.a0 = t.a0, this.a = t.a, this.t0 = t.t0;
      }, r.prototype.Copy = function () {
        var t = new r;
        return t.localCenter.SetV(this.localCenter), t.c0.SetV(this.c0), t.c.SetV(this.c), t.a0 = this.a0, t.a = this.a, t.t0 = this.t0, t;
      }, r.prototype.GetTransform = function (t, e) {
        void 0 === e && (e = 0), t.position.x = (1 - e) * this.c0.x + e * this.c.x, t.position.y = (1 - e) * this.c0.y + e * this.c.y;
        var i = (1 - e) * this.a0 + e * this.a;
        t.R.Set(i);
        var n = t.R;
        t.position.x -= n.col1.x * this.localCenter.x + n.col2.x * this.localCenter.y, t.position.y -= n.col1.y * this.localCenter.x + n.col2.y * this.localCenter.y;
      }, r.prototype.Advance = function (t) {
        if (void 0 === t && (t = 0), this.t0 < t && 1 - this.t0 > Number.MIN_VALUE) {
          var e = (t - this.t0) / (1 - this.t0);
          this.c0.x = (1 - e) * this.c0.x + e * this.c.x, this.c0.y = (1 - e) * this.c0.y + e * this.c.y, this.a0 = (1 - e) * this.a0 + e * this.a, this.t0 = t;
        }
      }, o.b2Transform = function () {
        this.position = new s, this.R = new t;
      }, o.prototype.b2Transform = function (t, e) {
        void 0 === t && (t = null), void 0 === e && (e = null), t && (this.position.SetV(t), this.R.SetM(e));
      }, o.prototype.Initialize = function (t, e) {
        this.position.SetV(t), this.R.SetM(e);
      }, o.prototype.SetIdentity = function () {
        this.position.SetZero(), this.R.SetIdentity();
      }, o.prototype.Set = function (t) {
        this.position.SetV(t.position), this.R.SetM(t.R);
      }, o.prototype.GetAngle = function () {
        return Math.atan2(this.R.col1.y, this.R.col1.x);
      }, s.b2Vec2 = function () {}, s.prototype.b2Vec2 = function (t, e) {
        void 0 === t && (t = 0), void 0 === e && (e = 0), this.x = t, this.y = e;
      }, s.prototype.SetZero = function () {
        this.x = 0, this.y = 0;
      }, s.prototype.Set = function (t, e) {
        void 0 === t && (t = 0), void 0 === e && (e = 0), this.x = t, this.y = e;
      }, s.prototype.SetV = function (t) {
        this.x = t.x, this.y = t.y;
      }, s.prototype.GetNegative = function () {
        return new s(-this.x, -this.y);
      }, s.prototype.NegativeSelf = function () {
        this.x = -this.x, this.y = -this.y;
      }, s.Make = function (t, e) {
        return void 0 === t && (t = 0), void 0 === e && (e = 0), new s(t, e);
      }, s.prototype.Copy = function () {
        return new s(this.x, this.y);
      }, s.prototype.Add = function (t) {
        this.x += t.x, this.y += t.y;
      }, s.prototype.Subtract = function (t) {
        this.x -= t.x, this.y -= t.y;
      }, s.prototype.Multiply = function (t) {
        void 0 === t && (t = 0), this.x *= t, this.y *= t;
      }, s.prototype.MulM = function (t) {
        var e = this.x;
        this.x = t.col1.x * e + t.col2.x * this.y, this.y = t.col1.y * e + t.col2.y * this.y;
      }, s.prototype.MulTM = function (t) {
        var e = n.Dot(this, t.col1);
        this.y = n.Dot(this, t.col2), this.x = e;
      }, s.prototype.CrossVF = function (t) {
        void 0 === t && (t = 0);
        var e = this.x;
        this.x = t * this.y, this.y = -t * e;
      }, s.prototype.CrossFV = function (t) {
        void 0 === t && (t = 0);
        var e = this.x;
        this.x = -t * this.y, this.y = t * e;
      }, s.prototype.MinV = function (t) {
        this.x = this.x < t.x ? this.x : t.x, this.y = this.y < t.y ? this.y : t.y;
      }, s.prototype.MaxV = function (t) {
        this.x = this.x > t.x ? this.x : t.x, this.y = this.y > t.y ? this.y : t.y;
      }, s.prototype.Abs = function () {
        this.x < 0 && (this.x = -this.x), this.y < 0 && (this.y = -this.y);
      }, s.prototype.Length = function () {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      }, s.prototype.LengthSquared = function () {
        return this.x * this.x + this.y * this.y;
      }, s.prototype.Normalize = function () {
        var t = Math.sqrt(this.x * this.x + this.y * this.y);
        if (t < Number.MIN_VALUE) return 0;
        var e = 1 / t;
        return this.x *= e, this.y *= e, t;
      }, s.prototype.IsValid = function () {
        return n.IsValid(this.x) && n.IsValid(this.y);
      }, a.b2Vec3 = function () {}, a.prototype.b2Vec3 = function (t, e, i) {
        void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), this.x = t, this.y = e, this.z = i;
      }, a.prototype.SetZero = function () {
        this.x = this.y = this.z = 0;
      }, a.prototype.Set = function (t, e, i) {
        void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), this.x = t, this.y = e, this.z = i;
      }, a.prototype.SetV = function (t) {
        this.x = t.x, this.y = t.y, this.z = t.z;
      }, a.prototype.GetNegative = function () {
        return new a(-this.x, -this.y, -this.z);
      }, a.prototype.NegativeSelf = function () {
        this.x = -this.x, this.y = -this.y, this.z = -this.z;
      }, a.prototype.Copy = function () {
        return new a(this.x, this.y, this.z);
      }, a.prototype.Add = function (t) {
        this.x += t.x, this.y += t.y, this.z += t.z;
      }, a.prototype.Subtract = function (t) {
        this.x -= t.x, this.y -= t.y, this.z -= t.z;
      }, a.prototype.Multiply = function (t) {
        void 0 === t && (t = 0), this.x *= t, this.y *= t, this.z *= t;
      };
    }(), function () {
      e.Dynamics.Controllers.b2ControllerEdge, e.Common.Math.b2Mat22, e.Common.Math.b2Mat33;
      var t = e.Common.Math.b2Math, i = e.Common.Math.b2Sweep, n = e.Common.Math.b2Transform, r = e.Common.Math.b2Vec2, o = (e.Common.Math.b2Vec3, e.Common.b2Color), s = (e.Common.b2internal, e.Common.b2Settings), a = e.Collision.b2AABB, l = (e.Collision.b2Bound, e.Collision.b2BoundValues, e.Collision.b2Collision, e.Collision.b2ContactID, e.Collision.b2ContactPoint), c = (e.Collision.b2Distance, e.Collision.b2DistanceInput, e.Collision.b2DistanceOutput, e.Collision.b2DistanceProxy, e.Collision.b2DynamicTree, e.Collision.b2DynamicTreeBroadPhase), h = (e.Collision.b2DynamicTreeNode, e.Collision.b2DynamicTreePair, e.Collision.b2Manifold, e.Collision.b2ManifoldPoint, e.Collision.b2Point, e.Collision.b2RayCastInput), u = e.Collision.b2RayCastOutput, m = (e.Collision.b2Segment, e.Collision.b2SeparationFunction, e.Collision.b2Simplex, e.Collision.b2SimplexCache, e.Collision.b2SimplexVertex, e.Collision.b2TimeOfImpact, e.Collision.b2TOIInput, e.Collision.b2WorldManifold, e.Collision.ClipVertex, e.Collision.Features, e.Collision.IBroadPhase, e.Collision.Shapes.b2CircleShape), p = (e.Collision.Shapes.b2EdgeChainDef, e.Collision.Shapes.b2EdgeShape), d = e.Collision.Shapes.b2MassData, f = e.Collision.Shapes.b2PolygonShape, _ = e.Collision.Shapes.b2Shape, y = e.Dynamics.b2Body, g = e.Dynamics.b2BodyDef, x = e.Dynamics.b2ContactFilter, v = e.Dynamics.b2ContactImpulse, b = e.Dynamics.b2ContactListener, w = e.Dynamics.b2ContactManager, S = e.Dynamics.b2DebugDraw, M = e.Dynamics.b2DestructionListener, C = e.Dynamics.b2FilterData, A = e.Dynamics.b2Fixture, T = e.Dynamics.b2FixtureDef, E = e.Dynamics.b2Island, L = e.Dynamics.b2TimeStep, D = e.Dynamics.b2World, V = (e.Dynamics.Contacts.b2CircleContact, e.Dynamics.Contacts.b2Contact), B = (e.Dynamics.Contacts.b2ContactConstraint, e.Dynamics.Contacts.b2ContactConstraintPoint, e.Dynamics.Contacts.b2ContactEdge, e.Dynamics.Contacts.b2ContactFactory), R = (e.Dynamics.Contacts.b2ContactRegister, e.Dynamics.Contacts.b2ContactResult, e.Dynamics.Contacts.b2ContactSolver), P = (e.Dynamics.Contacts.b2EdgeAndCircleContact, e.Dynamics.Contacts.b2NullContact, e.Dynamics.Contacts.b2PolyAndCircleContact, e.Dynamics.Contacts.b2PolyAndEdgeContact, e.Dynamics.Contacts.b2PolygonContact, e.Dynamics.Contacts.b2PositionSolverManifold, e.Dynamics.Controllers.b2Controller, e.Dynamics.Joints.b2DistanceJoint, e.Dynamics.Joints.b2DistanceJointDef, e.Dynamics.Joints.b2FrictionJoint, e.Dynamics.Joints.b2FrictionJointDef, e.Dynamics.Joints.b2GearJoint, e.Dynamics.Joints.b2GearJointDef, e.Dynamics.Joints.b2Jacobian, e.Dynamics.Joints.b2Joint), I = (e.Dynamics.Joints.b2JointDef, e.Dynamics.Joints.b2JointEdge, e.Dynamics.Joints.b2LineJoint, e.Dynamics.Joints.b2LineJointDef, e.Dynamics.Joints.b2MouseJoint, e.Dynamics.Joints.b2MouseJointDef, e.Dynamics.Joints.b2PrismaticJoint, e.Dynamics.Joints.b2PrismaticJointDef, e.Dynamics.Joints.b2PulleyJoint);
      e.Dynamics.Joints.b2PulleyJointDef, e.Dynamics.Joints.b2RevoluteJoint, e.Dynamics.Joints.b2RevoluteJointDef, e.Dynamics.Joints.b2WeldJoint, e.Dynamics.Joints.b2WeldJointDef;
      y.b2Body = function () {
        this.m_xf = new n, this.m_sweep = new i, this.m_linearVelocity = new r, this.m_force = new r;
      }, y.prototype.connectEdges = function (e, i, n) {
        void 0 === n && (n = 0);
        var r = Math.atan2(i.GetDirectionVector().y, i.GetDirectionVector().x), o = Math.tan(0.5 * (r - n)), a = t.MulFV(o, i.GetDirectionVector());
        a = t.SubtractVV(a, i.GetNormalVector()), a = t.MulFV(s.b2_toiSlop, a), a = t.AddVV(a, i.GetVertex1());
        var l = t.AddVV(e.GetDirectionVector(), i.GetDirectionVector());
        l.Normalize();
        var c = t.Dot(e.GetDirectionVector(), i.GetNormalVector()) > 0;
        return e.SetNextEdge(i, a, l, c), i.SetPrevEdge(e, a, l, c), r;
      }, y.prototype.CreateFixture = function (t) {
        if (1 == this.m_world.IsLocked()) return null;
        var e = new A;
        if (e.Create(this, this.m_xf, t), this.m_flags & y.e_activeFlag) {
          var i = this.m_world.m_contactManager.m_broadPhase;
          e.CreateProxy(i, this.m_xf);
        }
        return e.m_next = this.m_fixtureList, this.m_fixtureList = e, ++this.m_fixtureCount, e.m_body = this, e.m_density > 0 && this.ResetMassData(), this.m_world.m_flags |= D.e_newFixture, e;
      }, y.prototype.CreateFixture2 = function (t, e) {
        void 0 === e && (e = 0);
        var i = new T;
        return i.shape = t, i.density = e, this.CreateFixture(i);
      }, y.prototype.DestroyFixture = function (t) {
        if (1 != this.m_world.IsLocked()) {
          for (var e = this.m_fixtureList, i = null; null != e;) {
            if (e == t) {
              i ? i.m_next = t.m_next : this.m_fixtureList = t.m_next, true;
              break;
            }
            i = e, e = e.m_next;
          }
          for (var n = this.m_contactList; n;) {
            var r = n.contact;
            n = n.next;
            var o = r.GetFixtureA(), s = r.GetFixtureB();
            t != o && t != s || this.m_world.m_contactManager.Destroy(r);
          }
          if (this.m_flags & y.e_activeFlag) {
            var a = this.m_world.m_contactManager.m_broadPhase;
            t.DestroyProxy(a);
          }
          t.Destroy(), t.m_body = null, t.m_next = null, --this.m_fixtureCount, this.ResetMassData();
        }
      }, y.prototype.SetPositionAndAngle = function (t, e) {
        var i;
        if (void 0 === e && (e = 0), 1 != this.m_world.IsLocked()) {
          this.m_xf.R.Set(e), this.m_xf.position.SetV(t);
          var n = this.m_xf.R, r = this.m_sweep.localCenter;
          this.m_sweep.c.x = n.col1.x * r.x + n.col2.x * r.y, this.m_sweep.c.y = n.col1.y * r.x + n.col2.y * r.y, this.m_sweep.c.x += this.m_xf.position.x, this.m_sweep.c.y += this.m_xf.position.y, this.m_sweep.c0.SetV(this.m_sweep.c), this.m_sweep.a0 = this.m_sweep.a = e;
          var o = this.m_world.m_contactManager.m_broadPhase;
          for (i = this.m_fixtureList; i; i = i.m_next) i.Synchronize(o, this.m_xf, this.m_xf);
          this.m_world.m_contactManager.FindNewContacts();
        }
      }, y.prototype.SetTransform = function (t) {
        this.SetPositionAndAngle(t.position, t.GetAngle());
      }, y.prototype.GetTransform = function () {
        return this.m_xf;
      }, y.prototype.GetPosition = function () {
        return this.m_xf.position;
      }, y.prototype.SetPosition = function (t) {
        this.SetPositionAndAngle(t, this.GetAngle());
      }, y.prototype.GetAngle = function () {
        return this.m_sweep.a;
      }, y.prototype.SetAngle = function (t) {
        void 0 === t && (t = 0), this.SetPositionAndAngle(this.GetPosition(), t);
      }, y.prototype.GetWorldCenter = function () {
        return this.m_sweep.c;
      }, y.prototype.GetLocalCenter = function () {
        return this.m_sweep.localCenter;
      }, y.prototype.SetLinearVelocity = function (t) {
        this.m_type != y.b2_staticBody && this.m_linearVelocity.SetV(t);
      }, y.prototype.GetLinearVelocity = function () {
        return this.m_linearVelocity;
      }, y.prototype.SetAngularVelocity = function (t) {
        void 0 === t && (t = 0), this.m_type != y.b2_staticBody && (this.m_angularVelocity = t);
      }, y.prototype.GetAngularVelocity = function () {
        return this.m_angularVelocity;
      }, y.prototype.GetDefinition = function () {
        var t = new g;
        return t.type = this.GetType(), t.allowSleep = (this.m_flags & y.e_allowSleepFlag) == y.e_allowSleepFlag, t.angle = this.GetAngle(), t.angularDamping = this.m_angularDamping, t.angularVelocity = this.m_angularVelocity, t.fixedRotation = (this.m_flags & y.e_fixedRotationFlag) == y.e_fixedRotationFlag, t.bullet = (this.m_flags & y.e_bulletFlag) == y.e_bulletFlag, t.awake = (this.m_flags & y.e_awakeFlag) == y.e_awakeFlag, t.linearDamping = this.m_linearDamping, t.linearVelocity.SetV(this.GetLinearVelocity()), t.position = this.GetPosition(), t.userData = this.GetUserData(), t;
      }, y.prototype.ApplyForce = function (t, e) {
        this.m_type == y.b2_dynamicBody && (0 == this.IsAwake() && this.SetAwake(true), this.m_force.x += t.x, this.m_force.y += t.y, this.m_torque += (e.x - this.m_sweep.c.x) * t.y - (e.y - this.m_sweep.c.y) * t.x);
      }, y.prototype.ApplyTorque = function (t) {
        void 0 === t && (t = 0), this.m_type == y.b2_dynamicBody && (0 == this.IsAwake() && this.SetAwake(true), this.m_torque += t);
      }, y.prototype.ApplyImpulse = function (t, e) {
        this.m_type == y.b2_dynamicBody && (0 == this.IsAwake() && this.SetAwake(true), this.m_linearVelocity.x += this.m_invMass * t.x, this.m_linearVelocity.y += this.m_invMass * t.y, this.m_angularVelocity += this.m_invI * ((e.x - this.m_sweep.c.x) * t.y - (e.y - this.m_sweep.c.y) * t.x));
      }, y.prototype.Split = function (e) {
        for (var i, n = this.GetLinearVelocity().Copy(), r = this.GetAngularVelocity(), o = this.GetWorldCenter(), s = this, a = this.m_world.CreateBody(this.GetDefinition()), l = s.m_fixtureList; l;) if (e(l)) {
          var c = l.m_next;
          i ? i.m_next = c : s.m_fixtureList = c, s.m_fixtureCount--, l.m_next = a.m_fixtureList, a.m_fixtureList = l, a.m_fixtureCount++, l.m_body = a, l = c;
        } else i = l, l = l.m_next;
        s.ResetMassData(), a.ResetMassData();
        var h = s.GetWorldCenter(), u = a.GetWorldCenter(), m = t.AddVV(n, t.CrossFV(r, t.SubtractVV(h, o))), p = t.AddVV(n, t.CrossFV(r, t.SubtractVV(u, o)));
        return s.SetLinearVelocity(m), a.SetLinearVelocity(p), s.SetAngularVelocity(r), a.SetAngularVelocity(r), s.SynchronizeFixtures(), a.SynchronizeFixtures(), a;
      }, y.prototype.Merge = function (t) {
        var e;
        for (e = t.m_fixtureList; e;) {
          var i = e.m_next;
          t.m_fixtureCount--, e.m_next = this.m_fixtureList, this.m_fixtureList = e, this.m_fixtureCount++, e.m_body = r, e = i;
        }
        n.m_fixtureCount = 0;
        var n = this, r = t;
        n.GetWorldCenter(), r.GetWorldCenter(), n.GetLinearVelocity().Copy(), r.GetLinearVelocity().Copy(), n.GetAngularVelocity(), r.GetAngularVelocity();
        n.ResetMassData(), this.SynchronizeFixtures();
      }, y.prototype.GetMass = function () {
        return this.m_mass;
      }, y.prototype.GetInertia = function () {
        return this.m_I;
      }, y.prototype.GetMassData = function (t) {
        t.mass = this.m_mass, t.I = this.m_I, t.center.SetV(this.m_sweep.localCenter);
      }, y.prototype.SetMassData = function (e) {
        if (s.b2Assert(0 == this.m_world.IsLocked()), 1 != this.m_world.IsLocked() && this.m_type == y.b2_dynamicBody) {
          this.m_invMass = 0, this.m_I = 0, this.m_invI = 0, this.m_mass = e.mass, this.m_mass <= 0 && (this.m_mass = 1), this.m_invMass = 1 / this.m_mass, e.I > 0 && 0 == (this.m_flags & y.e_fixedRotationFlag) && (this.m_I = e.I - this.m_mass * (e.center.x * e.center.x + e.center.y * e.center.y), this.m_invI = 1 / this.m_I);
          var i = this.m_sweep.c.Copy();
          this.m_sweep.localCenter.SetV(e.center), this.m_sweep.c0.SetV(t.MulX(this.m_xf, this.m_sweep.localCenter)), this.m_sweep.c.SetV(this.m_sweep.c0), this.m_linearVelocity.x += this.m_angularVelocity * -(this.m_sweep.c.y - i.y), this.m_linearVelocity.y += this.m_angularVelocity * +(this.m_sweep.c.x - i.x);
        }
      }, y.prototype.ResetMassData = function () {
        if (this.m_mass = 0, this.m_invMass = 0, this.m_I = 0, this.m_invI = 0, this.m_sweep.localCenter.SetZero(), this.m_type != y.b2_staticBody && this.m_type != y.b2_kinematicBody) {
          for (var e = r.Make(0, 0), i = this.m_fixtureList; i; i = i.m_next) if (0 != i.m_density) {
            var n = i.GetMassData();
            this.m_mass += n.mass, e.x += n.center.x * n.mass, e.y += n.center.y * n.mass, this.m_I += n.I;
          }
          this.m_mass > 0 ? (this.m_invMass = 1 / this.m_mass, e.x *= this.m_invMass, e.y *= this.m_invMass) : (this.m_mass = 1, this.m_invMass = 1), this.m_I > 0 && 0 == (this.m_flags & y.e_fixedRotationFlag) ? (this.m_I -= this.m_mass * (e.x * e.x + e.y * e.y), this.m_I *= this.m_inertiaScale, s.b2Assert(this.m_I > 0), this.m_invI = 1 / this.m_I) : (this.m_I = 0, this.m_invI = 0);
          var o = this.m_sweep.c.Copy();
          this.m_sweep.localCenter.SetV(e), this.m_sweep.c0.SetV(t.MulX(this.m_xf, this.m_sweep.localCenter)), this.m_sweep.c.SetV(this.m_sweep.c0), this.m_linearVelocity.x += this.m_angularVelocity * -(this.m_sweep.c.y - o.y), this.m_linearVelocity.y += this.m_angularVelocity * +(this.m_sweep.c.x - o.x);
        }
      }, y.prototype.GetWorldPoint = function (t) {
        var e = this.m_xf.R, i = new r(e.col1.x * t.x + e.col2.x * t.y, e.col1.y * t.x + e.col2.y * t.y);
        return i.x += this.m_xf.position.x, i.y += this.m_xf.position.y, i;
      }, y.prototype.GetWorldVector = function (e) {
        return t.MulMV(this.m_xf.R, e);
      }, y.prototype.GetLocalPoint = function (e) {
        return t.MulXT(this.m_xf, e);
      }, y.prototype.GetLocalVector = function (e) {
        return t.MulTMV(this.m_xf.R, e);
      }, y.prototype.GetLinearVelocityFromWorldPoint = function (t) {
        return new r(this.m_linearVelocity.x - this.m_angularVelocity * (t.y - this.m_sweep.c.y), this.m_linearVelocity.y + this.m_angularVelocity * (t.x - this.m_sweep.c.x));
      }, y.prototype.GetLinearVelocityFromLocalPoint = function (t) {
        var e = this.m_xf.R, i = new r(e.col1.x * t.x + e.col2.x * t.y, e.col1.y * t.x + e.col2.y * t.y);
        return i.x += this.m_xf.position.x, i.y += this.m_xf.position.y, new r(this.m_linearVelocity.x - this.m_angularVelocity * (i.y - this.m_sweep.c.y), this.m_linearVelocity.y + this.m_angularVelocity * (i.x - this.m_sweep.c.x));
      }, y.prototype.GetLinearDamping = function () {
        return this.m_linearDamping;
      }, y.prototype.SetLinearDamping = function (t) {
        void 0 === t && (t = 0), this.m_linearDamping = t;
      }, y.prototype.GetAngularDamping = function () {
        return this.m_angularDamping;
      }, y.prototype.SetAngularDamping = function (t) {
        void 0 === t && (t = 0), this.m_angularDamping = t;
      }, y.prototype.SetType = function (t) {
        if (void 0 === t && (t = 0), this.m_type != t) {
          this.m_type = t, this.ResetMassData(), this.m_type == y.b2_staticBody && (this.m_linearVelocity.SetZero(), this.m_angularVelocity = 0), this.SetAwake(true), this.m_force.SetZero(), this.m_torque = 0;
          for (var e = this.m_contactList; e; e = e.next) e.contact.FlagForFiltering();
        }
      }, y.prototype.GetType = function () {
        return this.m_type;
      }, y.prototype.SetBullet = function (t) {
        t ? this.m_flags |= y.e_bulletFlag : this.m_flags &= ~y.e_bulletFlag;
      }, y.prototype.IsBullet = function () {
        return (this.m_flags & y.e_bulletFlag) == y.e_bulletFlag;
      }, y.prototype.SetSleepingAllowed = function (t) {
        t ? this.m_flags |= y.e_allowSleepFlag : (this.m_flags &= ~y.e_allowSleepFlag, this.SetAwake(true));
      }, y.prototype.SetAwake = function (t) {
        t ? (this.m_flags |= y.e_awakeFlag, this.m_sleepTime = 0) : (this.m_flags &= ~y.e_awakeFlag, this.m_sleepTime = 0, this.m_linearVelocity.SetZero(), this.m_angularVelocity = 0, this.m_force.SetZero(), this.m_torque = 0);
      }, y.prototype.IsAwake = function () {
        return (this.m_flags & y.e_awakeFlag) == y.e_awakeFlag;
      }, y.prototype.SetFixedRotation = function (t) {
        t ? this.m_flags |= y.e_fixedRotationFlag : this.m_flags &= ~y.e_fixedRotationFlag, this.ResetMassData();
      }, y.prototype.IsFixedRotation = function () {
        return (this.m_flags & y.e_fixedRotationFlag) == y.e_fixedRotationFlag;
      }, y.prototype.SetActive = function (t) {
        var e, i;
        if (t != this.IsActive()) if (t) for (this.m_flags |= y.e_activeFlag, e = this.m_world.m_contactManager.m_broadPhase, i = this.m_fixtureList; i; i = i.m_next) i.CreateProxy(e, this.m_xf); else {
          for (this.m_flags &= ~y.e_activeFlag, e = this.m_world.m_contactManager.m_broadPhase, i = this.m_fixtureList; i; i = i.m_next) i.DestroyProxy(e);
          for (var n = this.m_contactList; n;) {
            var r = n;
            n = n.next, this.m_world.m_contactManager.Destroy(r.contact);
          }
          this.m_contactList = null;
        }
      }, y.prototype.IsActive = function () {
        return (this.m_flags & y.e_activeFlag) == y.e_activeFlag;
      }, y.prototype.IsSleepingAllowed = function () {
        return (this.m_flags & y.e_allowSleepFlag) == y.e_allowSleepFlag;
      }, y.prototype.GetFixtureList = function () {
        return this.m_fixtureList;
      }, y.prototype.GetJointList = function () {
        return this.m_jointList;
      }, y.prototype.GetControllerList = function () {
        return this.m_controllerList;
      }, y.prototype.GetContactList = function () {
        return this.m_contactList;
      }, y.prototype.GetNext = function () {
        return this.m_next;
      }, y.prototype.GetUserData = function () {
        return this.m_userData;
      }, y.prototype.SetUserData = function (t) {
        this.m_userData = t;
      }, y.prototype.GetWorld = function () {
        return this.m_world;
      }, y.prototype.b2Body = function (t, e) {
        this.m_flags = 0, t.bullet && (this.m_flags |= y.e_bulletFlag), t.fixedRotation && (this.m_flags |= y.e_fixedRotationFlag), t.allowSleep && (this.m_flags |= y.e_allowSleepFlag), t.awake && (this.m_flags |= y.e_awakeFlag), t.active && (this.m_flags |= y.e_activeFlag), this.m_world = e, this.m_xf.position.SetV(t.position), this.m_xf.R.Set(t.angle), this.m_sweep.localCenter.SetZero(), this.m_sweep.t0 = 1, this.m_sweep.a0 = this.m_sweep.a = t.angle;
        var i = this.m_xf.R, n = this.m_sweep.localCenter;
        this.m_sweep.c.x = i.col1.x * n.x + i.col2.x * n.y, this.m_sweep.c.y = i.col1.y * n.x + i.col2.y * n.y, this.m_sweep.c.x += this.m_xf.position.x, this.m_sweep.c.y += this.m_xf.position.y, this.m_sweep.c0.SetV(this.m_sweep.c), this.m_jointList = null, this.m_controllerList = null, this.m_contactList = null, this.m_controllerCount = 0, this.m_prev = null, this.m_next = null, this.m_linearVelocity.SetV(t.linearVelocity), this.m_angularVelocity = t.angularVelocity, this.m_linearDamping = t.linearDamping, this.m_angularDamping = t.angularDamping, this.m_force.Set(0, 0), this.m_torque = 0, this.m_sleepTime = 0, this.m_type = t.type, this.m_type == y.b2_dynamicBody ? (this.m_mass = 1, this.m_invMass = 1) : (this.m_mass = 0, this.m_invMass = 0), this.m_I = 0, this.m_invI = 0, this.m_inertiaScale = t.inertiaScale, this.m_userData = t.userData, this.m_fixtureList = null, this.m_fixtureCount = 0;
      }, y.prototype.SynchronizeFixtures = function () {
        var t = y.s_xf1;
        t.R.Set(this.m_sweep.a0);
        var e, i = t.R, n = this.m_sweep.localCenter;
        t.position.x = this.m_sweep.c0.x - (i.col1.x * n.x + i.col2.x * n.y), t.position.y = this.m_sweep.c0.y - (i.col1.y * n.x + i.col2.y * n.y);
        var r = this.m_world.m_contactManager.m_broadPhase;
        for (e = this.m_fixtureList; e; e = e.m_next) e.Synchronize(r, t, this.m_xf);
      }, y.prototype.SynchronizeTransform = function () {
        this.m_xf.R.Set(this.m_sweep.a);
        var t = this.m_xf.R, e = this.m_sweep.localCenter;
        this.m_xf.position.x = this.m_sweep.c.x - (t.col1.x * e.x + t.col2.x * e.y), this.m_xf.position.y = this.m_sweep.c.y - (t.col1.y * e.x + t.col2.y * e.y);
      }, y.prototype.ShouldCollide = function (t) {
        if (this.m_type != y.b2_dynamicBody && t.m_type != y.b2_dynamicBody) return false;
        for (var e = this.m_jointList; e; e = e.next) if (e.other == t && 0 == e.joint.m_collideConnected) return false;
        return true;
      }, y.prototype.Advance = function (t) {
        void 0 === t && (t = 0), this.m_sweep.Advance(t), this.m_sweep.c.SetV(this.m_sweep.c0), this.m_sweep.a = this.m_sweep.a0, this.SynchronizeTransform();
      }, e.postDefs.push(function () {
        e.Dynamics.b2Body.s_xf1 = new n, e.Dynamics.b2Body.e_islandFlag = 1, e.Dynamics.b2Body.e_awakeFlag = 2, e.Dynamics.b2Body.e_allowSleepFlag = 4, e.Dynamics.b2Body.e_bulletFlag = 8, e.Dynamics.b2Body.e_fixedRotationFlag = 16, e.Dynamics.b2Body.e_activeFlag = 32, e.Dynamics.b2Body.b2_staticBody = 0, e.Dynamics.b2Body.b2_kinematicBody = 1, e.Dynamics.b2Body.b2_dynamicBody = 2;
      }), g.b2BodyDef = function () {
        this.position = new r, this.linearVelocity = new r;
      }, g.prototype.b2BodyDef = function () {
        this.userData = null, this.position.Set(0, 0), this.angle = 0, this.linearVelocity.Set(0, 0), this.angularVelocity = 0, this.linearDamping = 0, this.angularDamping = 0, this.allowSleep = true, this.awake = true, this.fixedRotation = false, this.bullet = false, this.type = y.b2_staticBody, this.active = true, this.inertiaScale = 1;
      }, x.b2ContactFilter = function () {}, x.prototype.ShouldCollide = function (t, e) {
        var i = t.GetFilterData(), n = e.GetFilterData();
        return i.groupIndex == n.groupIndex && 0 != i.groupIndex ? i.groupIndex > 0 : 0 != (i.maskBits & n.categoryBits) && 0 != (i.categoryBits & n.maskBits);
      }, x.prototype.RayCollide = function (t, e) {
        return !t || this.ShouldCollide(t instanceof A ? t : null, e);
      }, e.postDefs.push(function () {
        e.Dynamics.b2ContactFilter.b2_defaultFilter = new x;
      }), v.b2ContactImpulse = function () {
        this.normalImpulses = new H(s.b2_maxManifoldPoints), this.tangentImpulses = new H(s.b2_maxManifoldPoints);
      }, b.b2ContactListener = function () {}, b.prototype.BeginContact = function (t) {}, b.prototype.EndContact = function (t) {}, b.prototype.PreSolve = function (t, e) {}, b.prototype.PostSolve = function (t, e) {}, e.postDefs.push(function () {
        e.Dynamics.b2ContactListener.b2_defaultListener = new b;
      }), w.b2ContactManager = function () {}, w.prototype.b2ContactManager = function () {
        this.m_world = null, this.m_contactCount = 0, this.m_contactFilter = x.b2_defaultFilter, this.m_contactListener = b.b2_defaultListener, this.m_contactFactory = new B(this.m_allocator), this.m_broadPhase = new c;
      }, w.prototype.AddPair = function (t, e) {
        var i = t instanceof A ? t : null, n = e instanceof A ? e : null, r = i.GetBody(), o = n.GetBody();
        if (r != o) {
          for (var s = o.GetContactList(); s;) {
            if (s.other == r) {
              var a = s.contact.GetFixtureA(), l = s.contact.GetFixtureB();
              if (a == i && l == n) return;
              if (a == n && l == i) return;
            }
            s = s.next;
          }
          if (0 != o.ShouldCollide(r) && 0 != this.m_contactFilter.ShouldCollide(i, n)) {
            var c = this.m_contactFactory.Create(i, n);
            i = c.GetFixtureA(), n = c.GetFixtureB(), r = i.m_body, o = n.m_body, c.m_prev = null, c.m_next = this.m_world.m_contactList, null != this.m_world.m_contactList && (this.m_world.m_contactList.m_prev = c), this.m_world.m_contactList = c, c.m_nodeA.contact = c, c.m_nodeA.other = o, c.m_nodeA.prev = null, c.m_nodeA.next = r.m_contactList, null != r.m_contactList && (r.m_contactList.prev = c.m_nodeA), r.m_contactList = c.m_nodeA, c.m_nodeB.contact = c, c.m_nodeB.other = r, c.m_nodeB.prev = null, c.m_nodeB.next = o.m_contactList, null != o.m_contactList && (o.m_contactList.prev = c.m_nodeB), o.m_contactList = c.m_nodeB, ++this.m_world.m_contactCount;
          }
        }
      }, w.prototype.FindNewContacts = function () {
        this.m_broadPhase.UpdatePairs(e.generateCallback(this, this.AddPair));
      }, w.prototype.Destroy = function (t) {
        var e = t.GetFixtureA(), i = t.GetFixtureB(), n = e.GetBody(), r = i.GetBody();
        t.IsTouching() && this.m_contactListener.EndContact(t), t.m_prev && (t.m_prev.m_next = t.m_next), t.m_next && (t.m_next.m_prev = t.m_prev), t == this.m_world.m_contactList && (this.m_world.m_contactList = t.m_next), t.m_nodeA.prev && (t.m_nodeA.prev.next = t.m_nodeA.next), t.m_nodeA.next && (t.m_nodeA.next.prev = t.m_nodeA.prev), t.m_nodeA == n.m_contactList && (n.m_contactList = t.m_nodeA.next), t.m_nodeB.prev && (t.m_nodeB.prev.next = t.m_nodeB.next), t.m_nodeB.next && (t.m_nodeB.next.prev = t.m_nodeB.prev), t.m_nodeB == r.m_contactList && (r.m_contactList = t.m_nodeB.next), this.m_contactFactory.Destroy(t), --this.m_contactCount;
      }, w.prototype.Collide = function () {
        for (var t = this.m_world.m_contactList; t;) {
          var e = t.GetFixtureA(), i = t.GetFixtureB(), n = e.GetBody(), r = i.GetBody();
          if (0 != n.IsAwake() || 0 != r.IsAwake()) {
            if (t.m_flags & V.e_filterFlag) {
              if (0 == r.ShouldCollide(n)) {
                var o = t;
                t = o.GetNext(), this.Destroy(o);
                continue;
              }
              if (0 == this.m_contactFilter.ShouldCollide(e, i)) {
                t = (o = t).GetNext(), this.Destroy(o);
                continue;
              }
              t.m_flags &= ~V.e_filterFlag;
            }
            var s = e.m_proxy, a = i.m_proxy;
            0 != this.m_broadPhase.TestOverlap(s, a) ? (t.Update(this.m_contactListener), t = t.GetNext()) : (t = (o = t).GetNext(), this.Destroy(o));
          } else t = t.GetNext();
        }
      }, e.postDefs.push(function () {
        e.Dynamics.b2ContactManager.s_evalCP = new l;
      }), S.b2DebugDraw = function () {}, S.prototype.b2DebugDraw = function () {}, S.prototype.SetFlags = function (t) {
        void 0 === t && (t = 0);
      }, S.prototype.GetFlags = function () {}, S.prototype.AppendFlags = function (t) {
        void 0 === t && (t = 0);
      }, S.prototype.ClearFlags = function (t) {
        void 0 === t && (t = 0);
      }, S.prototype.SetSprite = function (t) {}, S.prototype.GetSprite = function () {}, S.prototype.SetDrawScale = function (t) {
        void 0 === t && (t = 0);
      }, S.prototype.GetDrawScale = function () {}, S.prototype.SetLineThickness = function (t) {
        void 0 === t && (t = 0);
      }, S.prototype.GetLineThickness = function () {}, S.prototype.SetAlpha = function (t) {
        void 0 === t && (t = 0);
      }, S.prototype.GetAlpha = function () {}, S.prototype.SetFillAlpha = function (t) {
        void 0 === t && (t = 0);
      }, S.prototype.GetFillAlpha = function () {}, S.prototype.SetXFormScale = function (t) {
        void 0 === t && (t = 0);
      }, S.prototype.GetXFormScale = function () {}, S.prototype.DrawPolygon = function (t, e, i) {
        void 0 === e && (e = 0);
      }, S.prototype.DrawSolidPolygon = function (t, e, i) {
        void 0 === e && (e = 0);
      }, S.prototype.DrawCircle = function (t, e, i) {
        void 0 === e && (e = 0);
      }, S.prototype.DrawSolidCircle = function (t, e, i, n) {
        void 0 === e && (e = 0);
      }, S.prototype.DrawSegment = function (t, e, i) {}, S.prototype.DrawTransform = function (t) {}, e.postDefs.push(function () {
        e.Dynamics.b2DebugDraw.e_shapeBit = 1, e.Dynamics.b2DebugDraw.e_jointBit = 2, e.Dynamics.b2DebugDraw.e_aabbBit = 4, e.Dynamics.b2DebugDraw.e_pairBit = 8, e.Dynamics.b2DebugDraw.e_centerOfMassBit = 16, e.Dynamics.b2DebugDraw.e_controllerBit = 32;
      }), M.b2DestructionListener = function () {}, M.prototype.SayGoodbyeJoint = function (t) {}, M.prototype.SayGoodbyeFixture = function (t) {}, C.b2FilterData = function () {
        this.categoryBits = 1, this.maskBits = 65535, this.groupIndex = 0;
      }, C.prototype.Copy = function () {
        var t = new C;
        return t.categoryBits = this.categoryBits, t.maskBits = this.maskBits, t.groupIndex = this.groupIndex, t;
      }, A.b2Fixture = function () {
        this.m_filter = new C;
      }, A.prototype.GetType = function () {
        return this.m_shape.GetType();
      }, A.prototype.GetShape = function () {
        return this.m_shape;
      }, A.prototype.SetSensor = function (t) {
        if (this.m_isSensor != t && (this.m_isSensor = t, null != this.m_body)) for (var e = this.m_body.GetContactList(); e;) {
          var i = e.contact, n = i.GetFixtureA(), r = i.GetFixtureB();
          n != this && r != this || i.SetSensor(n.IsSensor() || r.IsSensor()), e = e.next;
        }
      }, A.prototype.IsSensor = function () {
        return this.m_isSensor;
      }, A.prototype.SetFilterData = function (t) {
        if (this.m_filter = t.Copy(), !this.m_body) for (var e = this.m_body.GetContactList(); e;) {
          var i = e.contact, n = i.GetFixtureA(), r = i.GetFixtureB();
          n != this && r != this || i.FlagForFiltering(), e = e.next;
        }
      }, A.prototype.GetFilterData = function () {
        return this.m_filter.Copy();
      }, A.prototype.GetBody = function () {
        return this.m_body;
      }, A.prototype.GetNext = function () {
        return this.m_next;
      }, A.prototype.GetUserData = function () {
        return this.m_userData;
      }, A.prototype.SetUserData = function (t) {
        this.m_userData = t;
      }, A.prototype.TestPoint = function (t) {
        return this.m_shape.TestPoint(this.m_body.GetTransform(), t);
      }, A.prototype.RayCast = function (t, e) {
        return this.m_shape.RayCast(t, e, this.m_body.GetTransform());
      }, A.prototype.GetMassData = function (t) {
        return void 0 === t && (t = null), null == t && (t = new d), this.m_shape.ComputeMass(t, this.m_density), t;
      }, A.prototype.SetDensity = function (t) {
        void 0 === t && (t = 0), this.m_density = t;
      }, A.prototype.GetDensity = function () {
        return this.m_density;
      }, A.prototype.GetFriction = function () {
        return this.m_friction;
      }, A.prototype.SetFriction = function (t) {
        void 0 === t && (t = 0), this.m_friction = t;
      }, A.prototype.GetRestitution = function () {
        return this.m_restitution;
      }, A.prototype.SetRestitution = function (t) {
        void 0 === t && (t = 0), this.m_restitution = t;
      }, A.prototype.GetAABB = function () {
        return this.m_aabb;
      }, A.prototype.b2Fixture = function () {
        this.m_aabb = new a, this.m_userData = null, this.m_body = null, this.m_next = null, this.m_shape = null, this.m_density = 0, this.m_friction = 0, this.m_restitution = 0;
      }, A.prototype.Create = function (t, e, i) {
        this.m_userData = i.userData, this.m_friction = i.friction, this.m_restitution = i.restitution, this.m_body = t, this.m_next = null, this.m_filter = i.filter.Copy(), this.m_isSensor = i.isSensor, this.m_shape = i.shape.Copy(), this.m_density = i.density;
      }, A.prototype.Destroy = function () {
        this.m_shape = null;
      }, A.prototype.CreateProxy = function (t, e) {
        this.m_shape.ComputeAABB(this.m_aabb, e), this.m_proxy = t.CreateProxy(this.m_aabb, this);
      }, A.prototype.DestroyProxy = function (t) {
        null != this.m_proxy && (t.DestroyProxy(this.m_proxy), this.m_proxy = null);
      }, A.prototype.Synchronize = function (e, i, n) {
        if (this.m_proxy) {
          var r = new a, o = new a;
          this.m_shape.ComputeAABB(r, i), this.m_shape.ComputeAABB(o, n), this.m_aabb.Combine(r, o);
          var s = t.SubtractVV(n.position, i.position);
          e.MoveProxy(this.m_proxy, this.m_aabb, s);
        }
      }, T.b2FixtureDef = function () {
        this.filter = new C;
      }, T.prototype.b2FixtureDef = function () {
        this.shape = null, this.userData = null, this.friction = 0.2, this.restitution = 0, this.density = 0, this.filter.categoryBits = 1, this.filter.maskBits = 65535, this.filter.groupIndex = 0, this.isSensor = false;
      }, E.b2Island = function () {}, E.prototype.b2Island = function () {
        this.m_bodies = new k, this.m_contacts = new k, this.m_joints = new k;
      }, E.prototype.Initialize = function (t, e, i, n, r, o) {
        void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0);
        var s = 0;
        for (this.m_bodyCapacity = t, this.m_contactCapacity = e, this.m_jointCapacity = i, this.m_bodyCount = 0, this.m_contactCount = 0, this.m_jointCount = 0, this.m_allocator = n, this.m_listener = r, this.m_contactSolver = o, s = this.m_bodies.length; s < t; s++) this.m_bodies[s] = null;
        for (s = this.m_contacts.length; s < e; s++) this.m_contacts[s] = null;
        for (s = this.m_joints.length; s < i; s++) this.m_joints[s] = null;
      }, E.prototype.Clear = function () {
        this.m_bodyCount = 0, this.m_contactCount = 0, this.m_jointCount = 0;
      }, E.prototype.Solve = function (e, i, n) {
        var r, o = 0, a = 0;
        for (o = 0; o < this.m_bodyCount; ++o) (r = this.m_bodies[o]).GetType() == y.b2_dynamicBody && (r.m_linearVelocity.x += e.dt * (i.x + r.m_invMass * r.m_force.x), r.m_linearVelocity.y += e.dt * (i.y + r.m_invMass * r.m_force.y), r.m_angularVelocity += e.dt * r.m_invI * r.m_torque, r.m_linearVelocity.Multiply(t.Clamp(1 - e.dt * r.m_linearDamping, 0, 1)), r.m_angularVelocity *= t.Clamp(1 - e.dt * r.m_angularDamping, 0, 1));
        this.m_contactSolver.Initialize(e, this.m_contacts, this.m_contactCount, this.m_allocator);
        var l = this.m_contactSolver;
        for (l.InitVelocityConstraints(e), o = 0; o < this.m_jointCount; ++o) this.m_joints[o].InitVelocityConstraints(e);
        for (o = 0; o < e.velocityIterations; ++o) {
          for (a = 0; a < this.m_jointCount; ++a) this.m_joints[a].SolveVelocityConstraints(e);
          l.SolveVelocityConstraints();
        }
        for (o = 0; o < this.m_jointCount; ++o) this.m_joints[o].FinalizeVelocityConstraints();
        for (l.FinalizeVelocityConstraints(), o = 0; o < this.m_bodyCount; ++o) if ((r = this.m_bodies[o]).GetType() != y.b2_staticBody) {
          var c = e.dt * r.m_linearVelocity.x, h = e.dt * r.m_linearVelocity.y;
          c * c + h * h > s.b2_maxTranslationSquared && (r.m_linearVelocity.Normalize(), r.m_linearVelocity.x *= s.b2_maxTranslation * e.inv_dt, r.m_linearVelocity.y *= s.b2_maxTranslation * e.inv_dt);
          var u = e.dt * r.m_angularVelocity;
          u * u > s.b2_maxRotationSquared && (r.m_angularVelocity < 0 ? r.m_angularVelocity = -s.b2_maxRotation * e.inv_dt : r.m_angularVelocity = s.b2_maxRotation * e.inv_dt), r.m_sweep.c0.SetV(r.m_sweep.c), r.m_sweep.a0 = r.m_sweep.a, r.m_sweep.c.x += e.dt * r.m_linearVelocity.x, r.m_sweep.c.y += e.dt * r.m_linearVelocity.y, r.m_sweep.a += e.dt * r.m_angularVelocity, r.SynchronizeTransform();
        }
        for (o = 0; o < e.positionIterations; ++o) {
          var m = l.SolvePositionConstraints(s.b2_contactBaumgarte), p = true;
          for (a = 0; a < this.m_jointCount; ++a) {
            var d = this.m_joints[a].SolvePositionConstraints(s.b2_contactBaumgarte);
            p = p && d;
          }
          if (m && p) break;
        }
        if (this.Report(l.m_constraints), n) {
          var f = Number.MAX_VALUE, _ = s.b2_linearSleepTolerance * s.b2_linearSleepTolerance, g = s.b2_angularSleepTolerance * s.b2_angularSleepTolerance;
          for (o = 0; o < this.m_bodyCount; ++o) (r = this.m_bodies[o]).GetType() != y.b2_staticBody && (0 == (r.m_flags & y.e_allowSleepFlag) && (r.m_sleepTime = 0, f = 0), 0 == (r.m_flags & y.e_allowSleepFlag) || r.m_angularVelocity * r.m_angularVelocity > g || t.Dot(r.m_linearVelocity, r.m_linearVelocity) > _ ? (r.m_sleepTime = 0, f = 0) : (r.m_sleepTime += e.dt, f = t.Min(f, r.m_sleepTime)));
          if (f >= s.b2_timeToSleep) for (o = 0; o < this.m_bodyCount; ++o) (r = this.m_bodies[o]).SetAwake(false);
        }
      }, E.prototype.SolveTOI = function (t) {
        var e = 0, i = 0;
        this.m_contactSolver.Initialize(t, this.m_contacts, this.m_contactCount, this.m_allocator);
        var n = this.m_contactSolver;
        for (e = 0; e < this.m_jointCount; ++e) this.m_joints[e].InitVelocityConstraints(t);
        for (e = 0; e < t.velocityIterations; ++e) for (n.SolveVelocityConstraints(), i = 0; i < this.m_jointCount; ++i) this.m_joints[i].SolveVelocityConstraints(t);
        for (e = 0; e < this.m_bodyCount; ++e) {
          var r = this.m_bodies[e];
          if (r.GetType() != y.b2_staticBody) {
            var o = t.dt * r.m_linearVelocity.x, a = t.dt * r.m_linearVelocity.y;
            o * o + a * a > s.b2_maxTranslationSquared && (r.m_linearVelocity.Normalize(), r.m_linearVelocity.x *= s.b2_maxTranslation * t.inv_dt, r.m_linearVelocity.y *= s.b2_maxTranslation * t.inv_dt);
            var l = t.dt * r.m_angularVelocity;
            l * l > s.b2_maxRotationSquared && (r.m_angularVelocity < 0 ? r.m_angularVelocity = -s.b2_maxRotation * t.inv_dt : r.m_angularVelocity = s.b2_maxRotation * t.inv_dt), r.m_sweep.c0.SetV(r.m_sweep.c), r.m_sweep.a0 = r.m_sweep.a, r.m_sweep.c.x += t.dt * r.m_linearVelocity.x, r.m_sweep.c.y += t.dt * r.m_linearVelocity.y, r.m_sweep.a += t.dt * r.m_angularVelocity, r.SynchronizeTransform();
          }
        }
        for (e = 0; e < t.positionIterations; ++e) {
          var c = n.SolvePositionConstraints(0.75), h = true;
          for (i = 0; i < this.m_jointCount; ++i) {
            var u = this.m_joints[i].SolvePositionConstraints(s.b2_contactBaumgarte);
            h = h && u;
          }
          if (c && h) break;
        }
        this.Report(n.m_constraints);
      }, E.prototype.Report = function (t) {
        if (null != this.m_listener) for (var e = 0; e < this.m_contactCount; ++e) {
          for (var i = this.m_contacts[e], n = t[e], r = 0; r < n.pointCount; ++r) E.s_impulse.normalImpulses[r] = n.points[r].normalImpulse, E.s_impulse.tangentImpulses[r] = n.points[r].tangentImpulse;
          this.m_listener.PostSolve(i, E.s_impulse);
        }
      }, E.prototype.AddBody = function (t) {
        t.m_islandIndex = this.m_bodyCount, this.m_bodies[this.m_bodyCount++] = t;
      }, E.prototype.AddContact = function (t) {
        this.m_contacts[this.m_contactCount++] = t;
      }, E.prototype.AddJoint = function (t) {
        this.m_joints[this.m_jointCount++] = t;
      }, e.postDefs.push(function () {
        e.Dynamics.b2Island.s_impulse = new v;
      }), L.b2TimeStep = function () {}, L.prototype.Set = function (t) {
        this.dt = t.dt, this.inv_dt = t.inv_dt, this.positionIterations = t.positionIterations, this.velocityIterations = t.velocityIterations, this.warmStarting = t.warmStarting;
      }, D.b2World = function () {
        this.s_stack = new k, this.m_contactManager = new w, this.m_contactSolver = new R, this.m_island = new E;
      }, D.prototype.b2World = function (t, e) {
        this.m_destructionListener = null, this.m_debugDraw = null, this.m_bodyList = null, this.m_contactList = null, this.m_jointList = null, this.m_controllerList = null, this.m_bodyCount = 0, this.m_contactCount = 0, this.m_jointCount = 0, this.m_controllerCount = 0, D.m_warmStarting = true, D.m_continuousPhysics = true, this.m_allowSleep = e, this.m_gravity = t, this.m_inv_dt0 = 0, this.m_contactManager.m_world = this;
        var i = new g;
        this.m_groundBody = this.CreateBody(i);
      }, D.prototype.SetDestructionListener = function (t) {
        this.m_destructionListener = t;
      }, D.prototype.SetContactFilter = function (t) {
        this.m_contactManager.m_contactFilter = t;
      }, D.prototype.SetContactListener = function (t) {
        this.m_contactManager.m_contactListener = t;
      }, D.prototype.SetDebugDraw = function (t) {
        this.m_debugDraw = t;
      }, D.prototype.SetBroadPhase = function (t) {
        var e = this.m_contactManager.m_broadPhase;
        this.m_contactManager.m_broadPhase = t;
        for (var i = this.m_bodyList; i; i = i.m_next) for (var n = i.m_fixtureList; n; n = n.m_next) n.m_proxy = t.CreateProxy(e.GetFatAABB(n.m_proxy), n);
      }, D.prototype.Validate = function () {
        this.m_contactManager.m_broadPhase.Validate();
      }, D.prototype.GetProxyCount = function () {
        return this.m_contactManager.m_broadPhase.GetProxyCount();
      }, D.prototype.CreateBody = function (t) {
        if (1 == this.IsLocked()) return null;
        var e = new y(t, this);
        return e.m_prev = null, e.m_next = this.m_bodyList, this.m_bodyList && (this.m_bodyList.m_prev = e), this.m_bodyList = e, ++this.m_bodyCount, e;
      }, D.prototype.DestroyBody = function (t) {
        if (1 != this.IsLocked()) {
          for (var e = t.m_jointList; e;) {
            var i = e;
            e = e.next, this.m_destructionListener && this.m_destructionListener.SayGoodbyeJoint(i.joint), this.DestroyJoint(i.joint);
          }
          for (var n = t.m_controllerList; n;) {
            var r = n;
            n = n.nextController, r.controller.RemoveBody(t);
          }
          for (var o = t.m_contactList; o;) {
            var s = o;
            o = o.next, this.m_contactManager.Destroy(s.contact);
          }
          t.m_contactList = null;
          for (var a = t.m_fixtureList; a;) {
            var l = a;
            a = a.m_next, this.m_destructionListener && this.m_destructionListener.SayGoodbyeFixture(l), l.DestroyProxy(this.m_contactManager.m_broadPhase), l.Destroy();
          }
          t.m_fixtureList = null, t.m_fixtureCount = 0, t.m_prev && (t.m_prev.m_next = t.m_next), t.m_next && (t.m_next.m_prev = t.m_prev), t == this.m_bodyList && (this.m_bodyList = t.m_next), --this.m_bodyCount;
        }
      }, D.prototype.CreateJoint = function (t) {
        var e = P.Create(t, null);
        e.m_prev = null, e.m_next = this.m_jointList, this.m_jointList && (this.m_jointList.m_prev = e), this.m_jointList = e, ++this.m_jointCount, e.m_edgeA.joint = e, e.m_edgeA.other = e.m_bodyB, e.m_edgeA.prev = null, e.m_edgeA.next = e.m_bodyA.m_jointList, e.m_bodyA.m_jointList && (e.m_bodyA.m_jointList.prev = e.m_edgeA), e.m_bodyA.m_jointList = e.m_edgeA, e.m_edgeB.joint = e, e.m_edgeB.other = e.m_bodyA, e.m_edgeB.prev = null, e.m_edgeB.next = e.m_bodyB.m_jointList, e.m_bodyB.m_jointList && (e.m_bodyB.m_jointList.prev = e.m_edgeB), e.m_bodyB.m_jointList = e.m_edgeB;
        var i = t.bodyA, n = t.bodyB;
        if (0 == t.collideConnected) for (var r = n.GetContactList(); r;) r.other == i && r.contact.FlagForFiltering(), r = r.next;
        return e;
      }, D.prototype.DestroyJoint = function (t) {
        var e = t.m_collideConnected;
        t.m_prev && (t.m_prev.m_next = t.m_next), t.m_next && (t.m_next.m_prev = t.m_prev), t == this.m_jointList && (this.m_jointList = t.m_next);
        var i = t.m_bodyA, n = t.m_bodyB;
        if (i.SetAwake(true), n.SetAwake(true), t.m_edgeA.prev && (t.m_edgeA.prev.next = t.m_edgeA.next), t.m_edgeA.next && (t.m_edgeA.next.prev = t.m_edgeA.prev), t.m_edgeA == i.m_jointList && (i.m_jointList = t.m_edgeA.next), t.m_edgeA.prev = null, t.m_edgeA.next = null, t.m_edgeB.prev && (t.m_edgeB.prev.next = t.m_edgeB.next), t.m_edgeB.next && (t.m_edgeB.next.prev = t.m_edgeB.prev), t.m_edgeB == n.m_jointList && (n.m_jointList = t.m_edgeB.next), t.m_edgeB.prev = null, t.m_edgeB.next = null, P.Destroy(t, null), --this.m_jointCount, 0 == e) for (var r = n.GetContactList(); r;) r.other == i && r.contact.FlagForFiltering(), r = r.next;
      }, D.prototype.AddController = function (t) {
        return t.m_next = this.m_controllerList, t.m_prev = null, this.m_controllerList = t, t.m_world = this, this.m_controllerCount++, t;
      }, D.prototype.RemoveController = function (t) {
        t.m_prev && (t.m_prev.m_next = t.m_next), t.m_next && (t.m_next.m_prev = t.m_prev), this.m_controllerList == t && (this.m_controllerList = t.m_next), this.m_controllerCount--;
      }, D.prototype.CreateController = function (t) {
        if (t.m_world != this) throw new Error("Controller can only be a member of one world");
        return t.m_next = this.m_controllerList, t.m_prev = null, this.m_controllerList && (this.m_controllerList.m_prev = t), this.m_controllerList = t, ++this.m_controllerCount, t.m_world = this, t;
      }, D.prototype.DestroyController = function (t) {
        t.Clear(), t.m_next && (t.m_next.m_prev = t.m_prev), t.m_prev && (t.m_prev.m_next = t.m_next), t == this.m_controllerList && (this.m_controllerList = t.m_next), --this.m_controllerCount;
      }, D.prototype.SetWarmStarting = function (t) {
        D.m_warmStarting = t;
      }, D.prototype.SetContinuousPhysics = function (t) {
        D.m_continuousPhysics = t;
      }, D.prototype.GetBodyCount = function () {
        return this.m_bodyCount;
      }, D.prototype.GetJointCount = function () {
        return this.m_jointCount;
      }, D.prototype.GetContactCount = function () {
        return this.m_contactCount;
      }, D.prototype.SetGravity = function (t) {
        this.m_gravity = t;
      }, D.prototype.GetGravity = function () {
        return this.m_gravity;
      }, D.prototype.GetGroundBody = function () {
        return this.m_groundBody;
      }, D.prototype.Step = function (t, e, i) {
        void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), this.m_flags & D.e_newFixture && (this.m_contactManager.FindNewContacts(), this.m_flags &= ~D.e_newFixture), this.m_flags |= D.e_locked;
        var n = D.s_timestep2;
        n.dt = t, n.velocityIterations = e, n.positionIterations = i, n.inv_dt = t > 0 ? 1 / t : 0, n.dtRatio = this.m_inv_dt0 * t, n.warmStarting = D.m_warmStarting, this.m_contactManager.Collide(), n.dt > 0 && this.Solve(n), D.m_continuousPhysics && n.dt > 0 && this.SolveTOI(n), n.dt > 0 && (this.m_inv_dt0 = n.inv_dt), this.m_flags &= ~D.e_locked;
      }, D.prototype.ClearForces = function () {
        for (var t = this.m_bodyList; t; t = t.m_next) t.m_force.SetZero(), t.m_torque = 0;
      }, D.prototype.DrawDebugData = function () {
        if (null != this.m_debugDraw) {
          this.m_debugDraw.m_sprite.graphics.clear();
          var t, e, i, n, s, l, c = this.m_debugDraw.GetFlags(), h = (new r, new r, new r, new a, new a, [new r, new r, new r, new r]), u = new o(0, 0, 0);
          if (c & S.e_shapeBit) for (t = this.m_bodyList; t; t = t.m_next) for (l = t.m_xf, e = t.GetFixtureList(); e; e = e.m_next) i = e.GetShape(), 0 == t.IsActive() ? (u.Set(0.5, 0.5, 0.3), this.DrawShape(i, l, u)) : t.GetType() == y.b2_staticBody ? (u.Set(0.5, 0.9, 0.5), this.DrawShape(i, l, u)) : t.GetType() == y.b2_kinematicBody ? (u.Set(0.5, 0.5, 0.9), this.DrawShape(i, l, u)) : 0 == t.IsAwake() ? (u.Set(0.6, 0.6, 0.6), this.DrawShape(i, l, u)) : (u.Set(0.9, 0.7, 0.7), this.DrawShape(i, l, u));
          if (c & S.e_jointBit) for (n = this.m_jointList; n; n = n.m_next) this.DrawJoint(n);
          if (c & S.e_controllerBit) for (var m = this.m_controllerList; m; m = m.m_next) m.Draw(this.m_debugDraw);
          if (c & S.e_pairBit) {
            u.Set(0.3, 0.9, 0.9);
            for (var p = this.m_contactManager.m_contactList; p; p = p.GetNext()) {
              var d = p.GetFixtureA(), f = p.GetFixtureB(), _ = d.GetAABB().GetCenter(), g = f.GetAABB().GetCenter();
              this.m_debugDraw.DrawSegment(_, g, u);
            }
          }
          if (c & S.e_aabbBit) for (s = this.m_contactManager.m_broadPhase, h = [new r, new r, new r, new r], t = this.m_bodyList; t; t = t.GetNext()) if (0 != t.IsActive()) for (e = t.GetFixtureList(); e; e = e.GetNext()) {
            var x = s.GetFatAABB(e.m_proxy);
            h[0].Set(x.lowerBound.x, x.lowerBound.y), h[1].Set(x.upperBound.x, x.lowerBound.y), h[2].Set(x.upperBound.x, x.upperBound.y), h[3].Set(x.lowerBound.x, x.upperBound.y), this.m_debugDraw.DrawPolygon(h, 4, u);
          }
          if (c & S.e_centerOfMassBit) for (t = this.m_bodyList; t; t = t.m_next) (l = D.s_xf).R = t.m_xf.R, l.position = t.GetWorldCenter(), this.m_debugDraw.DrawTransform(l);
        }
      }, D.prototype.QueryAABB = function (t, e) {
        var i = this.m_contactManager.m_broadPhase;
        i.Query(function (e) {
          return t(i.GetUserData(e));
        }, e);
      }, D.prototype.QueryShape = function (t, e, i) {
        void 0 === i && (i = null), null == i && (i = new n).SetIdentity();
        var r = this.m_contactManager.m_broadPhase;
        var o = new a;
        e.ComputeAABB(o, i), r.Query(function (n) {
          var o = r.GetUserData(n) instanceof A ? r.GetUserData(n) : null;
          return !_.TestOverlap(e, i, o.GetShape(), o.GetBody().GetTransform()) || t(o);
        }, o);
      }, D.prototype.QueryPoint = function (t, e) {
        var i = this.m_contactManager.m_broadPhase;
        var n = new a;
        n.lowerBound.Set(e.x - s.b2_linearSlop, e.y - s.b2_linearSlop), n.upperBound.Set(e.x + s.b2_linearSlop, e.y + s.b2_linearSlop), i.Query(function (n) {
          var r = i.GetUserData(n) instanceof A ? i.GetUserData(n) : null;
          return !r.TestPoint(e) || t(r);
        }, n);
      }, D.prototype.RayCast = function (t, e, i) {
        var n = this.m_contactManager.m_broadPhase, o = new u;
        var s = new h(e, i);
        n.RayCast(function (s, a) {
          var l = n.GetUserData(a), c = l instanceof A ? l : null;
          if (c.RayCast(o, s)) {
            var h = o.fraction, u = new r((1 - h) * e.x + h * i.x, (1 - h) * e.y + h * i.y);
            return t(c, u, o.normal, h);
          }
          return s.maxFraction;
        }, s);
      }, D.prototype.RayCastOne = function (t, e) {
        var i;
        return this.RayCast(function (t, e, n, r) {
          return void 0 === r && (r = 0), i = t, r;
        }, t, e), i;
      }, D.prototype.RayCastAll = function (t, e) {
        var i = new k;
        return this.RayCast(function (t, e, n, r) {
          return void 0 === r && (r = 0), i[i.length] = t, 1;
        }, t, e), i;
      }, D.prototype.GetBodyList = function () {
        return this.m_bodyList;
      }, D.prototype.GetJointList = function () {
        return this.m_jointList;
      }, D.prototype.GetContactList = function () {
        return this.m_contactList;
      }, D.prototype.IsLocked = function () {
        return (this.m_flags & D.e_locked) > 0;
      }, D.prototype.Solve = function (t) {
        for (var e, i = this.m_controllerList; i; i = i.m_next) i.Step(t);
        var n = this.m_island;
        for (n.Initialize(this.m_bodyCount, this.m_contactCount, this.m_jointCount, null, this.m_contactManager.m_contactListener, this.m_contactSolver), e = this.m_bodyList; e; e = e.m_next) e.m_flags &= ~y.e_islandFlag;
        for (var r = this.m_contactList; r; r = r.m_next) r.m_flags &= ~V.e_islandFlag;
        for (var o = this.m_jointList; o; o = o.m_next) o.m_islandFlag = false;
        parseInt(this.m_bodyCount);
        for (var s = this.s_stack, a = this.m_bodyList; a; a = a.m_next) if (!(a.m_flags & y.e_islandFlag) && 0 != a.IsAwake() && 0 != a.IsActive() && a.GetType() != y.b2_staticBody) {
          n.Clear();
          var l = 0;
          for (s[l++] = a, a.m_flags |= y.e_islandFlag; l > 0;) if (e = s[--l], n.AddBody(e), 0 == e.IsAwake() && e.SetAwake(true), e.GetType() != y.b2_staticBody) {
            for (var c, h = e.m_contactList; h; h = h.next) h.contact.m_flags & V.e_islandFlag || 1 != h.contact.IsSensor() && 0 != h.contact.IsEnabled() && 0 != h.contact.IsTouching() && (n.AddContact(h.contact), h.contact.m_flags |= V.e_islandFlag, (c = h.other).m_flags & y.e_islandFlag || (s[l++] = c, c.m_flags |= y.e_islandFlag));
            for (var u = e.m_jointList; u; u = u.next) 1 != u.joint.m_islandFlag && 0 != (c = u.other).IsActive() && (n.AddJoint(u.joint), u.joint.m_islandFlag = true, c.m_flags & y.e_islandFlag || (s[l++] = c, c.m_flags |= y.e_islandFlag));
          }
          n.Solve(t, this.m_gravity, this.m_allowSleep);
          for (var m = 0; m < n.m_bodyCount; ++m) (e = n.m_bodies[m]).GetType() == y.b2_staticBody && (e.m_flags &= ~y.e_islandFlag);
        }
        for (m = 0; m < s.length && s[m]; ++m) s[m] = null;
        for (e = this.m_bodyList; e; e = e.m_next) 0 != e.IsAwake() && 0 != e.IsActive() && e.GetType() != y.b2_staticBody && e.SynchronizeFixtures();
        this.m_contactManager.FindNewContacts();
      }, D.prototype.SolveTOI = function (t) {
        var e, i, n, r, o, a, l, c = this.m_island;
        c.Initialize(this.m_bodyCount, s.b2_maxTOIContactsPerIsland, s.b2_maxTOIJointsPerIsland, null, this.m_contactManager.m_contactListener, this.m_contactSolver);
        var h, u = D.s_queue;
        for (e = this.m_bodyList; e; e = e.m_next) e.m_flags &= ~y.e_islandFlag, e.m_sweep.t0 = 0;
        for (h = this.m_contactList; h; h = h.m_next) h.m_flags &= ~(V.e_toiFlag | V.e_islandFlag);
        for (l = this.m_jointList; l; l = l.m_next) l.m_islandFlag = false;
        for (;;) {
          var m = null, p = 1;
          for (h = this.m_contactList; h; h = h.m_next) if (1 != h.IsSensor() && 0 != h.IsEnabled() && 0 != h.IsContinuous()) {
            var d = 1;
            if (h.m_flags & V.e_toiFlag) d = h.m_toi; else {
              if (i = h.m_fixtureA, n = h.m_fixtureB, r = i.m_body, o = n.m_body, !(r.GetType() == y.b2_dynamicBody && 0 != r.IsAwake() || o.GetType() == y.b2_dynamicBody && 0 != o.IsAwake())) continue;
              var f = r.m_sweep.t0;
              r.m_sweep.t0 < o.m_sweep.t0 ? (f = o.m_sweep.t0, r.m_sweep.Advance(f)) : o.m_sweep.t0 < r.m_sweep.t0 && (f = r.m_sweep.t0, o.m_sweep.Advance(f)), d = h.ComputeTOI(r.m_sweep, o.m_sweep), s.b2Assert(0 <= d && d <= 1), d > 0 && d < 1 && (d = (1 - d) * f + d) > 1 && (d = 1), h.m_toi = d, h.m_flags |= V.e_toiFlag;
            }
            Number.MIN_VALUE < d && d < p && (m = h, p = d);
          }
          if (null == m || 1 - 100 * Number.MIN_VALUE < p) break;
          if (i = m.m_fixtureA, n = m.m_fixtureB, r = i.m_body, o = n.m_body, D.s_backupA.Set(r.m_sweep), D.s_backupB.Set(o.m_sweep), r.Advance(p), o.Advance(p), m.Update(this.m_contactManager.m_contactListener), m.m_flags &= ~V.e_toiFlag, 1 != m.IsSensor() && 0 != m.IsEnabled()) {
            if (0 != m.IsTouching()) {
              var _ = r;
              _.GetType() != y.b2_dynamicBody && (_ = o), c.Clear();
              var g = 0, x = 0;
              for (u[g + x++] = _, _.m_flags |= y.e_islandFlag; x > 0;) if (e = u[g++], --x, c.AddBody(e), 0 == e.IsAwake() && e.SetAwake(true), e.GetType() == y.b2_dynamicBody) {
                for (a = e.m_contactList; a && c.m_contactCount != c.m_contactCapacity; a = a.next) if (!(a.contact.m_flags & V.e_islandFlag) && 1 != a.contact.IsSensor() && 0 != a.contact.IsEnabled() && 0 != a.contact.IsTouching()) {
                  c.AddContact(a.contact), a.contact.m_flags |= V.e_islandFlag;
                  var v = a.other;
                  v.m_flags & y.e_islandFlag || (v.GetType() != y.b2_staticBody && (v.Advance(p), v.SetAwake(true)), u[g + x] = v, ++x, v.m_flags |= y.e_islandFlag);
                }
                for (var b = e.m_jointList; b; b = b.next) c.m_jointCount != c.m_jointCapacity && 1 != b.joint.m_islandFlag && 0 != (v = b.other).IsActive() && (c.AddJoint(b.joint), b.joint.m_islandFlag = true, v.m_flags & y.e_islandFlag || (v.GetType() != y.b2_staticBody && (v.Advance(p), v.SetAwake(true)), u[g + x] = v, ++x, v.m_flags |= y.e_islandFlag));
              }
              var w = D.s_timestep;
              w.warmStarting = false, w.dt = (1 - p) * t.dt, w.inv_dt = 1 / w.dt, w.dtRatio = 0, w.velocityIterations = t.velocityIterations, w.positionIterations = t.positionIterations, c.SolveTOI(w);
              var S = 0;
              for (S = 0; S < c.m_bodyCount; ++S) if ((e = c.m_bodies[S]).m_flags &= ~y.e_islandFlag, 0 != e.IsAwake() && e.GetType() == y.b2_dynamicBody) for (e.SynchronizeFixtures(), a = e.m_contactList; a; a = a.next) a.contact.m_flags &= ~V.e_toiFlag;
              for (S = 0; S < c.m_contactCount; ++S) (h = c.m_contacts[S]).m_flags &= ~(V.e_toiFlag | V.e_islandFlag);
              for (S = 0; S < c.m_jointCount; ++S) (l = c.m_joints[S]).m_islandFlag = false;
              this.m_contactManager.FindNewContacts();
            }
          } else r.m_sweep.Set(D.s_backupA), o.m_sweep.Set(D.s_backupB), r.SynchronizeTransform(), o.SynchronizeTransform();
        }
      }, D.prototype.DrawJoint = function (t) {
        var e = t.GetBodyA(), i = t.GetBodyB(), n = e.m_xf, r = i.m_xf, o = n.position, s = r.position, a = t.GetAnchorA(), l = t.GetAnchorB(), c = D.s_jointColor;
        switch (t.m_type) {
          case P.e_distanceJoint:
            this.m_debugDraw.DrawSegment(a, l, c);
            break;
          case P.e_pulleyJoint:
            var h = t instanceof I ? t : null, u = h.GetGroundAnchorA(), m = h.GetGroundAnchorB();
            this.m_debugDraw.DrawSegment(u, a, c), this.m_debugDraw.DrawSegment(m, l, c), this.m_debugDraw.DrawSegment(u, m, c);
            break;
          case P.e_mouseJoint:
            this.m_debugDraw.DrawSegment(a, l, c);
            break;
          default:
            e != this.m_groundBody && this.m_debugDraw.DrawSegment(o, a, c), this.m_debugDraw.DrawSegment(a, l, c), i != this.m_groundBody && this.m_debugDraw.DrawSegment(s, l, c);
        }
      }, D.prototype.DrawShape = function (e, i, n) {
        switch (e.m_type) {
          case _.e_circleShape:
            var r = e instanceof m ? e : null, o = t.MulX(i, r.m_p), s = r.m_radius, a = i.R.col1;
            this.m_debugDraw.DrawSolidCircle(o, s, a, n);
            break;
          case _.e_polygonShape:
            var l = 0, c = e instanceof f ? e : null, h = parseInt(c.GetVertexCount()), u = c.GetVertices(), d = new k(h);
            for (l = 0; l < h; ++l) d[l] = t.MulX(i, u[l]);
            this.m_debugDraw.DrawSolidPolygon(d, h, n);
            break;
          case _.e_edgeShape:
            var y = e instanceof p ? e : null;
            this.m_debugDraw.DrawSegment(t.MulX(i, y.GetVertex1()), t.MulX(i, y.GetVertex2()), n);
        }
      }, e.postDefs.push(function () {
        e.Dynamics.b2World.s_timestep2 = new L, e.Dynamics.b2World.s_xf = new n, e.Dynamics.b2World.s_backupA = new i, e.Dynamics.b2World.s_backupB = new i, e.Dynamics.b2World.s_timestep = new L, e.Dynamics.b2World.s_queue = new k, e.Dynamics.b2World.s_jointColor = new o(0.5, 0.8, 0.8), e.Dynamics.b2World.e_newFixture = 1, e.Dynamics.b2World.e_locked = 2;
      });
    }(), function () {
      var t = e.Collision.Shapes.b2CircleShape, i = (e.Collision.Shapes.b2EdgeChainDef, e.Collision.Shapes.b2EdgeShape), n = (e.Collision.Shapes.b2MassData, e.Collision.Shapes.b2PolygonShape), r = e.Collision.Shapes.b2Shape, o = e.Dynamics.Contacts.b2CircleContact, s = e.Dynamics.Contacts.b2Contact, a = e.Dynamics.Contacts.b2ContactConstraint, l = e.Dynamics.Contacts.b2ContactConstraintPoint, c = e.Dynamics.Contacts.b2ContactEdge, h = e.Dynamics.Contacts.b2ContactFactory, u = e.Dynamics.Contacts.b2ContactRegister, m = e.Dynamics.Contacts.b2ContactResult, p = e.Dynamics.Contacts.b2ContactSolver, d = e.Dynamics.Contacts.b2EdgeAndCircleContact, f = e.Dynamics.Contacts.b2NullContact, _ = e.Dynamics.Contacts.b2PolyAndCircleContact, y = e.Dynamics.Contacts.b2PolyAndEdgeContact, g = e.Dynamics.Contacts.b2PolygonContact, x = e.Dynamics.Contacts.b2PositionSolverManifold, v = e.Dynamics.b2Body, b = (e.Dynamics.b2BodyDef, e.Dynamics.b2ContactFilter, e.Dynamics.b2ContactImpulse, e.Dynamics.b2ContactListener, e.Dynamics.b2ContactManager, e.Dynamics.b2DebugDraw, e.Dynamics.b2DestructionListener, e.Dynamics.b2FilterData, e.Dynamics.b2Fixture, e.Dynamics.b2FixtureDef, e.Dynamics.b2Island, e.Dynamics.b2TimeStep), w = (e.Dynamics.b2World, e.Common.b2Color, e.Common.b2internal, e.Common.b2Settings), S = e.Common.Math.b2Mat22, M = (e.Common.Math.b2Mat33, e.Common.Math.b2Math), C = (e.Common.Math.b2Sweep, e.Common.Math.b2Transform, e.Common.Math.b2Vec2), A = (e.Common.Math.b2Vec3, e.Collision.b2AABB, e.Collision.b2Bound, e.Collision.b2BoundValues, e.Collision.b2Collision), T = e.Collision.b2ContactID, E = (e.Collision.b2ContactPoint, e.Collision.b2Distance, e.Collision.b2DistanceInput, e.Collision.b2DistanceOutput, e.Collision.b2DistanceProxy, e.Collision.b2DynamicTree, e.Collision.b2DynamicTreeBroadPhase, e.Collision.b2DynamicTreeNode, e.Collision.b2DynamicTreePair, e.Collision.b2Manifold), L = (e.Collision.b2ManifoldPoint, e.Collision.b2Point, e.Collision.b2RayCastInput, e.Collision.b2RayCastOutput, e.Collision.b2Segment, e.Collision.b2SeparationFunction, e.Collision.b2Simplex, e.Collision.b2SimplexCache, e.Collision.b2SimplexVertex, e.Collision.b2TimeOfImpact), D = e.Collision.b2TOIInput, V = e.Collision.b2WorldManifold;
      e.Collision.ClipVertex, e.Collision.Features, e.Collision.IBroadPhase;
      e.inherit(o, e.Dynamics.Contacts.b2Contact), o.prototype.__super = e.Dynamics.Contacts.b2Contact.prototype, o.b2CircleContact = function () {
        e.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
      }, o.Create = function (t) {
        return new o;
      }, o.Destroy = function (t, e) {}, o.prototype.Reset = function (t, e) {
        this.__super.Reset.call(this, t, e);
      }, o.prototype.Evaluate = function () {
        var e = this.m_fixtureA.GetBody(), i = this.m_fixtureB.GetBody();
        A.CollideCircles(this.m_manifold, this.m_fixtureA.GetShape() instanceof t ? this.m_fixtureA.GetShape() : null, e.m_xf, this.m_fixtureB.GetShape() instanceof t ? this.m_fixtureB.GetShape() : null, i.m_xf);
      }, s.b2Contact = function () {
        this.m_nodeA = new c, this.m_nodeB = new c, this.m_manifold = new E, this.m_oldManifold = new E;
      }, s.prototype.GetManifold = function () {
        return this.m_manifold;
      }, s.prototype.GetWorldManifold = function (t) {
        var e = this.m_fixtureA.GetBody(), i = this.m_fixtureB.GetBody(), n = this.m_fixtureA.GetShape(), r = this.m_fixtureB.GetShape();
        t.Initialize(this.m_manifold, e.GetTransform(), n.m_radius, i.GetTransform(), r.m_radius);
      }, s.prototype.IsTouching = function () {
        return (this.m_flags & s.e_touchingFlag) == s.e_touchingFlag;
      }, s.prototype.IsContinuous = function () {
        return (this.m_flags & s.e_continuousFlag) == s.e_continuousFlag;
      }, s.prototype.SetSensor = function (t) {
        t ? this.m_flags |= s.e_sensorFlag : this.m_flags &= ~s.e_sensorFlag;
      }, s.prototype.IsSensor = function () {
        return (this.m_flags & s.e_sensorFlag) == s.e_sensorFlag;
      }, s.prototype.SetEnabled = function (t) {
        t ? this.m_flags |= s.e_enabledFlag : this.m_flags &= ~s.e_enabledFlag;
      }, s.prototype.IsEnabled = function () {
        return (this.m_flags & s.e_enabledFlag) == s.e_enabledFlag;
      }, s.prototype.GetNext = function () {
        return this.m_next;
      }, s.prototype.GetFixtureA = function () {
        return this.m_fixtureA;
      }, s.prototype.GetFixtureB = function () {
        return this.m_fixtureB;
      }, s.prototype.FlagForFiltering = function () {
        this.m_flags |= s.e_filterFlag;
      }, s.prototype.b2Contact = function () {}, s.prototype.Reset = function (t, e) {
        if (void 0 === t && (t = null), void 0 === e && (e = null), this.m_flags = s.e_enabledFlag, !t || !e) return this.m_fixtureA = null, void (this.m_fixtureB = null);
        (t.IsSensor() || e.IsSensor()) && (this.m_flags |= s.e_sensorFlag);
        var i = t.GetBody(), n = e.GetBody();
        (i.GetType() != v.b2_dynamicBody || i.IsBullet() || n.GetType() != v.b2_dynamicBody || n.IsBullet()) && (this.m_flags |= s.e_continuousFlag), this.m_fixtureA = t, this.m_fixtureB = e, this.m_manifold.m_pointCount = 0, this.m_prev = null, this.m_next = null, this.m_nodeA.contact = null, this.m_nodeA.prev = null, this.m_nodeA.next = null, this.m_nodeA.other = null, this.m_nodeB.contact = null, this.m_nodeB.prev = null, this.m_nodeB.next = null, this.m_nodeB.other = null;
      }, s.prototype.Update = function (t) {
        var e = this.m_oldManifold;
        this.m_oldManifold = this.m_manifold, this.m_manifold = e, this.m_flags |= s.e_enabledFlag;
        var i = false, n = (this.m_flags & s.e_touchingFlag) == s.e_touchingFlag, o = this.m_fixtureA.m_body, a = this.m_fixtureB.m_body, l = this.m_fixtureA.m_aabb.TestOverlap(this.m_fixtureB.m_aabb);
        if (this.m_flags & s.e_sensorFlag) {
          if (l) {
            var c = this.m_fixtureA.GetShape(), h = this.m_fixtureB.GetShape(), u = o.GetTransform(), m = a.GetTransform();
            i = r.TestOverlap(c, u, h, m);
          }
          this.m_manifold.m_pointCount = 0;
        } else {
          if (o.GetType() != v.b2_dynamicBody || o.IsBullet() || a.GetType() != v.b2_dynamicBody || a.IsBullet() ? this.m_flags |= s.e_continuousFlag : this.m_flags &= ~s.e_continuousFlag, l) {
            this.Evaluate(), i = this.m_manifold.m_pointCount > 0;
            for (var p = 0; p < this.m_manifold.m_pointCount; ++p) {
              var d = this.m_manifold.m_points[p];
              d.m_normalImpulse = 0, d.m_tangentImpulse = 0;
              for (var f = d.m_id, _ = 0; _ < this.m_oldManifold.m_pointCount; ++_) {
                var y = this.m_oldManifold.m_points[_];
                if (y.m_id.key == f.key) {
                  d.m_normalImpulse = y.m_normalImpulse, d.m_tangentImpulse = y.m_tangentImpulse;
                  break;
                }
              }
            }
          } else this.m_manifold.m_pointCount = 0;
          i != n && (o.SetAwake(true), a.SetAwake(true));
        }
        i ? this.m_flags |= s.e_touchingFlag : this.m_flags &= ~s.e_touchingFlag, 0 == n && 1 == i && t.BeginContact(this), 1 == n && 0 == i && t.EndContact(this), 0 == (this.m_flags & s.e_sensorFlag) && t.PreSolve(this, this.m_oldManifold);
      }, s.prototype.Evaluate = function () {}, s.prototype.ComputeTOI = function (t, e) {
        return s.s_input.proxyA.Set(this.m_fixtureA.GetShape()), s.s_input.proxyB.Set(this.m_fixtureB.GetShape()), s.s_input.sweepA = t, s.s_input.sweepB = e, s.s_input.tolerance = w.b2_linearSlop, L.TimeOfImpact(s.s_input);
      }, e.postDefs.push(function () {
        e.Dynamics.Contacts.b2Contact.e_sensorFlag = 1, e.Dynamics.Contacts.b2Contact.e_continuousFlag = 2, e.Dynamics.Contacts.b2Contact.e_islandFlag = 4, e.Dynamics.Contacts.b2Contact.e_toiFlag = 8, e.Dynamics.Contacts.b2Contact.e_touchingFlag = 16, e.Dynamics.Contacts.b2Contact.e_enabledFlag = 32, e.Dynamics.Contacts.b2Contact.e_filterFlag = 64, e.Dynamics.Contacts.b2Contact.s_input = new D;
      }), a.b2ContactConstraint = function () {
        this.localPlaneNormal = new C, this.localPoint = new C, this.normal = new C, this.normalMass = new S, this.K = new S;
      }, a.prototype.b2ContactConstraint = function () {
        this.points = new k(w.b2_maxManifoldPoints);
        for (var t = 0; t < w.b2_maxManifoldPoints; t++) this.points[t] = new l;
      }, l.b2ContactConstraintPoint = function () {
        this.localPoint = new C, this.rA = new C, this.rB = new C;
      }, c.b2ContactEdge = function () {}, h.b2ContactFactory = function () {}, h.prototype.b2ContactFactory = function (t) {
        this.m_allocator = t, this.InitializeRegisters();
      }, h.prototype.AddType = function (t, e, i, n) {
        void 0 === i && (i = 0), void 0 === n && (n = 0), this.m_registers[i][n].createFcn = t, this.m_registers[i][n].destroyFcn = e, this.m_registers[i][n].primary = true, i != n && (this.m_registers[n][i].createFcn = t, this.m_registers[n][i].destroyFcn = e, this.m_registers[n][i].primary = false);
      }, h.prototype.InitializeRegisters = function () {
        this.m_registers = new k(r.e_shapeTypeCount);
        for (var t = 0; t < r.e_shapeTypeCount; t++) {
          this.m_registers[t] = new k(r.e_shapeTypeCount);
          for (var e = 0; e < r.e_shapeTypeCount; e++) this.m_registers[t][e] = new u;
        }
        this.AddType(o.Create, o.Destroy, r.e_circleShape, r.e_circleShape), this.AddType(_.Create, _.Destroy, r.e_polygonShape, r.e_circleShape), this.AddType(g.Create, g.Destroy, r.e_polygonShape, r.e_polygonShape), this.AddType(d.Create, d.Destroy, r.e_edgeShape, r.e_circleShape), this.AddType(y.Create, y.Destroy, r.e_polygonShape, r.e_edgeShape);
      }, h.prototype.Create = function (t, e) {
        var i, n = parseInt(t.GetType()), r = parseInt(e.GetType()), o = this.m_registers[n][r];
        if (o.pool) return i = o.pool, o.pool = i.m_next, o.poolCount--, i.Reset(t, e), i;
        var s = o.createFcn;
        return null != s ? o.primary ? ((i = s(this.m_allocator)).Reset(t, e), i) : ((i = s(this.m_allocator)).Reset(e, t), i) : null;
      }, h.prototype.Destroy = function (t) {
        t.m_manifold.m_pointCount > 0 && (t.m_fixtureA.m_body.SetAwake(true), t.m_fixtureB.m_body.SetAwake(true));
        var e = parseInt(t.m_fixtureA.GetType()), i = parseInt(t.m_fixtureB.GetType()), n = this.m_registers[e][i];
        n.poolCount++, t.m_next = n.pool, n.pool = t, (0, n.destroyFcn)(t, this.m_allocator);
      }, u.b2ContactRegister = function () {}, m.b2ContactResult = function () {
        this.position = new C, this.normal = new C, this.id = new T;
      }, p.b2ContactSolver = function () {
        this.m_step = new b, this.m_constraints = new k;
      }, p.prototype.b2ContactSolver = function () {}, p.prototype.Initialize = function (t, e, i, n) {
        var r;
        void 0 === i && (i = 0), this.m_step.Set(t), this.m_allocator = n;
        var o = 0;
        for (this.m_constraintCount = i; this.m_constraints.length < this.m_constraintCount;) this.m_constraints[this.m_constraints.length] = new a;
        for (o = 0; o < i; ++o) {
          var s = (r = e[o]).m_fixtureA, l = r.m_fixtureB, c = s.m_shape, h = l.m_shape, u = c.m_radius, m = h.m_radius, d = s.m_body, f = l.m_body, _ = r.GetManifold(), y = w.b2MixFriction(s.GetFriction(), l.GetFriction()), g = w.b2MixRestitution(s.GetRestitution(), l.GetRestitution()), x = d.m_linearVelocity.x, v = d.m_linearVelocity.y, b = f.m_linearVelocity.x, S = f.m_linearVelocity.y, M = d.m_angularVelocity, C = f.m_angularVelocity;
          w.b2Assert(_.m_pointCount > 0), p.s_worldManifold.Initialize(_, d.m_xf, u, f.m_xf, m);
          var A = p.s_worldManifold.m_normal.x, T = p.s_worldManifold.m_normal.y, E = this.m_constraints[o];
          E.bodyA = d, E.bodyB = f, E.manifold = _, E.normal.x = A, E.normal.y = T, E.pointCount = _.m_pointCount, E.friction = y, E.restitution = g, E.localPlaneNormal.x = _.m_localPlaneNormal.x, E.localPlaneNormal.y = _.m_localPlaneNormal.y, E.localPoint.x = _.m_localPoint.x, E.localPoint.y = _.m_localPoint.y, E.radius = u + m, E.type = _.m_type;
          for (var L = 0; L < E.pointCount; ++L) {
            var D = _.m_points[L], V = E.points[L];
            V.normalImpulse = D.m_normalImpulse, V.tangentImpulse = D.m_tangentImpulse, V.localPoint.SetV(D.m_localPoint);
            var B = V.rA.x = p.s_worldManifold.m_points[L].x - d.m_sweep.c.x, R = V.rA.y = p.s_worldManifold.m_points[L].y - d.m_sweep.c.y, P = V.rB.x = p.s_worldManifold.m_points[L].x - f.m_sweep.c.x, I = V.rB.y = p.s_worldManifold.m_points[L].y - f.m_sweep.c.y, F = B * T - R * A, G = P * T - I * A;
            F *= F, G *= G;
            var N = d.m_invMass + f.m_invMass + d.m_invI * F + f.m_invI * G;
            V.normalMass = 1 / N;
            var z = d.m_mass * d.m_invMass + f.m_mass * f.m_invMass;
            z += d.m_mass * d.m_invI * F + f.m_mass * f.m_invI * G, V.equalizedMass = 1 / z;
            var O = -A, U = B * O - R * T, k = P * O - I * T;
            U *= U, k *= k;
            var H = d.m_invMass + f.m_invMass + d.m_invI * U + f.m_invI * k;
            V.tangentMass = 1 / H, V.velocityBias = 0;
            var W = b + -C * I - x - -M * R, J = S + C * P - v - M * B, j = E.normal.x * W + E.normal.y * J;
            j < -w.b2_velocityThreshold && (V.velocityBias += -E.restitution * j);
          }
          if (2 == E.pointCount) {
            var X = E.points[0], q = E.points[1], Y = d.m_invMass, Z = d.m_invI, K = f.m_invMass, Q = f.m_invI, $ = X.rA.x * T - X.rA.y * A, tt = X.rB.x * T - X.rB.y * A, et = q.rA.x * T - q.rA.y * A, it = q.rB.x * T - q.rB.y * A, nt = Y + K + Z * $ * $ + Q * tt * tt, rt = Y + K + Z * et * et + Q * it * it, ot = Y + K + Z * $ * et + Q * tt * it;
            nt * nt < 100 * (nt * rt - ot * ot) ? (E.K.col1.Set(nt, ot), E.K.col2.Set(ot, rt), E.K.GetInverse(E.normalMass)) : E.pointCount = 1;
          }
        }
      }, p.prototype.InitVelocityConstraints = function (t) {
        for (var e = 0; e < this.m_constraintCount; ++e) {
          var i = this.m_constraints[e], n = i.bodyA, r = i.bodyB, o = n.m_invMass, s = n.m_invI, a = r.m_invMass, l = r.m_invI, c = i.normal.x, h = i.normal.y, u = h, m = -c, p = 0, d = 0;
          if (t.warmStarting) for (d = i.pointCount, p = 0; p < d; ++p) {
            var f = i.points[p];
            f.normalImpulse *= t.dtRatio, f.tangentImpulse *= t.dtRatio;
            var _ = f.normalImpulse * c + f.tangentImpulse * u, y = f.normalImpulse * h + f.tangentImpulse * m;
            n.m_angularVelocity -= s * (f.rA.x * y - f.rA.y * _), n.m_linearVelocity.x -= o * _, n.m_linearVelocity.y -= o * y, r.m_angularVelocity += l * (f.rB.x * y - f.rB.y * _), r.m_linearVelocity.x += a * _, r.m_linearVelocity.y += a * y;
          } else for (d = i.pointCount, p = 0; p < d; ++p) {
            var g = i.points[p];
            g.normalImpulse = 0, g.tangentImpulse = 0;
          }
        }
      }, p.prototype.SolveVelocityConstraints = function () {
        for (var t, e, i = 0, n = 0, r = 0, o = 0, s = 0, a = 0, l = 0, c = 0, h = 0, u = 0, m = 0, p = 0, d = 0, f = 0, _ = 0; _ < this.m_constraintCount; ++_) {
          var y = this.m_constraints[_], g = y.bodyA, x = y.bodyB, v = g.m_angularVelocity, b = x.m_angularVelocity, w = g.m_linearVelocity, S = x.m_linearVelocity, C = g.m_invMass, A = g.m_invI, T = x.m_invMass, E = x.m_invI, L = y.normal.x, D = y.normal.y, V = D, B = -L, R = y.friction;
          for (i = 0; i < y.pointCount; i++) t = y.points[i], r = (S.x - b * t.rB.y - w.x + v * t.rA.y) * V + (S.y + b * t.rB.x - w.y - v * t.rA.x) * B, o = t.tangentMass * -r, s = R * t.normalImpulse, l = (o = (a = M.Clamp(t.tangentImpulse + o, -s, s)) - t.tangentImpulse) * V, c = o * B, w.x -= C * l, w.y -= C * c, v -= A * (t.rA.x * c - t.rA.y * l), S.x += T * l, S.y += T * c, b += E * (t.rB.x * c - t.rB.y * l), t.tangentImpulse = a;
          parseInt(y.pointCount);
          if (1 == y.pointCount) t = y.points[0], n = (S.x + -b * t.rB.y - w.x - -v * t.rA.y) * L + (S.y + b * t.rB.x - w.y - v * t.rA.x) * D, o = -t.normalMass * (n - t.velocityBias), l = (o = (a = (a = t.normalImpulse + o) > 0 ? a : 0) - t.normalImpulse) * L, c = o * D, w.x -= C * l, w.y -= C * c, v -= A * (t.rA.x * c - t.rA.y * l), S.x += T * l, S.y += T * c, b += E * (t.rB.x * c - t.rB.y * l), t.normalImpulse = a; else {
            var P = y.points[0], I = y.points[1], F = P.normalImpulse, G = I.normalImpulse, N = (S.x - b * P.rB.y - w.x + v * P.rA.y) * L + (S.y + b * P.rB.x - w.y - v * P.rA.x) * D, z = (S.x - b * I.rB.y - w.x + v * I.rA.y) * L + (S.y + b * I.rB.x - w.y - v * I.rA.x) * D, O = N - P.velocityBias, U = z - I.velocityBias;
            O -= (e = y.K).col1.x * F + e.col2.x * G, U -= e.col1.y * F + e.col2.y * G;
            for (;;) {
              var k = -((e = y.normalMass).col1.x * O + e.col2.x * U), H = -(e.col1.y * O + e.col2.y * U);
              if (k >= 0 && H >= 0) {
                m = (h = k - F) * L, p = h * D, d = (u = H - G) * L, f = u * D, w.x -= C * (m + d), w.y -= C * (p + f), v -= A * (P.rA.x * p - P.rA.y * m + I.rA.x * f - I.rA.y * d), S.x += T * (m + d), S.y += T * (p + f), b += E * (P.rB.x * p - P.rB.y * m + I.rB.x * f - I.rB.y * d), P.normalImpulse = k, I.normalImpulse = H;
                break;
              }
              if (k = -P.normalMass * O, H = 0, N = 0, z = y.K.col1.y * k + U, k >= 0 && z >= 0) {
                m = (h = k - F) * L, p = h * D, d = (u = H - G) * L, f = u * D, w.x -= C * (m + d), w.y -= C * (p + f), v -= A * (P.rA.x * p - P.rA.y * m + I.rA.x * f - I.rA.y * d), S.x += T * (m + d), S.y += T * (p + f), b += E * (P.rB.x * p - P.rB.y * m + I.rB.x * f - I.rB.y * d), P.normalImpulse = k, I.normalImpulse = H;
                break;
              }
              if (k = 0, H = -I.normalMass * U, N = y.K.col2.x * H + O, z = 0, H >= 0 && N >= 0) {
                m = (h = k - F) * L, p = h * D, d = (u = H - G) * L, f = u * D, w.x -= C * (m + d), w.y -= C * (p + f), v -= A * (P.rA.x * p - P.rA.y * m + I.rA.x * f - I.rA.y * d), S.x += T * (m + d), S.y += T * (p + f), b += E * (P.rB.x * p - P.rB.y * m + I.rB.x * f - I.rB.y * d), P.normalImpulse = k, I.normalImpulse = H;
                break;
              }
              if (k = 0, H = 0, z = U, (N = O) >= 0 && z >= 0) {
                m = (h = k - F) * L, p = h * D, d = (u = H - G) * L, f = u * D, w.x -= C * (m + d), w.y -= C * (p + f), v -= A * (P.rA.x * p - P.rA.y * m + I.rA.x * f - I.rA.y * d), S.x += T * (m + d), S.y += T * (p + f), b += E * (P.rB.x * p - P.rB.y * m + I.rB.x * f - I.rB.y * d), P.normalImpulse = k, I.normalImpulse = H;
                break;
              }
              break;
            }
          }
          g.m_angularVelocity = v, x.m_angularVelocity = b;
        }
      }, p.prototype.FinalizeVelocityConstraints = function () {
        for (var t = 0; t < this.m_constraintCount; ++t) for (var e = this.m_constraints[t], i = e.manifold, n = 0; n < e.pointCount; ++n) {
          var r = i.m_points[n], o = e.points[n];
          r.m_normalImpulse = o.normalImpulse, r.m_tangentImpulse = o.tangentImpulse;
        }
      }, p.prototype.SolvePositionConstraints = function (t) {
        void 0 === t && (t = 0);
        for (var e = 0, i = 0; i < this.m_constraintCount; i++) {
          var n = this.m_constraints[i], r = n.bodyA, o = n.bodyB, s = r.m_mass * r.m_invMass, a = r.m_mass * r.m_invI, l = o.m_mass * o.m_invMass, c = o.m_mass * o.m_invI;
          p.s_psm.Initialize(n);
          for (var h = p.s_psm.m_normal, u = 0; u < n.pointCount; u++) {
            var m = n.points[u], d = p.s_psm.m_points[u], f = p.s_psm.m_separations[u], _ = d.x - r.m_sweep.c.x, y = d.y - r.m_sweep.c.y, g = d.x - o.m_sweep.c.x, x = d.y - o.m_sweep.c.y;
            e = e < f ? e : f;
            var v = M.Clamp(t * (f + w.b2_linearSlop), -w.b2_maxLinearCorrection, 0), b = -m.equalizedMass * v, S = b * h.x, C = b * h.y;
            r.m_sweep.c.x -= s * S, r.m_sweep.c.y -= s * C, r.m_sweep.a -= a * (_ * C - y * S), r.SynchronizeTransform(), o.m_sweep.c.x += l * S, o.m_sweep.c.y += l * C, o.m_sweep.a += c * (g * C - x * S), o.SynchronizeTransform();
          }
        }
        return e > -1.5 * w.b2_linearSlop;
      }, e.postDefs.push(function () {
        e.Dynamics.Contacts.b2ContactSolver.s_worldManifold = new V, e.Dynamics.Contacts.b2ContactSolver.s_psm = new x;
      }), e.inherit(d, e.Dynamics.Contacts.b2Contact), d.prototype.__super = e.Dynamics.Contacts.b2Contact.prototype, d.b2EdgeAndCircleContact = function () {
        e.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
      }, d.Create = function (t) {
        return new d;
      }, d.Destroy = function (t, e) {}, d.prototype.Reset = function (t, e) {
        this.__super.Reset.call(this, t, e);
      }, d.prototype.Evaluate = function () {
        var e = this.m_fixtureA.GetBody(), n = this.m_fixtureB.GetBody();
        this.b2CollideEdgeAndCircle(this.m_manifold, this.m_fixtureA.GetShape() instanceof i ? this.m_fixtureA.GetShape() : null, e.m_xf, this.m_fixtureB.GetShape() instanceof t ? this.m_fixtureB.GetShape() : null, n.m_xf);
      }, d.prototype.b2CollideEdgeAndCircle = function (t, e, i, n, r) {}, e.inherit(f, e.Dynamics.Contacts.b2Contact), f.prototype.__super = e.Dynamics.Contacts.b2Contact.prototype, f.b2NullContact = function () {
        e.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
      }, f.prototype.b2NullContact = function () {
        this.__super.b2Contact.call(this);
      }, f.prototype.Evaluate = function () {}, e.inherit(_, e.Dynamics.Contacts.b2Contact), _.prototype.__super = e.Dynamics.Contacts.b2Contact.prototype, _.b2PolyAndCircleContact = function () {
        e.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
      }, _.Create = function (t) {
        return new _;
      }, _.Destroy = function (t, e) {}, _.prototype.Reset = function (t, e) {
        this.__super.Reset.call(this, t, e), w.b2Assert(t.GetType() == r.e_polygonShape), w.b2Assert(e.GetType() == r.e_circleShape);
      }, _.prototype.Evaluate = function () {
        var e = this.m_fixtureA.m_body, i = this.m_fixtureB.m_body;
        A.CollidePolygonAndCircle(this.m_manifold, this.m_fixtureA.GetShape() instanceof n ? this.m_fixtureA.GetShape() : null, e.m_xf, this.m_fixtureB.GetShape() instanceof t ? this.m_fixtureB.GetShape() : null, i.m_xf);
      }, e.inherit(y, e.Dynamics.Contacts.b2Contact), y.prototype.__super = e.Dynamics.Contacts.b2Contact.prototype, y.b2PolyAndEdgeContact = function () {
        e.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
      }, y.Create = function (t) {
        return new y;
      }, y.Destroy = function (t, e) {}, y.prototype.Reset = function (t, e) {
        this.__super.Reset.call(this, t, e), w.b2Assert(t.GetType() == r.e_polygonShape), w.b2Assert(e.GetType() == r.e_edgeShape);
      }, y.prototype.Evaluate = function () {
        var t = this.m_fixtureA.GetBody(), e = this.m_fixtureB.GetBody();
        this.b2CollidePolyAndEdge(this.m_manifold, this.m_fixtureA.GetShape() instanceof n ? this.m_fixtureA.GetShape() : null, t.m_xf, this.m_fixtureB.GetShape() instanceof i ? this.m_fixtureB.GetShape() : null, e.m_xf);
      }, y.prototype.b2CollidePolyAndEdge = function (t, e, i, n, r) {}, e.inherit(g, e.Dynamics.Contacts.b2Contact), g.prototype.__super = e.Dynamics.Contacts.b2Contact.prototype, g.b2PolygonContact = function () {
        e.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
      }, g.Create = function (t) {
        return new g;
      }, g.Destroy = function (t, e) {}, g.prototype.Reset = function (t, e) {
        this.__super.Reset.call(this, t, e);
      }, g.prototype.Evaluate = function () {
        var t = this.m_fixtureA.GetBody(), e = this.m_fixtureB.GetBody();
        A.CollidePolygons(this.m_manifold, this.m_fixtureA.GetShape() instanceof n ? this.m_fixtureA.GetShape() : null, t.m_xf, this.m_fixtureB.GetShape() instanceof n ? this.m_fixtureB.GetShape() : null, e.m_xf);
      }, x.b2PositionSolverManifold = function () {}, x.prototype.b2PositionSolverManifold = function () {
        this.m_normal = new C, this.m_separations = new H(w.b2_maxManifoldPoints), this.m_points = new k(w.b2_maxManifoldPoints);
        for (var t = 0; t < w.b2_maxManifoldPoints; t++) this.m_points[t] = new C;
      }, x.prototype.Initialize = function (t) {
        w.b2Assert(t.pointCount > 0);
        var e, i, n = 0, r = 0, o = 0, s = 0, a = 0;
        switch (t.type) {
          case E.e_circles:
            e = t.bodyA.m_xf.R, i = t.localPoint;
            var l = t.bodyA.m_xf.position.x + (e.col1.x * i.x + e.col2.x * i.y), c = t.bodyA.m_xf.position.y + (e.col1.y * i.x + e.col2.y * i.y);
            e = t.bodyB.m_xf.R, i = t.points[0].localPoint;
            var h = t.bodyB.m_xf.position.x + (e.col1.x * i.x + e.col2.x * i.y), u = t.bodyB.m_xf.position.y + (e.col1.y * i.x + e.col2.y * i.y), m = h - l, p = u - c, d = m * m + p * p;
            if (d > Number.MIN_VALUE * Number.MIN_VALUE) {
              var f = Math.sqrt(d);
              this.m_normal.x = m / f, this.m_normal.y = p / f;
            } else this.m_normal.x = 1, this.m_normal.y = 0;
            this.m_points[0].x = 0.5 * (l + h), this.m_points[0].y = 0.5 * (c + u), this.m_separations[0] = m * this.m_normal.x + p * this.m_normal.y - t.radius;
            break;
          case E.e_faceA:
            for (e = t.bodyA.m_xf.R, i = t.localPlaneNormal, this.m_normal.x = e.col1.x * i.x + e.col2.x * i.y, this.m_normal.y = e.col1.y * i.x + e.col2.y * i.y, e = t.bodyA.m_xf.R, i = t.localPoint, s = t.bodyA.m_xf.position.x + (e.col1.x * i.x + e.col2.x * i.y), a = t.bodyA.m_xf.position.y + (e.col1.y * i.x + e.col2.y * i.y), e = t.bodyB.m_xf.R, n = 0; n < t.pointCount; ++n) i = t.points[n].localPoint, r = t.bodyB.m_xf.position.x + (e.col1.x * i.x + e.col2.x * i.y), o = t.bodyB.m_xf.position.y + (e.col1.y * i.x + e.col2.y * i.y), this.m_separations[n] = (r - s) * this.m_normal.x + (o - a) * this.m_normal.y - t.radius, this.m_points[n].x = r, this.m_points[n].y = o;
            break;
          case E.e_faceB:
            for (e = t.bodyB.m_xf.R, i = t.localPlaneNormal, this.m_normal.x = e.col1.x * i.x + e.col2.x * i.y, this.m_normal.y = e.col1.y * i.x + e.col2.y * i.y, e = t.bodyB.m_xf.R, i = t.localPoint, s = t.bodyB.m_xf.position.x + (e.col1.x * i.x + e.col2.x * i.y), a = t.bodyB.m_xf.position.y + (e.col1.y * i.x + e.col2.y * i.y), e = t.bodyA.m_xf.R, n = 0; n < t.pointCount; ++n) i = t.points[n].localPoint, r = t.bodyA.m_xf.position.x + (e.col1.x * i.x + e.col2.x * i.y), o = t.bodyA.m_xf.position.y + (e.col1.y * i.x + e.col2.y * i.y), this.m_separations[n] = (r - s) * this.m_normal.x + (o - a) * this.m_normal.y - t.radius, this.m_points[n].Set(r, o);
            this.m_normal.x *= -1, this.m_normal.y *= -1;
        }
      }, e.postDefs.push(function () {
        e.Dynamics.Contacts.b2PositionSolverManifold.circlePointA = new C, e.Dynamics.Contacts.b2PositionSolverManifold.circlePointB = new C;
      });
    }(), function () {
      e.Dynamics.b2Body, e.Dynamics.b2BodyDef, e.Dynamics.b2ContactFilter, e.Dynamics.b2ContactImpulse, e.Dynamics.b2ContactListener, e.Dynamics.b2ContactManager, e.Dynamics.b2DebugDraw, e.Dynamics.b2DestructionListener, e.Dynamics.b2FilterData, e.Dynamics.b2Fixture, e.Dynamics.b2FixtureDef, e.Dynamics.b2Island, e.Dynamics.b2TimeStep, e.Dynamics.b2World;
      var t = e.Common.Math.b2Mat22, i = (e.Common.Math.b2Mat33, e.Common.Math.b2Math), n = (e.Common.Math.b2Sweep, e.Common.Math.b2Transform, e.Common.Math.b2Vec2), r = (e.Common.Math.b2Vec3, e.Common.b2Color), o = (e.Common.b2internal, e.Common.b2Settings, e.Collision.Shapes.b2CircleShape, e.Collision.Shapes.b2EdgeChainDef, e.Collision.Shapes.b2EdgeShape, e.Collision.Shapes.b2MassData, e.Collision.Shapes.b2PolygonShape, e.Collision.Shapes.b2Shape, e.Dynamics.Controllers.b2BuoyancyController), s = e.Dynamics.Controllers.b2ConstantAccelController, a = e.Dynamics.Controllers.b2ConstantForceController, l = e.Dynamics.Controllers.b2Controller, c = e.Dynamics.Controllers.b2ControllerEdge, h = e.Dynamics.Controllers.b2GravityController, u = e.Dynamics.Controllers.b2TensorDampingController;
      e.inherit(o, e.Dynamics.Controllers.b2Controller), o.prototype.__super = e.Dynamics.Controllers.b2Controller.prototype, o.b2BuoyancyController = function () {
        e.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments), this.normal = new n(0, -1), this.offset = 0, this.density = 0, this.velocity = new n(0, 0), this.linearDrag = 2, this.angularDrag = 1, this.useDensity = false, this.useWorldGravity = true, this.gravity = null;
      }, o.prototype.Step = function (t) {
        if (this.m_bodyList) {
          this.useWorldGravity && (this.gravity = this.GetWorld().GetGravity().Copy());
          for (var e = this.m_bodyList; e; e = e.nextBody) {
            var i = e.body;
            if (0 != i.IsAwake()) {
              for (var r = new n, o = new n, s = 0, a = 0, l = i.GetFixtureList(); l; l = l.GetNext()) {
                var c = new n, h = l.GetShape().ComputeSubmergedArea(this.normal, this.offset, i.GetTransform(), c);
                s += h, r.x += h * c.x, r.y += h * c.y;
                var u = 0;
                a += h * (u = (this.useDensity, 1)), o.x += h * c.x * u, o.y += h * c.y * u;
              }
              if (r.x /= s, r.y /= s, o.x /= a, o.y /= a, !(s < Number.MIN_VALUE)) {
                var m = this.gravity.GetNegative();
                m.Multiply(this.density * s), i.ApplyForce(m, o);
                var p = i.GetLinearVelocityFromWorldPoint(r);
                p.Subtract(this.velocity), p.Multiply(-this.linearDrag * s), i.ApplyForce(p, r), i.ApplyTorque(-i.GetInertia() / i.GetMass() * s * i.GetAngularVelocity() * this.angularDrag);
              }
            }
          }
        }
      }, o.prototype.Draw = function (t) {
        var e = 1e3, i = new n, o = new n;
        i.x = this.normal.x * this.offset + this.normal.y * e, i.y = this.normal.y * this.offset - this.normal.x * e, o.x = this.normal.x * this.offset - this.normal.y * e, o.y = this.normal.y * this.offset + this.normal.x * e;
        var s = new r(0, 0, 1);
        t.DrawSegment(i, o, s);
      }, e.inherit(s, e.Dynamics.Controllers.b2Controller), s.prototype.__super = e.Dynamics.Controllers.b2Controller.prototype, s.b2ConstantAccelController = function () {
        e.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments), this.A = new n(0, 0);
      }, s.prototype.Step = function (t) {
        for (var e = new n(this.A.x * t.dt, this.A.y * t.dt), i = this.m_bodyList; i; i = i.nextBody) {
          var r = i.body;
          r.IsAwake() && r.SetLinearVelocity(new n(r.GetLinearVelocity().x + e.x, r.GetLinearVelocity().y + e.y));
        }
      }, e.inherit(a, e.Dynamics.Controllers.b2Controller), a.prototype.__super = e.Dynamics.Controllers.b2Controller.prototype, a.b2ConstantForceController = function () {
        e.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments), this.F = new n(0, 0);
      }, a.prototype.Step = function (t) {
        for (var e = this.m_bodyList; e; e = e.nextBody) {
          var i = e.body;
          i.IsAwake() && i.ApplyForce(this.F, i.GetWorldCenter());
        }
      }, l.b2Controller = function () {}, l.prototype.Step = function (t) {}, l.prototype.Draw = function (t) {}, l.prototype.AddBody = function (t) {
        var e = new c;
        e.controller = this, e.body = t, e.nextBody = this.m_bodyList, e.prevBody = null, this.m_bodyList = e, e.nextBody && (e.nextBody.prevBody = e), this.m_bodyCount++, e.nextController = t.m_controllerList, e.prevController = null, t.m_controllerList = e, e.nextController && (e.nextController.prevController = e), t.m_controllerCount++;
      }, l.prototype.RemoveBody = function (t) {
        for (var e = t.m_controllerList; e && e.controller != this;) e = e.nextController;
        e.prevBody && (e.prevBody.nextBody = e.nextBody), e.nextBody && (e.nextBody.prevBody = e.prevBody), e.nextController && (e.nextController.prevController = e.prevController), e.prevController && (e.prevController.nextController = e.nextController), this.m_bodyList == e && (this.m_bodyList = e.nextBody), t.m_controllerList == e && (t.m_controllerList = e.nextController), t.m_controllerCount--, this.m_bodyCount--;
      }, l.prototype.Clear = function () {
        for (; this.m_bodyList;) this.RemoveBody(this.m_bodyList.body);
      }, l.prototype.GetNext = function () {
        return this.m_next;
      }, l.prototype.GetWorld = function () {
        return this.m_world;
      }, l.prototype.GetBodyList = function () {
        return this.m_bodyList;
      }, c.b2ControllerEdge = function () {}, e.inherit(h, e.Dynamics.Controllers.b2Controller), h.prototype.__super = e.Dynamics.Controllers.b2Controller.prototype, h.b2GravityController = function () {
        e.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments), this.G = 1, this.invSqr = true;
      }, h.prototype.Step = function (t) {
        var e = null, i = null, r = null, o = 0, s = null, a = null, l = null, c = 0, h = 0, u = 0, m = null;
        if (this.invSqr) for (e = this.m_bodyList; e; e = e.nextBody) for (r = (i = e.body).GetWorldCenter(), o = i.GetMass(), s = this.m_bodyList; s != e; s = s.nextBody) (u = (c = (l = (a = s.body).GetWorldCenter()).x - r.x) * c + (h = l.y - r.y) * h) < Number.MIN_VALUE || ((m = new n(c, h)).Multiply(this.G / u / Math.sqrt(u) * o * a.GetMass()), i.IsAwake() && i.ApplyForce(m, r), m.Multiply(-1), a.IsAwake() && a.ApplyForce(m, l)); else for (e = this.m_bodyList; e; e = e.nextBody) for (r = (i = e.body).GetWorldCenter(), o = i.GetMass(), s = this.m_bodyList; s != e; s = s.nextBody) (u = (c = (l = (a = s.body).GetWorldCenter()).x - r.x) * c + (h = l.y - r.y) * h) < Number.MIN_VALUE || ((m = new n(c, h)).Multiply(this.G / u * o * a.GetMass()), i.IsAwake() && i.ApplyForce(m, r), m.Multiply(-1), a.IsAwake() && a.ApplyForce(m, l));
      }, e.inherit(u, e.Dynamics.Controllers.b2Controller), u.prototype.__super = e.Dynamics.Controllers.b2Controller.prototype, u.b2TensorDampingController = function () {
        e.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments), this.T = new t, this.maxTimestep = 0;
      }, u.prototype.SetAxisAligned = function (t, e) {
        void 0 === t && (t = 0), void 0 === e && (e = 0), this.T.col1.x = -t, this.T.col1.y = 0, this.T.col2.x = 0, this.T.col2.y = -e, this.maxTimestep = t > 0 || e > 0 ? 1 / Math.max(t, e) : 0;
      }, u.prototype.Step = function (t) {
        var e = t.dt;
        if (!(e <= Number.MIN_VALUE)) {
          e > this.maxTimestep && this.maxTimestep > 0 && (e = this.maxTimestep);
          for (var r = this.m_bodyList; r; r = r.nextBody) {
            var o = r.body;
            if (o.IsAwake()) {
              var s = o.GetWorldVector(i.MulMV(this.T, o.GetLocalVector(o.GetLinearVelocity())));
              o.SetLinearVelocity(new n(o.GetLinearVelocity().x + s.x * e, o.GetLinearVelocity().y + s.y * e));
            }
          }
        }
      };
    }(), function () {
      e.Common.b2Color, e.Common.b2internal;
      var t = e.Common.b2Settings, i = e.Common.Math.b2Mat22, n = e.Common.Math.b2Mat33, r = e.Common.Math.b2Math, o = (e.Common.Math.b2Sweep, e.Common.Math.b2Transform, e.Common.Math.b2Vec2), s = e.Common.Math.b2Vec3, a = e.Dynamics.Joints.b2DistanceJoint, l = e.Dynamics.Joints.b2DistanceJointDef, c = e.Dynamics.Joints.b2FrictionJoint, h = e.Dynamics.Joints.b2FrictionJointDef, u = e.Dynamics.Joints.b2GearJoint, m = e.Dynamics.Joints.b2GearJointDef, p = e.Dynamics.Joints.b2Jacobian, d = e.Dynamics.Joints.b2Joint, f = e.Dynamics.Joints.b2JointDef, _ = e.Dynamics.Joints.b2JointEdge, y = e.Dynamics.Joints.b2LineJoint, g = e.Dynamics.Joints.b2LineJointDef, x = e.Dynamics.Joints.b2MouseJoint, v = e.Dynamics.Joints.b2MouseJointDef, b = e.Dynamics.Joints.b2PrismaticJoint, w = e.Dynamics.Joints.b2PrismaticJointDef, S = e.Dynamics.Joints.b2PulleyJoint, M = e.Dynamics.Joints.b2PulleyJointDef, C = e.Dynamics.Joints.b2RevoluteJoint, A = e.Dynamics.Joints.b2RevoluteJointDef, T = e.Dynamics.Joints.b2WeldJoint, E = e.Dynamics.Joints.b2WeldJointDef;
      e.Dynamics.b2Body, e.Dynamics.b2BodyDef, e.Dynamics.b2ContactFilter, e.Dynamics.b2ContactImpulse, e.Dynamics.b2ContactListener, e.Dynamics.b2ContactManager, e.Dynamics.b2DebugDraw, e.Dynamics.b2DestructionListener, e.Dynamics.b2FilterData, e.Dynamics.b2Fixture, e.Dynamics.b2FixtureDef, e.Dynamics.b2Island, e.Dynamics.b2TimeStep, e.Dynamics.b2World;
      e.inherit(a, e.Dynamics.Joints.b2Joint), a.prototype.__super = e.Dynamics.Joints.b2Joint.prototype, a.b2DistanceJoint = function () {
        e.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments), this.m_localAnchor1 = new o, this.m_localAnchor2 = new o, this.m_u = new o;
      }, a.prototype.GetAnchorA = function () {
        return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
      }, a.prototype.GetAnchorB = function () {
        return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
      }, a.prototype.GetReactionForce = function (t) {
        return void 0 === t && (t = 0), new o(t * this.m_impulse * this.m_u.x, t * this.m_impulse * this.m_u.y);
      }, a.prototype.GetReactionTorque = function (t) {
        return void 0 === t && (t = 0), 0;
      }, a.prototype.GetLength = function () {
        return this.m_length;
      }, a.prototype.SetLength = function (t) {
        void 0 === t && (t = 0), this.m_length = t;
      }, a.prototype.GetFrequency = function () {
        return this.m_frequencyHz;
      }, a.prototype.SetFrequency = function (t) {
        void 0 === t && (t = 0), this.m_frequencyHz = t;
      }, a.prototype.GetDampingRatio = function () {
        return this.m_dampingRatio;
      }, a.prototype.SetDampingRatio = function (t) {
        void 0 === t && (t = 0), this.m_dampingRatio = t;
      }, a.prototype.b2DistanceJoint = function (t) {
        this.__super.b2Joint.call(this, t);
        this.m_localAnchor1.SetV(t.localAnchorA), this.m_localAnchor2.SetV(t.localAnchorB), this.m_length = t.length, this.m_frequencyHz = t.frequencyHz, this.m_dampingRatio = t.dampingRatio, this.m_impulse = 0, this.m_gamma = 0, this.m_bias = 0;
      }, a.prototype.InitVelocityConstraints = function (e) {
        var i, n = 0, r = this.m_bodyA, o = this.m_bodyB;
        i = r.m_xf.R;
        var s = this.m_localAnchor1.x - r.m_sweep.localCenter.x, a = this.m_localAnchor1.y - r.m_sweep.localCenter.y;
        n = i.col1.x * s + i.col2.x * a, a = i.col1.y * s + i.col2.y * a, s = n, i = o.m_xf.R;
        var l = this.m_localAnchor2.x - o.m_sweep.localCenter.x, c = this.m_localAnchor2.y - o.m_sweep.localCenter.y;
        n = i.col1.x * l + i.col2.x * c, c = i.col1.y * l + i.col2.y * c, l = n, this.m_u.x = o.m_sweep.c.x + l - r.m_sweep.c.x - s, this.m_u.y = o.m_sweep.c.y + c - r.m_sweep.c.y - a;
        var h = Math.sqrt(this.m_u.x * this.m_u.x + this.m_u.y * this.m_u.y);
        h > t.b2_linearSlop ? this.m_u.Multiply(1 / h) : this.m_u.SetZero();
        var u = s * this.m_u.y - a * this.m_u.x, m = l * this.m_u.y - c * this.m_u.x, p = r.m_invMass + r.m_invI * u * u + o.m_invMass + o.m_invI * m * m;
        if (this.m_mass = 0 != p ? 1 / p : 0, this.m_frequencyHz > 0) {
          var d = h - this.m_length, f = 2 * Math.PI * this.m_frequencyHz, _ = 2 * this.m_mass * this.m_dampingRatio * f, y = this.m_mass * f * f;
          this.m_gamma = e.dt * (_ + e.dt * y), this.m_gamma = 0 != this.m_gamma ? 1 / this.m_gamma : 0, this.m_bias = d * e.dt * y * this.m_gamma, this.m_mass = p + this.m_gamma, this.m_mass = 0 != this.m_mass ? 1 / this.m_mass : 0;
        }
        if (e.warmStarting) {
          this.m_impulse *= e.dtRatio;
          var g = this.m_impulse * this.m_u.x, x = this.m_impulse * this.m_u.y;
          r.m_linearVelocity.x -= r.m_invMass * g, r.m_linearVelocity.y -= r.m_invMass * x, r.m_angularVelocity -= r.m_invI * (s * x - a * g), o.m_linearVelocity.x += o.m_invMass * g, o.m_linearVelocity.y += o.m_invMass * x, o.m_angularVelocity += o.m_invI * (l * x - c * g);
        } else this.m_impulse = 0;
      }, a.prototype.SolveVelocityConstraints = function (t) {
        var e, i = this.m_bodyA, n = this.m_bodyB;
        e = i.m_xf.R;
        var r = this.m_localAnchor1.x - i.m_sweep.localCenter.x, o = this.m_localAnchor1.y - i.m_sweep.localCenter.y, s = e.col1.x * r + e.col2.x * o;
        o = e.col1.y * r + e.col2.y * o, r = s, e = n.m_xf.R;
        var a = this.m_localAnchor2.x - n.m_sweep.localCenter.x, l = this.m_localAnchor2.y - n.m_sweep.localCenter.y;
        s = e.col1.x * a + e.col2.x * l, l = e.col1.y * a + e.col2.y * l, a = s;
        var c = i.m_linearVelocity.x + -i.m_angularVelocity * o, h = i.m_linearVelocity.y + i.m_angularVelocity * r, u = n.m_linearVelocity.x + -n.m_angularVelocity * l, m = n.m_linearVelocity.y + n.m_angularVelocity * a, p = this.m_u.x * (u - c) + this.m_u.y * (m - h), d = -this.m_mass * (p + this.m_bias + this.m_gamma * this.m_impulse);
        this.m_impulse += d;
        var f = d * this.m_u.x, _ = d * this.m_u.y;
        i.m_linearVelocity.x -= i.m_invMass * f, i.m_linearVelocity.y -= i.m_invMass * _, i.m_angularVelocity -= i.m_invI * (r * _ - o * f), n.m_linearVelocity.x += n.m_invMass * f, n.m_linearVelocity.y += n.m_invMass * _, n.m_angularVelocity += n.m_invI * (a * _ - l * f);
      }, a.prototype.SolvePositionConstraints = function (e) {
        var i;
        if (void 0 === e && (e = 0), this.m_frequencyHz > 0) return true;
        var n = this.m_bodyA, o = this.m_bodyB;
        i = n.m_xf.R;
        var s = this.m_localAnchor1.x - n.m_sweep.localCenter.x, a = this.m_localAnchor1.y - n.m_sweep.localCenter.y, l = i.col1.x * s + i.col2.x * a;
        a = i.col1.y * s + i.col2.y * a, s = l, i = o.m_xf.R;
        var c = this.m_localAnchor2.x - o.m_sweep.localCenter.x, h = this.m_localAnchor2.y - o.m_sweep.localCenter.y;
        l = i.col1.x * c + i.col2.x * h, h = i.col1.y * c + i.col2.y * h, c = l;
        var u = o.m_sweep.c.x + c - n.m_sweep.c.x - s, m = o.m_sweep.c.y + h - n.m_sweep.c.y - a, p = Math.sqrt(u * u + m * m);
        u /= p, m /= p;
        var d = p - this.m_length;
        d = r.Clamp(d, -t.b2_maxLinearCorrection, t.b2_maxLinearCorrection);
        var f = -this.m_mass * d;
        this.m_u.Set(u, m);
        var _ = f * this.m_u.x, y = f * this.m_u.y;
        return n.m_sweep.c.x -= n.m_invMass * _, n.m_sweep.c.y -= n.m_invMass * y, n.m_sweep.a -= n.m_invI * (s * y - a * _), o.m_sweep.c.x += o.m_invMass * _, o.m_sweep.c.y += o.m_invMass * y, o.m_sweep.a += o.m_invI * (c * y - h * _), n.SynchronizeTransform(), o.SynchronizeTransform(), r.Abs(d) < t.b2_linearSlop;
      }, e.inherit(l, e.Dynamics.Joints.b2JointDef), l.prototype.__super = e.Dynamics.Joints.b2JointDef.prototype, l.b2DistanceJointDef = function () {
        e.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments), this.localAnchorA = new o, this.localAnchorB = new o;
      }, l.prototype.b2DistanceJointDef = function () {
        this.__super.b2JointDef.call(this), this.type = d.e_distanceJoint, this.length = 1, this.frequencyHz = 0, this.dampingRatio = 0;
      }, l.prototype.Initialize = function (t, e, i, n) {
        this.bodyA = t, this.bodyB = e, this.localAnchorA.SetV(this.bodyA.GetLocalPoint(i)), this.localAnchorB.SetV(this.bodyB.GetLocalPoint(n));
        var r = n.x - i.x, o = n.y - i.y;
        this.length = Math.sqrt(r * r + o * o), this.frequencyHz = 0, this.dampingRatio = 0;
      }, e.inherit(c, e.Dynamics.Joints.b2Joint), c.prototype.__super = e.Dynamics.Joints.b2Joint.prototype, c.b2FrictionJoint = function () {
        e.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments), this.m_localAnchorA = new o, this.m_localAnchorB = new o, this.m_linearMass = new i, this.m_linearImpulse = new o;
      }, c.prototype.GetAnchorA = function () {
        return this.m_bodyA.GetWorldPoint(this.m_localAnchorA);
      }, c.prototype.GetAnchorB = function () {
        return this.m_bodyB.GetWorldPoint(this.m_localAnchorB);
      }, c.prototype.GetReactionForce = function (t) {
        return void 0 === t && (t = 0), new o(t * this.m_linearImpulse.x, t * this.m_linearImpulse.y);
      }, c.prototype.GetReactionTorque = function (t) {
        return void 0 === t && (t = 0), t * this.m_angularImpulse;
      }, c.prototype.SetMaxForce = function (t) {
        void 0 === t && (t = 0), this.m_maxForce = t;
      }, c.prototype.GetMaxForce = function () {
        return this.m_maxForce;
      }, c.prototype.SetMaxTorque = function (t) {
        void 0 === t && (t = 0), this.m_maxTorque = t;
      }, c.prototype.GetMaxTorque = function () {
        return this.m_maxTorque;
      }, c.prototype.b2FrictionJoint = function (t) {
        this.__super.b2Joint.call(this, t), this.m_localAnchorA.SetV(t.localAnchorA), this.m_localAnchorB.SetV(t.localAnchorB), this.m_linearMass.SetZero(), this.m_angularMass = 0, this.m_linearImpulse.SetZero(), this.m_angularImpulse = 0, this.m_maxForce = t.maxForce, this.m_maxTorque = t.maxTorque;
      }, c.prototype.InitVelocityConstraints = function (t) {
        var e, n = 0, r = this.m_bodyA, o = this.m_bodyB;
        e = r.m_xf.R;
        var s = this.m_localAnchorA.x - r.m_sweep.localCenter.x, a = this.m_localAnchorA.y - r.m_sweep.localCenter.y;
        n = e.col1.x * s + e.col2.x * a, a = e.col1.y * s + e.col2.y * a, s = n, e = o.m_xf.R;
        var l = this.m_localAnchorB.x - o.m_sweep.localCenter.x, c = this.m_localAnchorB.y - o.m_sweep.localCenter.y;
        n = e.col1.x * l + e.col2.x * c, c = e.col1.y * l + e.col2.y * c, l = n;
        var h = r.m_invMass, u = o.m_invMass, m = r.m_invI, p = o.m_invI, d = new i;
        if (d.col1.x = h + u, d.col2.x = 0, d.col1.y = 0, d.col2.y = h + u, d.col1.x += m * a * a, d.col2.x += -m * s * a, d.col1.y += -m * s * a, d.col2.y += m * s * s, d.col1.x += p * c * c, d.col2.x += -p * l * c, d.col1.y += -p * l * c, d.col2.y += p * l * l, d.GetInverse(this.m_linearMass), this.m_angularMass = m + p, this.m_angularMass > 0 && (this.m_angularMass = 1 / this.m_angularMass), t.warmStarting) {
          this.m_linearImpulse.x *= t.dtRatio, this.m_linearImpulse.y *= t.dtRatio, this.m_angularImpulse *= t.dtRatio;
          var f = this.m_linearImpulse;
          r.m_linearVelocity.x -= h * f.x, r.m_linearVelocity.y -= h * f.y, r.m_angularVelocity -= m * (s * f.y - a * f.x + this.m_angularImpulse), o.m_linearVelocity.x += u * f.x, o.m_linearVelocity.y += u * f.y, o.m_angularVelocity += p * (l * f.y - c * f.x + this.m_angularImpulse);
        } else this.m_linearImpulse.SetZero(), this.m_angularImpulse = 0;
      }, c.prototype.SolveVelocityConstraints = function (t) {
        var e, i = 0, n = this.m_bodyA, s = this.m_bodyB, a = n.m_linearVelocity, l = n.m_angularVelocity, c = s.m_linearVelocity, h = s.m_angularVelocity, u = n.m_invMass, m = s.m_invMass, p = n.m_invI, d = s.m_invI;
        e = n.m_xf.R;
        var f = this.m_localAnchorA.x - n.m_sweep.localCenter.x, _ = this.m_localAnchorA.y - n.m_sweep.localCenter.y;
        i = e.col1.x * f + e.col2.x * _, _ = e.col1.y * f + e.col2.y * _, f = i, e = s.m_xf.R;
        var y = this.m_localAnchorB.x - s.m_sweep.localCenter.x, g = this.m_localAnchorB.y - s.m_sweep.localCenter.y;
        i = e.col1.x * y + e.col2.x * g, g = e.col1.y * y + e.col2.y * g, y = i;
        var x = 0, v = h - l, b = -this.m_angularMass * v, w = this.m_angularImpulse;
        x = t.dt * this.m_maxTorque, this.m_angularImpulse = r.Clamp(this.m_angularImpulse + b, -x, x), l -= p * (b = this.m_angularImpulse - w), h += d * b;
        var S = c.x - h * g - a.x + l * _, M = c.y + h * y - a.y - l * f, C = r.MulMV(this.m_linearMass, new o(-S, -M)), A = this.m_linearImpulse.Copy();
        this.m_linearImpulse.Add(C), x = t.dt * this.m_maxForce, this.m_linearImpulse.LengthSquared() > x * x && (this.m_linearImpulse.Normalize(), this.m_linearImpulse.Multiply(x)), C = r.SubtractVV(this.m_linearImpulse, A), a.x -= u * C.x, a.y -= u * C.y, l -= p * (f * C.y - _ * C.x), c.x += m * C.x, c.y += m * C.y, h += d * (y * C.y - g * C.x), n.m_angularVelocity = l, s.m_angularVelocity = h;
      }, c.prototype.SolvePositionConstraints = function (t) {
        return void 0 === t && (t = 0), true;
      }, e.inherit(h, e.Dynamics.Joints.b2JointDef), h.prototype.__super = e.Dynamics.Joints.b2JointDef.prototype, h.b2FrictionJointDef = function () {
        e.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments), this.localAnchorA = new o, this.localAnchorB = new o;
      }, h.prototype.b2FrictionJointDef = function () {
        this.__super.b2JointDef.call(this), this.type = d.e_frictionJoint, this.maxForce = 0, this.maxTorque = 0;
      }, h.prototype.Initialize = function (t, e, i) {
        this.bodyA = t, this.bodyB = e, this.localAnchorA.SetV(this.bodyA.GetLocalPoint(i)), this.localAnchorB.SetV(this.bodyB.GetLocalPoint(i));
      }, e.inherit(u, e.Dynamics.Joints.b2Joint), u.prototype.__super = e.Dynamics.Joints.b2Joint.prototype, u.b2GearJoint = function () {
        e.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments), this.m_groundAnchor1 = new o, this.m_groundAnchor2 = new o, this.m_localAnchor1 = new o, this.m_localAnchor2 = new o, this.m_J = new p;
      }, u.prototype.GetAnchorA = function () {
        return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
      }, u.prototype.GetAnchorB = function () {
        return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
      }, u.prototype.GetReactionForce = function (t) {
        return void 0 === t && (t = 0), new o(t * this.m_impulse * this.m_J.linearB.x, t * this.m_impulse * this.m_J.linearB.y);
      }, u.prototype.GetReactionTorque = function (t) {
        void 0 === t && (t = 0);
        var e = this.m_bodyB.m_xf.R, i = this.m_localAnchor1.x - this.m_bodyB.m_sweep.localCenter.x, n = this.m_localAnchor1.y - this.m_bodyB.m_sweep.localCenter.y, r = e.col1.x * i + e.col2.x * n;
        n = e.col1.y * i + e.col2.y * n, i = r;
        var o = this.m_impulse * this.m_J.linearB.x, s = this.m_impulse * this.m_J.linearB.y;
        return t * (this.m_impulse * this.m_J.angularB - i * s + n * o);
      }, u.prototype.GetRatio = function () {
        return this.m_ratio;
      }, u.prototype.SetRatio = function (t) {
        void 0 === t && (t = 0), this.m_ratio = t;
      }, u.prototype.b2GearJoint = function (t) {
        this.__super.b2Joint.call(this, t);
        var e = parseInt(t.joint1.m_type), i = parseInt(t.joint2.m_type);
        this.m_revolute1 = null, this.m_prismatic1 = null, this.m_revolute2 = null, this.m_prismatic2 = null;
        var n = 0, r = 0;
        this.m_ground1 = t.joint1.GetBodyA(), this.m_bodyA = t.joint1.GetBodyB(), e == d.e_revoluteJoint ? (this.m_revolute1 = t.joint1 instanceof C ? t.joint1 : null, this.m_groundAnchor1.SetV(this.m_revolute1.m_localAnchor1), this.m_localAnchor1.SetV(this.m_revolute1.m_localAnchor2), n = this.m_revolute1.GetJointAngle()) : (this.m_prismatic1 = t.joint1 instanceof b ? t.joint1 : null, this.m_groundAnchor1.SetV(this.m_prismatic1.m_localAnchor1), this.m_localAnchor1.SetV(this.m_prismatic1.m_localAnchor2), n = this.m_prismatic1.GetJointTranslation()), this.m_ground2 = t.joint2.GetBodyA(), this.m_bodyB = t.joint2.GetBodyB(), i == d.e_revoluteJoint ? (this.m_revolute2 = t.joint2 instanceof C ? t.joint2 : null, this.m_groundAnchor2.SetV(this.m_revolute2.m_localAnchor1), this.m_localAnchor2.SetV(this.m_revolute2.m_localAnchor2), r = this.m_revolute2.GetJointAngle()) : (this.m_prismatic2 = t.joint2 instanceof b ? t.joint2 : null, this.m_groundAnchor2.SetV(this.m_prismatic2.m_localAnchor1), this.m_localAnchor2.SetV(this.m_prismatic2.m_localAnchor2), r = this.m_prismatic2.GetJointTranslation()), this.m_ratio = t.ratio, this.m_constant = n + this.m_ratio * r, this.m_impulse = 0;
      }, u.prototype.InitVelocityConstraints = function (t) {
        var e, i, n = this.m_ground1, r = this.m_ground2, o = this.m_bodyA, s = this.m_bodyB, a = 0, l = 0, c = 0, h = 0, u = 0, m = 0, p = 0;
        this.m_J.SetZero(), this.m_revolute1 ? (this.m_J.angularA = -1, p += o.m_invI) : (e = n.m_xf.R, i = this.m_prismatic1.m_localXAxis1, a = e.col1.x * i.x + e.col2.x * i.y, l = e.col1.y * i.x + e.col2.y * i.y, e = o.m_xf.R, c = this.m_localAnchor1.x - o.m_sweep.localCenter.x, h = this.m_localAnchor1.y - o.m_sweep.localCenter.y, m = e.col1.x * c + e.col2.x * h, h = e.col1.y * c + e.col2.y * h, u = (c = m) * l - h * a, this.m_J.linearA.Set(-a, -l), this.m_J.angularA = -u, p += o.m_invMass + o.m_invI * u * u), this.m_revolute2 ? (this.m_J.angularB = -this.m_ratio, p += this.m_ratio * this.m_ratio * s.m_invI) : (e = r.m_xf.R, i = this.m_prismatic2.m_localXAxis1, a = e.col1.x * i.x + e.col2.x * i.y, l = e.col1.y * i.x + e.col2.y * i.y, e = s.m_xf.R, c = this.m_localAnchor2.x - s.m_sweep.localCenter.x, h = this.m_localAnchor2.y - s.m_sweep.localCenter.y, m = e.col1.x * c + e.col2.x * h, h = e.col1.y * c + e.col2.y * h, u = (c = m) * l - h * a, this.m_J.linearB.Set(-this.m_ratio * a, -this.m_ratio * l), this.m_J.angularB = -this.m_ratio * u, p += this.m_ratio * this.m_ratio * (s.m_invMass + s.m_invI * u * u)), this.m_mass = p > 0 ? 1 / p : 0, t.warmStarting ? (o.m_linearVelocity.x += o.m_invMass * this.m_impulse * this.m_J.linearA.x, o.m_linearVelocity.y += o.m_invMass * this.m_impulse * this.m_J.linearA.y, o.m_angularVelocity += o.m_invI * this.m_impulse * this.m_J.angularA, s.m_linearVelocity.x += s.m_invMass * this.m_impulse * this.m_J.linearB.x, s.m_linearVelocity.y += s.m_invMass * this.m_impulse * this.m_J.linearB.y, s.m_angularVelocity += s.m_invI * this.m_impulse * this.m_J.angularB) : this.m_impulse = 0;
      }, u.prototype.SolveVelocityConstraints = function (t) {
        var e = this.m_bodyA, i = this.m_bodyB, n = this.m_J.Compute(e.m_linearVelocity, e.m_angularVelocity, i.m_linearVelocity, i.m_angularVelocity), r = -this.m_mass * n;
        this.m_impulse += r, e.m_linearVelocity.x += e.m_invMass * r * this.m_J.linearA.x, e.m_linearVelocity.y += e.m_invMass * r * this.m_J.linearA.y, e.m_angularVelocity += e.m_invI * r * this.m_J.angularA, i.m_linearVelocity.x += i.m_invMass * r * this.m_J.linearB.x, i.m_linearVelocity.y += i.m_invMass * r * this.m_J.linearB.y, i.m_angularVelocity += i.m_invI * r * this.m_J.angularB;
      }, u.prototype.SolvePositionConstraints = function (e) {
        void 0 === e && (e = 0);
        var i = this.m_bodyA, n = this.m_bodyB, r = 0, o = 0;
        r = this.m_revolute1 ? this.m_revolute1.GetJointAngle() : this.m_prismatic1.GetJointTranslation(), o = this.m_revolute2 ? this.m_revolute2.GetJointAngle() : this.m_prismatic2.GetJointTranslation();
        var s = this.m_constant - (r + this.m_ratio * o), a = -this.m_mass * s;
        return i.m_sweep.c.x += i.m_invMass * a * this.m_J.linearA.x, i.m_sweep.c.y += i.m_invMass * a * this.m_J.linearA.y, i.m_sweep.a += i.m_invI * a * this.m_J.angularA, n.m_sweep.c.x += n.m_invMass * a * this.m_J.linearB.x, n.m_sweep.c.y += n.m_invMass * a * this.m_J.linearB.y, n.m_sweep.a += n.m_invI * a * this.m_J.angularB, i.SynchronizeTransform(), n.SynchronizeTransform(), 0 < t.b2_linearSlop;
      }, e.inherit(m, e.Dynamics.Joints.b2JointDef), m.prototype.__super = e.Dynamics.Joints.b2JointDef.prototype, m.b2GearJointDef = function () {
        e.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
      }, m.prototype.b2GearJointDef = function () {
        this.__super.b2JointDef.call(this), this.type = d.e_gearJoint, this.joint1 = null, this.joint2 = null, this.ratio = 1;
      }, p.b2Jacobian = function () {
        this.linearA = new o, this.linearB = new o;
      }, p.prototype.SetZero = function () {
        this.linearA.SetZero(), this.angularA = 0, this.linearB.SetZero(), this.angularB = 0;
      }, p.prototype.Set = function (t, e, i, n) {
        void 0 === e && (e = 0), void 0 === n && (n = 0), this.linearA.SetV(t), this.angularA = e, this.linearB.SetV(i), this.angularB = n;
      }, p.prototype.Compute = function (t, e, i, n) {
        return void 0 === e && (e = 0), void 0 === n && (n = 0), this.linearA.x * t.x + this.linearA.y * t.y + this.angularA * e + (this.linearB.x * i.x + this.linearB.y * i.y) + this.angularB * n;
      }, d.b2Joint = function () {
        this.m_edgeA = new _, this.m_edgeB = new _, this.m_localCenterA = new o, this.m_localCenterB = new o;
      }, d.prototype.GetType = function () {
        return this.m_type;
      }, d.prototype.GetAnchorA = function () {
        return null;
      }, d.prototype.GetAnchorB = function () {
        return null;
      }, d.prototype.GetReactionForce = function (t) {
        return void 0 === t && (t = 0), null;
      }, d.prototype.GetReactionTorque = function (t) {
        return void 0 === t && (t = 0), 0;
      }, d.prototype.GetBodyA = function () {
        return this.m_bodyA;
      }, d.prototype.GetBodyB = function () {
        return this.m_bodyB;
      }, d.prototype.GetNext = function () {
        return this.m_next;
      }, d.prototype.GetUserData = function () {
        return this.m_userData;
      }, d.prototype.SetUserData = function (t) {
        this.m_userData = t;
      }, d.prototype.IsActive = function () {
        return this.m_bodyA.IsActive() && this.m_bodyB.IsActive();
      }, d.Create = function (t, e) {
        var i = null;
        switch (t.type) {
          case d.e_distanceJoint:
            i = new a(t instanceof l ? t : null);
            break;
          case d.e_mouseJoint:
            i = new x(t instanceof v ? t : null);
            break;
          case d.e_prismaticJoint:
            i = new b(t instanceof w ? t : null);
            break;
          case d.e_revoluteJoint:
            i = new C(t instanceof A ? t : null);
            break;
          case d.e_pulleyJoint:
            i = new S(t instanceof M ? t : null);
            break;
          case d.e_gearJoint:
            i = new u(t instanceof m ? t : null);
            break;
          case d.e_lineJoint:
            i = new y(t instanceof g ? t : null);
            break;
          case d.e_weldJoint:
            i = new T(t instanceof E ? t : null);
            break;
          case d.e_frictionJoint:
            i = new c(t instanceof h ? t : null);
        }
        return i;
      }, d.Destroy = function (t, e) {}, d.prototype.b2Joint = function (e) {
        t.b2Assert(e.bodyA != e.bodyB), this.m_type = e.type, this.m_prev = null, this.m_next = null, this.m_bodyA = e.bodyA, this.m_bodyB = e.bodyB, this.m_collideConnected = e.collideConnected, this.m_islandFlag = false, this.m_userData = e.userData;
      }, d.prototype.InitVelocityConstraints = function (t) {}, d.prototype.SolveVelocityConstraints = function (t) {}, d.prototype.FinalizeVelocityConstraints = function () {}, d.prototype.SolvePositionConstraints = function (t) {
        return void 0 === t && (t = 0), false;
      }, e.postDefs.push(function () {
        e.Dynamics.Joints.b2Joint.e_unknownJoint = 0, e.Dynamics.Joints.b2Joint.e_revoluteJoint = 1, e.Dynamics.Joints.b2Joint.e_prismaticJoint = 2, e.Dynamics.Joints.b2Joint.e_distanceJoint = 3, e.Dynamics.Joints.b2Joint.e_pulleyJoint = 4, e.Dynamics.Joints.b2Joint.e_mouseJoint = 5, e.Dynamics.Joints.b2Joint.e_gearJoint = 6, e.Dynamics.Joints.b2Joint.e_lineJoint = 7, e.Dynamics.Joints.b2Joint.e_weldJoint = 8, e.Dynamics.Joints.b2Joint.e_frictionJoint = 9, e.Dynamics.Joints.b2Joint.e_inactiveLimit = 0, e.Dynamics.Joints.b2Joint.e_atLowerLimit = 1, e.Dynamics.Joints.b2Joint.e_atUpperLimit = 2, e.Dynamics.Joints.b2Joint.e_equalLimits = 3;
      }), f.b2JointDef = function () {}, f.prototype.b2JointDef = function () {
        this.type = d.e_unknownJoint, this.userData = null, this.bodyA = null, this.bodyB = null, this.collideConnected = false;
      }, _.b2JointEdge = function () {}, e.inherit(y, e.Dynamics.Joints.b2Joint), y.prototype.__super = e.Dynamics.Joints.b2Joint.prototype, y.b2LineJoint = function () {
        e.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments), this.m_localAnchor1 = new o, this.m_localAnchor2 = new o, this.m_localXAxis1 = new o, this.m_localYAxis1 = new o, this.m_axis = new o, this.m_perp = new o, this.m_K = new i, this.m_impulse = new o;
      }, y.prototype.GetAnchorA = function () {
        return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
      }, y.prototype.GetAnchorB = function () {
        return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
      }, y.prototype.GetReactionForce = function (t) {
        return void 0 === t && (t = 0), new o(t * (this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.x), t * (this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.y));
      }, y.prototype.GetReactionTorque = function (t) {
        return void 0 === t && (t = 0), t * this.m_impulse.y;
      }, y.prototype.GetJointTranslation = function () {
        var t = this.m_bodyA, e = this.m_bodyB, i = t.GetWorldPoint(this.m_localAnchor1), n = e.GetWorldPoint(this.m_localAnchor2), r = n.x - i.x, o = n.y - i.y, s = t.GetWorldVector(this.m_localXAxis1);
        return s.x * r + s.y * o;
      }, y.prototype.GetJointSpeed = function () {
        var t, e = this.m_bodyA, i = this.m_bodyB;
        t = e.m_xf.R;
        var n = this.m_localAnchor1.x - e.m_sweep.localCenter.x, r = this.m_localAnchor1.y - e.m_sweep.localCenter.y, o = t.col1.x * n + t.col2.x * r;
        r = t.col1.y * n + t.col2.y * r, n = o, t = i.m_xf.R;
        var s = this.m_localAnchor2.x - i.m_sweep.localCenter.x, a = this.m_localAnchor2.y - i.m_sweep.localCenter.y;
        o = t.col1.x * s + t.col2.x * a, a = t.col1.y * s + t.col2.y * a, s = o;
        var l = e.m_sweep.c.x + n, c = e.m_sweep.c.y + r, h = i.m_sweep.c.x + s - l, u = i.m_sweep.c.y + a - c, m = e.GetWorldVector(this.m_localXAxis1), p = e.m_linearVelocity, d = i.m_linearVelocity, f = e.m_angularVelocity, _ = i.m_angularVelocity;
        return h * (-f * m.y) + u * (f * m.x) + (m.x * (d.x + -_ * a - p.x - -f * r) + m.y * (d.y + _ * s - p.y - f * n));
      }, y.prototype.IsLimitEnabled = function () {
        return this.m_enableLimit;
      }, y.prototype.EnableLimit = function (t) {
        this.m_bodyA.SetAwake(true), this.m_bodyB.SetAwake(true), this.m_enableLimit = t;
      }, y.prototype.GetLowerLimit = function () {
        return this.m_lowerTranslation;
      }, y.prototype.GetUpperLimit = function () {
        return this.m_upperTranslation;
      }, y.prototype.SetLimits = function (t, e) {
        void 0 === t && (t = 0), void 0 === e && (e = 0), this.m_bodyA.SetAwake(true), this.m_bodyB.SetAwake(true), this.m_lowerTranslation = t, this.m_upperTranslation = e;
      }, y.prototype.IsMotorEnabled = function () {
        return this.m_enableMotor;
      }, y.prototype.EnableMotor = function (t) {
        this.m_bodyA.SetAwake(true), this.m_bodyB.SetAwake(true), this.m_enableMotor = t;
      }, y.prototype.SetMotorSpeed = function (t) {
        void 0 === t && (t = 0), this.m_bodyA.SetAwake(true), this.m_bodyB.SetAwake(true), this.m_motorSpeed = t;
      }, y.prototype.GetMotorSpeed = function () {
        return this.m_motorSpeed;
      }, y.prototype.SetMaxMotorForce = function (t) {
        void 0 === t && (t = 0), this.m_bodyA.SetAwake(true), this.m_bodyB.SetAwake(true), this.m_maxMotorForce = t;
      }, y.prototype.GetMaxMotorForce = function () {
        return this.m_maxMotorForce;
      }, y.prototype.GetMotorForce = function () {
        return this.m_motorImpulse;
      }, y.prototype.b2LineJoint = function (t) {
        this.__super.b2Joint.call(this, t);
        this.m_localAnchor1.SetV(t.localAnchorA), this.m_localAnchor2.SetV(t.localAnchorB), this.m_localXAxis1.SetV(t.localAxisA), this.m_localYAxis1.x = -this.m_localXAxis1.y, this.m_localYAxis1.y = this.m_localXAxis1.x, this.m_impulse.SetZero(), this.m_motorMass = 0, this.m_motorImpulse = 0, this.m_lowerTranslation = t.lowerTranslation, this.m_upperTranslation = t.upperTranslation, this.m_maxMotorForce = t.maxMotorForce, this.m_motorSpeed = t.motorSpeed, this.m_enableLimit = t.enableLimit, this.m_enableMotor = t.enableMotor, this.m_limitState = d.e_inactiveLimit, this.m_axis.SetZero(), this.m_perp.SetZero();
      }, y.prototype.InitVelocityConstraints = function (e) {
        var i, n = this.m_bodyA, o = this.m_bodyB, s = 0;
        this.m_localCenterA.SetV(n.GetLocalCenter()), this.m_localCenterB.SetV(o.GetLocalCenter());
        var a = n.GetTransform();
        o.GetTransform();
        i = n.m_xf.R;
        var l = this.m_localAnchor1.x - this.m_localCenterA.x, c = this.m_localAnchor1.y - this.m_localCenterA.y;
        s = i.col1.x * l + i.col2.x * c, c = i.col1.y * l + i.col2.y * c, l = s, i = o.m_xf.R;
        var h = this.m_localAnchor2.x - this.m_localCenterB.x, u = this.m_localAnchor2.y - this.m_localCenterB.y;
        s = i.col1.x * h + i.col2.x * u, u = i.col1.y * h + i.col2.y * u, h = s;
        var m = o.m_sweep.c.x + h - n.m_sweep.c.x - l, p = o.m_sweep.c.y + u - n.m_sweep.c.y - c;
        this.m_invMassA = n.m_invMass, this.m_invMassB = o.m_invMass, this.m_invIA = n.m_invI, this.m_invIB = o.m_invI, this.m_axis.SetV(r.MulMV(a.R, this.m_localXAxis1)), this.m_a1 = (m + l) * this.m_axis.y - (p + c) * this.m_axis.x, this.m_a2 = h * this.m_axis.y - u * this.m_axis.x, this.m_motorMass = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_a1 * this.m_a1 + this.m_invIB * this.m_a2 * this.m_a2, this.m_motorMass = this.m_motorMass > Number.MIN_VALUE ? 1 / this.m_motorMass : 0, this.m_perp.SetV(r.MulMV(a.R, this.m_localYAxis1)), this.m_s1 = (m + l) * this.m_perp.y - (p + c) * this.m_perp.x, this.m_s2 = h * this.m_perp.y - u * this.m_perp.x;
        var f = this.m_invMassA, _ = this.m_invMassB, y = this.m_invIA, g = this.m_invIB;
        if (this.m_K.col1.x = f + _ + y * this.m_s1 * this.m_s1 + g * this.m_s2 * this.m_s2, this.m_K.col1.y = y * this.m_s1 * this.m_a1 + g * this.m_s2 * this.m_a2, this.m_K.col2.x = this.m_K.col1.y, this.m_K.col2.y = f + _ + y * this.m_a1 * this.m_a1 + g * this.m_a2 * this.m_a2, this.m_enableLimit) {
          var x = this.m_axis.x * m + this.m_axis.y * p;
          r.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * t.b2_linearSlop ? this.m_limitState = d.e_equalLimits : x <= this.m_lowerTranslation ? this.m_limitState != d.e_atLowerLimit && (this.m_limitState = d.e_atLowerLimit, this.m_impulse.y = 0) : x >= this.m_upperTranslation ? this.m_limitState != d.e_atUpperLimit && (this.m_limitState = d.e_atUpperLimit, this.m_impulse.y = 0) : (this.m_limitState = d.e_inactiveLimit, this.m_impulse.y = 0);
        } else this.m_limitState = d.e_inactiveLimit;
        if (0 == this.m_enableMotor && (this.m_motorImpulse = 0), e.warmStarting) {
          this.m_impulse.x *= e.dtRatio, this.m_impulse.y *= e.dtRatio, this.m_motorImpulse *= e.dtRatio;
          var v = this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.x, b = this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.y, w = this.m_impulse.x * this.m_s1 + (this.m_motorImpulse + this.m_impulse.y) * this.m_a1, S = this.m_impulse.x * this.m_s2 + (this.m_motorImpulse + this.m_impulse.y) * this.m_a2;
          n.m_linearVelocity.x -= this.m_invMassA * v, n.m_linearVelocity.y -= this.m_invMassA * b, n.m_angularVelocity -= this.m_invIA * w, o.m_linearVelocity.x += this.m_invMassB * v, o.m_linearVelocity.y += this.m_invMassB * b, o.m_angularVelocity += this.m_invIB * S;
        } else this.m_impulse.SetZero(), this.m_motorImpulse = 0;
      }, y.prototype.SolveVelocityConstraints = function (t) {
        var e = this.m_bodyA, i = this.m_bodyB, n = e.m_linearVelocity, s = e.m_angularVelocity, a = i.m_linearVelocity, l = i.m_angularVelocity, c = 0, h = 0, u = 0, m = 0;
        if (this.m_enableMotor && this.m_limitState != d.e_equalLimits) {
          var p = this.m_axis.x * (a.x - n.x) + this.m_axis.y * (a.y - n.y) + this.m_a2 * l - this.m_a1 * s, f = this.m_motorMass * (this.m_motorSpeed - p), _ = this.m_motorImpulse, y = t.dt * this.m_maxMotorForce;
          this.m_motorImpulse = r.Clamp(this.m_motorImpulse + f, -y, y), c = (f = this.m_motorImpulse - _) * this.m_axis.x, h = f * this.m_axis.y, u = f * this.m_a1, m = f * this.m_a2, n.x -= this.m_invMassA * c, n.y -= this.m_invMassA * h, s -= this.m_invIA * u, a.x += this.m_invMassB * c, a.y += this.m_invMassB * h, l += this.m_invIB * m;
        }
        var g = this.m_perp.x * (a.x - n.x) + this.m_perp.y * (a.y - n.y) + this.m_s2 * l - this.m_s1 * s;
        if (this.m_enableLimit && this.m_limitState != d.e_inactiveLimit) {
          var x = this.m_axis.x * (a.x - n.x) + this.m_axis.y * (a.y - n.y) + this.m_a2 * l - this.m_a1 * s, v = this.m_impulse.Copy(), b = this.m_K.Solve(new o, -g, -x);
          this.m_impulse.Add(b), this.m_limitState == d.e_atLowerLimit ? this.m_impulse.y = r.Max(this.m_impulse.y, 0) : this.m_limitState == d.e_atUpperLimit && (this.m_impulse.y = r.Min(this.m_impulse.y, 0));
          var w = -g - (this.m_impulse.y - v.y) * this.m_K.col2.x, S = 0;
          S = 0 != this.m_K.col1.x ? w / this.m_K.col1.x + v.x : v.x, this.m_impulse.x = S, b.x = this.m_impulse.x - v.x, b.y = this.m_impulse.y - v.y, c = b.x * this.m_perp.x + b.y * this.m_axis.x, h = b.x * this.m_perp.y + b.y * this.m_axis.y, u = b.x * this.m_s1 + b.y * this.m_a1, m = b.x * this.m_s2 + b.y * this.m_a2, n.x -= this.m_invMassA * c, n.y -= this.m_invMassA * h, s -= this.m_invIA * u, a.x += this.m_invMassB * c, a.y += this.m_invMassB * h, l += this.m_invIB * m;
        } else {
          var M = 0;
          M = 0 != this.m_K.col1.x ? -g / this.m_K.col1.x : 0, this.m_impulse.x += M, c = M * this.m_perp.x, h = M * this.m_perp.y, u = M * this.m_s1, m = M * this.m_s2, n.x -= this.m_invMassA * c, n.y -= this.m_invMassA * h, s -= this.m_invIA * u, a.x += this.m_invMassB * c, a.y += this.m_invMassB * h, l += this.m_invIB * m;
        }
        e.m_linearVelocity.SetV(n), e.m_angularVelocity = s, i.m_linearVelocity.SetV(a), i.m_angularVelocity = l;
      }, y.prototype.SolvePositionConstraints = function (e) {
        void 0 === e && (e = 0);
        var n, s = this.m_bodyA, a = this.m_bodyB, l = s.m_sweep.c, c = s.m_sweep.a, h = a.m_sweep.c, u = a.m_sweep.a, m = 0, p = 0, d = 0, f = 0, _ = 0, y = 0, g = false, x = 0, v = i.FromAngle(c), b = i.FromAngle(u);
        n = v;
        var w = this.m_localAnchor1.x - this.m_localCenterA.x, S = this.m_localAnchor1.y - this.m_localCenterA.y;
        m = n.col1.x * w + n.col2.x * S, S = n.col1.y * w + n.col2.y * S, w = m, n = b;
        var M = this.m_localAnchor2.x - this.m_localCenterB.x, C = this.m_localAnchor2.y - this.m_localCenterB.y;
        m = n.col1.x * M + n.col2.x * C, C = n.col1.y * M + n.col2.y * C, M = m;
        var A = h.x + M - l.x - w, T = h.y + C - l.y - S;
        if (this.m_enableLimit) {
          this.m_axis = r.MulMV(v, this.m_localXAxis1), this.m_a1 = (A + w) * this.m_axis.y - (T + S) * this.m_axis.x, this.m_a2 = M * this.m_axis.y - C * this.m_axis.x;
          var E = this.m_axis.x * A + this.m_axis.y * T;
          r.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * t.b2_linearSlop ? (x = r.Clamp(E, -t.b2_maxLinearCorrection, t.b2_maxLinearCorrection), y = r.Abs(E), g = true) : E <= this.m_lowerTranslation ? (x = r.Clamp(E - this.m_lowerTranslation + t.b2_linearSlop, -t.b2_maxLinearCorrection, 0), y = this.m_lowerTranslation - E, g = true) : E >= this.m_upperTranslation && (x = r.Clamp(E - this.m_upperTranslation + t.b2_linearSlop, 0, t.b2_maxLinearCorrection), y = E - this.m_upperTranslation, g = true);
        }
        this.m_perp = r.MulMV(v, this.m_localYAxis1), this.m_s1 = (A + w) * this.m_perp.y - (T + S) * this.m_perp.x, this.m_s2 = M * this.m_perp.y - C * this.m_perp.x;
        var L = new o, D = this.m_perp.x * A + this.m_perp.y * T;
        if (y = r.Max(y, r.Abs(D)), 0, g) p = this.m_invMassA, d = this.m_invMassB, f = this.m_invIA, _ = this.m_invIB, this.m_K.col1.x = p + d + f * this.m_s1 * this.m_s1 + _ * this.m_s2 * this.m_s2, this.m_K.col1.y = f * this.m_s1 * this.m_a1 + _ * this.m_s2 * this.m_a2, this.m_K.col2.x = this.m_K.col1.y, this.m_K.col2.y = p + d + f * this.m_a1 * this.m_a1 + _ * this.m_a2 * this.m_a2, this.m_K.Solve(L, -D, -x); else {
          p = this.m_invMassA, d = this.m_invMassB, f = this.m_invIA, _ = this.m_invIB;
          var V = p + d + f * this.m_s1 * this.m_s1 + _ * this.m_s2 * this.m_s2, B = 0;
          B = 0 != V ? -D / V : 0, L.x = B, L.y = 0;
        }
        var R = L.x * this.m_perp.x + L.y * this.m_axis.x, P = L.x * this.m_perp.y + L.y * this.m_axis.y, I = L.x * this.m_s1 + L.y * this.m_a1, F = L.x * this.m_s2 + L.y * this.m_a2;
        return l.x -= this.m_invMassA * R, l.y -= this.m_invMassA * P, c -= this.m_invIA * I, h.x += this.m_invMassB * R, h.y += this.m_invMassB * P, u += this.m_invIB * F, s.m_sweep.a = c, a.m_sweep.a = u, s.SynchronizeTransform(), a.SynchronizeTransform(), y <= t.b2_linearSlop && 0 <= t.b2_angularSlop;
      }, e.inherit(g, e.Dynamics.Joints.b2JointDef), g.prototype.__super = e.Dynamics.Joints.b2JointDef.prototype, g.b2LineJointDef = function () {
        e.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments), this.localAnchorA = new o, this.localAnchorB = new o, this.localAxisA = new o;
      }, g.prototype.b2LineJointDef = function () {
        this.__super.b2JointDef.call(this), this.type = d.e_lineJoint, this.localAxisA.Set(1, 0), this.enableLimit = false, this.lowerTranslation = 0, this.upperTranslation = 0, this.enableMotor = false, this.maxMotorForce = 0, this.motorSpeed = 0;
      }, g.prototype.Initialize = function (t, e, i, n) {
        this.bodyA = t, this.bodyB = e, this.localAnchorA = this.bodyA.GetLocalPoint(i), this.localAnchorB = this.bodyB.GetLocalPoint(i), this.localAxisA = this.bodyA.GetLocalVector(n);
      }, e.inherit(x, e.Dynamics.Joints.b2Joint), x.prototype.__super = e.Dynamics.Joints.b2Joint.prototype, x.b2MouseJoint = function () {
        e.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments), this.K = new i, this.K1 = new i, this.K2 = new i, this.m_localAnchor = new o, this.m_target = new o, this.m_impulse = new o, this.m_mass = new i, this.m_C = new o;
      }, x.prototype.GetAnchorA = function () {
        return this.m_target;
      }, x.prototype.GetAnchorB = function () {
        return this.m_bodyB.GetWorldPoint(this.m_localAnchor);
      }, x.prototype.GetReactionForce = function (t) {
        return void 0 === t && (t = 0), new o(t * this.m_impulse.x, t * this.m_impulse.y);
      }, x.prototype.GetReactionTorque = function (t) {
        return void 0 === t && (t = 0), 0;
      }, x.prototype.GetTarget = function () {
        return this.m_target;
      }, x.prototype.SetTarget = function (t) {
        0 == this.m_bodyB.IsAwake() && this.m_bodyB.SetAwake(true), this.m_target = t;
      }, x.prototype.GetMaxForce = function () {
        return this.m_maxForce;
      }, x.prototype.SetMaxForce = function (t) {
        void 0 === t && (t = 0), this.m_maxForce = t;
      }, x.prototype.GetFrequency = function () {
        return this.m_frequencyHz;
      }, x.prototype.SetFrequency = function (t) {
        void 0 === t && (t = 0), this.m_frequencyHz = t;
      }, x.prototype.GetDampingRatio = function () {
        return this.m_dampingRatio;
      }, x.prototype.SetDampingRatio = function (t) {
        void 0 === t && (t = 0), this.m_dampingRatio = t;
      }, x.prototype.b2MouseJoint = function (t) {
        this.__super.b2Joint.call(this, t), this.m_target.SetV(t.target);
        var e = this.m_target.x - this.m_bodyB.m_xf.position.x, i = this.m_target.y - this.m_bodyB.m_xf.position.y, n = this.m_bodyB.m_xf.R;
        this.m_localAnchor.x = e * n.col1.x + i * n.col1.y, this.m_localAnchor.y = e * n.col2.x + i * n.col2.y, this.m_maxForce = t.maxForce, this.m_impulse.SetZero(), this.m_frequencyHz = t.frequencyHz, this.m_dampingRatio = t.dampingRatio, this.m_beta = 0, this.m_gamma = 0;
      }, x.prototype.InitVelocityConstraints = function (t) {
        var e, i = this.m_bodyB, n = i.GetMass(), r = 2 * Math.PI * this.m_frequencyHz, o = 2 * n * this.m_dampingRatio * r, s = n * r * r;
        this.m_gamma = t.dt * (o + t.dt * s), this.m_gamma = 0 != this.m_gamma ? 1 / this.m_gamma : 0, this.m_beta = t.dt * s * this.m_gamma, e = i.m_xf.R;
        var a = this.m_localAnchor.x - i.m_sweep.localCenter.x, l = this.m_localAnchor.y - i.m_sweep.localCenter.y, c = e.col1.x * a + e.col2.x * l;
        l = e.col1.y * a + e.col2.y * l, a = c;
        var h = i.m_invMass, u = i.m_invI;
        this.K1.col1.x = h, this.K1.col2.x = 0, this.K1.col1.y = 0, this.K1.col2.y = h, this.K2.col1.x = u * l * l, this.K2.col2.x = -u * a * l, this.K2.col1.y = -u * a * l, this.K2.col2.y = u * a * a, this.K.SetM(this.K1), this.K.AddM(this.K2), this.K.col1.x += this.m_gamma, this.K.col2.y += this.m_gamma, this.K.GetInverse(this.m_mass), this.m_C.x = i.m_sweep.c.x + a - this.m_target.x, this.m_C.y = i.m_sweep.c.y + l - this.m_target.y, i.m_angularVelocity *= 0.98, this.m_impulse.x *= t.dtRatio, this.m_impulse.y *= t.dtRatio, i.m_linearVelocity.x += h * this.m_impulse.x, i.m_linearVelocity.y += h * this.m_impulse.y, i.m_angularVelocity += u * (a * this.m_impulse.y - l * this.m_impulse.x);
      }, x.prototype.SolveVelocityConstraints = function (t) {
        var e, i, n = this.m_bodyB, r = 0;
        e = n.m_xf.R;
        var o = this.m_localAnchor.x - n.m_sweep.localCenter.x, s = this.m_localAnchor.y - n.m_sweep.localCenter.y;
        r = e.col1.x * o + e.col2.x * s, s = e.col1.y * o + e.col2.y * s, o = r;
        var a = n.m_linearVelocity.x + -n.m_angularVelocity * s, l = n.m_linearVelocity.y + n.m_angularVelocity * o;
        e = this.m_mass, r = a + this.m_beta * this.m_C.x + this.m_gamma * this.m_impulse.x, i = l + this.m_beta * this.m_C.y + this.m_gamma * this.m_impulse.y;
        var c = -(e.col1.x * r + e.col2.x * i), h = -(e.col1.y * r + e.col2.y * i), u = this.m_impulse.x, m = this.m_impulse.y;
        this.m_impulse.x += c, this.m_impulse.y += h;
        var p = t.dt * this.m_maxForce;
        this.m_impulse.LengthSquared() > p * p && this.m_impulse.Multiply(p / this.m_impulse.Length()), c = this.m_impulse.x - u, h = this.m_impulse.y - m, n.m_linearVelocity.x += n.m_invMass * c, n.m_linearVelocity.y += n.m_invMass * h, n.m_angularVelocity += n.m_invI * (o * h - s * c);
      }, x.prototype.SolvePositionConstraints = function (t) {
        return void 0 === t && (t = 0), true;
      }, e.inherit(v, e.Dynamics.Joints.b2JointDef), v.prototype.__super = e.Dynamics.Joints.b2JointDef.prototype, v.b2MouseJointDef = function () {
        e.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments), this.target = new o;
      }, v.prototype.b2MouseJointDef = function () {
        this.__super.b2JointDef.call(this), this.type = d.e_mouseJoint, this.maxForce = 0, this.frequencyHz = 5, this.dampingRatio = 0.7;
      }, e.inherit(b, e.Dynamics.Joints.b2Joint), b.prototype.__super = e.Dynamics.Joints.b2Joint.prototype, b.b2PrismaticJoint = function () {
        e.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments), this.m_localAnchor1 = new o, this.m_localAnchor2 = new o, this.m_localXAxis1 = new o, this.m_localYAxis1 = new o, this.m_axis = new o, this.m_perp = new o, this.m_K = new n, this.m_impulse = new s;
      }, b.prototype.GetAnchorA = function () {
        return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
      }, b.prototype.GetAnchorB = function () {
        return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
      }, b.prototype.GetReactionForce = function (t) {
        return void 0 === t && (t = 0), new o(t * (this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.x), t * (this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.y));
      }, b.prototype.GetReactionTorque = function (t) {
        return void 0 === t && (t = 0), t * this.m_impulse.y;
      }, b.prototype.GetJointTranslation = function () {
        var t = this.m_bodyA, e = this.m_bodyB, i = t.GetWorldPoint(this.m_localAnchor1), n = e.GetWorldPoint(this.m_localAnchor2), r = n.x - i.x, o = n.y - i.y, s = t.GetWorldVector(this.m_localXAxis1);
        return s.x * r + s.y * o;
      }, b.prototype.GetJointSpeed = function () {
        var t, e = this.m_bodyA, i = this.m_bodyB;
        t = e.m_xf.R;
        var n = this.m_localAnchor1.x - e.m_sweep.localCenter.x, r = this.m_localAnchor1.y - e.m_sweep.localCenter.y, o = t.col1.x * n + t.col2.x * r;
        r = t.col1.y * n + t.col2.y * r, n = o, t = i.m_xf.R;
        var s = this.m_localAnchor2.x - i.m_sweep.localCenter.x, a = this.m_localAnchor2.y - i.m_sweep.localCenter.y;
        o = t.col1.x * s + t.col2.x * a, a = t.col1.y * s + t.col2.y * a, s = o;
        var l = e.m_sweep.c.x + n, c = e.m_sweep.c.y + r, h = i.m_sweep.c.x + s - l, u = i.m_sweep.c.y + a - c, m = e.GetWorldVector(this.m_localXAxis1), p = e.m_linearVelocity, d = i.m_linearVelocity, f = e.m_angularVelocity, _ = i.m_angularVelocity;
        return h * (-f * m.y) + u * (f * m.x) + (m.x * (d.x + -_ * a - p.x - -f * r) + m.y * (d.y + _ * s - p.y - f * n));
      }, b.prototype.IsLimitEnabled = function () {
        return this.m_enableLimit;
      }, b.prototype.EnableLimit = function (t) {
        this.m_bodyA.SetAwake(true), this.m_bodyB.SetAwake(true), this.m_enableLimit = t;
      }, b.prototype.GetLowerLimit = function () {
        return this.m_lowerTranslation;
      }, b.prototype.GetUpperLimit = function () {
        return this.m_upperTranslation;
      }, b.prototype.SetLimits = function (t, e) {
        void 0 === t && (t = 0), void 0 === e && (e = 0), this.m_bodyA.SetAwake(true), this.m_bodyB.SetAwake(true), this.m_lowerTranslation = t, this.m_upperTranslation = e;
      }, b.prototype.IsMotorEnabled = function () {
        return this.m_enableMotor;
      }, b.prototype.EnableMotor = function (t) {
        this.m_bodyA.SetAwake(true), this.m_bodyB.SetAwake(true), this.m_enableMotor = t;
      }, b.prototype.SetMotorSpeed = function (t) {
        void 0 === t && (t = 0), this.m_bodyA.SetAwake(true), this.m_bodyB.SetAwake(true), this.m_motorSpeed = t;
      }, b.prototype.GetMotorSpeed = function () {
        return this.m_motorSpeed;
      }, b.prototype.SetMaxMotorForce = function (t) {
        void 0 === t && (t = 0), this.m_bodyA.SetAwake(true), this.m_bodyB.SetAwake(true), this.m_maxMotorForce = t;
      }, b.prototype.GetMotorForce = function () {
        return this.m_motorImpulse;
      }, b.prototype.b2PrismaticJoint = function (t) {
        this.__super.b2Joint.call(this, t);
        this.m_localAnchor1.SetV(t.localAnchorA), this.m_localAnchor2.SetV(t.localAnchorB), this.m_localXAxis1.SetV(t.localAxisA), this.m_localYAxis1.x = -this.m_localXAxis1.y, this.m_localYAxis1.y = this.m_localXAxis1.x, this.m_refAngle = t.referenceAngle, this.m_impulse.SetZero(), this.m_motorMass = 0, this.m_motorImpulse = 0, this.m_lowerTranslation = t.lowerTranslation, this.m_upperTranslation = t.upperTranslation, this.m_maxMotorForce = t.maxMotorForce, this.m_motorSpeed = t.motorSpeed, this.m_enableLimit = t.enableLimit, this.m_enableMotor = t.enableMotor, this.m_limitState = d.e_inactiveLimit, this.m_axis.SetZero(), this.m_perp.SetZero();
      }, b.prototype.InitVelocityConstraints = function (e) {
        var i, n = this.m_bodyA, o = this.m_bodyB, s = 0;
        this.m_localCenterA.SetV(n.GetLocalCenter()), this.m_localCenterB.SetV(o.GetLocalCenter());
        var a = n.GetTransform();
        o.GetTransform();
        i = n.m_xf.R;
        var l = this.m_localAnchor1.x - this.m_localCenterA.x, c = this.m_localAnchor1.y - this.m_localCenterA.y;
        s = i.col1.x * l + i.col2.x * c, c = i.col1.y * l + i.col2.y * c, l = s, i = o.m_xf.R;
        var h = this.m_localAnchor2.x - this.m_localCenterB.x, u = this.m_localAnchor2.y - this.m_localCenterB.y;
        s = i.col1.x * h + i.col2.x * u, u = i.col1.y * h + i.col2.y * u, h = s;
        var m = o.m_sweep.c.x + h - n.m_sweep.c.x - l, p = o.m_sweep.c.y + u - n.m_sweep.c.y - c;
        this.m_invMassA = n.m_invMass, this.m_invMassB = o.m_invMass, this.m_invIA = n.m_invI, this.m_invIB = o.m_invI, this.m_axis.SetV(r.MulMV(a.R, this.m_localXAxis1)), this.m_a1 = (m + l) * this.m_axis.y - (p + c) * this.m_axis.x, this.m_a2 = h * this.m_axis.y - u * this.m_axis.x, this.m_motorMass = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_a1 * this.m_a1 + this.m_invIB * this.m_a2 * this.m_a2, this.m_motorMass > Number.MIN_VALUE && (this.m_motorMass = 1 / this.m_motorMass), this.m_perp.SetV(r.MulMV(a.R, this.m_localYAxis1)), this.m_s1 = (m + l) * this.m_perp.y - (p + c) * this.m_perp.x, this.m_s2 = h * this.m_perp.y - u * this.m_perp.x;
        var f = this.m_invMassA, _ = this.m_invMassB, y = this.m_invIA, g = this.m_invIB;
        if (this.m_K.col1.x = f + _ + y * this.m_s1 * this.m_s1 + g * this.m_s2 * this.m_s2, this.m_K.col1.y = y * this.m_s1 + g * this.m_s2, this.m_K.col1.z = y * this.m_s1 * this.m_a1 + g * this.m_s2 * this.m_a2, this.m_K.col2.x = this.m_K.col1.y, this.m_K.col2.y = y + g, this.m_K.col2.z = y * this.m_a1 + g * this.m_a2, this.m_K.col3.x = this.m_K.col1.z, this.m_K.col3.y = this.m_K.col2.z, this.m_K.col3.z = f + _ + y * this.m_a1 * this.m_a1 + g * this.m_a2 * this.m_a2, this.m_enableLimit) {
          var x = this.m_axis.x * m + this.m_axis.y * p;
          r.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * t.b2_linearSlop ? this.m_limitState = d.e_equalLimits : x <= this.m_lowerTranslation ? this.m_limitState != d.e_atLowerLimit && (this.m_limitState = d.e_atLowerLimit, this.m_impulse.z = 0) : x >= this.m_upperTranslation ? this.m_limitState != d.e_atUpperLimit && (this.m_limitState = d.e_atUpperLimit, this.m_impulse.z = 0) : (this.m_limitState = d.e_inactiveLimit, this.m_impulse.z = 0);
        } else this.m_limitState = d.e_inactiveLimit;
        if (0 == this.m_enableMotor && (this.m_motorImpulse = 0), e.warmStarting) {
          this.m_impulse.x *= e.dtRatio, this.m_impulse.y *= e.dtRatio, this.m_motorImpulse *= e.dtRatio;
          var v = this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.x, b = this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.y, w = this.m_impulse.x * this.m_s1 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a1, S = this.m_impulse.x * this.m_s2 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a2;
          n.m_linearVelocity.x -= this.m_invMassA * v, n.m_linearVelocity.y -= this.m_invMassA * b, n.m_angularVelocity -= this.m_invIA * w, o.m_linearVelocity.x += this.m_invMassB * v, o.m_linearVelocity.y += this.m_invMassB * b, o.m_angularVelocity += this.m_invIB * S;
        } else this.m_impulse.SetZero(), this.m_motorImpulse = 0;
      }, b.prototype.SolveVelocityConstraints = function (t) {
        var e = this.m_bodyA, i = this.m_bodyB, n = e.m_linearVelocity, a = e.m_angularVelocity, l = i.m_linearVelocity, c = i.m_angularVelocity, h = 0, u = 0, m = 0, p = 0;
        if (this.m_enableMotor && this.m_limitState != d.e_equalLimits) {
          var f = this.m_axis.x * (l.x - n.x) + this.m_axis.y * (l.y - n.y) + this.m_a2 * c - this.m_a1 * a, _ = this.m_motorMass * (this.m_motorSpeed - f), y = this.m_motorImpulse, g = t.dt * this.m_maxMotorForce;
          this.m_motorImpulse = r.Clamp(this.m_motorImpulse + _, -g, g), h = (_ = this.m_motorImpulse - y) * this.m_axis.x, u = _ * this.m_axis.y, m = _ * this.m_a1, p = _ * this.m_a2, n.x -= this.m_invMassA * h, n.y -= this.m_invMassA * u, a -= this.m_invIA * m, l.x += this.m_invMassB * h, l.y += this.m_invMassB * u, c += this.m_invIB * p;
        }
        var x = this.m_perp.x * (l.x - n.x) + this.m_perp.y * (l.y - n.y) + this.m_s2 * c - this.m_s1 * a, v = c - a;
        if (this.m_enableLimit && this.m_limitState != d.e_inactiveLimit) {
          var b = this.m_axis.x * (l.x - n.x) + this.m_axis.y * (l.y - n.y) + this.m_a2 * c - this.m_a1 * a, w = this.m_impulse.Copy(), S = this.m_K.Solve33(new s, -x, -v, -b);
          this.m_impulse.Add(S), this.m_limitState == d.e_atLowerLimit ? this.m_impulse.z = r.Max(this.m_impulse.z, 0) : this.m_limitState == d.e_atUpperLimit && (this.m_impulse.z = r.Min(this.m_impulse.z, 0));
          var M = -x - (this.m_impulse.z - w.z) * this.m_K.col3.x, C = -v - (this.m_impulse.z - w.z) * this.m_K.col3.y, A = this.m_K.Solve22(new o, M, C);
          A.x += w.x, A.y += w.y, this.m_impulse.x = A.x, this.m_impulse.y = A.y, S.x = this.m_impulse.x - w.x, S.y = this.m_impulse.y - w.y, S.z = this.m_impulse.z - w.z, h = S.x * this.m_perp.x + S.z * this.m_axis.x, u = S.x * this.m_perp.y + S.z * this.m_axis.y, m = S.x * this.m_s1 + S.y + S.z * this.m_a1, p = S.x * this.m_s2 + S.y + S.z * this.m_a2, n.x -= this.m_invMassA * h, n.y -= this.m_invMassA * u, a -= this.m_invIA * m, l.x += this.m_invMassB * h, l.y += this.m_invMassB * u, c += this.m_invIB * p;
        } else {
          var T = this.m_K.Solve22(new o, -x, -v);
          this.m_impulse.x += T.x, this.m_impulse.y += T.y, h = T.x * this.m_perp.x, u = T.x * this.m_perp.y, m = T.x * this.m_s1 + T.y, p = T.x * this.m_s2 + T.y, n.x -= this.m_invMassA * h, n.y -= this.m_invMassA * u, a -= this.m_invIA * m, l.x += this.m_invMassB * h, l.y += this.m_invMassB * u, c += this.m_invIB * p;
        }
        e.m_linearVelocity.SetV(n), e.m_angularVelocity = a, i.m_linearVelocity.SetV(l), i.m_angularVelocity = c;
      }, b.prototype.SolvePositionConstraints = function (e) {
        void 0 === e && (e = 0);
        var n, a, l = this.m_bodyA, c = this.m_bodyB, h = l.m_sweep.c, u = l.m_sweep.a, m = c.m_sweep.c, p = c.m_sweep.a, d = 0, f = 0, _ = 0, y = 0, g = 0, x = 0, v = false, b = 0, w = i.FromAngle(u), S = i.FromAngle(p);
        n = w;
        var M = this.m_localAnchor1.x - this.m_localCenterA.x, C = this.m_localAnchor1.y - this.m_localCenterA.y;
        d = n.col1.x * M + n.col2.x * C, C = n.col1.y * M + n.col2.y * C, M = d, n = S;
        var A = this.m_localAnchor2.x - this.m_localCenterB.x, T = this.m_localAnchor2.y - this.m_localCenterB.y;
        d = n.col1.x * A + n.col2.x * T, T = n.col1.y * A + n.col2.y * T, A = d;
        var E = m.x + A - h.x - M, L = m.y + T - h.y - C;
        if (this.m_enableLimit) {
          this.m_axis = r.MulMV(w, this.m_localXAxis1), this.m_a1 = (E + M) * this.m_axis.y - (L + C) * this.m_axis.x, this.m_a2 = A * this.m_axis.y - T * this.m_axis.x;
          var D = this.m_axis.x * E + this.m_axis.y * L;
          r.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * t.b2_linearSlop ? (b = r.Clamp(D, -t.b2_maxLinearCorrection, t.b2_maxLinearCorrection), x = r.Abs(D), v = true) : D <= this.m_lowerTranslation ? (b = r.Clamp(D - this.m_lowerTranslation + t.b2_linearSlop, -t.b2_maxLinearCorrection, 0), x = this.m_lowerTranslation - D, v = true) : D >= this.m_upperTranslation && (b = r.Clamp(D - this.m_upperTranslation + t.b2_linearSlop, 0, t.b2_maxLinearCorrection), x = D - this.m_upperTranslation, v = true);
        }
        this.m_perp = r.MulMV(w, this.m_localYAxis1), this.m_s1 = (E + M) * this.m_perp.y - (L + C) * this.m_perp.x, this.m_s2 = A * this.m_perp.y - T * this.m_perp.x;
        var V = new s, B = this.m_perp.x * E + this.m_perp.y * L, R = p - u - this.m_refAngle;
        if (x = r.Max(x, r.Abs(B)), a = r.Abs(R), v) f = this.m_invMassA, _ = this.m_invMassB, y = this.m_invIA, g = this.m_invIB, this.m_K.col1.x = f + _ + y * this.m_s1 * this.m_s1 + g * this.m_s2 * this.m_s2, this.m_K.col1.y = y * this.m_s1 + g * this.m_s2, this.m_K.col1.z = y * this.m_s1 * this.m_a1 + g * this.m_s2 * this.m_a2, this.m_K.col2.x = this.m_K.col1.y, this.m_K.col2.y = y + g, this.m_K.col2.z = y * this.m_a1 + g * this.m_a2, this.m_K.col3.x = this.m_K.col1.z, this.m_K.col3.y = this.m_K.col2.z, this.m_K.col3.z = f + _ + y * this.m_a1 * this.m_a1 + g * this.m_a2 * this.m_a2, this.m_K.Solve33(V, -B, -R, -b); else {
          f = this.m_invMassA, _ = this.m_invMassB, y = this.m_invIA, g = this.m_invIB;
          var P = f + _ + y * this.m_s1 * this.m_s1 + g * this.m_s2 * this.m_s2, I = y * this.m_s1 + g * this.m_s2, F = y + g;
          this.m_K.col1.Set(P, I, 0), this.m_K.col2.Set(I, F, 0);
          var G = this.m_K.Solve22(new o, -B, -R);
          V.x = G.x, V.y = G.y, V.z = 0;
        }
        var N = V.x * this.m_perp.x + V.z * this.m_axis.x, z = V.x * this.m_perp.y + V.z * this.m_axis.y, O = V.x * this.m_s1 + V.y + V.z * this.m_a1, U = V.x * this.m_s2 + V.y + V.z * this.m_a2;
        return h.x -= this.m_invMassA * N, h.y -= this.m_invMassA * z, u -= this.m_invIA * O, m.x += this.m_invMassB * N, m.y += this.m_invMassB * z, p += this.m_invIB * U, l.m_sweep.a = u, c.m_sweep.a = p, l.SynchronizeTransform(), c.SynchronizeTransform(), x <= t.b2_linearSlop && a <= t.b2_angularSlop;
      }, e.inherit(w, e.Dynamics.Joints.b2JointDef), w.prototype.__super = e.Dynamics.Joints.b2JointDef.prototype, w.b2PrismaticJointDef = function () {
        e.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments), this.localAnchorA = new o, this.localAnchorB = new o, this.localAxisA = new o;
      }, w.prototype.b2PrismaticJointDef = function () {
        this.__super.b2JointDef.call(this), this.type = d.e_prismaticJoint, this.localAxisA.Set(1, 0), this.referenceAngle = 0, this.enableLimit = false, this.lowerTranslation = 0, this.upperTranslation = 0, this.enableMotor = false, this.maxMotorForce = 0, this.motorSpeed = 0;
      }, w.prototype.Initialize = function (t, e, i, n) {
        this.bodyA = t, this.bodyB = e, this.localAnchorA = this.bodyA.GetLocalPoint(i), this.localAnchorB = this.bodyB.GetLocalPoint(i), this.localAxisA = this.bodyA.GetLocalVector(n), this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle();
      }, e.inherit(S, e.Dynamics.Joints.b2Joint), S.prototype.__super = e.Dynamics.Joints.b2Joint.prototype, S.b2PulleyJoint = function () {
        e.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments), this.m_groundAnchor1 = new o, this.m_groundAnchor2 = new o, this.m_localAnchor1 = new o, this.m_localAnchor2 = new o, this.m_u1 = new o, this.m_u2 = new o;
      }, S.prototype.GetAnchorA = function () {
        return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
      }, S.prototype.GetAnchorB = function () {
        return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
      }, S.prototype.GetReactionForce = function (t) {
        return void 0 === t && (t = 0), new o(t * this.m_impulse * this.m_u2.x, t * this.m_impulse * this.m_u2.y);
      }, S.prototype.GetReactionTorque = function (t) {
        return void 0 === t && (t = 0), 0;
      }, S.prototype.GetGroundAnchorA = function () {
        var t = this.m_ground.m_xf.position.Copy();
        return t.Add(this.m_groundAnchor1), t;
      }, S.prototype.GetGroundAnchorB = function () {
        var t = this.m_ground.m_xf.position.Copy();
        return t.Add(this.m_groundAnchor2), t;
      }, S.prototype.GetLength1 = function () {
        var t = this.m_bodyA.GetWorldPoint(this.m_localAnchor1), e = this.m_ground.m_xf.position.x + this.m_groundAnchor1.x, i = this.m_ground.m_xf.position.y + this.m_groundAnchor1.y, n = t.x - e, r = t.y - i;
        return Math.sqrt(n * n + r * r);
      }, S.prototype.GetLength2 = function () {
        var t = this.m_bodyB.GetWorldPoint(this.m_localAnchor2), e = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x, i = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y, n = t.x - e, r = t.y - i;
        return Math.sqrt(n * n + r * r);
      }, S.prototype.GetRatio = function () {
        return this.m_ratio;
      }, S.prototype.b2PulleyJoint = function (t) {
        this.__super.b2Joint.call(this, t);
        this.m_ground = this.m_bodyA.m_world.m_groundBody, this.m_groundAnchor1.x = t.groundAnchorA.x - this.m_ground.m_xf.position.x, this.m_groundAnchor1.y = t.groundAnchorA.y - this.m_ground.m_xf.position.y, this.m_groundAnchor2.x = t.groundAnchorB.x - this.m_ground.m_xf.position.x, this.m_groundAnchor2.y = t.groundAnchorB.y - this.m_ground.m_xf.position.y, this.m_localAnchor1.SetV(t.localAnchorA), this.m_localAnchor2.SetV(t.localAnchorB), this.m_ratio = t.ratio, this.m_constant = t.lengthA + this.m_ratio * t.lengthB, this.m_maxLength1 = r.Min(t.maxLengthA, this.m_constant - this.m_ratio * S.b2_minPulleyLength), this.m_maxLength2 = r.Min(t.maxLengthB, (this.m_constant - S.b2_minPulleyLength) / this.m_ratio), this.m_impulse = 0, this.m_limitImpulse1 = 0, this.m_limitImpulse2 = 0;
      }, S.prototype.InitVelocityConstraints = function (e) {
        var i, n = this.m_bodyA, r = this.m_bodyB;
        i = n.m_xf.R;
        var o = this.m_localAnchor1.x - n.m_sweep.localCenter.x, s = this.m_localAnchor1.y - n.m_sweep.localCenter.y, a = i.col1.x * o + i.col2.x * s;
        s = i.col1.y * o + i.col2.y * s, o = a, i = r.m_xf.R;
        var l = this.m_localAnchor2.x - r.m_sweep.localCenter.x, c = this.m_localAnchor2.y - r.m_sweep.localCenter.y;
        a = i.col1.x * l + i.col2.x * c, c = i.col1.y * l + i.col2.y * c, l = a;
        var h = n.m_sweep.c.x + o, u = n.m_sweep.c.y + s, m = r.m_sweep.c.x + l, p = r.m_sweep.c.y + c, f = this.m_ground.m_xf.position.x + this.m_groundAnchor1.x, _ = this.m_ground.m_xf.position.y + this.m_groundAnchor1.y, y = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x, g = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y;
        this.m_u1.Set(h - f, u - _), this.m_u2.Set(m - y, p - g);
        var x = this.m_u1.Length(), v = this.m_u2.Length();
        x > t.b2_linearSlop ? this.m_u1.Multiply(1 / x) : this.m_u1.SetZero(), v > t.b2_linearSlop ? this.m_u2.Multiply(1 / v) : this.m_u2.SetZero(), this.m_constant - x - this.m_ratio * v > 0 ? (this.m_state = d.e_inactiveLimit, this.m_impulse = 0) : this.m_state = d.e_atUpperLimit, x < this.m_maxLength1 ? (this.m_limitState1 = d.e_inactiveLimit, this.m_limitImpulse1 = 0) : this.m_limitState1 = d.e_atUpperLimit, v < this.m_maxLength2 ? (this.m_limitState2 = d.e_inactiveLimit, this.m_limitImpulse2 = 0) : this.m_limitState2 = d.e_atUpperLimit;
        var b = o * this.m_u1.y - s * this.m_u1.x, w = l * this.m_u2.y - c * this.m_u2.x;
        if (this.m_limitMass1 = n.m_invMass + n.m_invI * b * b, this.m_limitMass2 = r.m_invMass + r.m_invI * w * w, this.m_pulleyMass = this.m_limitMass1 + this.m_ratio * this.m_ratio * this.m_limitMass2, this.m_limitMass1 = 1 / this.m_limitMass1, this.m_limitMass2 = 1 / this.m_limitMass2, this.m_pulleyMass = 1 / this.m_pulleyMass, e.warmStarting) {
          this.m_impulse *= e.dtRatio, this.m_limitImpulse1 *= e.dtRatio, this.m_limitImpulse2 *= e.dtRatio;
          var S = (-this.m_impulse - this.m_limitImpulse1) * this.m_u1.x, M = (-this.m_impulse - this.m_limitImpulse1) * this.m_u1.y, C = (-this.m_ratio * this.m_impulse - this.m_limitImpulse2) * this.m_u2.x, A = (-this.m_ratio * this.m_impulse - this.m_limitImpulse2) * this.m_u2.y;
          n.m_linearVelocity.x += n.m_invMass * S, n.m_linearVelocity.y += n.m_invMass * M, n.m_angularVelocity += n.m_invI * (o * M - s * S), r.m_linearVelocity.x += r.m_invMass * C, r.m_linearVelocity.y += r.m_invMass * A, r.m_angularVelocity += r.m_invI * (l * A - c * C);
        } else this.m_impulse = 0, this.m_limitImpulse1 = 0, this.m_limitImpulse2 = 0;
      }, S.prototype.SolveVelocityConstraints = function (t) {
        var e, i = this.m_bodyA, n = this.m_bodyB;
        e = i.m_xf.R;
        var o = this.m_localAnchor1.x - i.m_sweep.localCenter.x, s = this.m_localAnchor1.y - i.m_sweep.localCenter.y, a = e.col1.x * o + e.col2.x * s;
        s = e.col1.y * o + e.col2.y * s, o = a, e = n.m_xf.R;
        var l = this.m_localAnchor2.x - n.m_sweep.localCenter.x, c = this.m_localAnchor2.y - n.m_sweep.localCenter.y;
        a = e.col1.x * l + e.col2.x * c, c = e.col1.y * l + e.col2.y * c, l = a;
        var h = 0, u = 0, m = 0, p = 0, f = 0, _ = 0, y = 0, g = 0, x = 0, v = 0, b = 0;
        this.m_state == d.e_atUpperLimit && (h = i.m_linearVelocity.x + -i.m_angularVelocity * s, u = i.m_linearVelocity.y + i.m_angularVelocity * o, m = n.m_linearVelocity.x + -n.m_angularVelocity * c, p = n.m_linearVelocity.y + n.m_angularVelocity * l, x = -(this.m_u1.x * h + this.m_u1.y * u) - this.m_ratio * (this.m_u2.x * m + this.m_u2.y * p), v = this.m_pulleyMass * -x, b = this.m_impulse, this.m_impulse = r.Max(0, this.m_impulse + v), f = -(v = this.m_impulse - b) * this.m_u1.x, _ = -v * this.m_u1.y, y = -this.m_ratio * v * this.m_u2.x, g = -this.m_ratio * v * this.m_u2.y, i.m_linearVelocity.x += i.m_invMass * f, i.m_linearVelocity.y += i.m_invMass * _, i.m_angularVelocity += i.m_invI * (o * _ - s * f), n.m_linearVelocity.x += n.m_invMass * y, n.m_linearVelocity.y += n.m_invMass * g, n.m_angularVelocity += n.m_invI * (l * g - c * y)), this.m_limitState1 == d.e_atUpperLimit && (h = i.m_linearVelocity.x + -i.m_angularVelocity * s, u = i.m_linearVelocity.y + i.m_angularVelocity * o, x = -(this.m_u1.x * h + this.m_u1.y * u), v = -this.m_limitMass1 * x, b = this.m_limitImpulse1, this.m_limitImpulse1 = r.Max(0, this.m_limitImpulse1 + v), f = -(v = this.m_limitImpulse1 - b) * this.m_u1.x, _ = -v * this.m_u1.y, i.m_linearVelocity.x += i.m_invMass * f, i.m_linearVelocity.y += i.m_invMass * _, i.m_angularVelocity += i.m_invI * (o * _ - s * f)), this.m_limitState2 == d.e_atUpperLimit && (m = n.m_linearVelocity.x + -n.m_angularVelocity * c, p = n.m_linearVelocity.y + n.m_angularVelocity * l, x = -(this.m_u2.x * m + this.m_u2.y * p), v = -this.m_limitMass2 * x, b = this.m_limitImpulse2, this.m_limitImpulse2 = r.Max(0, this.m_limitImpulse2 + v), y = -(v = this.m_limitImpulse2 - b) * this.m_u2.x, g = -v * this.m_u2.y, n.m_linearVelocity.x += n.m_invMass * y, n.m_linearVelocity.y += n.m_invMass * g, n.m_angularVelocity += n.m_invI * (l * g - c * y));
      }, S.prototype.SolvePositionConstraints = function (e) {
        void 0 === e && (e = 0);
        var i, n = this.m_bodyA, o = this.m_bodyB, s = this.m_ground.m_xf.position.x + this.m_groundAnchor1.x, a = this.m_ground.m_xf.position.y + this.m_groundAnchor1.y, l = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x, c = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y, h = 0, u = 0, m = 0, p = 0, f = 0, _ = 0, y = 0, g = 0, x = 0, v = 0, b = 0, w = 0, S = 0, M = 0;
        return this.m_state == d.e_atUpperLimit && (i = n.m_xf.R, h = this.m_localAnchor1.x - n.m_sweep.localCenter.x, u = this.m_localAnchor1.y - n.m_sweep.localCenter.y, S = i.col1.x * h + i.col2.x * u, u = i.col1.y * h + i.col2.y * u, h = S, i = o.m_xf.R, m = this.m_localAnchor2.x - o.m_sweep.localCenter.x, p = this.m_localAnchor2.y - o.m_sweep.localCenter.y, S = i.col1.x * m + i.col2.x * p, p = i.col1.y * m + i.col2.y * p, m = S, f = n.m_sweep.c.x + h, _ = n.m_sweep.c.y + u, y = o.m_sweep.c.x + m, g = o.m_sweep.c.y + p, this.m_u1.Set(f - s, _ - a), this.m_u2.Set(y - l, g - c), x = this.m_u1.Length(), v = this.m_u2.Length(), x > t.b2_linearSlop ? this.m_u1.Multiply(1 / x) : this.m_u1.SetZero(), v > t.b2_linearSlop ? this.m_u2.Multiply(1 / v) : this.m_u2.SetZero(), b = this.m_constant - x - this.m_ratio * v, M = r.Max(M, -b), b = r.Clamp(b + t.b2_linearSlop, -t.b2_maxLinearCorrection, 0), f = -(w = -this.m_pulleyMass * b) * this.m_u1.x, _ = -w * this.m_u1.y, y = -this.m_ratio * w * this.m_u2.x, g = -this.m_ratio * w * this.m_u2.y, n.m_sweep.c.x += n.m_invMass * f, n.m_sweep.c.y += n.m_invMass * _, n.m_sweep.a += n.m_invI * (h * _ - u * f), o.m_sweep.c.x += o.m_invMass * y, o.m_sweep.c.y += o.m_invMass * g, o.m_sweep.a += o.m_invI * (m * g - p * y), n.SynchronizeTransform(), o.SynchronizeTransform()), this.m_limitState1 == d.e_atUpperLimit && (i = n.m_xf.R, h = this.m_localAnchor1.x - n.m_sweep.localCenter.x, u = this.m_localAnchor1.y - n.m_sweep.localCenter.y, S = i.col1.x * h + i.col2.x * u, u = i.col1.y * h + i.col2.y * u, h = S, f = n.m_sweep.c.x + h, _ = n.m_sweep.c.y + u, this.m_u1.Set(f - s, _ - a), (x = this.m_u1.Length()) > t.b2_linearSlop ? (this.m_u1.x *= 1 / x, this.m_u1.y *= 1 / x) : this.m_u1.SetZero(), b = this.m_maxLength1 - x, M = r.Max(M, -b), b = r.Clamp(b + t.b2_linearSlop, -t.b2_maxLinearCorrection, 0), f = -(w = -this.m_limitMass1 * b) * this.m_u1.x, _ = -w * this.m_u1.y, n.m_sweep.c.x += n.m_invMass * f, n.m_sweep.c.y += n.m_invMass * _, n.m_sweep.a += n.m_invI * (h * _ - u * f), n.SynchronizeTransform()), this.m_limitState2 == d.e_atUpperLimit && (i = o.m_xf.R, m = this.m_localAnchor2.x - o.m_sweep.localCenter.x, p = this.m_localAnchor2.y - o.m_sweep.localCenter.y, S = i.col1.x * m + i.col2.x * p, p = i.col1.y * m + i.col2.y * p, m = S, y = o.m_sweep.c.x + m, g = o.m_sweep.c.y + p, this.m_u2.Set(y - l, g - c), (v = this.m_u2.Length()) > t.b2_linearSlop ? (this.m_u2.x *= 1 / v, this.m_u2.y *= 1 / v) : this.m_u2.SetZero(), b = this.m_maxLength2 - v, M = r.Max(M, -b), b = r.Clamp(b + t.b2_linearSlop, -t.b2_maxLinearCorrection, 0), y = -(w = -this.m_limitMass2 * b) * this.m_u2.x, g = -w * this.m_u2.y, o.m_sweep.c.x += o.m_invMass * y, o.m_sweep.c.y += o.m_invMass * g, o.m_sweep.a += o.m_invI * (m * g - p * y), o.SynchronizeTransform()), M < t.b2_linearSlop;
      }, e.postDefs.push(function () {
        e.Dynamics.Joints.b2PulleyJoint.b2_minPulleyLength = 2;
      }), e.inherit(M, e.Dynamics.Joints.b2JointDef), M.prototype.__super = e.Dynamics.Joints.b2JointDef.prototype, M.b2PulleyJointDef = function () {
        e.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments), this.groundAnchorA = new o, this.groundAnchorB = new o, this.localAnchorA = new o, this.localAnchorB = new o;
      }, M.prototype.b2PulleyJointDef = function () {
        this.__super.b2JointDef.call(this), this.type = d.e_pulleyJoint, this.groundAnchorA.Set(-1, 1), this.groundAnchorB.Set(1, 1), this.localAnchorA.Set(-1, 0), this.localAnchorB.Set(1, 0), this.lengthA = 0, this.maxLengthA = 0, this.lengthB = 0, this.maxLengthB = 0, this.ratio = 1, this.collideConnected = true;
      }, M.prototype.Initialize = function (t, e, i, n, r, o, s) {
        void 0 === s && (s = 0), this.bodyA = t, this.bodyB = e, this.groundAnchorA.SetV(i), this.groundAnchorB.SetV(n), this.localAnchorA = this.bodyA.GetLocalPoint(r), this.localAnchorB = this.bodyB.GetLocalPoint(o);
        var a = r.x - i.x, l = r.y - i.y;
        this.lengthA = Math.sqrt(a * a + l * l);
        var c = o.x - n.x, h = o.y - n.y;
        this.lengthB = Math.sqrt(c * c + h * h), this.ratio = s;
        var u = this.lengthA + this.ratio * this.lengthB;
        this.maxLengthA = u - this.ratio * S.b2_minPulleyLength, this.maxLengthB = (u - S.b2_minPulleyLength) / this.ratio;
      }, e.inherit(C, e.Dynamics.Joints.b2Joint), C.prototype.__super = e.Dynamics.Joints.b2Joint.prototype, C.b2RevoluteJoint = function () {
        e.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments), this.K = new i, this.K1 = new i, this.K2 = new i, this.K3 = new i, this.impulse3 = new s, this.impulse2 = new o, this.reduced = new o, this.m_localAnchor1 = new o, this.m_localAnchor2 = new o, this.m_impulse = new s, this.m_mass = new n;
      }, C.prototype.GetAnchorA = function () {
        return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
      }, C.prototype.GetAnchorB = function () {
        return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
      }, C.prototype.GetReactionForce = function (t) {
        return void 0 === t && (t = 0), new o(t * this.m_impulse.x, t * this.m_impulse.y);
      }, C.prototype.GetReactionTorque = function (t) {
        return void 0 === t && (t = 0), t * this.m_impulse.z;
      }, C.prototype.GetJointAngle = function () {
        return this.m_bodyB.m_sweep.a - this.m_bodyA.m_sweep.a - this.m_referenceAngle;
      }, C.prototype.GetJointSpeed = function () {
        return this.m_bodyB.m_angularVelocity - this.m_bodyA.m_angularVelocity;
      }, C.prototype.IsLimitEnabled = function () {
        return this.m_enableLimit;
      }, C.prototype.EnableLimit = function (t) {
        this.m_enableLimit = t;
      }, C.prototype.GetLowerLimit = function () {
        return this.m_lowerAngle;
      }, C.prototype.GetUpperLimit = function () {
        return this.m_upperAngle;
      }, C.prototype.SetLimits = function (t, e) {
        void 0 === t && (t = 0), void 0 === e && (e = 0), this.m_lowerAngle = t, this.m_upperAngle = e;
      }, C.prototype.IsMotorEnabled = function () {
        return this.m_bodyA.SetAwake(true), this.m_bodyB.SetAwake(true), this.m_enableMotor;
      }, C.prototype.EnableMotor = function (t) {
        this.m_enableMotor = t;
      }, C.prototype.SetMotorSpeed = function (t) {
        void 0 === t && (t = 0), this.m_bodyA.SetAwake(true), this.m_bodyB.SetAwake(true), this.m_motorSpeed = t;
      }, C.prototype.GetMotorSpeed = function () {
        return this.m_motorSpeed;
      }, C.prototype.SetMaxMotorTorque = function (t) {
        void 0 === t && (t = 0), this.m_maxMotorTorque = t;
      }, C.prototype.GetMotorTorque = function () {
        return this.m_maxMotorTorque;
      }, C.prototype.b2RevoluteJoint = function (t) {
        this.__super.b2Joint.call(this, t), this.m_localAnchor1.SetV(t.localAnchorA), this.m_localAnchor2.SetV(t.localAnchorB), this.m_referenceAngle = t.referenceAngle, this.m_impulse.SetZero(), this.m_motorImpulse = 0, this.m_lowerAngle = t.lowerAngle, this.m_upperAngle = t.upperAngle, this.m_maxMotorTorque = t.maxMotorTorque, this.m_motorSpeed = t.motorSpeed, this.m_enableLimit = t.enableLimit, this.m_enableMotor = t.enableMotor, this.m_limitState = d.e_inactiveLimit;
      }, C.prototype.InitVelocityConstraints = function (e) {
        var i, n = this.m_bodyA, o = this.m_bodyB, s = 0;
        this.m_enableMotor || this.m_enableLimit, i = n.m_xf.R;
        var a = this.m_localAnchor1.x - n.m_sweep.localCenter.x, l = this.m_localAnchor1.y - n.m_sweep.localCenter.y;
        s = i.col1.x * a + i.col2.x * l, l = i.col1.y * a + i.col2.y * l, a = s, i = o.m_xf.R;
        var c = this.m_localAnchor2.x - o.m_sweep.localCenter.x, h = this.m_localAnchor2.y - o.m_sweep.localCenter.y;
        s = i.col1.x * c + i.col2.x * h, h = i.col1.y * c + i.col2.y * h, c = s;
        var u = n.m_invMass, m = o.m_invMass, p = n.m_invI, f = o.m_invI;
        if (this.m_mass.col1.x = u + m + l * l * p + h * h * f, this.m_mass.col2.x = -l * a * p - h * c * f, this.m_mass.col3.x = -l * p - h * f, this.m_mass.col1.y = this.m_mass.col2.x, this.m_mass.col2.y = u + m + a * a * p + c * c * f, this.m_mass.col3.y = a * p + c * f, this.m_mass.col1.z = this.m_mass.col3.x, this.m_mass.col2.z = this.m_mass.col3.y, this.m_mass.col3.z = p + f, this.m_motorMass = 1 / (p + f), 0 == this.m_enableMotor && (this.m_motorImpulse = 0), this.m_enableLimit) {
          var _ = o.m_sweep.a - n.m_sweep.a - this.m_referenceAngle;
          r.Abs(this.m_upperAngle - this.m_lowerAngle) < 2 * t.b2_angularSlop ? this.m_limitState = d.e_equalLimits : _ <= this.m_lowerAngle ? (this.m_limitState != d.e_atLowerLimit && (this.m_impulse.z = 0), this.m_limitState = d.e_atLowerLimit) : _ >= this.m_upperAngle ? (this.m_limitState != d.e_atUpperLimit && (this.m_impulse.z = 0), this.m_limitState = d.e_atUpperLimit) : (this.m_limitState = d.e_inactiveLimit, this.m_impulse.z = 0);
        } else this.m_limitState = d.e_inactiveLimit;
        if (e.warmStarting) {
          this.m_impulse.x *= e.dtRatio, this.m_impulse.y *= e.dtRatio, this.m_motorImpulse *= e.dtRatio;
          var y = this.m_impulse.x, g = this.m_impulse.y;
          n.m_linearVelocity.x -= u * y, n.m_linearVelocity.y -= u * g, n.m_angularVelocity -= p * (a * g - l * y + this.m_motorImpulse + this.m_impulse.z), o.m_linearVelocity.x += m * y, o.m_linearVelocity.y += m * g, o.m_angularVelocity += f * (c * g - h * y + this.m_motorImpulse + this.m_impulse.z);
        } else this.m_impulse.SetZero(), this.m_motorImpulse = 0;
      }, C.prototype.SolveVelocityConstraints = function (t) {
        var e, i = this.m_bodyA, n = this.m_bodyB, o = 0, s = 0, a = 0, l = 0, c = 0, h = i.m_linearVelocity, u = i.m_angularVelocity, m = n.m_linearVelocity, p = n.m_angularVelocity, f = i.m_invMass, _ = n.m_invMass, y = i.m_invI, g = n.m_invI;
        if (this.m_enableMotor && this.m_limitState != d.e_equalLimits) {
          var x = p - u - this.m_motorSpeed, v = this.m_motorMass * -x, b = this.m_motorImpulse, w = t.dt * this.m_maxMotorTorque;
          this.m_motorImpulse = r.Clamp(this.m_motorImpulse + v, -w, w), u -= y * (v = this.m_motorImpulse - b), p += g * v;
        }
        if (this.m_enableLimit && this.m_limitState != d.e_inactiveLimit) {
          e = i.m_xf.R, s = this.m_localAnchor1.x - i.m_sweep.localCenter.x, a = this.m_localAnchor1.y - i.m_sweep.localCenter.y, o = e.col1.x * s + e.col2.x * a, a = e.col1.y * s + e.col2.y * a, s = o, e = n.m_xf.R, l = this.m_localAnchor2.x - n.m_sweep.localCenter.x, c = this.m_localAnchor2.y - n.m_sweep.localCenter.y, o = e.col1.x * l + e.col2.x * c, c = e.col1.y * l + e.col2.y * c, l = o;
          var S = m.x + -p * c - h.x - -u * a, M = m.y + p * l - h.y - u * s, C = p - u;
          this.m_mass.Solve33(this.impulse3, -S, -M, -C), this.m_limitState == d.e_equalLimits ? this.m_impulse.Add(this.impulse3) : this.m_limitState == d.e_atLowerLimit ? this.m_impulse.z + this.impulse3.z < 0 && (this.m_mass.Solve22(this.reduced, -S, -M), this.impulse3.x = this.reduced.x, this.impulse3.y = this.reduced.y, this.impulse3.z = -this.m_impulse.z, this.m_impulse.x += this.reduced.x, this.m_impulse.y += this.reduced.y, this.m_impulse.z = 0) : this.m_limitState == d.e_atUpperLimit && this.m_impulse.z + this.impulse3.z > 0 && (this.m_mass.Solve22(this.reduced, -S, -M), this.impulse3.x = this.reduced.x, this.impulse3.y = this.reduced.y, this.impulse3.z = -this.m_impulse.z, this.m_impulse.x += this.reduced.x, this.m_impulse.y += this.reduced.y, this.m_impulse.z = 0), h.x -= f * this.impulse3.x, h.y -= f * this.impulse3.y, u -= y * (s * this.impulse3.y - a * this.impulse3.x + this.impulse3.z), m.x += _ * this.impulse3.x, m.y += _ * this.impulse3.y, p += g * (l * this.impulse3.y - c * this.impulse3.x + this.impulse3.z);
        } else {
          e = i.m_xf.R, s = this.m_localAnchor1.x - i.m_sweep.localCenter.x, a = this.m_localAnchor1.y - i.m_sweep.localCenter.y, o = e.col1.x * s + e.col2.x * a, a = e.col1.y * s + e.col2.y * a, s = o, e = n.m_xf.R, l = this.m_localAnchor2.x - n.m_sweep.localCenter.x, c = this.m_localAnchor2.y - n.m_sweep.localCenter.y, o = e.col1.x * l + e.col2.x * c, c = e.col1.y * l + e.col2.y * c, l = o;
          var A = m.x + -p * c - h.x - -u * a, T = m.y + p * l - h.y - u * s;
          this.m_mass.Solve22(this.impulse2, -A, -T), this.m_impulse.x += this.impulse2.x, this.m_impulse.y += this.impulse2.y, h.x -= f * this.impulse2.x, h.y -= f * this.impulse2.y, u -= y * (s * this.impulse2.y - a * this.impulse2.x), m.x += _ * this.impulse2.x, m.y += _ * this.impulse2.y, p += g * (l * this.impulse2.y - c * this.impulse2.x);
        }
        i.m_linearVelocity.SetV(h), i.m_angularVelocity = u, n.m_linearVelocity.SetV(m), n.m_angularVelocity = p;
      }, C.prototype.SolvePositionConstraints = function (e) {
        void 0 === e && (e = 0);
        var i, n, o = 0, s = this.m_bodyA, a = this.m_bodyB, l = 0, c = 0, h = 0, u = 0;
        if (this.m_enableLimit && this.m_limitState != d.e_inactiveLimit) {
          var m = a.m_sweep.a - s.m_sweep.a - this.m_referenceAngle, p = 0;
          this.m_limitState == d.e_equalLimits ? (o = r.Clamp(m - this.m_lowerAngle, -t.b2_maxAngularCorrection, t.b2_maxAngularCorrection), p = -this.m_motorMass * o, l = r.Abs(o)) : this.m_limitState == d.e_atLowerLimit ? (l = -(o = m - this.m_lowerAngle), o = r.Clamp(o + t.b2_angularSlop, -t.b2_maxAngularCorrection, 0), p = -this.m_motorMass * o) : this.m_limitState == d.e_atUpperLimit && (l = o = m - this.m_upperAngle, o = r.Clamp(o - t.b2_angularSlop, 0, t.b2_maxAngularCorrection), p = -this.m_motorMass * o), s.m_sweep.a -= s.m_invI * p, a.m_sweep.a += a.m_invI * p, s.SynchronizeTransform(), a.SynchronizeTransform();
        }
        i = s.m_xf.R;
        var f = this.m_localAnchor1.x - s.m_sweep.localCenter.x, _ = this.m_localAnchor1.y - s.m_sweep.localCenter.y;
        c = i.col1.x * f + i.col2.x * _, _ = i.col1.y * f + i.col2.y * _, f = c, i = a.m_xf.R;
        var y = this.m_localAnchor2.x - a.m_sweep.localCenter.x, g = this.m_localAnchor2.y - a.m_sweep.localCenter.y;
        c = i.col1.x * y + i.col2.x * g, g = i.col1.y * y + i.col2.y * g, y = c;
        var x = a.m_sweep.c.x + y - s.m_sweep.c.x - f, v = a.m_sweep.c.y + g - s.m_sweep.c.y - _, b = x * x + v * v, w = Math.sqrt(b);
        n = w;
        var S = s.m_invMass, M = a.m_invMass, A = s.m_invI, T = a.m_invI, E = 10 * t.b2_linearSlop;
        if (b > E * E) {
          var L = 1 / (S + M);
          h = L * -x, u = L * -v;
          var D = 0.5;
          s.m_sweep.c.x -= D * S * h, s.m_sweep.c.y -= D * S * u, a.m_sweep.c.x += D * M * h, a.m_sweep.c.y += D * M * u, x = a.m_sweep.c.x + y - s.m_sweep.c.x - f, v = a.m_sweep.c.y + g - s.m_sweep.c.y - _;
        }
        return this.K1.col1.x = S + M, this.K1.col2.x = 0, this.K1.col1.y = 0, this.K1.col2.y = S + M, this.K2.col1.x = A * _ * _, this.K2.col2.x = -A * f * _, this.K2.col1.y = -A * f * _, this.K2.col2.y = A * f * f, this.K3.col1.x = T * g * g, this.K3.col2.x = -T * y * g, this.K3.col1.y = -T * y * g, this.K3.col2.y = T * y * y, this.K.SetM(this.K1), this.K.AddM(this.K2), this.K.AddM(this.K3), this.K.Solve(C.tImpulse, -x, -v), h = C.tImpulse.x, u = C.tImpulse.y, s.m_sweep.c.x -= s.m_invMass * h, s.m_sweep.c.y -= s.m_invMass * u, s.m_sweep.a -= s.m_invI * (f * u - _ * h), a.m_sweep.c.x += a.m_invMass * h, a.m_sweep.c.y += a.m_invMass * u, a.m_sweep.a += a.m_invI * (y * u - g * h), s.SynchronizeTransform(), a.SynchronizeTransform(), n <= t.b2_linearSlop && l <= t.b2_angularSlop;
      }, e.postDefs.push(function () {
        e.Dynamics.Joints.b2RevoluteJoint.tImpulse = new o;
      }), e.inherit(A, e.Dynamics.Joints.b2JointDef), A.prototype.__super = e.Dynamics.Joints.b2JointDef.prototype, A.b2RevoluteJointDef = function () {
        e.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments), this.localAnchorA = new o, this.localAnchorB = new o;
      }, A.prototype.b2RevoluteJointDef = function () {
        this.__super.b2JointDef.call(this), this.type = d.e_revoluteJoint, this.localAnchorA.Set(0, 0), this.localAnchorB.Set(0, 0), this.referenceAngle = 0, this.lowerAngle = 0, this.upperAngle = 0, this.maxMotorTorque = 0, this.motorSpeed = 0, this.enableLimit = false, this.enableMotor = false;
      }, A.prototype.Initialize = function (t, e, i) {
        this.bodyA = t, this.bodyB = e, this.localAnchorA = this.bodyA.GetLocalPoint(i), this.localAnchorB = this.bodyB.GetLocalPoint(i), this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle();
      }, e.inherit(T, e.Dynamics.Joints.b2Joint), T.prototype.__super = e.Dynamics.Joints.b2Joint.prototype, T.b2WeldJoint = function () {
        e.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments), this.m_localAnchorA = new o, this.m_localAnchorB = new o, this.m_impulse = new s, this.m_mass = new n;
      }, T.prototype.GetAnchorA = function () {
        return this.m_bodyA.GetWorldPoint(this.m_localAnchorA);
      }, T.prototype.GetAnchorB = function () {
        return this.m_bodyB.GetWorldPoint(this.m_localAnchorB);
      }, T.prototype.GetReactionForce = function (t) {
        return void 0 === t && (t = 0), new o(t * this.m_impulse.x, t * this.m_impulse.y);
      }, T.prototype.GetReactionTorque = function (t) {
        return void 0 === t && (t = 0), t * this.m_impulse.z;
      }, T.prototype.b2WeldJoint = function (t) {
        this.__super.b2Joint.call(this, t), this.m_localAnchorA.SetV(t.localAnchorA), this.m_localAnchorB.SetV(t.localAnchorB), this.m_referenceAngle = t.referenceAngle, this.m_impulse.SetZero(), this.m_mass = new n;
      }, T.prototype.InitVelocityConstraints = function (t) {
        var e, i = 0, n = this.m_bodyA, r = this.m_bodyB;
        e = n.m_xf.R;
        var o = this.m_localAnchorA.x - n.m_sweep.localCenter.x, s = this.m_localAnchorA.y - n.m_sweep.localCenter.y;
        i = e.col1.x * o + e.col2.x * s, s = e.col1.y * o + e.col2.y * s, o = i, e = r.m_xf.R;
        var a = this.m_localAnchorB.x - r.m_sweep.localCenter.x, l = this.m_localAnchorB.y - r.m_sweep.localCenter.y;
        i = e.col1.x * a + e.col2.x * l, l = e.col1.y * a + e.col2.y * l, a = i;
        var c = n.m_invMass, h = r.m_invMass, u = n.m_invI, m = r.m_invI;
        this.m_mass.col1.x = c + h + s * s * u + l * l * m, this.m_mass.col2.x = -s * o * u - l * a * m, this.m_mass.col3.x = -s * u - l * m, this.m_mass.col1.y = this.m_mass.col2.x, this.m_mass.col2.y = c + h + o * o * u + a * a * m, this.m_mass.col3.y = o * u + a * m, this.m_mass.col1.z = this.m_mass.col3.x, this.m_mass.col2.z = this.m_mass.col3.y, this.m_mass.col3.z = u + m, t.warmStarting ? (this.m_impulse.x *= t.dtRatio, this.m_impulse.y *= t.dtRatio, this.m_impulse.z *= t.dtRatio, n.m_linearVelocity.x -= c * this.m_impulse.x, n.m_linearVelocity.y -= c * this.m_impulse.y, n.m_angularVelocity -= u * (o * this.m_impulse.y - s * this.m_impulse.x + this.m_impulse.z), r.m_linearVelocity.x += h * this.m_impulse.x, r.m_linearVelocity.y += h * this.m_impulse.y, r.m_angularVelocity += m * (a * this.m_impulse.y - l * this.m_impulse.x + this.m_impulse.z)) : this.m_impulse.SetZero();
      }, T.prototype.SolveVelocityConstraints = function (t) {
        var e, i = 0, n = this.m_bodyA, r = this.m_bodyB, o = n.m_linearVelocity, a = n.m_angularVelocity, l = r.m_linearVelocity, c = r.m_angularVelocity, h = n.m_invMass, u = r.m_invMass, m = n.m_invI, p = r.m_invI;
        e = n.m_xf.R;
        var d = this.m_localAnchorA.x - n.m_sweep.localCenter.x, f = this.m_localAnchorA.y - n.m_sweep.localCenter.y;
        i = e.col1.x * d + e.col2.x * f, f = e.col1.y * d + e.col2.y * f, d = i, e = r.m_xf.R;
        var _ = this.m_localAnchorB.x - r.m_sweep.localCenter.x, y = this.m_localAnchorB.y - r.m_sweep.localCenter.y;
        i = e.col1.x * _ + e.col2.x * y, y = e.col1.y * _ + e.col2.y * y, _ = i;
        var g = l.x - c * y - o.x + a * f, x = l.y + c * _ - o.y - a * d, v = c - a, b = new s;
        this.m_mass.Solve33(b, -g, -x, -v), this.m_impulse.Add(b), o.x -= h * b.x, o.y -= h * b.y, a -= m * (d * b.y - f * b.x + b.z), l.x += u * b.x, l.y += u * b.y, c += p * (_ * b.y - y * b.x + b.z), n.m_angularVelocity = a, r.m_angularVelocity = c;
      }, T.prototype.SolvePositionConstraints = function (e) {
        var i;
        void 0 === e && (e = 0);
        var n = 0, o = this.m_bodyA, a = this.m_bodyB;
        i = o.m_xf.R;
        var l = this.m_localAnchorA.x - o.m_sweep.localCenter.x, c = this.m_localAnchorA.y - o.m_sweep.localCenter.y;
        n = i.col1.x * l + i.col2.x * c, c = i.col1.y * l + i.col2.y * c, l = n, i = a.m_xf.R;
        var h = this.m_localAnchorB.x - a.m_sweep.localCenter.x, u = this.m_localAnchorB.y - a.m_sweep.localCenter.y;
        n = i.col1.x * h + i.col2.x * u, u = i.col1.y * h + i.col2.y * u, h = n;
        var m = o.m_invMass, p = a.m_invMass, d = o.m_invI, f = a.m_invI, _ = a.m_sweep.c.x + h - o.m_sweep.c.x - l, y = a.m_sweep.c.y + u - o.m_sweep.c.y - c, g = a.m_sweep.a - o.m_sweep.a - this.m_referenceAngle, x = 10 * t.b2_linearSlop, v = Math.sqrt(_ * _ + y * y), b = r.Abs(g);
        v > x && (d *= 1, f *= 1), this.m_mass.col1.x = m + p + c * c * d + u * u * f, this.m_mass.col2.x = -c * l * d - u * h * f, this.m_mass.col3.x = -c * d - u * f, this.m_mass.col1.y = this.m_mass.col2.x, this.m_mass.col2.y = m + p + l * l * d + h * h * f, this.m_mass.col3.y = l * d + h * f, this.m_mass.col1.z = this.m_mass.col3.x, this.m_mass.col2.z = this.m_mass.col3.y, this.m_mass.col3.z = d + f;
        var w = new s;
        return this.m_mass.Solve33(w, -_, -y, -g), o.m_sweep.c.x -= m * w.x, o.m_sweep.c.y -= m * w.y, o.m_sweep.a -= d * (l * w.y - c * w.x + w.z), a.m_sweep.c.x += p * w.x, a.m_sweep.c.y += p * w.y, a.m_sweep.a += f * (h * w.y - u * w.x + w.z), o.SynchronizeTransform(), a.SynchronizeTransform(), v <= t.b2_linearSlop && b <= t.b2_angularSlop;
      }, e.inherit(E, e.Dynamics.Joints.b2JointDef), E.prototype.__super = e.Dynamics.Joints.b2JointDef.prototype, E.b2WeldJointDef = function () {
        e.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments), this.localAnchorA = new o, this.localAnchorB = new o;
      }, E.prototype.b2WeldJointDef = function () {
        this.__super.b2JointDef.call(this), this.type = d.e_weldJoint, this.referenceAngle = 0;
      }, E.prototype.Initialize = function (t, e, i) {
        this.bodyA = t, this.bodyB = e, this.localAnchorA.SetV(this.bodyA.GetLocalPoint(i)), this.localAnchorB.SetV(this.bodyB.GetLocalPoint(i)), this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle();
      };
    }(), (O = e.Dynamics.b2DebugDraw).b2DebugDraw = function () {
      this.m_drawScale = 1, this.m_lineThickness = 1, this.m_alpha = 1, this.m_fillAlpha = 1, this.m_xformScale = 1, this.m_sprite = {graphics: {clear: function () {}}};
    }, O.prototype._color = function (t, e) {
      return "rgba(" + ((16711680 & t) >> 16) + "," + ((65280 & t) >> 8) + "," + (255 & t) + "," + e + ")";
    }, O.prototype.b2DebugDraw = function () {
      this.m_drawFlags = 0;
    }, O.prototype.SetFlags = function (t) {
      void 0 === t && (t = 0), this.m_drawFlags = t;
    }, O.prototype.GetFlags = function () {
      return this.m_drawFlags;
    }, O.prototype.AppendFlags = function (t) {
      void 0 === t && (t = 0), this.m_drawFlags |= t;
    }, O.prototype.ClearFlags = function (t) {
      void 0 === t && (t = 0), this.m_drawFlags &= ~t;
    }, O.prototype.SetSprite = function (t) {
      this.m_ctx = t;
    }, O.prototype.GetSprite = function () {
      return this.m_ctx;
    }, O.prototype.SetDrawScale = function (t) {
      void 0 === t && (t = 0), this.m_drawScale = t;
    }, O.prototype.GetDrawScale = function () {
      return this.m_drawScale;
    }, O.prototype.SetLineThickness = function (t) {
      void 0 === t && (t = 0), this.m_lineThickness = t, this.m_ctx.strokeWidth = t;
    }, O.prototype.GetLineThickness = function () {
      return this.m_lineThickness;
    }, O.prototype.SetAlpha = function (t) {
      void 0 === t && (t = 0), this.m_alpha = t;
    }, O.prototype.GetAlpha = function () {
      return this.m_alpha;
    }, O.prototype.SetFillAlpha = function (t) {
      void 0 === t && (t = 0), this.m_fillAlpha = t;
    }, O.prototype.GetFillAlpha = function () {
      return this.m_fillAlpha;
    }, O.prototype.SetXFormScale = function (t) {
      void 0 === t && (t = 0), this.m_xformScale = t;
    }, O.prototype.GetXFormScale = function () {
      return this.m_xformScale;
    }, O.prototype.DrawPolygon = function (t, e, i) {
      if (e) {
        var n = this.m_ctx, r = this.m_drawScale;
        n.beginPath(), n.strokeStyle = this._color(i.color, this.m_alpha), n.moveTo(t[0].x * r, t[0].y * r);
        for (var o = 1; o < e; o++) n.lineTo(t[o].x * r, t[o].y * r);
        n.lineTo(t[0].x * r, t[0].y * r), n.closePath(), n.stroke();
      }
    }, O.prototype.DrawSolidPolygon = function (t, e, i) {
      if (e) {
        var n = this.m_ctx, r = this.m_drawScale;
        n.beginPath(), n.strokeStyle = this._color(i.color, this.m_alpha), n.fillStyle = this._color(i.color, this.m_fillAlpha), n.moveTo(t[0].x * r, t[0].y * r);
        for (var o = 1; o < e; o++) n.lineTo(t[o].x * r, t[o].y * r);
        n.lineTo(t[0].x * r, t[0].y * r), n.closePath(), n.fill(), n.stroke();
      }
    }, O.prototype.DrawCircle = function (t, e, i) {
      if (e) {
        var n = this.m_ctx, r = this.m_drawScale;
        n.beginPath(), n.strokeStyle = this._color(i.color, this.m_alpha), n.arc(t.x * r, t.y * r, e * r, 0, 2 * Math.PI, true), n.closePath(), n.stroke();
      }
    }, O.prototype.DrawSolidCircle = function (t, e, i, n) {
      if (e) {
        var r = this.m_ctx, o = this.m_drawScale, s = t.x * o, a = t.y * o;
        r.moveTo(0, 0), r.beginPath(), r.strokeStyle = this._color(n.color, this.m_alpha), r.fillStyle = this._color(n.color, this.m_fillAlpha), r.arc(s, a, e * o, 0, 2 * Math.PI, true), r.moveTo(s, a), r.lineTo((t.x + i.x * e) * o, (t.y + i.y * e) * o), r.closePath(), r.fill(), r.stroke();
      }
    }, O.prototype.DrawSegment = function (t, e, i) {
      var n = this.m_ctx, r = this.m_drawScale;
      n.strokeStyle = this._color(i.color, this.m_alpha), n.beginPath(), n.moveTo(t.x * r, t.y * r), n.lineTo(e.x * r, e.y * r), n.closePath(), n.stroke();
    }, O.prototype.DrawTransform = function (t) {
      var e = this.m_ctx, i = this.m_drawScale;
      e.beginPath(), e.strokeStyle = this._color(16711680, this.m_alpha), e.moveTo(t.position.x * i, t.position.y * i), e.lineTo((t.position.x + this.m_xformScale * t.R.col1.x) * i, (t.position.y + this.m_xformScale * t.R.col1.y) * i), e.strokeStyle = this._color(65280, this.m_alpha), e.moveTo(t.position.x * i, t.position.y * i), e.lineTo((t.position.x + this.m_xformScale * t.R.col2.x) * i, (t.position.y + this.m_xformScale * t.R.col2.y) * i), e.closePath(), e.stroke();
    }, U = 0; U < e.postDefs.length; ++U) e.postDefs[U]();
    t.exports = e;
  }}, e = {};
  function i(n) {
    var r = e[n];
    if (void 0 !== r) return r.exports;
    var o = e[n] = {exports: {}};
    return t[n](o, o.exports, i), o.exports;
  }
  (() => {
    function t(t, e) {
      if (!Object.prototype.hasOwnProperty.call(t, e)) throw new TypeError("attempted to use private field on non-instance");
      return t;
    }
    var e = 0;
    function r() {
      return (r = Object.assign || function (t) {
        for (var e = 1; e < arguments.length; e++) {
          var i = arguments[e];
          for (var n in i) Object.prototype.hasOwnProperty.call(i, n) && (t[n] = i[n]);
        }
        return t;
      }).apply(this, arguments);
    }
    const o = 100, s = 301, a = 302, l = 303, c = 304, h = 306, u = 307, m = 1e3, p = 1001, d = 1002, f = 1003, _ = 1004, y = 1005, g = 1006, x = 1008, v = 1009, b = 1012, w = 1014, S = 1015, M = 1016, C = 1020, A = 1022, T = 1023, E = 1026, L = 1027, D = 2300, V = 2301, B = 2302, R = 2400, P = 2401, I = 2402, F = 2500, G = 3e3, N = 3001, z = 3007, O = 3002, U = 7680, k = 35044, H = 35048, W = "300 es";
    class EventDispatcher {
      addEventListener(t, e) {
        void 0 === this._listeners && (this._listeners = {});
        const i = this._listeners;
        void 0 === i[t] && (i[t] = []), -1 === i[t].indexOf(e) && i[t].push(e);
      }
      hasEventListener(t, e) {
        if (void 0 === this._listeners) return false;
        const i = this._listeners;
        return void 0 !== i[t] && -1 !== i[t].indexOf(e);
      }
      removeEventListener(t, e) {
        if (void 0 === this._listeners) return;
        const i = this._listeners[t];
        if (void 0 !== i) {
          const t = i.indexOf(e);
          -1 !== t && i.splice(t, 1);
        }
      }
      dispatchEvent(t) {
        if (void 0 === this._listeners) return;
        const e = this._listeners[t.type];
        if (void 0 !== e) {
          t.target = this;
          const i = e.slice(0);
          for (let e = 0, n = i.length; e < n; e++) i[e].call(this, t);
          t.target = null;
        }
      }
    }
    const J = [];
    for (let t = 0; t < 256; t++) J[t] = (t < 16 ? "0" : "") + t.toString(16);
    const j = Math.PI / 180, X = 180 / Math.PI;
    function q() {
      const t = 4294967295 * Math.random() | 0, e = 4294967295 * Math.random() | 0, i = 4294967295 * Math.random() | 0, n = 4294967295 * Math.random() | 0;
      return (J[255 & t] + J[t >> 8 & 255] + J[t >> 16 & 255] + J[t >> 24 & 255] + "-" + J[255 & e] + J[e >> 8 & 255] + "-" + J[e >> 16 & 15 | 64] + J[e >> 24 & 255] + "-" + J[63 & i | 128] + J[i >> 8 & 255] + "-" + J[i >> 16 & 255] + J[i >> 24 & 255] + J[255 & n] + J[n >> 8 & 255] + J[n >> 16 & 255] + J[n >> 24 & 255]).toUpperCase();
    }
    class Vector2 {
      constructor(t = 0, e = 0) {
        this.x = t, this.y = e;
      }
      get width() {
        return this.x;
      }
      set width (t) {
        this.x = t;
      }
      get height() {
        return this.y;
      }
      set height (t) {
        this.y = t;
      }
      set(t, e) {
        return this.x = t, this.y = e, this;
      }
      setScalar(t) {
        return this.x = t, this.y = t, this;
      }
      setX(t) {
        return this.x = t, this;
      }
      setY(t) {
        return this.y = t, this;
      }
      setComponent(t, e) {
        switch (t) {
          case 0:
            this.x = e;
            break;
          case 1:
            this.y = e;
            break;
          default:
            throw new Error("index is out of range: " + t);
        }
        return this;
      }
      getComponent(t) {
        switch (t) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          default:
            throw new Error("index is out of range: " + t);
        }
      }
      clone() {
        return new this.constructor(this.x, this.y);
      }
      copy(t) {
        return this.x = t.x, this.y = t.y, this;
      }
      add(t, e) {
        return void 0 !== e ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this);
      }
      addScalar(t) {
        return this.x += t, this.y += t, this;
      }
      addVectors(t, e) {
        return this.x = t.x + e.x, this.y = t.y + e.y, this;
      }
      addScaledVector(t, e) {
        return this.x += t.x * e, this.y += t.y * e, this;
      }
      sub(t, e) {
        return void 0 !== e ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this);
      }
      subScalar(t) {
        return this.x -= t, this.y -= t, this;
      }
      subVectors(t, e) {
        return this.x = t.x - e.x, this.y = t.y - e.y, this;
      }
      multiply(t) {
        return this.x *= t.x, this.y *= t.y, this;
      }
      multiplyScalar(t) {
        return this.x *= t, this.y *= t, this;
      }
      divide(t) {
        return this.x /= t.x, this.y /= t.y, this;
      }
      divideScalar(t) {
        return this.multiplyScalar(1 / t);
      }
      applyMatrix3(t) {
        const e = this.x, i = this.y, n = t.elements;
        return this.x = n[0] * e + n[3] * i + n[6], this.y = n[1] * e + n[4] * i + n[7], this;
      }
      min(t) {
        return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this;
      }
      max(t) {
        return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this;
      }
      clamp(t, e) {
        return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this;
      }
      clampScalar(t, e) {
        return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this;
      }
      clampLength(t, e) {
        const i = this.length();
        return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)));
      }
      floor() {
        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
      }
      ceil() {
        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
      }
      round() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
      }
      roundToZero() {
        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this;
      }
      negate() {
        return this.x = -this.x, this.y = -this.y, this;
      }
      dot(t) {
        return this.x * t.x + this.y * t.y;
      }
      cross(t) {
        return this.x * t.y - this.y * t.x;
      }
      lengthSq() {
        return this.x * this.x + this.y * this.y;
      }
      length() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      }
      manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y);
      }
      normalize() {
        return this.divideScalar(this.length() || 1);
      }
      angle() {
        return Math.atan2(-this.y, -this.x) + Math.PI;
      }
      distanceTo(t) {
        return Math.sqrt(this.distanceToSquared(t));
      }
      distanceToSquared(t) {
        const e = this.x - t.x, i = this.y - t.y;
        return e * e + i * i;
      }
      manhattanDistanceTo(t) {
        return Math.abs(this.x - t.x) + Math.abs(this.y - t.y);
      }
      setLength(t) {
        return this.normalize().multiplyScalar(t);
      }
      lerp(t, e) {
        return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this;
      }
      lerpVectors(t, e, i) {
        return this.x = t.x + (e.x - t.x) * i, this.y = t.y + (e.y - t.y) * i, this;
      }
      equals(t) {
        return t.x === this.x && t.y === this.y;
      }
      fromArray(t, e = 0) {
        return this.x = t[e], this.y = t[e + 1], this;
      }
      toArray(t = [], e = 0) {
        return t[e] = this.x, t[e + 1] = this.y, t;
      }
      fromBufferAttribute(t, e, i) {
        return void 0 !== i && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this;
      }
      rotateAround(t, e) {
        const i = Math.cos(e), n = Math.sin(e), r = this.x - t.x, o = this.y - t.y;
        return this.x = r * i - o * n + t.x, this.y = r * n + o * i + t.y, this;
      }
      random() {
        return this.x = Math.random(), this.y = Math.random(), this;
      }
    }
    Vector2.prototype.isVector2 = true;
    class Matrix3 {
      constructor() {
        this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.");
      }
      set(t, e, i, n, r, o, s, a, l) {
        const c = this.elements;
        return c[0] = t, c[1] = n, c[2] = s, c[3] = e, c[4] = r, c[5] = a, c[6] = i, c[7] = o, c[8] = l, this;
      }
      identity() {
        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
      }
      copy(t) {
        const e = this.elements, i = t.elements;
        return e[0] = i[0], e[1] = i[1], e[2] = i[2], e[3] = i[3], e[4] = i[4], e[5] = i[5], e[6] = i[6], e[7] = i[7], e[8] = i[8], this;
      }
      extractBasis(t, e, i) {
        return t.setFromMatrix3Column(this, 0), e.setFromMatrix3Column(this, 1), i.setFromMatrix3Column(this, 2), this;
      }
      setFromMatrix4(t) {
        const e = t.elements;
        return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this;
      }
      multiply(t) {
        return this.multiplyMatrices(this, t);
      }
      premultiply(t) {
        return this.multiplyMatrices(t, this);
      }
      multiplyMatrices(t, e) {
        const i = t.elements, n = e.elements, r = this.elements, o = i[0], s = i[3], a = i[6], l = i[1], c = i[4], h = i[7], u = i[2], m = i[5], p = i[8], d = n[0], f = n[3], _ = n[6], y = n[1], g = n[4], x = n[7], v = n[2], b = n[5], w = n[8];
        return r[0] = o * d + s * y + a * v, r[3] = o * f + s * g + a * b, r[6] = o * _ + s * x + a * w, r[1] = l * d + c * y + h * v, r[4] = l * f + c * g + h * b, r[7] = l * _ + c * x + h * w, r[2] = u * d + m * y + p * v, r[5] = u * f + m * g + p * b, r[8] = u * _ + m * x + p * w, this;
      }
      multiplyScalar(t) {
        const e = this.elements;
        return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this;
      }
      determinant() {
        const t = this.elements, e = t[0], i = t[1], n = t[2], r = t[3], o = t[4], s = t[5], a = t[6], l = t[7], c = t[8];
        return e * o * c - e * s * l - i * r * c + i * s * a + n * r * l - n * o * a;
      }
      invert() {
        const t = this.elements, e = t[0], i = t[1], n = t[2], r = t[3], o = t[4], s = t[5], a = t[6], l = t[7], c = t[8], h = c * o - s * l, u = s * a - c * r, m = l * r - o * a, p = e * h + i * u + n * m;
        if (0 === p) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        const d = 1 / p;
        return t[0] = h * d, t[1] = (n * l - c * i) * d, t[2] = (s * i - n * o) * d, t[3] = u * d, t[4] = (c * e - n * a) * d, t[5] = (n * r - s * e) * d, t[6] = m * d, t[7] = (i * a - l * e) * d, t[8] = (o * e - i * r) * d, this;
      }
      transpose() {
        let t;
        const e = this.elements;
        return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this;
      }
      getNormalMatrix(t) {
        return this.setFromMatrix4(t).invert().transpose();
      }
      transposeIntoArray(t) {
        const e = this.elements;
        return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this;
      }
      setUvTransform(t, e, i, n, r, o, s) {
        const a = Math.cos(r), l = Math.sin(r);
        return this.set(i * a, i * l, -i * (a * o + l * s) + o + t, -n * l, n * a, -n * (-l * o + a * s) + s + e, 0, 0, 1), this;
      }
      scale(t, e) {
        const i = this.elements;
        return i[0] *= t, i[3] *= t, i[6] *= t, i[1] *= e, i[4] *= e, i[7] *= e, this;
      }
      rotate(t) {
        const e = Math.cos(t), i = Math.sin(t), n = this.elements, r = n[0], o = n[3], s = n[6], a = n[1], l = n[4], c = n[7];
        return n[0] = e * r + i * a, n[3] = e * o + i * l, n[6] = e * s + i * c, n[1] = -i * r + e * a, n[4] = -i * o + e * l, n[7] = -i * s + e * c, this;
      }
      translate(t, e) {
        const i = this.elements;
        return i[0] += t * i[2], i[3] += t * i[5], i[6] += t * i[8], i[1] += e * i[2], i[4] += e * i[5], i[7] += e * i[8], this;
      }
      equals(t) {
        const e = this.elements, i = t.elements;
        for (let t = 0; t < 9; t++) if (e[t] !== i[t]) return false;
        return true;
      }
      fromArray(t, e = 0) {
        for (let i = 0; i < 9; i++) this.elements[i] = t[i + e];
        return this;
      }
      toArray(t = [], e = 0) {
        const i = this.elements;
        return t[e] = i[0], t[e + 1] = i[1], t[e + 2] = i[2], t[e + 3] = i[3], t[e + 4] = i[4], t[e + 5] = i[5], t[e + 6] = i[6], t[e + 7] = i[7], t[e + 8] = i[8], t;
      }
      clone() {
        return (new this.constructor).fromArray(this.elements);
      }
    }
    let tt;
    Matrix3.prototype.isMatrix3 = true;
    class ImageUtils {
      static getDataURL(t) {
        if (/^data:/i.test(t.src)) return t.src;
        if ("undefined" == typeof HTMLCanvasElement) return t.src;
        let e;
        if (t instanceof HTMLCanvasElement) e = t; else {
          void 0 === tt && (tt = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), tt.width = t.width, tt.height = t.height;
          const i = tt.getContext("2d");
          t instanceof ImageData ? i.putImageData(t, 0, 0) : i.drawImage(t, 0, 0, t.width, t.height), e = tt;
        }
        return e.width > 2048 || e.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", t), e.toDataURL("image/jpeg", 0.6)) : e.toDataURL("image/png");
      }
    }
    let et = 0;
    class Texture extends EventDispatcher {
      constructor(t = Texture.DEFAULT_IMAGE, e = Texture.DEFAULT_MAPPING, i = 1001, n = 1001, r = 1006, o = 1008, s = 1023, a = 1009, l = 1, c = 3e3) {
        super(), Object.defineProperty(this, "id", {value: et++}), this.uuid = q(), this.name = "", this.image = t, this.mipmaps = [], this.mapping = e, this.wrapS = i, this.wrapT = n, this.magFilter = r, this.minFilter = o, this.anisotropy = l, this.format = s, this.internalFormat = null, this.type = a, this.offset = new Vector2(0, 0), this.repeat = new Vector2(1, 1), this.center = new Vector2(0, 0), this.rotation = 0, this.matrixAutoUpdate = true, this.matrix = new Matrix3, this.generateMipmaps = true, this.premultiplyAlpha = false, this.flipY = true, this.unpackAlignment = 4, this.encoding = c, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = false;
      }
      updateMatrix() {
        this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
      }
      clone() {
        return (new this.constructor).copy(this);
      }
      copy(t) {
        return this.name = t.name, this.image = t.image, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.internalFormat = t.internalFormat, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.encoding = t.encoding, this;
      }
      toJSON(t) {
        const e = void 0 === t || "string" == typeof t;
        if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid];
        const i = {metadata: {version: 4.5, type: "Texture", generator: "Texture.toJSON"}, uuid: this.uuid, name: this.name, mapping: this.mapping, repeat: [this.repeat.x, this.repeat.y], offset: [this.offset.x, this.offset.y], center: [this.center.x, this.center.y], rotation: this.rotation, wrap: [this.wrapS, this.wrapT], format: this.format, type: this.type, encoding: this.encoding, minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY, premultiplyAlpha: this.premultiplyAlpha, unpackAlignment: this.unpackAlignment};
        if (void 0 !== this.image) {
          const n = this.image;
          if (void 0 === n.uuid && (n.uuid = q()), !e && void 0 === t.images[n.uuid]) {
            let e;
            if (Array.isArray(n)) {
              e = [];
              for (let t = 0, i = n.length; t < i; t++) n[t].isDataTexture ? e.push(it(n[t].image)) : e.push(it(n[t]));
            } else e = it(n);
            t.images[n.uuid] = {uuid: n.uuid, url: e};
          }
          i.image = n.uuid;
        }
        return e || (t.textures[this.uuid] = i), i;
      }
      dispose() {
        this.dispatchEvent({type: "dispose"});
      }
      transformUv(t) {
        if (300 !== this.mapping) return t;
        if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1) switch (this.wrapS) {
          case m:
            t.x = t.x - Math.floor(t.x);
            break;
          case p:
            t.x = t.x < 0 ? 0 : 1;
            break;
          case d:
            1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x);
        }
        if (t.y < 0 || t.y > 1) switch (this.wrapT) {
          case m:
            t.y = t.y - Math.floor(t.y);
            break;
          case p:
            t.y = t.y < 0 ? 0 : 1;
            break;
          case d:
            1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y);
        }
        return this.flipY && (t.y = 1 - t.y), t;
      }
      set needsUpdate (t) {
        true === t && this.version++;
      }
    }
    function it(t) {
      return "undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap ? ImageUtils.getDataURL(t) : t.data ? {data: Array.prototype.slice.call(t.data), width: t.width, height: t.height, type: t.data.constructor.name} : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
    }
    Texture.DEFAULT_IMAGE = void 0, Texture.DEFAULT_MAPPING = 300, Texture.prototype.isTexture = true;
    class Vector4 {
      constructor(t = 0, e = 0, i = 0, n = 1) {
        this.x = t, this.y = e, this.z = i, this.w = n;
      }
      get width() {
        return this.z;
      }
      set width (t) {
        this.z = t;
      }
      get height() {
        return this.w;
      }
      set height (t) {
        this.w = t;
      }
      set(t, e, i, n) {
        return this.x = t, this.y = e, this.z = i, this.w = n, this;
      }
      setScalar(t) {
        return this.x = t, this.y = t, this.z = t, this.w = t, this;
      }
      setX(t) {
        return this.x = t, this;
      }
      setY(t) {
        return this.y = t, this;
      }
      setZ(t) {
        return this.z = t, this;
      }
      setW(t) {
        return this.w = t, this;
      }
      setComponent(t, e) {
        switch (t) {
          case 0:
            this.x = e;
            break;
          case 1:
            this.y = e;
            break;
          case 2:
            this.z = e;
            break;
          case 3:
            this.w = e;
            break;
          default:
            throw new Error("index is out of range: " + t);
        }
        return this;
      }
      getComponent(t) {
        switch (t) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          case 2:
            return this.z;
          case 3:
            return this.w;
          default:
            throw new Error("index is out of range: " + t);
        }
      }
      clone() {
        return new this.constructor(this.x, this.y, this.z, this.w);
      }
      copy(t) {
        return this.x = t.x, this.y = t.y, this.z = t.z, this.w = void 0 !== t.w ? t.w : 1, this;
      }
      add(t, e) {
        return void 0 !== e ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this);
      }
      addScalar(t) {
        return this.x += t, this.y += t, this.z += t, this.w += t, this;
      }
      addVectors(t, e) {
        return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this;
      }
      addScaledVector(t, e) {
        return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this;
      }
      sub(t, e) {
        return void 0 !== e ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this);
      }
      subScalar(t) {
        return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this;
      }
      subVectors(t, e) {
        return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this;
      }
      multiply(t) {
        return this.x *= t.x, this.y *= t.y, this.z *= t.z, this.w *= t.w, this;
      }
      multiplyScalar(t) {
        return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this;
      }
      applyMatrix4(t) {
        const e = this.x, i = this.y, n = this.z, r = this.w, o = t.elements;
        return this.x = o[0] * e + o[4] * i + o[8] * n + o[12] * r, this.y = o[1] * e + o[5] * i + o[9] * n + o[13] * r, this.z = o[2] * e + o[6] * i + o[10] * n + o[14] * r, this.w = o[3] * e + o[7] * i + o[11] * n + o[15] * r, this;
      }
      divideScalar(t) {
        return this.multiplyScalar(1 / t);
      }
      setAxisAngleFromQuaternion(t) {
        this.w = 2 * Math.acos(t.w);
        const e = Math.sqrt(1 - t.w * t.w);
        return e < 0.0001 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this;
      }
      setAxisAngleFromRotationMatrix(t) {
        let e, i, n, r;
        const o = 0.01, s = 0.1, a = t.elements, l = a[0], c = a[4], h = a[8], u = a[1], m = a[5], p = a[9], d = a[2], f = a[6], _ = a[10];
        if (Math.abs(c - u) < o && Math.abs(h - d) < o && Math.abs(p - f) < o) {
          if (Math.abs(c + u) < s && Math.abs(h + d) < s && Math.abs(p + f) < s && Math.abs(l + m + _ - 3) < s) return this.set(1, 0, 0, 0), this;
          e = Math.PI;
          const t = (l + 1) / 2, a = (m + 1) / 2, y = (_ + 1) / 2, g = (c + u) / 4, x = (h + d) / 4, v = (p + f) / 4;
          return t > a && t > y ? t < o ? (i = 0, n = 0.707106781, r = 0.707106781) : (i = Math.sqrt(t), n = g / i, r = x / i) : a > y ? a < o ? (i = 0.707106781, n = 0, r = 0.707106781) : (n = Math.sqrt(a), i = g / n, r = v / n) : y < o ? (i = 0.707106781, n = 0.707106781, r = 0) : (r = Math.sqrt(y), i = x / r, n = v / r), this.set(i, n, r, e), this;
        }
        let y = Math.sqrt((f - p) * (f - p) + (h - d) * (h - d) + (u - c) * (u - c));
        return Math.abs(y) < 0.001 && (y = 1), this.x = (f - p) / y, this.y = (h - d) / y, this.z = (u - c) / y, this.w = Math.acos((l + m + _ - 1) / 2), this;
      }
      min(t) {
        return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this;
      }
      max(t) {
        return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this;
      }
      clamp(t, e) {
        return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this;
      }
      clampScalar(t, e) {
        return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this.w = Math.max(t, Math.min(e, this.w)), this;
      }
      clampLength(t, e) {
        const i = this.length();
        return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)));
      }
      floor() {
        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
      }
      ceil() {
        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
      }
      round() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
      }
      roundToZero() {
        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this;
      }
      negate() {
        return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
      }
      dot(t) {
        return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w;
      }
      lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
      }
      length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
      }
      manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
      }
      normalize() {
        return this.divideScalar(this.length() || 1);
      }
      setLength(t) {
        return this.normalize().multiplyScalar(t);
      }
      lerp(t, e) {
        return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this;
      }
      lerpVectors(t, e, i) {
        return this.x = t.x + (e.x - t.x) * i, this.y = t.y + (e.y - t.y) * i, this.z = t.z + (e.z - t.z) * i, this.w = t.w + (e.w - t.w) * i, this;
      }
      equals(t) {
        return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w;
      }
      fromArray(t, e = 0) {
        return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this;
      }
      toArray(t = [], e = 0) {
        return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t;
      }
      fromBufferAttribute(t, e, i) {
        return void 0 !== i && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this;
      }
      random() {
        return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
      }
    }
    Vector4.prototype.isVector4 = true;
    class WebGLRenderTarget extends EventDispatcher {
      constructor(t, e, i = {}) {
        super(), this.width = t, this.height = e, this.depth = 1, this.scissor = new Vector4(0, 0, t, e), this.scissorTest = false, this.viewport = new Vector4(0, 0, t, e), this.texture = new Texture(void 0, i.mapping, i.wrapS, i.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i.encoding), this.texture.isRenderTargetTexture = true, this.texture.image = {width: t, height: e, depth: 1}, this.texture.generateMipmaps = void 0 !== i.generateMipmaps && i.generateMipmaps, this.texture.internalFormat = void 0 !== i.internalFormat ? i.internalFormat : null, this.texture.minFilter = void 0 !== i.minFilter ? i.minFilter : g, this.depthBuffer = void 0 === i.depthBuffer || i.depthBuffer, this.stencilBuffer = void 0 !== i.stencilBuffer && i.stencilBuffer, this.depthTexture = void 0 !== i.depthTexture ? i.depthTexture : null;
      }
      setTexture(t) {
        t.image = {width: this.width, height: this.height, depth: this.depth}, this.texture = t;
      }
      setSize(t, e, i = 1) {
        this.width === t && this.height === e && this.depth === i || (this.width = t, this.height = e, this.depth = i, this.texture.image.width = t, this.texture.image.height = e, this.texture.image.depth = i, this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e);
      }
      clone() {
        return (new this.constructor).copy(this);
      }
      copy(t) {
        return this.width = t.width, this.height = t.height, this.depth = t.depth, this.viewport.copy(t.viewport), this.texture = t.texture.clone(), this.texture.image = r({}, this.texture.image), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t.depthTexture, this;
      }
      dispose() {
        this.dispatchEvent({type: "dispose"});
      }
    }
    WebGLRenderTarget.prototype.isWebGLRenderTarget = true;
    (class WebGLMultipleRenderTargets extends WebGLRenderTarget {
      constructor(t, e, i) {
        super(t, e);
        const n = this.texture;
        this.texture = [];
        for (let t = 0; t < i; t++) this.texture[t] = n.clone();
      }
      setSize(t, e, i = 1) {
        if (this.width !== t || this.height !== e || this.depth !== i) {
          this.width = t, this.height = e, this.depth = i;
          for (let n = 0, r = this.texture.length; n < r; n++) this.texture[n].image.width = t, this.texture[n].image.height = e, this.texture[n].image.depth = i;
          this.dispose();
        }
        return this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e), this;
      }
      copy(t) {
        this.dispose(), this.width = t.width, this.height = t.height, this.depth = t.depth, this.viewport.set(0, 0, this.width, this.height), this.scissor.set(0, 0, this.width, this.height), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t.depthTexture, this.texture.length = 0;
        for (let e = 0, i = t.texture.length; e < i; e++) this.texture[e] = t.texture[e].clone();
        return this;
      }
    }.prototype.isWebGLMultipleRenderTargets = true);
    class WebGLMultisampleRenderTarget extends WebGLRenderTarget {
      constructor(t, e, i) {
        super(t, e, i), this.samples = 4;
      }
      copy(t) {
        return super.copy.call(this, t), this.samples = t.samples, this;
      }
    }
    WebGLMultisampleRenderTarget.prototype.isWebGLMultisampleRenderTarget = true;
    class Quaternion {
      constructor(t = 0, e = 0, i = 0, n = 1) {
        this._x = t, this._y = e, this._z = i, this._w = n;
      }
      static slerp(t, e, i, n) {
        return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."), i.slerpQuaternions(t, e, n);
      }
      static slerpFlat(t, e, i, n, r, o, s) {
        let a = i[n + 0], l = i[n + 1], c = i[n + 2], h = i[n + 3];
        const u = r[o + 0], m = r[o + 1], p = r[o + 2], d = r[o + 3];
        if (0 === s) return t[e + 0] = a, t[e + 1] = l, t[e + 2] = c, void (t[e + 3] = h);
        if (1 === s) return t[e + 0] = u, t[e + 1] = m, t[e + 2] = p, void (t[e + 3] = d);
        if (h !== d || a !== u || l !== m || c !== p) {
          let t = 1 - s;
          const e = a * u + l * m + c * p + h * d, i = e >= 0 ? 1 : -1, n = 1 - e * e;
          if (n > Number.EPSILON) {
            const r = Math.sqrt(n), o = Math.atan2(r, e * i);
            t = Math.sin(t * o) / r, s = Math.sin(s * o) / r;
          }
          const r = s * i;
          if (a = a * t + u * r, l = l * t + m * r, c = c * t + p * r, h = h * t + d * r, t === 1 - s) {
            const t = 1 / Math.sqrt(a * a + l * l + c * c + h * h);
            a *= t, l *= t, c *= t, h *= t;
          }
        }
        t[e] = a, t[e + 1] = l, t[e + 2] = c, t[e + 3] = h;
      }
      static multiplyQuaternionsFlat(t, e, i, n, r, o) {
        const s = i[n], a = i[n + 1], l = i[n + 2], c = i[n + 3], h = r[o], u = r[o + 1], m = r[o + 2], p = r[o + 3];
        return t[e] = s * p + c * h + a * m - l * u, t[e + 1] = a * p + c * u + l * h - s * m, t[e + 2] = l * p + c * m + s * u - a * h, t[e + 3] = c * p - s * h - a * u - l * m, t;
      }
      get x() {
        return this._x;
      }
      set x (t) {
        this._x = t, this._onChangeCallback();
      }
      get y() {
        return this._y;
      }
      set y (t) {
        this._y = t, this._onChangeCallback();
      }
      get z() {
        return this._z;
      }
      set z (t) {
        this._z = t, this._onChangeCallback();
      }
      get w() {
        return this._w;
      }
      set w (t) {
        this._w = t, this._onChangeCallback();
      }
      set(t, e, i, n) {
        return this._x = t, this._y = e, this._z = i, this._w = n, this._onChangeCallback(), this;
      }
      clone() {
        return new this.constructor(this._x, this._y, this._z, this._w);
      }
      copy(t) {
        return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this._onChangeCallback(), this;
      }
      setFromEuler(t, e) {
        if (!t || !t.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
        const i = t._x, n = t._y, r = t._z, o = t._order, s = Math.cos, a = Math.sin, l = s(i / 2), c = s(n / 2), h = s(r / 2), u = a(i / 2), m = a(n / 2), p = a(r / 2);
        switch (o) {
          case "XYZ":
            this._x = u * c * h + l * m * p, this._y = l * m * h - u * c * p, this._z = l * c * p + u * m * h, this._w = l * c * h - u * m * p;
            break;
          case "YXZ":
            this._x = u * c * h + l * m * p, this._y = l * m * h - u * c * p, this._z = l * c * p - u * m * h, this._w = l * c * h + u * m * p;
            break;
          case "ZXY":
            this._x = u * c * h - l * m * p, this._y = l * m * h + u * c * p, this._z = l * c * p + u * m * h, this._w = l * c * h - u * m * p;
            break;
          case "ZYX":
            this._x = u * c * h - l * m * p, this._y = l * m * h + u * c * p, this._z = l * c * p - u * m * h, this._w = l * c * h + u * m * p;
            break;
          case "YZX":
            this._x = u * c * h + l * m * p, this._y = l * m * h + u * c * p, this._z = l * c * p - u * m * h, this._w = l * c * h - u * m * p;
            break;
          case "XZY":
            this._x = u * c * h - l * m * p, this._y = l * m * h - u * c * p, this._z = l * c * p + u * m * h, this._w = l * c * h + u * m * p;
            break;
          default:
            console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o);
        }
        return false !== e && this._onChangeCallback(), this;
      }
      setFromAxisAngle(t, e) {
        const i = e / 2, n = Math.sin(i);
        return this._x = t.x * n, this._y = t.y * n, this._z = t.z * n, this._w = Math.cos(i), this._onChangeCallback(), this;
      }
      setFromRotationMatrix(t) {
        const e = t.elements, i = e[0], n = e[4], r = e[8], o = e[1], s = e[5], a = e[9], l = e[2], c = e[6], h = e[10], u = i + s + h;
        if (u > 0) {
          const t = 0.5 / Math.sqrt(u + 1);
          this._w = 0.25 / t, this._x = (c - a) * t, this._y = (r - l) * t, this._z = (o - n) * t;
        } else if (i > s && i > h) {
          const t = 2 * Math.sqrt(1 + i - s - h);
          this._w = (c - a) / t, this._x = 0.25 * t, this._y = (n + o) / t, this._z = (r + l) / t;
        } else if (s > h) {
          const t = 2 * Math.sqrt(1 + s - i - h);
          this._w = (r - l) / t, this._x = (n + o) / t, this._y = 0.25 * t, this._z = (a + c) / t;
        } else {
          const t = 2 * Math.sqrt(1 + h - i - s);
          this._w = (o - n) / t, this._x = (r + l) / t, this._y = (a + c) / t, this._z = 0.25 * t;
        }
        return this._onChangeCallback(), this;
      }
      setFromUnitVectors(t, e) {
        let i = t.dot(e) + 1;
        return i < Number.EPSILON ? (i = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0, this._w = i) : (this._x = 0, this._y = -t.z, this._z = t.y, this._w = i)) : (this._x = t.y * e.z - t.z * e.y, this._y = t.z * e.x - t.x * e.z, this._z = t.x * e.y - t.y * e.x, this._w = i), this.normalize();
      }
      angleTo(t) {
        return 2 * Math.acos(Math.abs(Math.max(-1, Math.min(1, this.dot(t)))));
      }
      rotateTowards(t, e) {
        const i = this.angleTo(t);
        if (0 === i) return this;
        const n = Math.min(1, e / i);
        return this.slerp(t, n), this;
      }
      identity() {
        return this.set(0, 0, 0, 1);
      }
      invert() {
        return this.conjugate();
      }
      conjugate() {
        return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
      }
      dot(t) {
        return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w;
      }
      lengthSq() {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
      }
      length() {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
      }
      normalize() {
        let t = this.length();
        return 0 === t ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this._onChangeCallback(), this;
      }
      multiply(t, e) {
        return void 0 !== e ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(t, e)) : this.multiplyQuaternions(this, t);
      }
      premultiply(t) {
        return this.multiplyQuaternions(t, this);
      }
      multiplyQuaternions(t, e) {
        const i = t._x, n = t._y, r = t._z, o = t._w, s = e._x, a = e._y, l = e._z, c = e._w;
        return this._x = i * c + o * s + n * l - r * a, this._y = n * c + o * a + r * s - i * l, this._z = r * c + o * l + i * a - n * s, this._w = o * c - i * s - n * a - r * l, this._onChangeCallback(), this;
      }
      slerp(t, e) {
        if (0 === e) return this;
        if (1 === e) return this.copy(t);
        const i = this._x, n = this._y, r = this._z, o = this._w;
        let s = o * t._w + i * t._x + n * t._y + r * t._z;
        if (s < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, s = -s) : this.copy(t), s >= 1) return this._w = o, this._x = i, this._y = n, this._z = r, this;
        const a = 1 - s * s;
        if (a <= Number.EPSILON) {
          const t = 1 - e;
          return this._w = t * o + e * this._w, this._x = t * i + e * this._x, this._y = t * n + e * this._y, this._z = t * r + e * this._z, this.normalize(), this._onChangeCallback(), this;
        }
        const l = Math.sqrt(a), c = Math.atan2(l, s), h = Math.sin((1 - e) * c) / l, u = Math.sin(e * c) / l;
        return this._w = o * h + this._w * u, this._x = i * h + this._x * u, this._y = n * h + this._y * u, this._z = r * h + this._z * u, this._onChangeCallback(), this;
      }
      slerpQuaternions(t, e, i) {
        this.copy(t).slerp(e, i);
      }
      equals(t) {
        return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w;
      }
      fromArray(t, e = 0) {
        return this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this._onChangeCallback(), this;
      }
      toArray(t = [], e = 0) {
        return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t;
      }
      fromBufferAttribute(t, e) {
        return this._x = t.getX(e), this._y = t.getY(e), this._z = t.getZ(e), this._w = t.getW(e), this;
      }
      _onChange(t) {
        return this._onChangeCallback = t, this;
      }
      _onChangeCallback() {}
    }
    Quaternion.prototype.isQuaternion = true;
    class three_module_Vector3 {
      constructor(t = 0, e = 0, i = 0) {
        this.x = t, this.y = e, this.z = i;
      }
      set(t, e, i) {
        return void 0 === i && (i = this.z), this.x = t, this.y = e, this.z = i, this;
      }
      setScalar(t) {
        return this.x = t, this.y = t, this.z = t, this;
      }
      setX(t) {
        return this.x = t, this;
      }
      setY(t) {
        return this.y = t, this;
      }
      setZ(t) {
        return this.z = t, this;
      }
      setComponent(t, e) {
        switch (t) {
          case 0:
            this.x = e;
            break;
          case 1:
            this.y = e;
            break;
          case 2:
            this.z = e;
            break;
          default:
            throw new Error("index is out of range: " + t);
        }
        return this;
      }
      getComponent(t) {
        switch (t) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          case 2:
            return this.z;
          default:
            throw new Error("index is out of range: " + t);
        }
      }
      clone() {
        return new this.constructor(this.x, this.y, this.z);
      }
      copy(t) {
        return this.x = t.x, this.y = t.y, this.z = t.z, this;
      }
      add(t, e) {
        return void 0 !== e ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this);
      }
      addScalar(t) {
        return this.x += t, this.y += t, this.z += t, this;
      }
      addVectors(t, e) {
        return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this;
      }
      addScaledVector(t, e) {
        return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this;
      }
      sub(t, e) {
        return void 0 !== e ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this);
      }
      subScalar(t) {
        return this.x -= t, this.y -= t, this.z -= t, this;
      }
      subVectors(t, e) {
        return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this;
      }
      multiply(t, e) {
        return void 0 !== e ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(t, e)) : (this.x *= t.x, this.y *= t.y, this.z *= t.z, this);
      }
      multiplyScalar(t) {
        return this.x *= t, this.y *= t, this.z *= t, this;
      }
      multiplyVectors(t, e) {
        return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this;
      }
      applyEuler(t) {
        return t && t.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(rt.setFromEuler(t));
      }
      applyAxisAngle(t, e) {
        return this.applyQuaternion(rt.setFromAxisAngle(t, e));
      }
      applyMatrix3(t) {
        const e = this.x, i = this.y, n = this.z, r = t.elements;
        return this.x = r[0] * e + r[3] * i + r[6] * n, this.y = r[1] * e + r[4] * i + r[7] * n, this.z = r[2] * e + r[5] * i + r[8] * n, this;
      }
      applyNormalMatrix(t) {
        return this.applyMatrix3(t).normalize();
      }
      applyMatrix4(t) {
        const e = this.x, i = this.y, n = this.z, r = t.elements, o = 1 / (r[3] * e + r[7] * i + r[11] * n + r[15]);
        return this.x = (r[0] * e + r[4] * i + r[8] * n + r[12]) * o, this.y = (r[1] * e + r[5] * i + r[9] * n + r[13]) * o, this.z = (r[2] * e + r[6] * i + r[10] * n + r[14]) * o, this;
      }
      applyQuaternion(t) {
        const e = this.x, i = this.y, n = this.z, r = t.x, o = t.y, s = t.z, a = t.w, l = a * e + o * n - s * i, c = a * i + s * e - r * n, h = a * n + r * i - o * e, u = -r * e - o * i - s * n;
        return this.x = l * a + u * -r + c * -s - h * -o, this.y = c * a + u * -o + h * -r - l * -s, this.z = h * a + u * -s + l * -o - c * -r, this;
      }
      project(t) {
        return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix);
      }
      unproject(t) {
        return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld);
      }
      transformDirection(t) {
        const e = this.x, i = this.y, n = this.z, r = t.elements;
        return this.x = r[0] * e + r[4] * i + r[8] * n, this.y = r[1] * e + r[5] * i + r[9] * n, this.z = r[2] * e + r[6] * i + r[10] * n, this.normalize();
      }
      divide(t) {
        return this.x /= t.x, this.y /= t.y, this.z /= t.z, this;
      }
      divideScalar(t) {
        return this.multiplyScalar(1 / t);
      }
      min(t) {
        return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this;
      }
      max(t) {
        return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this;
      }
      clamp(t, e) {
        return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this;
      }
      clampScalar(t, e) {
        return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this;
      }
      clampLength(t, e) {
        const i = this.length();
        return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)));
      }
      floor() {
        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
      }
      ceil() {
        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
      }
      round() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
      }
      roundToZero() {
        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this;
      }
      negate() {
        return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
      }
      dot(t) {
        return this.x * t.x + this.y * t.y + this.z * t.z;
      }
      lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z;
      }
      length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
      }
      manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
      }
      normalize() {
        return this.divideScalar(this.length() || 1);
      }
      setLength(t) {
        return this.normalize().multiplyScalar(t);
      }
      lerp(t, e) {
        return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this;
      }
      lerpVectors(t, e, i) {
        return this.x = t.x + (e.x - t.x) * i, this.y = t.y + (e.y - t.y) * i, this.z = t.z + (e.z - t.z) * i, this;
      }
      cross(t, e) {
        return void 0 !== e ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(t, e)) : this.crossVectors(this, t);
      }
      crossVectors(t, e) {
        const i = t.x, n = t.y, r = t.z, o = e.x, s = e.y, a = e.z;
        return this.x = n * a - r * s, this.y = r * o - i * a, this.z = i * s - n * o, this;
      }
      projectOnVector(t) {
        const e = t.lengthSq();
        if (0 === e) return this.set(0, 0, 0);
        const i = t.dot(this) / e;
        return this.copy(t).multiplyScalar(i);
      }
      projectOnPlane(t) {
        return nt.copy(this).projectOnVector(t), this.sub(nt);
      }
      reflect(t) {
        return this.sub(nt.copy(t).multiplyScalar(2 * this.dot(t)));
      }
      angleTo(t) {
        const e = Math.sqrt(this.lengthSq() * t.lengthSq());
        if (0 === e) return Math.PI / 2;
        const i = this.dot(t) / e;
        return Math.acos(Math.max(-1, Math.min(1, i)));
      }
      distanceTo(t) {
        return Math.sqrt(this.distanceToSquared(t));
      }
      distanceToSquared(t) {
        const e = this.x - t.x, i = this.y - t.y, n = this.z - t.z;
        return e * e + i * i + n * n;
      }
      manhattanDistanceTo(t) {
        return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z);
      }
      setFromSpherical(t) {
        return this.setFromSphericalCoords(t.radius, t.phi, t.theta);
      }
      setFromSphericalCoords(t, e, i) {
        const n = Math.sin(e) * t;
        return this.x = n * Math.sin(i), this.y = Math.cos(e) * t, this.z = n * Math.cos(i), this;
      }
      setFromCylindrical(t) {
        return this.setFromCylindricalCoords(t.radius, t.theta, t.y);
      }
      setFromCylindricalCoords(t, e, i) {
        return this.x = t * Math.sin(e), this.y = i, this.z = t * Math.cos(e), this;
      }
      setFromMatrixPosition(t) {
        const e = t.elements;
        return this.x = e[12], this.y = e[13], this.z = e[14], this;
      }
      setFromMatrixScale(t) {
        const e = this.setFromMatrixColumn(t, 0).length(), i = this.setFromMatrixColumn(t, 1).length(), n = this.setFromMatrixColumn(t, 2).length();
        return this.x = e, this.y = i, this.z = n, this;
      }
      setFromMatrixColumn(t, e) {
        return this.fromArray(t.elements, 4 * e);
      }
      setFromMatrix3Column(t, e) {
        return this.fromArray(t.elements, 3 * e);
      }
      equals(t) {
        return t.x === this.x && t.y === this.y && t.z === this.z;
      }
      fromArray(t, e = 0) {
        return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this;
      }
      toArray(t = [], e = 0) {
        return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t;
      }
      fromBufferAttribute(t, e, i) {
        return void 0 !== i && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this;
      }
      random() {
        return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
      }
    }
    three_module_Vector3.prototype.isVector3 = true;
    const nt = new three_module_Vector3, rt = new Quaternion;
    class Box3 {
      constructor(t = new three_module_Vector3(Infinity, Infinity, Infinity), e = new three_module_Vector3(-Infinity, -Infinity, -Infinity)) {
        this.min = t, this.max = e;
      }
      set(t, e) {
        return this.min.copy(t), this.max.copy(e), this;
      }
      setFromArray(t) {
        let e = Infinity, i = Infinity, n = Infinity, r = -Infinity, o = -Infinity, s = -Infinity;
        for (let a = 0, l = t.length; a < l; a += 3) {
          const l = t[a], c = t[a + 1], h = t[a + 2];
          l < e && (e = l), c < i && (i = c), h < n && (n = h), l > r && (r = l), c > o && (o = c), h > s && (s = h);
        }
        return this.min.set(e, i, n), this.max.set(r, o, s), this;
      }
      setFromBufferAttribute(t) {
        let e = Infinity, i = Infinity, n = Infinity, r = -Infinity, o = -Infinity, s = -Infinity;
        for (let a = 0, l = t.count; a < l; a++) {
          const l = t.getX(a), c = t.getY(a), h = t.getZ(a);
          l < e && (e = l), c < i && (i = c), h < n && (n = h), l > r && (r = l), c > o && (o = c), h > s && (s = h);
        }
        return this.min.set(e, i, n), this.max.set(r, o, s), this;
      }
      setFromPoints(t) {
        this.makeEmpty();
        for (let e = 0, i = t.length; e < i; e++) this.expandByPoint(t[e]);
        return this;
      }
      setFromCenterAndSize(t, e) {
        const i = st.copy(e).multiplyScalar(0.5);
        return this.min.copy(t).sub(i), this.max.copy(t).add(i), this;
      }
      setFromObject(t) {
        return this.makeEmpty(), this.expandByObject(t);
      }
      clone() {
        return (new this.constructor).copy(this);
      }
      copy(t) {
        return this.min.copy(t.min), this.max.copy(t.max), this;
      }
      makeEmpty() {
        return this.min.x = this.min.y = this.min.z = Infinity, this.max.x = this.max.y = this.max.z = -Infinity, this;
      }
      isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
      }
      getCenter(t) {
        return this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(0.5);
      }
      getSize(t) {
        return this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min);
      }
      expandByPoint(t) {
        return this.min.min(t), this.max.max(t), this;
      }
      expandByVector(t) {
        return this.min.sub(t), this.max.add(t), this;
      }
      expandByScalar(t) {
        return this.min.addScalar(-t), this.max.addScalar(t), this;
      }
      expandByObject(t) {
        t.updateWorldMatrix(false, false);
        const e = t.geometry;
        void 0 !== e && (null === e.boundingBox && e.computeBoundingBox(), at.copy(e.boundingBox), at.applyMatrix4(t.matrixWorld), this.union(at));
        const i = t.children;
        for (let t = 0, e = i.length; t < e; t++) this.expandByObject(i[t]);
        return this;
      }
      containsPoint(t) {
        return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z);
      }
      containsBox(t) {
        return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z;
      }
      getParameter(t, e) {
        return e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z));
      }
      intersectsBox(t) {
        return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z);
      }
      intersectsSphere(t) {
        return this.clampPoint(t.center, st), st.distanceToSquared(t.center) <= t.radius * t.radius;
      }
      intersectsPlane(t) {
        let e, i;
        return t.normal.x > 0 ? (e = t.normal.x * this.min.x, i = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, i = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, i += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, i += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, i += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, i += t.normal.z * this.min.z), e <= -t.constant && i >= -t.constant;
      }
      intersectsTriangle(t) {
        if (this.isEmpty()) return false;
        this.getCenter(dt), ft.subVectors(this.max, dt), lt.subVectors(t.a, dt), ct.subVectors(t.b, dt), ht.subVectors(t.c, dt), ut.subVectors(ct, lt), mt.subVectors(ht, ct), pt.subVectors(lt, ht);
        let e = [0, -ut.z, ut.y, 0, -mt.z, mt.y, 0, -pt.z, pt.y, ut.z, 0, -ut.x, mt.z, 0, -mt.x, pt.z, 0, -pt.x, -ut.y, ut.x, 0, -mt.y, mt.x, 0, -pt.y, pt.x, 0];
        return !!gt(e, lt, ct, ht, ft) && (e = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!gt(e, lt, ct, ht, ft) && (_t.crossVectors(ut, mt), e = [_t.x, _t.y, _t.z], gt(e, lt, ct, ht, ft)));
      }
      clampPoint(t, e) {
        return e.copy(t).clamp(this.min, this.max);
      }
      distanceToPoint(t) {
        return st.copy(t).clamp(this.min, this.max).sub(t).length();
      }
      getBoundingSphere(t) {
        return this.getCenter(t.center), t.radius = 0.5 * this.getSize(st).length(), t;
      }
      intersect(t) {
        return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this;
      }
      union(t) {
        return this.min.min(t.min), this.max.max(t.max), this;
      }
      applyMatrix4(t) {
        return this.isEmpty() || (ot[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), ot[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), ot[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), ot[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), ot[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), ot[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), ot[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), ot[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(ot)), this;
      }
      translate(t) {
        return this.min.add(t), this.max.add(t), this;
      }
      equals(t) {
        return t.min.equals(this.min) && t.max.equals(this.max);
      }
    }
    Box3.prototype.isBox3 = true;
    const ot = [new three_module_Vector3, new three_module_Vector3, new three_module_Vector3, new three_module_Vector3, new three_module_Vector3, new three_module_Vector3, new three_module_Vector3, new three_module_Vector3], st = new three_module_Vector3, at = new Box3, lt = new three_module_Vector3, ct = new three_module_Vector3, ht = new three_module_Vector3, ut = new three_module_Vector3, mt = new three_module_Vector3, pt = new three_module_Vector3, dt = new three_module_Vector3, ft = new three_module_Vector3, _t = new three_module_Vector3, yt = new three_module_Vector3;
    function gt(t, e, i, n, r) {
      for (let o = 0, s = t.length - 3; o <= s; o += 3) {
        yt.fromArray(t, o);
        const s = r.x * Math.abs(yt.x) + r.y * Math.abs(yt.y) + r.z * Math.abs(yt.z), a = e.dot(yt), l = i.dot(yt), c = n.dot(yt);
        if (Math.max(-Math.max(a, l, c), Math.min(a, l, c)) > s) return false;
      }
      return true;
    }
    const xt = new Box3, vt = new three_module_Vector3, bt = new three_module_Vector3, wt = new three_module_Vector3;
    class Sphere {
      constructor(t = new three_module_Vector3, e = -1) {
        this.center = t, this.radius = e;
      }
      set(t, e) {
        return this.center.copy(t), this.radius = e, this;
      }
      setFromPoints(t, e) {
        const i = this.center;
        void 0 !== e ? i.copy(e) : xt.setFromPoints(t).getCenter(i);
        let n = 0;
        for (let e = 0, r = t.length; e < r; e++) n = Math.max(n, i.distanceToSquared(t[e]));
        return this.radius = Math.sqrt(n), this;
      }
      copy(t) {
        return this.center.copy(t.center), this.radius = t.radius, this;
      }
      isEmpty() {
        return this.radius < 0;
      }
      makeEmpty() {
        return this.center.set(0, 0, 0), this.radius = -1, this;
      }
      containsPoint(t) {
        return t.distanceToSquared(this.center) <= this.radius * this.radius;
      }
      distanceToPoint(t) {
        return t.distanceTo(this.center) - this.radius;
      }
      intersectsSphere(t) {
        const e = this.radius + t.radius;
        return t.center.distanceToSquared(this.center) <= e * e;
      }
      intersectsBox(t) {
        return t.intersectsSphere(this);
      }
      intersectsPlane(t) {
        return Math.abs(t.distanceToPoint(this.center)) <= this.radius;
      }
      clampPoint(t, e) {
        const i = this.center.distanceToSquared(t);
        return e.copy(t), i > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e;
      }
      getBoundingBox(t) {
        return this.isEmpty() ? (t.makeEmpty(), t) : (t.set(this.center, this.center), t.expandByScalar(this.radius), t);
      }
      applyMatrix4(t) {
        return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this;
      }
      translate(t) {
        return this.center.add(t), this;
      }
      expandByPoint(t) {
        wt.subVectors(t, this.center);
        const e = wt.lengthSq();
        if (e > this.radius * this.radius) {
          const t = Math.sqrt(e), i = 0.5 * (t - this.radius);
          this.center.add(wt.multiplyScalar(i / t)), this.radius += i;
        }
        return this;
      }
      union(t) {
        return bt.subVectors(t.center, this.center).normalize().multiplyScalar(t.radius), this.expandByPoint(vt.copy(t.center).add(bt)), this.expandByPoint(vt.copy(t.center).sub(bt)), this;
      }
      equals(t) {
        return t.center.equals(this.center) && t.radius === this.radius;
      }
      clone() {
        return (new this.constructor).copy(this);
      }
    }
    const St = new three_module_Vector3, Mt = new three_module_Vector3, Ct = new three_module_Vector3, At = new three_module_Vector3, Tt = new three_module_Vector3, Et = new three_module_Vector3, Lt = new three_module_Vector3;
    class Ray {
      constructor(t = new three_module_Vector3, e = new three_module_Vector3(0, 0, -1)) {
        this.origin = t, this.direction = e;
      }
      set(t, e) {
        return this.origin.copy(t), this.direction.copy(e), this;
      }
      copy(t) {
        return this.origin.copy(t.origin), this.direction.copy(t.direction), this;
      }
      at(t, e) {
        return e.copy(this.direction).multiplyScalar(t).add(this.origin);
      }
      lookAt(t) {
        return this.direction.copy(t).sub(this.origin).normalize(), this;
      }
      recast(t) {
        return this.origin.copy(this.at(t, St)), this;
      }
      closestPointToPoint(t, e) {
        e.subVectors(t, this.origin);
        const i = e.dot(this.direction);
        return i < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(i).add(this.origin);
      }
      distanceToPoint(t) {
        return Math.sqrt(this.distanceSqToPoint(t));
      }
      distanceSqToPoint(t) {
        const e = St.subVectors(t, this.origin).dot(this.direction);
        return e < 0 ? this.origin.distanceToSquared(t) : (St.copy(this.direction).multiplyScalar(e).add(this.origin), St.distanceToSquared(t));
      }
      distanceSqToSegment(t, e, i, n) {
        Mt.copy(t).add(e).multiplyScalar(0.5), Ct.copy(e).sub(t).normalize(), At.copy(this.origin).sub(Mt);
        const r = 0.5 * t.distanceTo(e), o = -this.direction.dot(Ct), s = At.dot(this.direction), a = -At.dot(Ct), l = At.lengthSq(), c = Math.abs(1 - o * o);
        let h, u, m, p;
        if (c > 0) if (h = o * a - s, u = o * s - a, p = r * c, h >= 0) if (u >= -p) if (u <= p) {
          const t = 1 / c;
          h *= t, u *= t, m = h * (h + o * u + 2 * s) + u * (o * h + u + 2 * a) + l;
        } else u = r, h = Math.max(0, -(o * u + s)), m = -h * h + u * (u + 2 * a) + l; else u = -r, h = Math.max(0, -(o * u + s)), m = -h * h + u * (u + 2 * a) + l; else u <= -p ? (h = Math.max(0, -(-o * r + s)), u = h > 0 ? -r : Math.min(Math.max(-r, -a), r), m = -h * h + u * (u + 2 * a) + l) : u <= p ? (h = 0, u = Math.min(Math.max(-r, -a), r), m = u * (u + 2 * a) + l) : (h = Math.max(0, -(o * r + s)), u = h > 0 ? r : Math.min(Math.max(-r, -a), r), m = -h * h + u * (u + 2 * a) + l); else u = o > 0 ? -r : r, h = Math.max(0, -(o * u + s)), m = -h * h + u * (u + 2 * a) + l;
        return i && i.copy(this.direction).multiplyScalar(h).add(this.origin), n && n.copy(Ct).multiplyScalar(u).add(Mt), m;
      }
      intersectSphere(t, e) {
        St.subVectors(t.center, this.origin);
        const i = St.dot(this.direction), n = St.dot(St) - i * i, r = t.radius * t.radius;
        if (n > r) return null;
        const o = Math.sqrt(r - n), s = i - o, a = i + o;
        return s < 0 && a < 0 ? null : s < 0 ? this.at(a, e) : this.at(s, e);
      }
      intersectsSphere(t) {
        return this.distanceSqToPoint(t.center) <= t.radius * t.radius;
      }
      distanceToPlane(t) {
        const e = t.normal.dot(this.direction);
        if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
        const i = -(this.origin.dot(t.normal) + t.constant) / e;
        return i >= 0 ? i : null;
      }
      intersectPlane(t, e) {
        const i = this.distanceToPlane(t);
        return null === i ? null : this.at(i, e);
      }
      intersectsPlane(t) {
        const e = t.distanceToPoint(this.origin);
        if (0 === e) return true;
        return t.normal.dot(this.direction) * e < 0;
      }
      intersectBox(t, e) {
        let i, n, r, o, s, a;
        const l = 1 / this.direction.x, c = 1 / this.direction.y, h = 1 / this.direction.z, u = this.origin;
        return l >= 0 ? (i = (t.min.x - u.x) * l, n = (t.max.x - u.x) * l) : (i = (t.max.x - u.x) * l, n = (t.min.x - u.x) * l), c >= 0 ? (r = (t.min.y - u.y) * c, o = (t.max.y - u.y) * c) : (r = (t.max.y - u.y) * c, o = (t.min.y - u.y) * c), i > o || r > n ? null : ((r > i || i != i) && (i = r), (o < n || n != n) && (n = o), h >= 0 ? (s = (t.min.z - u.z) * h, a = (t.max.z - u.z) * h) : (s = (t.max.z - u.z) * h, a = (t.min.z - u.z) * h), i > a || s > n ? null : ((s > i || i != i) && (i = s), (a < n || n != n) && (n = a), n < 0 ? null : this.at(i >= 0 ? i : n, e)));
      }
      intersectsBox(t) {
        return null !== this.intersectBox(t, St);
      }
      intersectTriangle(t, e, i, n, r) {
        Tt.subVectors(e, t), Et.subVectors(i, t), Lt.crossVectors(Tt, Et);
        let o, s = this.direction.dot(Lt);
        if (s > 0) {
          if (n) return null;
          o = 1;
        } else {
          if (!(s < 0)) return null;
          o = -1, s = -s;
        }
        At.subVectors(this.origin, t);
        const a = o * this.direction.dot(Et.crossVectors(At, Et));
        if (a < 0) return null;
        const l = o * this.direction.dot(Tt.cross(At));
        if (l < 0) return null;
        if (a + l > s) return null;
        const c = -o * At.dot(Lt);
        return c < 0 ? null : this.at(c / s, r);
      }
      applyMatrix4(t) {
        return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this;
      }
      equals(t) {
        return t.origin.equals(this.origin) && t.direction.equals(this.direction);
      }
      clone() {
        return (new this.constructor).copy(this);
      }
    }
    class Matrix4 {
      constructor() {
        this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
      }
      set(t, e, i, n, r, o, s, a, l, c, h, u, m, p, d, f) {
        const _ = this.elements;
        return _[0] = t, _[4] = e, _[8] = i, _[12] = n, _[1] = r, _[5] = o, _[9] = s, _[13] = a, _[2] = l, _[6] = c, _[10] = h, _[14] = u, _[3] = m, _[7] = p, _[11] = d, _[15] = f, this;
      }
      identity() {
        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
      }
      clone() {
        return (new Matrix4).fromArray(this.elements);
      }
      copy(t) {
        const e = this.elements, i = t.elements;
        return e[0] = i[0], e[1] = i[1], e[2] = i[2], e[3] = i[3], e[4] = i[4], e[5] = i[5], e[6] = i[6], e[7] = i[7], e[8] = i[8], e[9] = i[9], e[10] = i[10], e[11] = i[11], e[12] = i[12], e[13] = i[13], e[14] = i[14], e[15] = i[15], this;
      }
      copyPosition(t) {
        const e = this.elements, i = t.elements;
        return e[12] = i[12], e[13] = i[13], e[14] = i[14], this;
      }
      setFromMatrix3(t) {
        const e = t.elements;
        return this.set(e[0], e[3], e[6], 0, e[1], e[4], e[7], 0, e[2], e[5], e[8], 0, 0, 0, 0, 1), this;
      }
      extractBasis(t, e, i) {
        return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this;
      }
      makeBasis(t, e, i) {
        return this.set(t.x, e.x, i.x, 0, t.y, e.y, i.y, 0, t.z, e.z, i.z, 0, 0, 0, 0, 1), this;
      }
      extractRotation(t) {
        const e = this.elements, i = t.elements, n = 1 / Dt.setFromMatrixColumn(t, 0).length(), r = 1 / Dt.setFromMatrixColumn(t, 1).length(), o = 1 / Dt.setFromMatrixColumn(t, 2).length();
        return e[0] = i[0] * n, e[1] = i[1] * n, e[2] = i[2] * n, e[3] = 0, e[4] = i[4] * r, e[5] = i[5] * r, e[6] = i[6] * r, e[7] = 0, e[8] = i[8] * o, e[9] = i[9] * o, e[10] = i[10] * o, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this;
      }
      makeRotationFromEuler(t) {
        t && t.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
        const e = this.elements, i = t.x, n = t.y, r = t.z, o = Math.cos(i), s = Math.sin(i), a = Math.cos(n), l = Math.sin(n), c = Math.cos(r), h = Math.sin(r);
        if ("XYZ" === t.order) {
          const t = o * c, i = o * h, n = s * c, r = s * h;
          e[0] = a * c, e[4] = -a * h, e[8] = l, e[1] = i + n * l, e[5] = t - r * l, e[9] = -s * a, e[2] = r - t * l, e[6] = n + i * l, e[10] = o * a;
        } else if ("YXZ" === t.order) {
          const t = a * c, i = a * h, n = l * c, r = l * h;
          e[0] = t + r * s, e[4] = n * s - i, e[8] = o * l, e[1] = o * h, e[5] = o * c, e[9] = -s, e[2] = i * s - n, e[6] = r + t * s, e[10] = o * a;
        } else if ("ZXY" === t.order) {
          const t = a * c, i = a * h, n = l * c, r = l * h;
          e[0] = t - r * s, e[4] = -o * h, e[8] = n + i * s, e[1] = i + n * s, e[5] = o * c, e[9] = r - t * s, e[2] = -o * l, e[6] = s, e[10] = o * a;
        } else if ("ZYX" === t.order) {
          const t = o * c, i = o * h, n = s * c, r = s * h;
          e[0] = a * c, e[4] = n * l - i, e[8] = t * l + r, e[1] = a * h, e[5] = r * l + t, e[9] = i * l - n, e[2] = -l, e[6] = s * a, e[10] = o * a;
        } else if ("YZX" === t.order) {
          const t = o * a, i = o * l, n = s * a, r = s * l;
          e[0] = a * c, e[4] = r - t * h, e[8] = n * h + i, e[1] = h, e[5] = o * c, e[9] = -s * c, e[2] = -l * c, e[6] = i * h + n, e[10] = t - r * h;
        } else if ("XZY" === t.order) {
          const t = o * a, i = o * l, n = s * a, r = s * l;
          e[0] = a * c, e[4] = -h, e[8] = l * c, e[1] = t * h + r, e[5] = o * c, e[9] = i * h - n, e[2] = n * h - i, e[6] = s * c, e[10] = r * h + t;
        }
        return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this;
      }
      makeRotationFromQuaternion(t) {
        return this.compose(Bt, t, Rt);
      }
      lookAt(t, e, i) {
        const n = this.elements;
        return Ft.subVectors(t, e), 0 === Ft.lengthSq() && (Ft.z = 1), Ft.normalize(), Pt.crossVectors(i, Ft), 0 === Pt.lengthSq() && (1 === Math.abs(i.z) ? Ft.x += 0.0001 : Ft.z += 0.0001, Ft.normalize(), Pt.crossVectors(i, Ft)), Pt.normalize(), It.crossVectors(Ft, Pt), n[0] = Pt.x, n[4] = It.x, n[8] = Ft.x, n[1] = Pt.y, n[5] = It.y, n[9] = Ft.y, n[2] = Pt.z, n[6] = It.z, n[10] = Ft.z, this;
      }
      multiply(t, e) {
        return void 0 !== e ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t);
      }
      premultiply(t) {
        return this.multiplyMatrices(t, this);
      }
      multiplyMatrices(t, e) {
        const i = t.elements, n = e.elements, r = this.elements, o = i[0], s = i[4], a = i[8], l = i[12], c = i[1], h = i[5], u = i[9], m = i[13], p = i[2], d = i[6], f = i[10], _ = i[14], y = i[3], g = i[7], x = i[11], v = i[15], b = n[0], w = n[4], S = n[8], M = n[12], C = n[1], A = n[5], T = n[9], E = n[13], L = n[2], D = n[6], V = n[10], B = n[14], R = n[3], P = n[7], I = n[11], F = n[15];
        return r[0] = o * b + s * C + a * L + l * R, r[4] = o * w + s * A + a * D + l * P, r[8] = o * S + s * T + a * V + l * I, r[12] = o * M + s * E + a * B + l * F, r[1] = c * b + h * C + u * L + m * R, r[5] = c * w + h * A + u * D + m * P, r[9] = c * S + h * T + u * V + m * I, r[13] = c * M + h * E + u * B + m * F, r[2] = p * b + d * C + f * L + _ * R, r[6] = p * w + d * A + f * D + _ * P, r[10] = p * S + d * T + f * V + _ * I, r[14] = p * M + d * E + f * B + _ * F, r[3] = y * b + g * C + x * L + v * R, r[7] = y * w + g * A + x * D + v * P, r[11] = y * S + g * T + x * V + v * I, r[15] = y * M + g * E + x * B + v * F, this;
      }
      multiplyScalar(t) {
        const e = this.elements;
        return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this;
      }
      determinant() {
        const t = this.elements, e = t[0], i = t[4], n = t[8], r = t[12], o = t[1], s = t[5], a = t[9], l = t[13], c = t[2], h = t[6], u = t[10], m = t[14];
        return t[3] * (+r * a * h - n * l * h - r * s * u + i * l * u + n * s * m - i * a * m) + t[7] * (+e * a * m - e * l * u + r * o * u - n * o * m + n * l * c - r * a * c) + t[11] * (+e * l * h - e * s * m - r * o * h + i * o * m + r * s * c - i * l * c) + t[15] * (-n * s * c - e * a * h + e * s * u + n * o * h - i * o * u + i * a * c);
      }
      transpose() {
        const t = this.elements;
        let e;
        return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this;
      }
      setPosition(t, e, i) {
        const n = this.elements;
        return t.isVector3 ? (n[12] = t.x, n[13] = t.y, n[14] = t.z) : (n[12] = t, n[13] = e, n[14] = i), this;
      }
      invert() {
        const t = this.elements, e = t[0], i = t[1], n = t[2], r = t[3], o = t[4], s = t[5], a = t[6], l = t[7], c = t[8], h = t[9], u = t[10], m = t[11], p = t[12], d = t[13], f = t[14], _ = t[15], y = h * f * l - d * u * l + d * a * m - s * f * m - h * a * _ + s * u * _, g = p * u * l - c * f * l - p * a * m + o * f * m + c * a * _ - o * u * _, x = c * d * l - p * h * l + p * s * m - o * d * m - c * s * _ + o * h * _, v = p * h * a - c * d * a - p * s * u + o * d * u + c * s * f - o * h * f, b = e * y + i * g + n * x + r * v;
        if (0 === b) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        const w = 1 / b;
        return t[0] = y * w, t[1] = (d * u * r - h * f * r - d * n * m + i * f * m + h * n * _ - i * u * _) * w, t[2] = (s * f * r - d * a * r + d * n * l - i * f * l - s * n * _ + i * a * _) * w, t[3] = (h * a * r - s * u * r - h * n * l + i * u * l + s * n * m - i * a * m) * w, t[4] = g * w, t[5] = (c * f * r - p * u * r + p * n * m - e * f * m - c * n * _ + e * u * _) * w, t[6] = (p * a * r - o * f * r - p * n * l + e * f * l + o * n * _ - e * a * _) * w, t[7] = (o * u * r - c * a * r + c * n * l - e * u * l - o * n * m + e * a * m) * w, t[8] = x * w, t[9] = (p * h * r - c * d * r - p * i * m + e * d * m + c * i * _ - e * h * _) * w, t[10] = (o * d * r - p * s * r + p * i * l - e * d * l - o * i * _ + e * s * _) * w, t[11] = (c * s * r - o * h * r - c * i * l + e * h * l + o * i * m - e * s * m) * w, t[12] = v * w, t[13] = (c * d * n - p * h * n + p * i * u - e * d * u - c * i * f + e * h * f) * w, t[14] = (p * s * n - o * d * n - p * i * a + e * d * a + o * i * f - e * s * f) * w, t[15] = (o * h * n - c * s * n + c * i * a - e * h * a - o * i * u + e * s * u) * w, this;
      }
      scale(t) {
        const e = this.elements, i = t.x, n = t.y, r = t.z;
        return e[0] *= i, e[4] *= n, e[8] *= r, e[1] *= i, e[5] *= n, e[9] *= r, e[2] *= i, e[6] *= n, e[10] *= r, e[3] *= i, e[7] *= n, e[11] *= r, this;
      }
      getMaxScaleOnAxis() {
        const t = this.elements, e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2], i = t[4] * t[4] + t[5] * t[5] + t[6] * t[6], n = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
        return Math.sqrt(Math.max(e, i, n));
      }
      makeTranslation(t, e, i) {
        return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, i, 0, 0, 0, 1), this;
      }
      makeRotationX(t) {
        const e = Math.cos(t), i = Math.sin(t);
        return this.set(1, 0, 0, 0, 0, e, -i, 0, 0, i, e, 0, 0, 0, 0, 1), this;
      }
      makeRotationY(t) {
        const e = Math.cos(t), i = Math.sin(t);
        return this.set(e, 0, i, 0, 0, 1, 0, 0, -i, 0, e, 0, 0, 0, 0, 1), this;
      }
      makeRotationZ(t) {
        const e = Math.cos(t), i = Math.sin(t);
        return this.set(e, -i, 0, 0, i, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
      }
      makeRotationAxis(t, e) {
        const i = Math.cos(e), n = Math.sin(e), r = 1 - i, o = t.x, s = t.y, a = t.z, l = r * o, c = r * s;
        return this.set(l * o + i, l * s - n * a, l * a + n * s, 0, l * s + n * a, c * s + i, c * a - n * o, 0, l * a - n * s, c * a + n * o, r * a * a + i, 0, 0, 0, 0, 1), this;
      }
      makeScale(t, e, i) {
        return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this;
      }
      makeShear(t, e, i, n, r, o) {
        return this.set(1, i, r, 0, t, 1, o, 0, e, n, 1, 0, 0, 0, 0, 1), this;
      }
      compose(t, e, i) {
        const n = this.elements, r = e._x, o = e._y, s = e._z, a = e._w, l = r + r, c = o + o, h = s + s, u = r * l, m = r * c, p = r * h, d = o * c, f = o * h, _ = s * h, y = a * l, g = a * c, x = a * h, v = i.x, b = i.y, w = i.z;
        return n[0] = (1 - (d + _)) * v, n[1] = (m + x) * v, n[2] = (p - g) * v, n[3] = 0, n[4] = (m - x) * b, n[5] = (1 - (u + _)) * b, n[6] = (f + y) * b, n[7] = 0, n[8] = (p + g) * w, n[9] = (f - y) * w, n[10] = (1 - (u + d)) * w, n[11] = 0, n[12] = t.x, n[13] = t.y, n[14] = t.z, n[15] = 1, this;
      }
      decompose(t, e, i) {
        const n = this.elements;
        let r = Dt.set(n[0], n[1], n[2]).length();
        const o = Dt.set(n[4], n[5], n[6]).length(), s = Dt.set(n[8], n[9], n[10]).length();
        this.determinant() < 0 && (r = -r), t.x = n[12], t.y = n[13], t.z = n[14], Vt.copy(this);
        const a = 1 / r, l = 1 / o, c = 1 / s;
        return Vt.elements[0] *= a, Vt.elements[1] *= a, Vt.elements[2] *= a, Vt.elements[4] *= l, Vt.elements[5] *= l, Vt.elements[6] *= l, Vt.elements[8] *= c, Vt.elements[9] *= c, Vt.elements[10] *= c, e.setFromRotationMatrix(Vt), i.x = r, i.y = o, i.z = s, this;
      }
      makePerspective(t, e, i, n, r, o) {
        void 0 === o && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
        const s = this.elements, a = 2 * r / (e - t), l = 2 * r / (i - n), c = (e + t) / (e - t), h = (i + n) / (i - n), u = -(o + r) / (o - r), m = -2 * o * r / (o - r);
        return s[0] = a, s[4] = 0, s[8] = c, s[12] = 0, s[1] = 0, s[5] = l, s[9] = h, s[13] = 0, s[2] = 0, s[6] = 0, s[10] = u, s[14] = m, s[3] = 0, s[7] = 0, s[11] = -1, s[15] = 0, this;
      }
      makeOrthographic(t, e, i, n, r, o) {
        const s = this.elements, a = 1 / (e - t), l = 1 / (i - n), c = 1 / (o - r), h = (e + t) * a, u = (i + n) * l, m = (o + r) * c;
        return s[0] = 2 * a, s[4] = 0, s[8] = 0, s[12] = -h, s[1] = 0, s[5] = 2 * l, s[9] = 0, s[13] = -u, s[2] = 0, s[6] = 0, s[10] = -2 * c, s[14] = -m, s[3] = 0, s[7] = 0, s[11] = 0, s[15] = 1, this;
      }
      equals(t) {
        const e = this.elements, i = t.elements;
        for (let t = 0; t < 16; t++) if (e[t] !== i[t]) return false;
        return true;
      }
      fromArray(t, e = 0) {
        for (let i = 0; i < 16; i++) this.elements[i] = t[i + e];
        return this;
      }
      toArray(t = [], e = 0) {
        const i = this.elements;
        return t[e] = i[0], t[e + 1] = i[1], t[e + 2] = i[2], t[e + 3] = i[3], t[e + 4] = i[4], t[e + 5] = i[5], t[e + 6] = i[6], t[e + 7] = i[7], t[e + 8] = i[8], t[e + 9] = i[9], t[e + 10] = i[10], t[e + 11] = i[11], t[e + 12] = i[12], t[e + 13] = i[13], t[e + 14] = i[14], t[e + 15] = i[15], t;
      }
    }
    Matrix4.prototype.isMatrix4 = true;
    const Dt = new three_module_Vector3, Vt = new Matrix4, Bt = new three_module_Vector3(0, 0, 0), Rt = new three_module_Vector3(1, 1, 1), Pt = new three_module_Vector3, It = new three_module_Vector3, Ft = new three_module_Vector3, Gt = new Matrix4, Nt = new Quaternion;
    class Euler {
      constructor(t = 0, e = 0, i = 0, n = Euler.DefaultOrder) {
        this._x = t, this._y = e, this._z = i, this._order = n;
      }
      get x() {
        return this._x;
      }
      set x (t) {
        this._x = t, this._onChangeCallback();
      }
      get y() {
        return this._y;
      }
      set y (t) {
        this._y = t, this._onChangeCallback();
      }
      get z() {
        return this._z;
      }
      set z (t) {
        this._z = t, this._onChangeCallback();
      }
      get order() {
        return this._order;
      }
      set order (t) {
        this._order = t, this._onChangeCallback();
      }
      set(t, e, i, n = this._order) {
        return this._x = t, this._y = e, this._z = i, this._order = n, this._onChangeCallback(), this;
      }
      clone() {
        return new this.constructor(this._x, this._y, this._z, this._order);
      }
      copy(t) {
        return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this._onChangeCallback(), this;
      }
      setFromRotationMatrix(t, e = this._order, i = true) {
        const n = t.elements, r = n[0], o = n[4], s = n[8], a = n[1], l = n[5], c = n[9], h = n[2], u = n[6], m = n[10];
        switch (e) {
          case "XYZ":
            this._y = Math.asin(Math.max(-1, Math.min(1, s))), Math.abs(s) < 0.9999999 ? (this._x = Math.atan2(-c, m), this._z = Math.atan2(-o, r)) : (this._x = Math.atan2(u, l), this._z = 0);
            break;
          case "YXZ":
            this._x = Math.asin(-Math.max(-1, Math.min(1, c))), Math.abs(c) < 0.9999999 ? (this._y = Math.atan2(s, m), this._z = Math.atan2(a, l)) : (this._y = Math.atan2(-h, r), this._z = 0);
            break;
          case "ZXY":
            this._x = Math.asin(Math.max(-1, Math.min(1, u))), Math.abs(u) < 0.9999999 ? (this._y = Math.atan2(-h, m), this._z = Math.atan2(-o, l)) : (this._y = 0, this._z = Math.atan2(a, r));
            break;
          case "ZYX":
            this._y = Math.asin(-Math.max(-1, Math.min(1, h))), Math.abs(h) < 0.9999999 ? (this._x = Math.atan2(u, m), this._z = Math.atan2(a, r)) : (this._x = 0, this._z = Math.atan2(-o, l));
            break;
          case "YZX":
            this._z = Math.asin(Math.max(-1, Math.min(1, a))), Math.abs(a) < 0.9999999 ? (this._x = Math.atan2(-c, l), this._y = Math.atan2(-h, r)) : (this._x = 0, this._y = Math.atan2(s, m));
            break;
          case "XZY":
            this._z = Math.asin(-Math.max(-1, Math.min(1, o))), Math.abs(o) < 0.9999999 ? (this._x = Math.atan2(u, l), this._y = Math.atan2(s, r)) : (this._x = Math.atan2(-c, m), this._y = 0);
            break;
          default:
            console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e);
        }
        return this._order = e, true === i && this._onChangeCallback(), this;
      }
      setFromQuaternion(t, e, i) {
        return Gt.makeRotationFromQuaternion(t), this.setFromRotationMatrix(Gt, e, i);
      }
      setFromVector3(t, e = this._order) {
        return this.set(t.x, t.y, t.z, e);
      }
      reorder(t) {
        return Nt.setFromEuler(this), this.setFromQuaternion(Nt, t);
      }
      equals(t) {
        return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order;
      }
      fromArray(t) {
        return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (this._order = t[3]), this._onChangeCallback(), this;
      }
      toArray(t = [], e = 0) {
        return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t;
      }
      toVector3(t) {
        return t ? t.set(this._x, this._y, this._z) : new three_module_Vector3(this._x, this._y, this._z);
      }
      _onChange(t) {
        return this._onChangeCallback = t, this;
      }
      _onChangeCallback() {}
    }
    Euler.prototype.isEuler = true, Euler.DefaultOrder = "XYZ", Euler.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
    class Layers {
      constructor() {
        this.mask = 1;
      }
      set(t) {
        this.mask = 1 << t | 0;
      }
      enable(t) {
        this.mask |= 1 << t | 0;
      }
      enableAll() {
        this.mask = -1;
      }
      toggle(t) {
        this.mask ^= 1 << t | 0;
      }
      disable(t) {
        this.mask &= ~(1 << t | 0);
      }
      disableAll() {
        this.mask = 0;
      }
      test(t) {
        return 0 != (this.mask & t.mask);
      }
    }
    let zt = 0;
    const Ot = new three_module_Vector3, Ut = new Quaternion, kt = new Matrix4, Ht = new three_module_Vector3, Wt = new three_module_Vector3, Jt = new three_module_Vector3, jt = new Quaternion, Xt = new three_module_Vector3(1, 0, 0), qt = new three_module_Vector3(0, 1, 0), Yt = new three_module_Vector3(0, 0, 1), Zt = {type: "added"}, Kt = {type: "removed"};
    class Object3D extends EventDispatcher {
      constructor() {
        super(), Object.defineProperty(this, "id", {value: zt++}), this.uuid = q(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Object3D.DefaultUp.clone();
        const t = new three_module_Vector3, e = new Euler, i = new Quaternion, n = new three_module_Vector3(1, 1, 1);
        e._onChange(function () {
          i.setFromEuler(e, false);
        }), i._onChange(function () {
          e.setFromQuaternion(i, void 0, false);
        }), Object.defineProperties(this, {position: {configurable: true, enumerable: true, value: t}, rotation: {configurable: true, enumerable: true, value: e}, quaternion: {configurable: true, enumerable: true, value: i}, scale: {configurable: true, enumerable: true, value: n}, modelViewMatrix: {value: new Matrix4}, normalMatrix: {value: new Matrix3}}), this.matrix = new Matrix4, this.matrixWorld = new Matrix4, this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = false, this.layers = new Layers, this.visible = true, this.castShadow = false, this.receiveShadow = false, this.frustumCulled = true, this.renderOrder = 0, this.animations = [], this.userData = {};
      }
      onBeforeRender() {}
      onAfterRender() {}
      applyMatrix4(t) {
        this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale);
      }
      applyQuaternion(t) {
        return this.quaternion.premultiply(t), this;
      }
      setRotationFromAxisAngle(t, e) {
        this.quaternion.setFromAxisAngle(t, e);
      }
      setRotationFromEuler(t) {
        this.quaternion.setFromEuler(t, true);
      }
      setRotationFromMatrix(t) {
        this.quaternion.setFromRotationMatrix(t);
      }
      setRotationFromQuaternion(t) {
        this.quaternion.copy(t);
      }
      rotateOnAxis(t, e) {
        return Ut.setFromAxisAngle(t, e), this.quaternion.multiply(Ut), this;
      }
      rotateOnWorldAxis(t, e) {
        return Ut.setFromAxisAngle(t, e), this.quaternion.premultiply(Ut), this;
      }
      rotateX(t) {
        return this.rotateOnAxis(Xt, t);
      }
      rotateY(t) {
        return this.rotateOnAxis(qt, t);
      }
      rotateZ(t) {
        return this.rotateOnAxis(Yt, t);
      }
      translateOnAxis(t, e) {
        return Ot.copy(t).applyQuaternion(this.quaternion), this.position.add(Ot.multiplyScalar(e)), this;
      }
      translateX(t) {
        return this.translateOnAxis(Xt, t);
      }
      translateY(t) {
        return this.translateOnAxis(qt, t);
      }
      translateZ(t) {
        return this.translateOnAxis(Yt, t);
      }
      localToWorld(t) {
        return t.applyMatrix4(this.matrixWorld);
      }
      worldToLocal(t) {
        return t.applyMatrix4(kt.copy(this.matrixWorld).invert());
      }
      lookAt(t, e, i) {
        t.isVector3 ? Ht.copy(t) : Ht.set(t, e, i);
        const n = this.parent;
        this.updateWorldMatrix(true, false), Wt.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? kt.lookAt(Wt, Ht, this.up) : kt.lookAt(Ht, Wt, this.up), this.quaternion.setFromRotationMatrix(kt), n && (kt.extractRotation(n.matrixWorld), Ut.setFromRotationMatrix(kt), this.quaternion.premultiply(Ut.invert()));
      }
      add(t) {
        if (arguments.length > 1) {
          for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
          return this;
        }
        return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (null !== t.parent && t.parent.remove(t), t.parent = this, this.children.push(t), t.dispatchEvent(Zt)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this);
      }
      remove(t) {
        if (arguments.length > 1) {
          for (let t = 0; t < arguments.length; t++) this.remove(arguments[t]);
          return this;
        }
        const e = this.children.indexOf(t);
        return -1 !== e && (t.parent = null, this.children.splice(e, 1), t.dispatchEvent(Kt)), this;
      }
      removeFromParent() {
        const t = this.parent;
        return null !== t && t.remove(this), this;
      }
      clear() {
        for (let t = 0; t < this.children.length; t++) {
          const e = this.children[t];
          e.parent = null, e.dispatchEvent(Kt);
        }
        return this.children.length = 0, this;
      }
      attach(t) {
        return this.updateWorldMatrix(true, false), kt.copy(this.matrixWorld).invert(), null !== t.parent && (t.parent.updateWorldMatrix(true, false), kt.multiply(t.parent.matrixWorld)), t.applyMatrix4(kt), this.add(t), t.updateWorldMatrix(false, true), this;
      }
      getObjectById(t) {
        return this.getObjectByProperty("id", t);
      }
      getObjectByName(t) {
        return this.getObjectByProperty("name", t);
      }
      getObjectByProperty(t, e) {
        if (this[t] === e) return this;
        for (let i = 0, n = this.children.length; i < n; i++) {
          const n = this.children[i].getObjectByProperty(t, e);
          if (void 0 !== n) return n;
        }
      }
      getWorldPosition(t) {
        return this.updateWorldMatrix(true, false), t.setFromMatrixPosition(this.matrixWorld);
      }
      getWorldQuaternion(t) {
        return this.updateWorldMatrix(true, false), this.matrixWorld.decompose(Wt, t, Jt), t;
      }
      getWorldScale(t) {
        return this.updateWorldMatrix(true, false), this.matrixWorld.decompose(Wt, jt, t), t;
      }
      getWorldDirection(t) {
        this.updateWorldMatrix(true, false);
        const e = this.matrixWorld.elements;
        return t.set(e[8], e[9], e[10]).normalize();
      }
      raycast() {}
      traverse(t) {
        t(this);
        const e = this.children;
        for (let i = 0, n = e.length; i < n; i++) e[i].traverse(t);
      }
      traverseVisible(t) {
        if (false === this.visible) return;
        t(this);
        const e = this.children;
        for (let i = 0, n = e.length; i < n; i++) e[i].traverseVisible(t);
      }
      traverseAncestors(t) {
        const e = this.parent;
        null !== e && (t(e), e.traverseAncestors(t));
      }
      updateMatrix() {
        this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = true;
      }
      updateMatrixWorld(t) {
        this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = false, t = true);
        const e = this.children;
        for (let i = 0, n = e.length; i < n; i++) e[i].updateMatrixWorld(t);
      }
      updateWorldMatrix(t, e) {
        const i = this.parent;
        if (true === t && null !== i && i.updateWorldMatrix(true, false), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), true === e) {
          const t = this.children;
          for (let e = 0, i = t.length; e < i; e++) t[e].updateWorldMatrix(false, true);
        }
      }
      toJSON(t) {
        const e = void 0 === t || "string" == typeof t, i = {};
        e && (t = {geometries: {}, materials: {}, textures: {}, images: {}, shapes: {}, skeletons: {}, animations: {}}, i.metadata = {version: 4.5, type: "Object", generator: "Object3D.toJSON"});
        const n = {};
        if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), true === this.castShadow && (n.castShadow = true), true === this.receiveShadow && (n.receiveShadow = true), false === this.visible && (n.visible = false), false === this.frustumCulled && (n.frustumCulled = false), 0 !== this.renderOrder && (n.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), n.layers = this.layers.mask, n.matrix = this.matrix.toArray(), false === this.matrixAutoUpdate && (n.matrixAutoUpdate = false), this.isInstancedMesh && (n.type = "InstancedMesh", n.count = this.count, n.instanceMatrix = this.instanceMatrix.toJSON(), null !== this.instanceColor && (n.instanceColor = this.instanceColor.toJSON())), this.isScene) this.background && (this.background.isColor ? n.background = this.background.toJSON() : this.background.isTexture && (n.background = this.background.toJSON(t).uuid)), this.environment && this.environment.isTexture && (n.environment = this.environment.toJSON(t).uuid); else if (this.isMesh || this.isLine || this.isPoints) {
          n.geometry = (void 0 === t.geometries[this.geometry.uuid] && (t.geometries[this.geometry.uuid] = this.geometry.toJSON(t)), this.geometry.uuid);
          const e = this.geometry.parameters;
          if (void 0 !== e && void 0 !== e.shapes) {
            const i = e.shapes;
            if (Array.isArray(i)) for (let e = 0, n = i.length; e < n; e++) {
              const n = i[e];
              void 0 === t.shapes[n.uuid] && (t.shapes[n.uuid] = n.toJSON(t)), n.uuid;
            } else void 0 === t.shapes[i.uuid] && (t.shapes[i.uuid] = i.toJSON(t)), i.uuid;
          }
        }
        if (this.isSkinnedMesh && (n.bindMode = this.bindMode, n.bindMatrix = this.bindMatrix.toArray(), void 0 !== this.skeleton && (void 0 === t.skeletons[this.skeleton.uuid] && (t.skeletons[this.skeleton.uuid] = this.skeleton.toJSON(t)), this.skeleton.uuid, n.skeleton = this.skeleton.uuid)), void 0 !== this.material) if (Array.isArray(this.material)) {
          const e = [];
          for (let i = 0, n = this.material.length; i < n; i++) e.push((void 0 === t.materials[this.material[i].uuid] && (t.materials[this.material[i].uuid] = this.material[i].toJSON(t)), this.material[i].uuid));
          n.material = e;
        } else n.material = (void 0 === t.materials[this.material.uuid] && (t.materials[this.material.uuid] = this.material.toJSON(t)), this.material.uuid);
        if (this.children.length > 0) {
          n.children = [];
          for (let e = 0; e < this.children.length; e++) n.children.push(this.children[e].toJSON(t).object);
        }
        if (this.animations.length > 0) {
          n.animations = [];
          for (let e = 0; e < this.animations.length; e++) {
            const i = this.animations[e];
            n.animations.push((void 0 === t.animations[i.uuid] && (t.animations[i.uuid] = i.toJSON(t)), i.uuid));
          }
        }
        if (e) {
          const e = o(t.geometries), n = o(t.materials), r = o(t.textures), s = o(t.images), a = o(t.shapes), l = o(t.skeletons), c = o(t.animations);
          e.length > 0 && (i.geometries = e), n.length > 0 && (i.materials = n), r.length > 0 && (i.textures = r), s.length > 0 && (i.images = s), a.length > 0 && (i.shapes = a), l.length > 0 && (i.skeletons = l), c.length > 0 && (i.animations = c);
        }
        return i.object = n, i;
        function o(t) {
          const e = [];
          for (const i in t) {
            const n = t[i];
            delete n.metadata, e.push(n);
          }
          return e;
        }
      }
      clone(t) {
        return (new this.constructor).copy(this, t);
      }
      copy(t, e = true) {
        if (this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.rotation.order = t.rotation.order, this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.userData = JSON.parse(JSON.stringify(t.userData)), true === e) for (let e = 0; e < t.children.length; e++) {
          const i = t.children[e];
          this.add(i.clone());
        }
        return this;
      }
    }
    Object3D.DefaultUp = new three_module_Vector3(0, 1, 0), Object3D.DefaultMatrixAutoUpdate = true, Object3D.prototype.isObject3D = true;
    const Qt = new three_module_Vector3, $t = new three_module_Vector3, te = new three_module_Vector3, ee = new three_module_Vector3, ie = new three_module_Vector3, ne = new three_module_Vector3, re = new three_module_Vector3, oe = new three_module_Vector3, se = new three_module_Vector3, ae = new three_module_Vector3;
    class Triangle {
      constructor(t = new three_module_Vector3, e = new three_module_Vector3, i = new three_module_Vector3) {
        this.a = t, this.b = e, this.c = i;
      }
      static getNormal(t, e, i, n) {
        n.subVectors(i, e), Qt.subVectors(t, e), n.cross(Qt);
        const r = n.lengthSq();
        return r > 0 ? n.multiplyScalar(1 / Math.sqrt(r)) : n.set(0, 0, 0);
      }
      static getBarycoord(t, e, i, n, r) {
        Qt.subVectors(n, e), $t.subVectors(i, e), te.subVectors(t, e);
        const o = Qt.dot(Qt), s = Qt.dot($t), a = Qt.dot(te), l = $t.dot($t), c = $t.dot(te), h = o * l - s * s;
        if (0 === h) return r.set(-2, -1, -1);
        const u = 1 / h, m = (l * a - s * c) * u, p = (o * c - s * a) * u;
        return r.set(1 - m - p, p, m);
      }
      static containsPoint(t, e, i, n) {
        return this.getBarycoord(t, e, i, n, ee), ee.x >= 0 && ee.y >= 0 && ee.x + ee.y <= 1;
      }
      static getUV(t, e, i, n, r, o, s, a) {
        return this.getBarycoord(t, e, i, n, ee), a.set(0, 0), a.addScaledVector(r, ee.x), a.addScaledVector(o, ee.y), a.addScaledVector(s, ee.z), a;
      }
      static isFrontFacing(t, e, i, n) {
        return Qt.subVectors(i, e), $t.subVectors(t, e), Qt.cross($t).dot(n) < 0;
      }
      set(t, e, i) {
        return this.a.copy(t), this.b.copy(e), this.c.copy(i), this;
      }
      setFromPointsAndIndices(t, e, i, n) {
        return this.a.copy(t[e]), this.b.copy(t[i]), this.c.copy(t[n]), this;
      }
      clone() {
        return (new this.constructor).copy(this);
      }
      copy(t) {
        return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this;
      }
      getArea() {
        return Qt.subVectors(this.c, this.b), $t.subVectors(this.a, this.b), 0.5 * Qt.cross($t).length();
      }
      getMidpoint(t) {
        return t.addVectors(this.a, this.b).add(this.c).multiplyScalar(0.3333333333333333);
      }
      getNormal(t) {
        return Triangle.getNormal(this.a, this.b, this.c, t);
      }
      getPlane(t) {
        return t.setFromCoplanarPoints(this.a, this.b, this.c);
      }
      getBarycoord(t, e) {
        return Triangle.getBarycoord(t, this.a, this.b, this.c, e);
      }
      getUV(t, e, i, n, r) {
        return Triangle.getUV(t, this.a, this.b, this.c, e, i, n, r);
      }
      containsPoint(t) {
        return Triangle.containsPoint(t, this.a, this.b, this.c);
      }
      isFrontFacing(t) {
        return Triangle.isFrontFacing(this.a, this.b, this.c, t);
      }
      intersectsBox(t) {
        return t.intersectsTriangle(this);
      }
      closestPointToPoint(t, e) {
        const i = this.a, n = this.b, r = this.c;
        let o, s;
        ie.subVectors(n, i), ne.subVectors(r, i), oe.subVectors(t, i);
        const a = ie.dot(oe), l = ne.dot(oe);
        if (a <= 0 && l <= 0) return e.copy(i);
        se.subVectors(t, n);
        const c = ie.dot(se), h = ne.dot(se);
        if (c >= 0 && h <= c) return e.copy(n);
        const u = a * h - c * l;
        if (u <= 0 && a >= 0 && c <= 0) return o = a / (a - c), e.copy(i).addScaledVector(ie, o);
        ae.subVectors(t, r);
        const m = ie.dot(ae), p = ne.dot(ae);
        if (p >= 0 && m <= p) return e.copy(r);
        const d = m * l - a * p;
        if (d <= 0 && l >= 0 && p <= 0) return s = l / (l - p), e.copy(i).addScaledVector(ne, s);
        const f = c * p - m * h;
        if (f <= 0 && h - c >= 0 && m - p >= 0) return re.subVectors(r, n), s = (h - c) / (h - c + (m - p)), e.copy(n).addScaledVector(re, s);
        const _ = 1 / (f + d + u);
        return o = d * _, s = u * _, e.copy(i).addScaledVector(ie, o).addScaledVector(ne, s);
      }
      equals(t) {
        return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c);
      }
    }
    let le = 0;
    var ce = "__private_" + e++ + "_" + "alphaTest";
    class Material extends EventDispatcher {
      constructor() {
        super(), Object.defineProperty(this, ce, {writable: true, value: 0}), Object.defineProperty(this, "id", {value: le++}), this.uuid = q(), this.name = "", this.type = "Material", this.fog = true, this.blending = 1, this.side = 0, this.vertexColors = false, this.opacity = 1, this.format = T, this.transparent = false, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = o, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = 3, this.depthTest = true, this.depthWrite = true, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = U, this.stencilZFail = U, this.stencilZPass = U, this.stencilWrite = false, this.clippingPlanes = null, this.clipIntersection = false, this.clipShadows = false, this.shadowSide = null, this.colorWrite = true, this.precision = null, this.polygonOffset = false, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = false, this.alphaToCoverage = false, this.premultipliedAlpha = false, this.visible = true, this.toneMapped = true, this.userData = {}, this.version = 0;
      }
      get alphaTest() {
        return t(this, ce)[ce];
      }
      set alphaTest (e) {
        t(this, ce)[ce] > 0 != e > 0 && this.version++, t(this, ce)[ce] = e;
      }
      onBuild() {}
      onBeforeCompile() {}
      customProgramCacheKey() {
        return this.onBeforeCompile.toString();
      }
      setValues(t) {
        if (void 0 !== t) for (const e in t) {
          const i = t[e];
          if (void 0 === i) {
            console.warn("THREE.Material: '" + e + "' parameter is undefined.");
            continue;
          }
          if ("shading" === e) {
            console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === i;
            continue;
          }
          const n = this[e];
          void 0 !== n ? n && n.isColor ? n.set(i) : n && n.isVector3 && i && i.isVector3 ? n.copy(i) : this[e] = i : console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material.");
        }
      }
      toJSON(t) {
        const e = void 0 === t || "string" == typeof t;
        e && (t = {textures: {}, images: {}});
        const i = {metadata: {version: 4.5, type: "Material", generator: "Material.toJSON"}};
        function n(t) {
          const e = [];
          for (const i in t) {
            const n = t[i];
            delete n.metadata, e.push(n);
          }
          return e;
        }
        if (i.uuid = this.uuid, i.type = this.type, "" !== this.name && (i.name = this.name), this.color && this.color.isColor && (i.color = this.color.getHex()), void 0 !== this.roughness && (i.roughness = this.roughness), void 0 !== this.metalness && (i.metalness = this.metalness), this.sheenTint && this.sheenTint.isColor && (i.sheenTint = this.sheenTint.getHex()), this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (i.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (i.specular = this.specular.getHex()), void 0 !== this.specularIntensity && (i.specularIntensity = this.specularIntensity), this.specularTint && this.specularTint.isColor && (i.specularTint = this.specularTint.getHex()), void 0 !== this.shininess && (i.shininess = this.shininess), void 0 !== this.clearcoat && (i.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (i.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (i.clearcoatMap = this.clearcoatMap.toJSON(t).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid, i.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (i.map = this.map.toJSON(t).uuid), this.matcap && this.matcap.isTexture && (i.matcap = this.matcap.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(t).uuid, i.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (i.aoMap = this.aoMap.toJSON(t).uuid, i.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(t).uuid, i.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(t).uuid, i.normalMapType = this.normalMapType, i.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(t).uuid, i.displacementScale = this.displacementScale, i.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(t).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (i.specularIntensityMap = this.specularIntensityMap.toJSON(t).uuid), this.specularTintMap && this.specularTintMap.isTexture && (i.specularTintMap = this.specularTintMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(t).uuid, void 0 !== this.combine && (i.combine = this.combine)), void 0 !== this.envMapIntensity && (i.envMapIntensity = this.envMapIntensity), void 0 !== this.reflectivity && (i.reflectivity = this.reflectivity), void 0 !== this.refractionRatio && (i.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(t).uuid), void 0 !== this.transmission && (i.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (i.transmissionMap = this.transmissionMap.toJSON(t).uuid), void 0 !== this.thickness && (i.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (i.thicknessMap = this.thicknessMap.toJSON(t).uuid), void 0 !== this.attenuationDistance && (i.attenuationDistance = this.attenuationDistance), void 0 !== this.attenuationTint && (i.attenuationTint = this.attenuationTint.getHex()), void 0 !== this.size && (i.size = this.size), null !== this.shadowSide && (i.shadowSide = this.shadowSide), void 0 !== this.sizeAttenuation && (i.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (i.blending = this.blending), 0 !== this.side && (i.side = this.side), this.vertexColors && (i.vertexColors = true), this.opacity < 1 && (i.opacity = this.opacity), this.format !== T && (i.format = this.format), true === this.transparent && (i.transparent = this.transparent), i.depthFunc = this.depthFunc, i.depthTest = this.depthTest, i.depthWrite = this.depthWrite, i.colorWrite = this.colorWrite, i.stencilWrite = this.stencilWrite, i.stencilWriteMask = this.stencilWriteMask, i.stencilFunc = this.stencilFunc, i.stencilRef = this.stencilRef, i.stencilFuncMask = this.stencilFuncMask, i.stencilFail = this.stencilFail, i.stencilZFail = this.stencilZFail, i.stencilZPass = this.stencilZPass, this.rotation && 0 !== this.rotation && (i.rotation = this.rotation), true === this.polygonOffset && (i.polygonOffset = true), 0 !== this.polygonOffsetFactor && (i.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (i.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && 1 !== this.linewidth && (i.linewidth = this.linewidth), void 0 !== this.dashSize && (i.dashSize = this.dashSize), void 0 !== this.gapSize && (i.gapSize = this.gapSize), void 0 !== this.scale && (i.scale = this.scale), true === this.dithering && (i.dithering = true), this.alphaTest > 0 && (i.alphaTest = this.alphaTest), true === this.alphaToCoverage && (i.alphaToCoverage = this.alphaToCoverage), true === this.premultipliedAlpha && (i.premultipliedAlpha = this.premultipliedAlpha), true === this.wireframe && (i.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (i.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (i.wireframeLinejoin = this.wireframeLinejoin), true === this.flatShading && (i.flatShading = this.flatShading), false === this.visible && (i.visible = false), false === this.toneMapped && (i.toneMapped = false), "{}" !== JSON.stringify(this.userData) && (i.userData = this.userData), e) {
          const e = "__private_" + e++ + "_" + t.textures, r = "__private_" + e++ + "_" + t.images;
          e.length > 0 && (i.textures = e), r.length > 0 && (i.images = r);
        }
        return i;
      }
      clone() {
        return (new this.constructor).copy(this);
      }
      copy(t) {
        this.name = t.name, this.fog = t.fog, this.blending = t.blending, this.side = t.side, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.format = t.format, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.stencilWriteMask = t.stencilWriteMask, this.stencilFunc = t.stencilFunc, this.stencilRef = t.stencilRef, this.stencilFuncMask = t.stencilFuncMask, this.stencilFail = t.stencilFail, this.stencilZFail = t.stencilZFail, this.stencilZPass = t.stencilZPass, this.stencilWrite = t.stencilWrite;
        const e = t.clippingPlanes;
        let i = null;
        if (null !== e) {
          const t = e.length;
          i = new Array(t);
          for (let n = 0; n !== t; ++n) i[n] = e[n].clone();
        }
        return this.clippingPlanes = i, this.clipIntersection = t.clipIntersection, this.clipShadows = t.clipShadows, this.shadowSide = t.shadowSide, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.alphaToCoverage = t.alphaToCoverage, this.premultipliedAlpha = t.premultipliedAlpha, this.visible = t.visible, this.toneMapped = t.toneMapped, this.userData = JSON.parse(JSON.stringify(t.userData)), this;
      }
      dispose() {
        this.dispatchEvent({type: "dispose"});
      }
      set needsUpdate (t) {
        true === t && this.version++;
      }
    }
    Material.prototype.isMaterial = true;
    const he = {aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074}, ue = {h: 0, s: 0, l: 0}, me = {h: 0, s: 0, l: 0};
    function de(t) {
      return t < 0.04045 ? 0.0773993808 * t : Math.pow(0.9478672986 * t + 0.0521327014, 2.4);
    }
    function fe(t) {
      return t < 0.0031308 ? 12.92 * t : 1.055 * Math.pow(t, 0.41666) - 0.055;
    }
    class three_module_Color {
      constructor(t, e, i) {
        return void 0 === e && void 0 === i ? this.set(t) : this.setRGB(t, e, i);
      }
      set(t) {
        return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t), this;
      }
      setScalar(t) {
        return this.r = t, this.g = t, this.b = t, this;
      }
      setHex(t) {
        return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (255 & t) / 255, this;
      }
      setRGB(t, e, i) {
        return this.r = t, this.g = e, this.b = i, this;
      }
      setHSL(t, e, i) {
        if (t = (t % 1 + 1) % 1, e = Math.max(0, Math.min(1, e)), i = Math.max(0, Math.min(1, i)), 0 === e) this.r = this.g = this.b = i; else {
          const n = i <= 0.5 ? i * (1 + e) : i + e - i * e, r = 2 * i - n;
          this.r = (t + 0.3333333333333333 < 0 && (t + 0.3333333333333333 += 1), t + 0.3333333333333333 > 1 && (t + 0.3333333333333333 -= 1), t + 0.3333333333333333 < 0.16666666666666666 ? r + 6 * (n - r) * (t + 0.3333333333333333) : t + 0.3333333333333333 < 0.5 ? n : t + 0.3333333333333333 < 0.6666666666666666 ? r + 6 * (n - r) * (0.6666666666666666 - (t + 0.3333333333333333)) : r), this.g = (t < 0 && (t += 1), t > 1 && (t -= 1), t < 0.16666666666666666 ? r + 6 * (n - r) * t : t < 0.5 ? n : t < 0.6666666666666666 ? r + 6 * (n - r) * (0.6666666666666666 - t) : r), this.b = (t - 0.3333333333333333 < 0 && (t - 0.3333333333333333 += 1), t - 0.3333333333333333 > 1 && (t - 0.3333333333333333 -= 1), t - 0.3333333333333333 < 0.16666666666666666 ? r + 6 * (n - r) * (t - 0.3333333333333333) : t - 0.3333333333333333 < 0.5 ? n : t - 0.3333333333333333 < 0.6666666666666666 ? r + 6 * (n - r) * (0.6666666666666666 - (t - 0.3333333333333333)) : r);
        }
        return this;
      }
      setStyle(t) {
        function e(e) {
          void 0 !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.");
        }
        let i;
        if (i = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t)) {
          let t;
          const n = i[1], r = i[2];
          switch (n) {
            case "rgb":
            case "rgba":
              if (t = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r)) return this.r = Math.min(255, parseInt(t[1], 10)) / 255, this.g = Math.min(255, parseInt(t[2], 10)) / 255, this.b = Math.min(255, parseInt(t[3], 10)) / 255, e(t[4]), this;
              if (t = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r)) return this.r = Math.min(100, parseInt(t[1], 10)) / 100, this.g = Math.min(100, parseInt(t[2], 10)) / 100, this.b = Math.min(100, parseInt(t[3], 10)) / 100, e(t[4]), this;
              break;
            case "hsl":
            case "hsla":
              if (t = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r)) {
                const i = parseFloat(t[1]) / 360, n = parseInt(t[2], 10) / 100, r = parseInt(t[3], 10) / 100;
                return e(t[4]), this.setHSL(i, n, r);
              }
          }
        } else if (i = /^\#([A-Fa-f\d]+)$/.exec(t)) {
          const t = i[1], e = t.length;
          if (3 === e) return this.r = parseInt(t.charAt(0) + t.charAt(0), 16) / 255, this.g = parseInt(t.charAt(1) + t.charAt(1), 16) / 255, this.b = parseInt(t.charAt(2) + t.charAt(2), 16) / 255, this;
          if (6 === e) return this.r = parseInt(t.charAt(0) + t.charAt(1), 16) / 255, this.g = parseInt(t.charAt(2) + t.charAt(3), 16) / 255, this.b = parseInt(t.charAt(4) + t.charAt(5), 16) / 255, this;
        }
        return t && t.length > 0 ? this.setColorName(t) : this;
      }
      setColorName(t) {
        const e = he[t.toLowerCase()];
        return void 0 !== e ? this.setHex(e) : console.warn("THREE.Color: Unknown color " + t), this;
      }
      clone() {
        return new this.constructor(this.r, this.g, this.b);
      }
      copy(t) {
        return this.r = t.r, this.g = t.g, this.b = t.b, this;
      }
      copyGammaToLinear(t, e = 2) {
        return this.r = Math.pow(t.r, e), this.g = Math.pow(t.g, e), this.b = Math.pow(t.b, e), this;
      }
      copyLinearToGamma(t, e = 2) {
        const i = e > 0 ? 1 / e : 1;
        return this.r = Math.pow(t.r, i), this.g = Math.pow(t.g, i), this.b = Math.pow(t.b, i), this;
      }
      convertGammaToLinear(t) {
        return this.copyGammaToLinear(this, t), this;
      }
      convertLinearToGamma(t) {
        return this.copyLinearToGamma(this, t), this;
      }
      copySRGBToLinear(t) {
        return this.r = de(t.r), this.g = de(t.g), this.b = de(t.b), this;
      }
      copyLinearToSRGB(t) {
        return this.r = fe(t.r), this.g = fe(t.g), this.b = fe(t.b), this;
      }
      convertSRGBToLinear() {
        return this.copySRGBToLinear(this), this;
      }
      convertLinearToSRGB() {
        return this.copyLinearToSRGB(this), this;
      }
      getHex() {
        return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0;
      }
      getHexString() {
        return ("000000" + this.getHex().toString(16)).slice(-6);
      }
      getHSL(t) {
        const e = this.r, i = this.g, n = this.b, r = Math.max(e, i, n), o = Math.min(e, i, n);
        let s, a;
        const l = (o + r) / 2;
        if (o === r) s = 0, a = 0; else {
          const t = r - o;
          switch (a = l <= 0.5 ? t / (r + o) : t / (2 - r - o), r) {
            case e:
              s = (i - n) / t + (i < n ? 6 : 0);
              break;
            case i:
              s = (n - e) / t + 2;
              break;
            case n:
              s = (e - i) / t + 4;
          }
          s /= 6;
        }
        return t.h = s, t.s = a, t.l = l, t;
      }
      getStyle() {
        return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")";
      }
      offsetHSL(t, e, i) {
        return this.getHSL(ue), ue.h += t, ue.s += e, ue.l += i, this.setHSL(ue.h, ue.s, ue.l), this;
      }
      add(t) {
        return this.r += t.r, this.g += t.g, this.b += t.b, this;
      }
      addColors(t, e) {
        return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this;
      }
      addScalar(t) {
        return this.r += t, this.g += t, this.b += t, this;
      }
      sub(t) {
        return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this;
      }
      multiply(t) {
        return this.r *= t.r, this.g *= t.g, this.b *= t.b, this;
      }
      multiplyScalar(t) {
        return this.r *= t, this.g *= t, this.b *= t, this;
      }
      lerp(t, e) {
        return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this;
      }
      lerpColors(t, e, i) {
        return this.r = t.r + (e.r - t.r) * i, this.g = t.g + (e.g - t.g) * i, this.b = t.b + (e.b - t.b) * i, this;
      }
      lerpHSL(t, e) {
        this.getHSL(ue), t.getHSL(me);
        const i = (1 - e) * ue.h + e * me.h, n = (1 - e) * ue.s + e * me.s, r = (1 - e) * ue.l + e * me.l;
        return this.setHSL(i, n, r), this;
      }
      equals(t) {
        return t.r === this.r && t.g === this.g && t.b === this.b;
      }
      fromArray(t, e = 0) {
        return this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this;
      }
      toArray(t = [], e = 0) {
        return t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t;
      }
      fromBufferAttribute(t, e) {
        return this.r = t.getX(e), this.g = t.getY(e), this.b = t.getZ(e), true === t.normalized && (this.r /= 255, this.g /= 255, this.b /= 255), this;
      }
      toJSON() {
        return this.getHex();
      }
    }
    three_module_Color.NAMES = he, three_module_Color.prototype.isColor = true, three_module_Color.prototype.r = 1, three_module_Color.prototype.g = 1, three_module_Color.prototype.b = 1;
    class MeshBasicMaterial extends Material {
      constructor(t) {
        super(), this.type = "MeshBasicMaterial", this.color = new three_module_Color(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(t);
      }
      copy(t) {
        return super.copy(t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this;
      }
    }
    MeshBasicMaterial.prototype.isMeshBasicMaterial = true;
    const _e = new three_module_Vector3, ye = new Vector2;
    class BufferAttribute {
      constructor(t, e, i) {
        if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.name = "", this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e : 0, this.normalized = true === i, this.usage = k, this.updateRange = {offset: 0, count: -1}, this.version = 0;
      }
      onUploadCallback() {}
      set needsUpdate (t) {
        true === t && this.version++;
      }
      setUsage(t) {
        return this.usage = t, this;
      }
      copy(t) {
        return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.usage = t.usage, this;
      }
      copyAt(t, e, i) {
        t *= this.itemSize, i *= e.itemSize;
        for (let n = 0, r = this.itemSize; n < r; n++) this.array[t + n] = e.array[i + n];
        return this;
      }
      copyArray(t) {
        return this.array.set(t), this;
      }
      copyColorsArray(t) {
        const e = this.array;
        let i = 0;
        for (let n = 0, r = t.length; n < r; n++) {
          let r = t[n];
          void 0 === r && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", n), r = new three_module_Color), e[i++] = r.r, e[i++] = r.g, e[i++] = r.b;
        }
        return this;
      }
      copyVector2sArray(t) {
        const e = this.array;
        let i = 0;
        for (let n = 0, r = t.length; n < r; n++) {
          let r = t[n];
          void 0 === r && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", n), r = new Vector2), e[i++] = r.x, e[i++] = r.y;
        }
        return this;
      }
      copyVector3sArray(t) {
        const e = this.array;
        let i = 0;
        for (let n = 0, r = t.length; n < r; n++) {
          let r = t[n];
          void 0 === r && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", n), r = new three_module_Vector3), e[i++] = r.x, e[i++] = r.y, e[i++] = r.z;
        }
        return this;
      }
      copyVector4sArray(t) {
        const e = this.array;
        let i = 0;
        for (let n = 0, r = t.length; n < r; n++) {
          let r = t[n];
          void 0 === r && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", n), r = new Vector4), e[i++] = r.x, e[i++] = r.y, e[i++] = r.z, e[i++] = r.w;
        }
        return this;
      }
      applyMatrix3(t) {
        if (2 === this.itemSize) for (let e = 0, i = this.count; e < i; e++) ye.fromBufferAttribute(this, e), ye.applyMatrix3(t), this.setXY(e, ye.x, ye.y); else if (3 === this.itemSize) for (let e = 0, i = this.count; e < i; e++) _e.fromBufferAttribute(this, e), _e.applyMatrix3(t), this.setXYZ(e, _e.x, _e.y, _e.z);
        return this;
      }
      applyMatrix4(t) {
        for (let e = 0, i = this.count; e < i; e++) _e.x = this.getX(e), _e.y = this.getY(e), _e.z = this.getZ(e), _e.applyMatrix4(t), this.setXYZ(e, _e.x, _e.y, _e.z);
        return this;
      }
      applyNormalMatrix(t) {
        for (let e = 0, i = this.count; e < i; e++) _e.x = this.getX(e), _e.y = this.getY(e), _e.z = this.getZ(e), _e.applyNormalMatrix(t), this.setXYZ(e, _e.x, _e.y, _e.z);
        return this;
      }
      transformDirection(t) {
        for (let e = 0, i = this.count; e < i; e++) _e.x = this.getX(e), _e.y = this.getY(e), _e.z = this.getZ(e), _e.transformDirection(t), this.setXYZ(e, _e.x, _e.y, _e.z);
        return this;
      }
      set(t, e = 0) {
        return this.array.set(t, e), this;
      }
      getX(t) {
        return this.array[t * this.itemSize];
      }
      setX(t, e) {
        return this.array[t * this.itemSize] = e, this;
      }
      getY(t) {
        return this.array[t * this.itemSize + 1];
      }
      setY(t, e) {
        return this.array[t * this.itemSize + 1] = e, this;
      }
      getZ(t) {
        return this.array[t * this.itemSize + 2];
      }
      setZ(t, e) {
        return this.array[t * this.itemSize + 2] = e, this;
      }
      getW(t) {
        return this.array[t * this.itemSize + 3];
      }
      setW(t, e) {
        return this.array[t * this.itemSize + 3] = e, this;
      }
      setXY(t, e, i) {
        return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this;
      }
      setXYZ(t, e, i, n) {
        return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this.array[t + 2] = n, this;
      }
      setXYZW(t, e, i, n, r) {
        return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this.array[t + 2] = n, this.array[t + 3] = r, this;
      }
      onUpload(t) {
        return this.onUploadCallback = t, this;
      }
      clone() {
        return new this.constructor(this.array, this.itemSize).copy(this);
      }
      toJSON() {
        const t = {itemSize: this.itemSize, type: this.array.constructor.name, array: Array.prototype.slice.call(this.array), normalized: this.normalized};
        return "" !== this.name && (t.name = this.name), this.usage !== k && (t.usage = this.usage), 0 === this.updateRange.offset && -1 === this.updateRange.count || (t.updateRange = this.updateRange), t;
      }
    }
    BufferAttribute.prototype.isBufferAttribute = true;
    class Uint16BufferAttribute extends BufferAttribute {
      constructor(t, e, i) {
        super(new Uint16Array(t), e, i);
      }
    }
    class Uint32BufferAttribute extends BufferAttribute {
      constructor(t, e, i) {
        super(new Uint32Array(t), e, i);
      }
    }
    (class Float16BufferAttribute extends BufferAttribute {
      constructor(t, e, i) {
        super(new Uint16Array(t), e, i);
      }
    }.prototype.isFloat16BufferAttribute = true);
    class Float32BufferAttribute extends BufferAttribute {
      constructor(t, e, i) {
        super(new Float32Array(t), e, i);
      }
    }
    function ge(t) {
      if (0 === t.length) return -Infinity;
      let e = t[0];
      for (let i = 1, n = t.length; i < n; ++i) t[i] > e && (e = t[i]);
      return e;
    }
    Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array;
    let xe = 0;
    const ve = new Matrix4, be = new Object3D, we = new three_module_Vector3, Se = new Box3, Me = new Box3, Ce = new three_module_Vector3;
    class BufferGeometry extends EventDispatcher {
      constructor() {
        super(), Object.defineProperty(this, "id", {value: xe++}), this.uuid = q(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = false, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {start: 0, count: Infinity}, this.userData = {};
      }
      getIndex() {
        return this.index;
      }
      setIndex(t) {
        return Array.isArray(t) ? this.index = new (ge(t) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(t, 1) : this.index = t, this;
      }
      getAttribute(t) {
        return this.attributes[t];
      }
      setAttribute(t, e) {
        return this.attributes[t] = e, this;
      }
      deleteAttribute(t) {
        return delete this.attributes[t], this;
      }
      hasAttribute(t) {
        return void 0 !== this.attributes[t];
      }
      addGroup(t, e, i = 0) {
        this.groups.push({start: t, count: e, materialIndex: i});
      }
      clearGroups() {
        this.groups = [];
      }
      setDrawRange(t, e) {
        this.drawRange.start = t, this.drawRange.count = e;
      }
      applyMatrix4(t) {
        const e = this.attributes.position;
        void 0 !== e && (e.applyMatrix4(t), e.needsUpdate = true);
        const i = this.attributes.normal;
        if (void 0 !== i) {
          const e = (new Matrix3).getNormalMatrix(t);
          i.applyNormalMatrix(e), i.needsUpdate = true;
        }
        const n = this.attributes.tangent;
        return void 0 !== n && (n.transformDirection(t), n.needsUpdate = true), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this;
      }
      applyQuaternion(t) {
        return ve.makeRotationFromQuaternion(t), this.applyMatrix4(ve), this;
      }
      rotateX(t) {
        return ve.makeRotationX(t), this.applyMatrix4(ve), this;
      }
      rotateY(t) {
        return ve.makeRotationY(t), this.applyMatrix4(ve), this;
      }
      rotateZ(t) {
        return ve.makeRotationZ(t), this.applyMatrix4(ve), this;
      }
      translate(t, e, i) {
        return ve.makeTranslation(t, e, i), this.applyMatrix4(ve), this;
      }
      scale(t, e, i) {
        return ve.makeScale(t, e, i), this.applyMatrix4(ve), this;
      }
      lookAt(t) {
        return be.lookAt(t), be.updateMatrix(), this.applyMatrix4(be.matrix), this;
      }
      center() {
        return this.computeBoundingBox(), this.boundingBox.getCenter(we).negate(), this.translate(we.x, we.y, we.z), this;
      }
      setFromPoints(t) {
        const e = [];
        for (let i = 0, n = t.length; i < n; i++) {
          const n = t[i];
          e.push(n.x, n.y, n.z || 0);
        }
        return this.setAttribute("position", new Float32BufferAttribute(e, 3)), this;
      }
      computeBoundingBox() {
        null === this.boundingBox && (this.boundingBox = new Box3);
        const t = this.attributes.position, e = this.morphAttributes.position;
        if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingBox.set(new three_module_Vector3(-Infinity, -Infinity, -Infinity), new three_module_Vector3(Infinity, Infinity, Infinity));
        if (void 0 !== t) {
          if (this.boundingBox.setFromBufferAttribute(t), e) for (let t = 0, i = e.length; t < i; t++) {
            const i = e[t];
            Se.setFromBufferAttribute(i), this.morphTargetsRelative ? (Ce.addVectors(this.boundingBox.min, Se.min), this.boundingBox.expandByPoint(Ce), Ce.addVectors(this.boundingBox.max, Se.max), this.boundingBox.expandByPoint(Ce)) : (this.boundingBox.expandByPoint(Se.min), this.boundingBox.expandByPoint(Se.max));
          }
        } else this.boundingBox.makeEmpty();
        (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
      }
      computeBoundingSphere() {
        null === this.boundingSphere && (this.boundingSphere = new Sphere);
        const t = this.attributes.position, e = this.morphAttributes.position;
        if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingSphere.set(new three_module_Vector3, Infinity);
        if (t) {
          const i = this.boundingSphere.center;
          if (Se.setFromBufferAttribute(t), e) for (let t = 0, i = e.length; t < i; t++) {
            const i = e[t];
            Me.setFromBufferAttribute(i), this.morphTargetsRelative ? (Ce.addVectors(Se.min, Me.min), Se.expandByPoint(Ce), Ce.addVectors(Se.max, Me.max), Se.expandByPoint(Ce)) : (Se.expandByPoint(Me.min), Se.expandByPoint(Me.max));
          }
          Se.getCenter(i);
          let n = 0;
          for (let e = 0, r = t.count; e < r; e++) Ce.fromBufferAttribute(t, e), n = Math.max(n, i.distanceToSquared(Ce));
          if (e) for (let r = 0, o = e.length; r < o; r++) {
            const o = e[r], s = this.morphTargetsRelative;
            for (let e = 0, r = o.count; e < r; e++) Ce.fromBufferAttribute(o, e), s && (we.fromBufferAttribute(t, e), Ce.add(we)), n = Math.max(n, i.distanceToSquared(Ce));
          }
          this.boundingSphere.radius = Math.sqrt(n), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
        }
      }
      computeTangents() {
        const t = this.index, e = this.attributes;
        if (null === t || void 0 === e.position || void 0 === e.normal || void 0 === e.uv) return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
        const i = t.array, n = e.position.array, r = e.normal.array, o = e.uv.array, s = n.length / 3;
        void 0 === e.tangent && this.setAttribute("tangent", new BufferAttribute(new Float32Array(4 * s), 4));
        const a = e.tangent.array, l = [], c = [];
        for (let t = 0; t < s; t++) l[t] = new three_module_Vector3, c[t] = new three_module_Vector3;
        const h = new three_module_Vector3, u = new three_module_Vector3, m = new three_module_Vector3, p = new Vector2, d = new Vector2, f = new Vector2, _ = new three_module_Vector3, y = new three_module_Vector3;
        function g(t, e, i) {
          h.fromArray(n, 3 * t), u.fromArray(n, 3 * e), m.fromArray(n, 3 * i), p.fromArray(o, 2 * t), d.fromArray(o, 2 * e), f.fromArray(o, 2 * i), u.sub(h), m.sub(h), d.sub(p), f.sub(p);
          const r = 1 / (d.x * f.y - f.x * d.y);
          isFinite(r) && (_.copy(u).multiplyScalar(f.y).addScaledVector(m, -d.y).multiplyScalar(r), y.copy(m).multiplyScalar(d.x).addScaledVector(u, -f.x).multiplyScalar(r), l[t].add(_), l[e].add(_), l[i].add(_), c[t].add(y), c[e].add(y), c[i].add(y));
        }
        let x = this.groups;
        0 === x.length && (x = [{start: 0, count: i.length}]);
        for (let t = 0, e = x.length; t < e; ++t) {
          const e = x[t], n = e.start;
          for (let r = n + e.count; t < r; t += 3) g(i[t + 0], i[t + 1], i[t + 2]);
        }
        const v = new three_module_Vector3, b = new three_module_Vector3, w = new three_module_Vector3, S = new three_module_Vector3;
        function M(t) {
          w.fromArray(r, 3 * t), S.copy(w);
          const e = l[t];
          v.copy(e), v.sub(w.multiplyScalar(w.dot(e))).normalize(), b.crossVectors(S, e);
          const i = b.dot(c[t]) < 0 ? -1 : 1;
          a[4 * t] = v.x, a[4 * t + 1] = v.y, a[4 * t + 2] = v.z, a[4 * t + 3] = i;
        }
        for (let t = 0, e = x.length; t < e; ++t) {
          const e = x[t], n = e.start;
          for (let r = n + e.count; t < r; t += 3) M(i[t + 0]), M(i[t + 1]), M(i[t + 2]);
        }
      }
      computeVertexNormals() {
        const t = this.index, e = this.getAttribute("position");
        if (void 0 !== e) {
          let i = this.getAttribute("normal");
          if (void 0 === i) i = new BufferAttribute(new Float32Array(3 * e.count), 3), this.setAttribute("normal", i); else for (let t = 0, e = i.count; t < e; t++) i.setXYZ(t, 0, 0, 0);
          const n = new three_module_Vector3, r = new three_module_Vector3, o = new three_module_Vector3, s = new three_module_Vector3, a = new three_module_Vector3, l = new three_module_Vector3, c = new three_module_Vector3, h = new three_module_Vector3;
          if (t) for (let u = 0, m = t.count; u < m; u += 3) {
            const m = t.getX(u + 0), p = t.getX(u + 1), d = t.getX(u + 2);
            n.fromBufferAttribute(e, m), r.fromBufferAttribute(e, p), o.fromBufferAttribute(e, d), c.subVectors(o, r), h.subVectors(n, r), c.cross(h), s.fromBufferAttribute(i, m), a.fromBufferAttribute(i, p), l.fromBufferAttribute(i, d), s.add(c), a.add(c), l.add(c), i.setXYZ(m, s.x, s.y, s.z), i.setXYZ(p, a.x, a.y, a.z), i.setXYZ(d, l.x, l.y, l.z);
          } else for (let t = 0, s = e.count; t < s; t += 3) n.fromBufferAttribute(e, t + 0), r.fromBufferAttribute(e, t + 1), o.fromBufferAttribute(e, t + 2), c.subVectors(o, r), h.subVectors(n, r), c.cross(h), i.setXYZ(t + 0, c.x, c.y, c.z), i.setXYZ(t + 1, c.x, c.y, c.z), i.setXYZ(t + 2, c.x, c.y, c.z);
          this.normalizeNormals(), i.needsUpdate = true;
        }
      }
      merge(t, e) {
        if (!t || !t.isBufferGeometry) return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t);
        void 0 === e && (e = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
        const i = this.attributes;
        for (const n in i) {
          if (void 0 === t.attributes[n]) continue;
          const r = i[n].array, o = t.attributes[n], s = o.array, a = o.itemSize * e, l = Math.min(s.length, r.length - a);
          for (let t = 0, e = a; t < l; t++, e++) r[e] = s[t];
        }
        return this;
      }
      normalizeNormals() {
        const t = this.attributes.normal;
        for (let e = 0, i = t.count; e < i; e++) Ce.fromBufferAttribute(t, e), Ce.normalize(), t.setXYZ(e, Ce.x, Ce.y, Ce.z);
      }
      toNonIndexed() {
        function t(t, e) {
          const i = t.array, n = t.itemSize, r = t.normalized, o = new i.constructor(e.length * n);
          let s = 0, a = 0;
          for (let r = 0, l = e.length; r < l; r++) {
            s = t.isInterleavedBufferAttribute ? e[r] * t.data.stride + t.offset : e[r] * n;
            for (let t = 0; t < n; t++) o[a++] = i[s++];
          }
          return new BufferAttribute(o, n, r);
        }
        if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
        const e = new BufferGeometry, i = this.index.array, n = this.attributes;
        for (const r in n) {
          const o = t(n[r], i);
          e.setAttribute(r, o);
        }
        const r = this.morphAttributes;
        for (const n in r) {
          const o = [], s = r[n];
          for (let e = 0, n = s.length; e < n; e++) {
            const n = t(s[e], i);
            o.push(n);
          }
          e.morphAttributes[n] = o;
        }
        e.morphTargetsRelative = this.morphTargetsRelative;
        const o = this.groups;
        for (let t = 0, i = o.length; t < i; t++) {
          const i = o[t];
          e.addGroup(i.start, i.count, i.materialIndex);
        }
        return e;
      }
      toJSON() {
        const t = {metadata: {version: 4.5, type: "BufferGeometry", generator: "BufferGeometry.toJSON"}};
        if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), Object.keys(this.userData).length > 0 && (t.userData = this.userData), void 0 !== this.parameters) {
          const e = this.parameters;
          for (const i in e) void 0 !== e[i] && (t[i] = e[i]);
          return t;
        }
        t.data = {attributes: {}};
        const e = this.index;
        null !== e && (t.data.index = {type: e.array.constructor.name, array: Array.prototype.slice.call(e.array)});
        const i = this.attributes;
        for (const e in i) {
          const n = i[e];
          t.data.attributes[e] = n.toJSON(t.data);
        }
        const n = {};
        let r = false;
        for (const e in this.morphAttributes) {
          const i = this.morphAttributes[e], o = [];
          for (let e = 0, n = i.length; e < n; e++) {
            const n = i[e];
            o.push(n.toJSON(t.data));
          }
          o.length > 0 && (n[e] = o, r = true);
        }
        r && (t.data.morphAttributes = n, t.data.morphTargetsRelative = this.morphTargetsRelative);
        const o = this.groups;
        o.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(o)));
        const s = this.boundingSphere;
        return null !== s && (t.data.boundingSphere = {center: s.center.toArray(), radius: s.radius}), t;
      }
      clone() {
        return (new BufferGeometry).copy(this);
      }
      copy(t) {
        this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
        const e = {};
        this.name = t.name;
        const i = t.index;
        null !== i && this.setIndex(i.clone(e));
        const n = t.attributes;
        for (const t in n) {
          const i = n[t];
          this.setAttribute(t, i.clone(e));
        }
        const r = t.morphAttributes;
        for (const t in r) {
          const i = [], n = r[t];
          for (let t = 0, r = n.length; t < r; t++) i.push(n[t].clone(e));
          this.morphAttributes[t] = i;
        }
        this.morphTargetsRelative = t.morphTargetsRelative;
        const o = t.groups;
        for (let t = 0, e = o.length; t < e; t++) {
          const e = o[t];
          this.addGroup(e.start, e.count, e.materialIndex);
        }
        const s = t.boundingBox;
        null !== s && (this.boundingBox = s.clone());
        const a = t.boundingSphere;
        return null !== a && (this.boundingSphere = a.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, this;
      }
      dispose() {
        this.dispatchEvent({type: "dispose"});
      }
    }
    BufferGeometry.prototype.isBufferGeometry = true;
    const Ae = new Matrix4, Te = new Ray, Ee = new Sphere, Le = new three_module_Vector3, De = new three_module_Vector3, Ve = new three_module_Vector3, Be = new three_module_Vector3, Re = new three_module_Vector3, Pe = new three_module_Vector3, Ie = new three_module_Vector3, Fe = new three_module_Vector3, Ge = new three_module_Vector3, Ne = new Vector2, ze = new Vector2, Oe = new Vector2, Ue = new three_module_Vector3, ke = new three_module_Vector3;
    class Mesh extends Object3D {
      constructor(t = new BufferGeometry, e = new MeshBasicMaterial) {
        super(), this.type = "Mesh", this.geometry = t, this.material = e, this.updateMorphTargets();
      }
      copy(t) {
        return super.copy(t), void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this.material = t.material, this.geometry = t.geometry, this;
      }
      updateMorphTargets() {
        const t = this.geometry;
        if (t.isBufferGeometry) {
          const e = t.morphAttributes, i = Object.keys(e);
          if (i.length > 0) {
            const t = e[i[0]];
            if (void 0 !== t) {
              this.morphTargetInfluences = [], this.morphTargetDictionary = {};
              for (let e = 0, i = t.length; e < i; e++) {
                const i = t[e].name || String(e);
                this.morphTargetInfluences.push(0), this.morphTargetDictionary[i] = e;
              }
            }
          }
        } else {
          const e = t.morphTargets;
          void 0 !== e && e.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
        }
      }
      raycast(t, e) {
        const i = this.geometry, n = this.material, r = this.matrixWorld;
        if (void 0 === n) return;
        if (null === i.boundingSphere && i.computeBoundingSphere(), Ee.copy(i.boundingSphere), Ee.applyMatrix4(r), false === t.ray.intersectsSphere(Ee)) return;
        if (Ae.copy(r).invert(), Te.copy(t.ray).applyMatrix4(Ae), null !== i.boundingBox && false === Te.intersectsBox(i.boundingBox)) return;
        let o;
        if (i.isBufferGeometry) {
          const r = i.index, s = i.attributes.position, a = i.morphAttributes.position, l = i.morphTargetsRelative, c = i.attributes.uv, h = i.attributes.uv2, u = i.groups, m = i.drawRange;
          if (null !== r) if (Array.isArray(n)) for (let i = 0, p = u.length; i < p; i++) {
            const p = u[i], d = n[p.materialIndex];
            for (let i = Math.max(p.start, m.start), n = Math.min(p.start + p.count, m.start + m.count); i < n; i += 3) {
              const n = r.getX(i), u = r.getX(i + 1), m = r.getX(i + 2);
              o = He(this, d, t, Te, s, a, l, c, h, n, u, m), o && (o.faceIndex = Math.floor(i / 3), o.face.materialIndex = p.materialIndex, e.push(o));
            }
          } else {
            for (let i = Math.max(0, m.start), u = Math.min(r.count, m.start + m.count); i < u; i += 3) {
              const u = r.getX(i), m = r.getX(i + 1), p = r.getX(i + 2);
              o = He(this, n, t, Te, s, a, l, c, h, u, m, p), o && (o.faceIndex = Math.floor(i / 3), e.push(o));
            }
          } else if (void 0 !== s) if (Array.isArray(n)) for (let i = 0, r = u.length; i < r; i++) {
            const r = u[i], p = n[r.materialIndex];
            for (let i = Math.max(r.start, m.start), n = Math.min(r.start + r.count, m.start + m.count); i < n; i += 3) {
              o = He(this, p, t, Te, s, a, l, c, h, i, i + 1, i + 2), o && (o.faceIndex = Math.floor(i / 3), o.face.materialIndex = r.materialIndex, e.push(o));
            }
          } else {
            for (let i = Math.max(0, m.start), r = Math.min(s.count, m.start + m.count); i < r; i += 3) {
              o = He(this, n, t, Te, s, a, l, c, h, i, i + 1, i + 2), o && (o.faceIndex = Math.floor(i / 3), e.push(o));
            }
          }
        } else i.isGeometry && console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
    }
    function He(t, e, i, n, r, o, s, a, l, c, h, u) {
      Le.fromBufferAttribute(r, c), De.fromBufferAttribute(r, h), Ve.fromBufferAttribute(r, u);
      const m = t.morphTargetInfluences;
      if (o && m) {
        Ie.set(0, 0, 0), Fe.set(0, 0, 0), Ge.set(0, 0, 0);
        for (let t = 0, e = o.length; t < e; t++) {
          const e = m[t], i = o[t];
          0 !== e && (Be.fromBufferAttribute(i, c), Re.fromBufferAttribute(i, h), Pe.fromBufferAttribute(i, u), s ? (Ie.addScaledVector(Be, e), Fe.addScaledVector(Re, e), Ge.addScaledVector(Pe, e)) : (Ie.addScaledVector(Be.sub(Le), e), Fe.addScaledVector(Re.sub(De), e), Ge.addScaledVector(Pe.sub(Ve), e)));
        }
        Le.add(Ie), De.add(Fe), Ve.add(Ge);
      }
      t.isSkinnedMesh && (t.boneTransform(c, Le), t.boneTransform(h, De), t.boneTransform(u, Ve));
      const p = function (t, e, i, n, r, o, s, a) {
        let l;
        if (l = 1 === e.side ? n.intersectTriangle(s, o, r, true, a) : n.intersectTriangle(r, o, s, 2 !== e.side, a), null === l) return null;
        ke.copy(a), ke.applyMatrix4(t.matrixWorld);
        const c = i.ray.origin.distanceTo(ke);
        return c < i.near || c > i.far ? null : {distance: c, point: ke.clone(), object: t};
      }(t, e, i, n, Le, De, Ve, Ue);
      if (p) {
        a && (Ne.fromBufferAttribute(a, c), ze.fromBufferAttribute(a, h), Oe.fromBufferAttribute(a, u), p.uv = Triangle.getUV(Ue, Le, De, Ve, Ne, ze, Oe, new Vector2)), l && (Ne.fromBufferAttribute(l, c), ze.fromBufferAttribute(l, h), Oe.fromBufferAttribute(l, u), p.uv2 = Triangle.getUV(Ue, Le, De, Ve, Ne, ze, Oe, new Vector2));
        const t = {a: c, b: h, c: u, normal: new three_module_Vector3, materialIndex: 0};
        Triangle.getNormal(Le, De, Ve, t.normal), p.face = t;
      }
      return p;
    }
    Mesh.prototype.isMesh = true;
    class BoxGeometry extends BufferGeometry {
      constructor(t = 1, e = 1, i = 1, n = 1, r = 1, o = 1) {
        super(), this.type = "BoxGeometry", this.parameters = {width: t, height: e, depth: i, widthSegments: n, heightSegments: r, depthSegments: o};
        const s = this;
        n = Math.floor(n), r = Math.floor(r), o = Math.floor(o);
        const a = [], l = [], c = [], h = [];
        let u = 0, m = 0;
        function p(t, e, i, n, r, o, p, d, f, _, y) {
          const g = o / f, x = p / _, v = o / 2, b = p / 2, w = d / 2, S = f + 1, M = _ + 1;
          let C = 0, A = 0;
          const T = new three_module_Vector3;
          for (let o = 0; o < M; o++) {
            const s = o * x - b;
            for (let a = 0; a < S; a++) {
              const u = a * g - v;
              T[t] = u * n, T[e] = s * r, T[i] = w, l.push(T.x, T.y, T.z), T[t] = 0, T[e] = 0, T[i] = d > 0 ? 1 : -1, c.push(T.x, T.y, T.z), h.push(a / f), h.push(1 - o / _), C += 1;
            }
          }
          for (let t = 0; t < _; t++) for (let e = 0; e < f; e++) {
            const i = u + e + S * t, n = u + e + S * (t + 1), r = u + (e + 1) + S * (t + 1), o = u + (e + 1) + S * t;
            a.push(i, n, o), a.push(n, r, o), A += 6;
          }
          s.addGroup(m, A, y), m += A, u += C;
        }
        p("z", "y", "x", -1, -1, i, e, t, o, r, 0), p("z", "y", "x", 1, -1, i, e, -t, o, r, 1), p("x", "z", "y", 1, 1, t, i, e, n, o, 2), p("x", "z", "y", 1, -1, t, i, -e, n, o, 3), p("x", "y", "z", 1, -1, t, e, i, n, r, 4), p("x", "y", "z", -1, -1, t, e, -i, n, r, 5), this.setIndex(a), this.setAttribute("position", new Float32BufferAttribute(l, 3)), this.setAttribute("normal", new Float32BufferAttribute(c, 3)), this.setAttribute("uv", new Float32BufferAttribute(h, 2));
      }
      static fromJSON(t) {
        return new BoxGeometry(t.width, t.height, t.depth, t.widthSegments, t.heightSegments, t.depthSegments);
      }
    }
    function We(t) {
      const e = {};
      for (const i in t) {
        e[i] = {};
        for (const n in t[i]) {
          const r = t[i][n];
          r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? e[i][n] = r.clone() : Array.isArray(r) ? e[i][n] = r.slice() : e[i][n] = r;
        }
      }
      return e;
    }
    function Je(t) {
      const e = {};
      for (let i = 0; i < t.length; i++) {
        const n = We(t[i]);
        for (const t in n) e[t] = n[t];
      }
      return e;
    }
    const je = {clone: We, merge: Je};
    class ShaderMaterial extends Material {
      constructor(t) {
        super(), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = false, this.wireframeLinewidth = 1, this.fog = false, this.lights = false, this.clipping = false, this.extensions = {derivatives: false, fragDepth: false, drawBuffers: false, shaderTextureLOD: false}, this.defaultAttributeValues = {color: [1, 1, 1], uv: [0, 0], uv2: [0, 0]}, this.index0AttributeName = void 0, this.uniformsNeedUpdate = false, this.glslVersion = null, void 0 !== t && (void 0 !== t.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(t));
      }
      copy(t) {
        return super.copy(t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = We(t.uniforms), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.lights = t.lights, this.clipping = t.clipping, this.extensions = Object.assign({}, t.extensions), this.glslVersion = t.glslVersion, this;
      }
      toJSON(t) {
        const e = super.toJSON(t);
        e.glslVersion = this.glslVersion, e.uniforms = {};
        for (const i in this.uniforms) {
          const n = this.uniforms[i].value;
          n && n.isTexture ? e.uniforms[i] = {type: "t", value: n.toJSON(t).uuid} : n && n.isColor ? e.uniforms[i] = {type: "c", value: n.getHex()} : n && n.isVector2 ? e.uniforms[i] = {type: "v2", value: n.toArray()} : n && n.isVector3 ? e.uniforms[i] = {type: "v3", value: n.toArray()} : n && n.isVector4 ? e.uniforms[i] = {type: "v4", value: n.toArray()} : n && n.isMatrix3 ? e.uniforms[i] = {type: "m3", value: n.toArray()} : n && n.isMatrix4 ? e.uniforms[i] = {type: "m4", value: n.toArray()} : e.uniforms[i] = {value: n};
        }
        Object.keys(this.defines).length > 0 && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader;
        const i = {};
        for (const t in this.extensions) true === this.extensions[t] && (i[t] = true);
        return Object.keys(i).length > 0 && (e.extensions = i), e;
      }
    }
    ShaderMaterial.prototype.isShaderMaterial = true;
    class Camera extends Object3D {
      constructor() {
        super(), this.type = "Camera", this.matrixWorldInverse = new Matrix4, this.projectionMatrix = new Matrix4, this.projectionMatrixInverse = new Matrix4;
      }
      copy(t, e) {
        return super.copy(t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this;
      }
      getWorldDirection(t) {
        this.updateWorldMatrix(true, false);
        const e = this.matrixWorld.elements;
        return t.set(-e[8], -e[9], -e[10]).normalize();
      }
      updateMatrixWorld(t) {
        super.updateMatrixWorld(t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
      }
      updateWorldMatrix(t, e) {
        super.updateWorldMatrix(t, e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
      }
      clone() {
        return (new this.constructor).copy(this);
      }
    }
    Camera.prototype.isCamera = true;
    class PerspectiveCamera extends Camera {
      constructor(t = 50, e = 1, i = 0.1, n = 2e3) {
        super(), this.type = "PerspectiveCamera", this.fov = t, this.zoom = 1, this.near = i, this.far = n, this.focus = 10, this.aspect = e, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
      }
      copy(t, e) {
        return super.copy(t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = null === t.view ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this;
      }
      setFocalLength(t) {
        const e = 0.5 * this.getFilmHeight() / t;
        this.fov = 2 * X * Math.atan(e), this.updateProjectionMatrix();
      }
      getFocalLength() {
        const t = Math.tan(0.5 * j * this.fov);
        return 0.5 * this.getFilmHeight() / t;
      }
      getEffectiveFOV() {
        return 2 * X * Math.atan(Math.tan(0.5 * j * this.fov) / this.zoom);
      }
      getFilmWidth() {
        return this.filmGauge * Math.min(this.aspect, 1);
      }
      getFilmHeight() {
        return this.filmGauge / Math.max(this.aspect, 1);
      }
      setViewOffset(t, e, i, n, r, o) {
        this.aspect = t / e, null === this.view && (this.view = {enabled: true, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1}), this.view.enabled = true, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = i, this.view.offsetY = n, this.view.width = r, this.view.height = o, this.updateProjectionMatrix();
      }
      clearViewOffset() {
        null !== this.view && (this.view.enabled = false), this.updateProjectionMatrix();
      }
      updateProjectionMatrix() {
        const t = this.near;
        let e = t * Math.tan(0.5 * j * this.fov) / this.zoom, i = 2 * e, n = this.aspect * i, r = -0.5 * n;
        const o = this.view;
        if (null !== this.view && this.view.enabled) {
          const t = o.fullWidth, s = o.fullHeight;
          r += o.offsetX * n / t, e -= o.offsetY * i / s, n *= o.width / t, i *= o.height / s;
        }
        const s = this.filmOffset;
        0 !== s && (r += t * s / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + n, e, e - i, t, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
      }
      toJSON(t) {
        const e = super.toJSON(t);
        return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, null !== this.view && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e;
      }
    }
    PerspectiveCamera.prototype.isPerspectiveCamera = true;
    const Xe = 90;
    class CubeCamera extends Object3D {
      constructor(t, e, i) {
        if (super(), this.type = "CubeCamera", true !== i.isWebGLCubeRenderTarget) return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
        this.renderTarget = i;
        const n = new PerspectiveCamera(Xe, 1, t, e);
        n.layers = this.layers, n.up.set(0, -1, 0), n.lookAt(new three_module_Vector3(1, 0, 0)), this.add(n);
        const r = new PerspectiveCamera(Xe, 1, t, e);
        r.layers = this.layers, r.up.set(0, -1, 0), r.lookAt(new three_module_Vector3(-1, 0, 0)), this.add(r);
        const o = new PerspectiveCamera(Xe, 1, t, e);
        o.layers = this.layers, o.up.set(0, 0, 1), o.lookAt(new three_module_Vector3(0, 1, 0)), this.add(o);
        const s = new PerspectiveCamera(Xe, 1, t, e);
        s.layers = this.layers, s.up.set(0, 0, -1), s.lookAt(new three_module_Vector3(0, -1, 0)), this.add(s);
        const a = new PerspectiveCamera(Xe, 1, t, e);
        a.layers = this.layers, a.up.set(0, -1, 0), a.lookAt(new three_module_Vector3(0, 0, 1)), this.add(a);
        const l = new PerspectiveCamera(Xe, 1, t, e);
        l.layers = this.layers, l.up.set(0, -1, 0), l.lookAt(new three_module_Vector3(0, 0, -1)), this.add(l);
      }
      update(t, e) {
        null === this.parent && this.updateMatrixWorld();
        const i = this.renderTarget, [n, r, o, s, a, l] = this.children, c = t.xr.enabled, h = t.getRenderTarget();
        t.xr.enabled = false;
        const u = i.texture.generateMipmaps;
        i.texture.generateMipmaps = false, t.setRenderTarget(i, 0), t.render(e, n), t.setRenderTarget(i, 1), t.render(e, r), t.setRenderTarget(i, 2), t.render(e, o), t.setRenderTarget(i, 3), t.render(e, s), t.setRenderTarget(i, 4), t.render(e, a), i.texture.generateMipmaps = u, t.setRenderTarget(i, 5), t.render(e, l), t.setRenderTarget(h), t.xr.enabled = c;
      }
    }
    class CubeTexture extends Texture {
      constructor(t, e, i, n, r, o, a, l, c, h) {
        super(t = void 0 !== t ? t : [], e = void 0 !== e ? e : s, i, n, r, o, a = void 0 !== a ? a : A, l, c, h), this.flipY = false;
      }
      get images() {
        return this.image;
      }
      set images (t) {
        this.image = t;
      }
    }
    CubeTexture.prototype.isCubeTexture = true;
    class WebGLCubeRenderTarget extends WebGLRenderTarget {
      constructor(t, e, i) {
        Number.isInteger(e) && (console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"), e = i), super(t, t, e), e = e || {}, this.texture = new CubeTexture(void 0, e.mapping, e.wrapS, e.wrapT, e.magFilter, e.minFilter, e.format, e.type, e.anisotropy, e.encoding), this.texture.isRenderTargetTexture = true, this.texture.generateMipmaps = void 0 !== e.generateMipmaps && e.generateMipmaps, this.texture.minFilter = void 0 !== e.minFilter ? e.minFilter : g, this.texture._needsFlipEnvMap = false;
      }
      fromEquirectangularTexture(t, e) {
        this.texture.type = e.type, this.texture.format = T, this.texture.encoding = e.encoding, this.texture.generateMipmaps = e.generateMipmaps, this.texture.minFilter = e.minFilter, this.texture.magFilter = e.magFilter;
        const i = {uniforms: {tEquirect: {value: null}}, vertexShader: "\n\n				varying vec3 vWorldDirection;\n\n				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n				}\n\n				void main() {\n\n					vWorldDirection = transformDirection( position, modelMatrix );\n\n					#include <begin_vertex>\n					#include <project_vertex>\n\n				}\n			", fragmentShader: "\n\n				uniform sampler2D tEquirect;\n\n				varying vec3 vWorldDirection;\n\n				#include <common>\n\n				void main() {\n\n					vec3 direction = normalize( vWorldDirection );\n\n					vec2 sampleUV = equirectUv( direction );\n\n					gl_FragColor = texture2D( tEquirect, sampleUV );\n\n				}\n			"}, n = new BoxGeometry(5, 5, 5), r = new ShaderMaterial({name: "CubemapFromEquirect", uniforms: We(i.uniforms), vertexShader: i.vertexShader, fragmentShader: i.fragmentShader, side: 1, blending: 0});
        r.uniforms.tEquirect.value = e;
        const o = new Mesh(n, r), s = e.minFilter;
        e.minFilter === x && (e.minFilter = g);
        return new CubeCamera(1, 10, this).update(t, o), e.minFilter = s, o.geometry.dispose(), o.material.dispose(), this;
      }
      clear(t, e, i, n) {
        const r = t.getRenderTarget();
        for (let r = 0; r < 6; r++) t.setRenderTarget(this, r), t.clear(e, i, n);
        t.setRenderTarget(r);
      }
    }
    WebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = true;
    const qe = new three_module_Vector3, Ye = new three_module_Vector3, Ze = new Matrix3;
    class Plane {
      constructor(t = new three_module_Vector3(1, 0, 0), e = 0) {
        this.normal = t, this.constant = e;
      }
      set(t, e) {
        return this.normal.copy(t), this.constant = e, this;
      }
      setComponents(t, e, i, n) {
        return this.normal.set(t, e, i), this.constant = n, this;
      }
      setFromNormalAndCoplanarPoint(t, e) {
        return this.normal.copy(t), this.constant = -e.dot(this.normal), this;
      }
      setFromCoplanarPoints(t, e, i) {
        const n = qe.subVectors(i, e).cross(Ye.subVectors(t, e)).normalize();
        return this.setFromNormalAndCoplanarPoint(n, t), this;
      }
      copy(t) {
        return this.normal.copy(t.normal), this.constant = t.constant, this;
      }
      normalize() {
        const t = 1 / this.normal.length();
        return this.normal.multiplyScalar(t), this.constant *= t, this;
      }
      negate() {
        return this.constant *= -1, this.normal.negate(), this;
      }
      distanceToPoint(t) {
        return this.normal.dot(t) + this.constant;
      }
      distanceToSphere(t) {
        return this.distanceToPoint(t.center) - t.radius;
      }
      projectPoint(t, e) {
        return e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t);
      }
      intersectLine(t, e) {
        const i = t.delta(qe), n = this.normal.dot(i);
        if (0 === n) return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : null;
        const r = -(t.start.dot(this.normal) + this.constant) / n;
        return r < 0 || r > 1 ? null : e.copy(i).multiplyScalar(r).add(t.start);
      }
      intersectsLine(t) {
        const e = this.distanceToPoint(t.start), i = this.distanceToPoint(t.end);
        return e < 0 && i > 0 || i < 0 && e > 0;
      }
      intersectsBox(t) {
        return t.intersectsPlane(this);
      }
      intersectsSphere(t) {
        return t.intersectsPlane(this);
      }
      coplanarPoint(t) {
        return t.copy(this.normal).multiplyScalar(-this.constant);
      }
      applyMatrix4(t, e) {
        const i = e || Ze.getNormalMatrix(t), n = this.coplanarPoint(qe).applyMatrix4(t), r = this.normal.applyMatrix3(i).normalize();
        return this.constant = -n.dot(r), this;
      }
      translate(t) {
        return this.constant -= t.dot(this.normal), this;
      }
      equals(t) {
        return t.normal.equals(this.normal) && t.constant === this.constant;
      }
      clone() {
        return (new this.constructor).copy(this);
      }
    }
    Plane.prototype.isPlane = true;
    const Ke = new Sphere, Qe = new three_module_Vector3;
    class Frustum {
      constructor(t = new Plane, e = new Plane, i = new Plane, n = new Plane, r = new Plane, o = new Plane) {
        this.planes = [t, e, i, n, r, o];
      }
      set(t, e, i, n, r, o) {
        const s = this.planes;
        return s[0].copy(t), s[1].copy(e), s[2].copy(i), s[3].copy(n), s[4].copy(r), s[5].copy(o), this;
      }
      copy(t) {
        const e = this.planes;
        for (let i = 0; i < 6; i++) e[i].copy(t.planes[i]);
        return this;
      }
      setFromProjectionMatrix(t) {
        const e = this.planes, i = t.elements, n = i[0], r = i[1], o = i[2], s = i[3], a = i[4], l = i[5], c = i[6], h = i[7], u = i[8], m = i[9], p = i[10], d = i[11], f = i[12], _ = i[13], y = i[14], g = i[15];
        return e[0].setComponents(s - n, h - a, d - u, g - f).normalize(), e[1].setComponents(s + n, h + a, d + u, g + f).normalize(), e[2].setComponents(s + r, h + l, d + m, g + _).normalize(), e[3].setComponents(s - r, h - l, d - m, g - _).normalize(), e[4].setComponents(s - o, h - c, d - p, g - y).normalize(), e[5].setComponents(s + o, h + c, d + p, g + y).normalize(), this;
      }
      intersectsObject(t) {
        const e = t.geometry;
        return null === e.boundingSphere && e.computeBoundingSphere(), Ke.copy(e.boundingSphere).applyMatrix4(t.matrixWorld), this.intersectsSphere(Ke);
      }
      intersectsSprite(t) {
        return Ke.center.set(0, 0, 0), Ke.radius = 0.7071067811865476, Ke.applyMatrix4(t.matrixWorld), this.intersectsSphere(Ke);
      }
      intersectsSphere(t) {
        const e = this.planes, i = t.center, n = -t.radius;
        for (let t = 0; t < 6; t++) {
          if (e[t].distanceToPoint(i) < n) return false;
        }
        return true;
      }
      intersectsBox(t) {
        const e = this.planes;
        for (let i = 0; i < 6; i++) {
          const n = e[i];
          if (Qe.x = n.normal.x > 0 ? t.max.x : t.min.x, Qe.y = n.normal.y > 0 ? t.max.y : t.min.y, Qe.z = n.normal.z > 0 ? t.max.z : t.min.z, n.distanceToPoint(Qe) < 0) return false;
        }
        return true;
      }
      containsPoint(t) {
        const e = this.planes;
        for (let i = 0; i < 6; i++) if (e[i].distanceToPoint(t) < 0) return false;
        return true;
      }
      clone() {
        return (new this.constructor).copy(this);
      }
    }
    function $e() {
      let t = null, e = false, i = null, n = null;
      function r(e, o) {
        i(e, o), n = t.requestAnimationFrame(r);
      }
      return {start: function () {
        true !== e && null !== i && (n = t.requestAnimationFrame(r), e = true);
      }, stop: function () {
        t.cancelAnimationFrame(n), e = false;
      }, setAnimationLoop: function (t) {
        i = t;
      }, setContext: function (e) {
        t = e;
      }};
    }
    function ti(t, e) {
      const i = e.isWebGL2, n = new WeakMap;
      return {get: function (t) {
        return t.isInterleavedBufferAttribute && (t = t.data), n.get(t);
      }, remove: function (e) {
        e.isInterleavedBufferAttribute && (e = e.data);
        const i = n.get(e);
        i && (t.deleteBuffer(i.buffer), n.delete(e));
      }, update: function (e, r) {
        if (e.isGLBufferAttribute) {
          const t = n.get(e);
          return void ((!t || t.version < e.version) && n.set(e, {buffer: e.buffer, type: e.type, bytesPerElement: e.elementSize, version: e.version}));
        }
        e.isInterleavedBufferAttribute && (e = e.data);
        const o = n.get(e);
        void 0 === o ? n.set(e, function (e, n) {
          const r = e.array, o = e.usage, s = t.createBuffer();
          t.bindBuffer(n, s), t.bufferData(n, r, o), e.onUploadCallback();
          let a = 5126;
          return r instanceof Float32Array ? a = 5126 : r instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : r instanceof Uint16Array ? e.isFloat16BufferAttribute ? i ? a = 5131 : console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.") : a = 5123 : r instanceof Int16Array ? a = 5122 : r instanceof Uint32Array ? a = 5125 : r instanceof Int32Array ? a = 5124 : r instanceof Int8Array ? a = 5120 : (r instanceof Uint8Array || r instanceof Uint8ClampedArray) && (a = 5121), {buffer: s, type: a, bytesPerElement: r.BYTES_PER_ELEMENT, version: e.version};
        }(e, r)) : o.version < e.version && (!function (e, n, r) {
          const o = n.array, s = n.updateRange;
          t.bindBuffer(r, e), -1 === s.count ? t.bufferSubData(r, 0, o) : (i ? t.bufferSubData(r, s.offset * o.BYTES_PER_ELEMENT, o, s.offset, s.count) : t.bufferSubData(r, s.offset * o.BYTES_PER_ELEMENT, o.subarray(s.offset, s.offset + s.count)), s.count = -1);
        }(o.buffer, e, r), o.version = e.version);
      }};
    }
    class PlaneGeometry extends BufferGeometry {
      constructor(t = 1, e = 1, i = 1, n = 1) {
        super(), this.type = "PlaneGeometry", this.parameters = {width: t, height: e, widthSegments: i, heightSegments: n};
        const r = t / 2, o = e / 2, s = Math.floor(i), a = Math.floor(n), l = s + 1, c = a + 1, h = t / s, u = e / a, m = [], p = [], d = [], f = [];
        for (let t = 0; t < c; t++) {
          const e = t * u - o;
          for (let i = 0; i < l; i++) {
            const n = i * h - r;
            p.push(n, -e, 0), d.push(0, 0, 1), f.push(i / s), f.push(1 - t / a);
          }
        }
        for (let t = 0; t < a; t++) for (let e = 0; e < s; e++) {
          const i = e + l * t, n = e + l * (t + 1), r = e + 1 + l * (t + 1), o = e + 1 + l * t;
          m.push(i, n, o), m.push(n, r, o);
        }
        this.setIndex(m), this.setAttribute("position", new Float32BufferAttribute(p, 3)), this.setAttribute("normal", new Float32BufferAttribute(d, 3)), this.setAttribute("uv", new Float32BufferAttribute(f, 2));
      }
      static fromJSON(t) {
        return new PlaneGeometry(t.width, t.height, t.widthSegments, t.heightSegments);
      }
    }
    const ei = {alphamap_fragment: "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif", alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif", alphatest_fragment: "#ifdef USE_ALPHATEST\n	if ( diffuseColor.a < alphaTest ) discard;\n#endif", alphatest_pars_fragment: "#ifdef USE_ALPHATEST\n	uniform float alphaTest;\n#endif", aomap_fragment: "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n	#endif\n#endif", aomap_pars_fragment: "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif", begin_vertex: "vec3 transformed = vec3( position );", beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif", bsdfs: "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( incidentLight.direction + viewDir );\n	float dotNL = saturate( dot( normal, incidentLight.direction ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( f0, f90, dotVH );\n	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n	float D = D_GGX( alpha, dotNH );\n	return F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n	float dotNH = saturate( dot( geometry.normal, halfDir ) );\n	float dotVH = saturate( dot( geometry.viewDir, halfDir ) );\n	vec3 F = F_Schlick( specularColor, 1.0, dotVH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float NoH ) {\n	float invAlpha = 1.0 / roughness;\n	float cos2h = NoH * NoH;\n	float sin2h = max( 1.0 - cos2h, 0.0078125 );\n	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float NoV, float NoL ) {\n	return saturate( 1.0 / ( 4.0 * ( NoL + NoV - NoL * NoV ) ) );\n}\nvec3 BRDF_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n	vec3 N = geometry.normal;\n	vec3 V = geometry.viewDir;\n	vec3 H = normalize( V + L );\n	float dotNH = saturate( dot( N, H ) );\n	return specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif", bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 ) * faceDirection;\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif", clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n		plane = clippingPlanes[ i ];\n		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n	}\n	#pragma unroll_loop_end\n	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n		bool clipped = true;\n		#pragma unroll_loop_start\n		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n		}\n		#pragma unroll_loop_end\n		if ( clipped ) discard;\n	#endif\n#endif", clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif", clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n#endif", clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n	vClipPosition = - mvPosition.xyz;\n#endif", color_fragment: "#if defined( USE_COLOR_ALPHA )\n	diffuseColor *= vColor;\n#elif defined( USE_COLOR )\n	diffuseColor.rgb *= vColor;\n#endif", color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR )\n	varying vec3 vColor;\n#endif", color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	varying vec3 vColor;\n#endif", color_vertex: "#if defined( USE_COLOR_ALPHA )\n	vColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	vColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n	vColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n	vColor.xyz *= instanceColor.xyz;\n#endif", common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\nstruct GeometricContext {\n	vec3 position;\n	vec3 normal;\n	vec3 viewDir;\n#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n	return dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n	return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	return vec2( u, v );\n}", cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n	#define cubeUV_maxMipLevel 8.0\n	#define cubeUV_minMipLevel 4.0\n	#define cubeUV_maxTileSize 256.0\n	#define cubeUV_minTileSize 16.0\n	float getFace( vec3 direction ) {\n		vec3 absDirection = abs( direction );\n		float face = - 1.0;\n		if ( absDirection.x > absDirection.z ) {\n			if ( absDirection.x > absDirection.y )\n				face = direction.x > 0.0 ? 0.0 : 3.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		} else {\n			if ( absDirection.z > absDirection.y )\n				face = direction.z > 0.0 ? 2.0 : 5.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		}\n		return face;\n	}\n	vec2 getUV( vec3 direction, float face ) {\n		vec2 uv;\n		if ( face == 0.0 ) {\n			uv = vec2( direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 1.0 ) {\n			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n		} else if ( face == 2.0 ) {\n			uv = vec2( - direction.x, direction.y ) / abs( direction.z );\n		} else if ( face == 3.0 ) {\n			uv = vec2( - direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 4.0 ) {\n			uv = vec2( - direction.x, direction.z ) / abs( direction.y );\n		} else {\n			uv = vec2( direction.x, direction.y ) / abs( direction.z );\n		}\n		return 0.5 * ( uv + 1.0 );\n	}\n	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n		float face = getFace( direction );\n		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n		mipInt = max( mipInt, cubeUV_minMipLevel );\n		float faceSize = exp2( mipInt );\n		float texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n		vec2 f = fract( uv );\n		uv += 0.5 - f;\n		if ( face > 2.0 ) {\n			uv.y += faceSize;\n			face -= 3.0;\n		}\n		uv.x += face * faceSize;\n		if ( mipInt < cubeUV_maxMipLevel ) {\n			uv.y += 2.0 * cubeUV_maxTileSize;\n		}\n		uv.y += filterInt * 2.0 * cubeUV_minTileSize;\n		uv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n		uv *= texelSize;\n		vec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.x += texelSize;\n		vec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.y += texelSize;\n		vec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.x -= texelSize;\n		vec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		vec3 tm = mix( tl, tr, f.x );\n		vec3 bm = mix( bl, br, f.x );\n		return mix( tm, bm, f.y );\n	}\n	#define r0 1.0\n	#define v0 0.339\n	#define m0 - 2.0\n	#define r1 0.8\n	#define v1 0.276\n	#define m1 - 1.0\n	#define r4 0.4\n	#define v4 0.046\n	#define m4 2.0\n	#define r5 0.305\n	#define v5 0.016\n	#define m5 3.0\n	#define r6 0.21\n	#define v6 0.0038\n	#define m6 4.0\n	float roughnessToMip( float roughness ) {\n		float mip = 0.0;\n		if ( roughness >= r1 ) {\n			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n		} else if ( roughness >= r4 ) {\n			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n		} else if ( roughness >= r5 ) {\n			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n		} else if ( roughness >= r6 ) {\n			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n		} else {\n			mip = - 2.0 * log2( 1.16 * roughness );		}\n		return mip;\n	}\n	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n		float mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n		float mipF = fract( mip );\n		float mipInt = floor( mip );\n		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n		if ( mipF == 0.0 ) {\n			return vec4( color0, 1.0 );\n		} else {\n			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n			return vec4( mix( color0, color1, mipF ), 1.0 );\n		}\n	}\n#endif", defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n	mat3 m = mat3( instanceMatrix );\n	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n	transformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif", displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif", displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif", emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif", emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif", encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );", encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n	return value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n	float maxComponent = max( max( value.r, value.g ), value.b );\n	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.r, max( value.g, value.b ) );\n	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n	M = ceil( M * 255.0 ) / 255.0;\n	return vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.r, max( value.g, value.b ) );\n	float D = max( maxRange / maxRGB, 1.0 );\n	D = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n	vec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n	vec4 vResult;\n	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n	vResult.w = fract( Le );\n	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n	return vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n	float Le = value.z * 255.0 + value.w;\n	vec3 Xp_Y_XYZp;\n	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n	vec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n	return vec4( max( vRGB, 0.0 ), 1.0 );\n}", envmap_fragment: "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToFrag;\n		if ( isOrthographic ) {\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n		envColor = envMapTexelToLinear( envColor );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif", envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	uniform int maxMipLevel;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	\n#endif", envmap_pars_fragment: "#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif", envmap_pars_vertex: "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif", envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n	#ifdef ENVMAP_MODE_REFRACTION\n		uniform float refractionRatio;\n	#endif\n	vec3 getIBLIrradiance( const in GeometricContext geometry ) {\n		#if defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n			return PI * envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n		#if defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 reflectVec;\n			#ifdef ENVMAP_MODE_REFLECTION\n				reflectVec = reflect( - viewDir, normal );\n				reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n			#else\n				reflectVec = refract( - viewDir, normal, refractionRatio );\n			#endif\n			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n			return envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n#endif", envmap_vertex: "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex;\n		if ( isOrthographic ) {\n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif", fog_vertex: "#ifdef USE_FOG\n	vFogDepth = - mvPosition.z;\n#endif", fog_pars_vertex: "#ifdef USE_FOG\n	varying float vFogDepth;\n#endif", fog_fragment: "#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif", fog_pars_fragment: "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float vFogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif", gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n	uniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n	#ifdef USE_GRADIENTMAP\n		return texture2D( gradientMap, coord ).rgb;\n	#else\n		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n	#endif\n}", lightmap_fragment: "#ifdef USE_LIGHTMAP\n	vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n	vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		lightMapIrradiance *= PI;\n	#endif\n	reflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif", lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif", lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n	vLightBack = vec3( 0.0 );\n	vIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		getPointLightInfo( pointLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		getSpotLightInfo( spotLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		#ifdef DOUBLE_SIDED\n			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif", lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n	vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	return irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n	#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n		if ( cutoffDistance > 0.0 ) {\n			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n		}\n		return distanceFalloff;\n	#else\n		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n		}\n		return 1.0;\n	#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n	return smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n		light.color = directionalLight.color;\n		light.direction = directionalLight.direction;\n		light.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n		vec3 lVector = pointLight.position - geometry.position;\n		light.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		light.color = pointLight.color;\n		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n		light.visible = ( light.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n		vec3 lVector = spotLight.position - geometry.position;\n		light.direction = normalize( lVector );\n		float angleCos = dot( light.direction, spotLight.direction );\n		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n		if ( spotAttenuation > 0.0 ) {\n			float lightDistance = length( lVector );\n			light.color = spotLight.color * spotAttenuation;\n			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n			light.visible = ( light.color != vec3( 0.0 ) );\n		} else {\n			light.color = vec3( 0.0 );\n			light.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n		float dotNL = dot( geometry.normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		return irradiance;\n	}\n#endif", lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;", lights_toon_pars_fragment: "varying vec3 vViewPosition;\nstruct ToonMaterial {\n	vec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )	(0)", lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;", lights_phong_pars_fragment: "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n	vec3 diffuseColor;\n	vec3 specularColor;\n	float specularShininess;\n	float specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )	(0)", lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n	#ifdef SPECULAR\n		float specularIntensityFactor = specularIntensity;\n		vec3 specularTintFactor = specularTint;\n		#ifdef USE_SPECULARINTENSITYMAP\n			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n		#endif\n		#ifdef USE_SPECULARTINTMAP\n			specularTintFactor *= specularTintMapTexelToLinear( texture2D( specularTintMap, vUv ) ).rgb;\n		#endif\n		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n	#else\n		float specularIntensityFactor = 1.0;\n		vec3 specularTintFactor = vec3( 1.0 );\n		material.specularF90 = 1.0;\n	#endif\n	material.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularTintFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n	material.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n	material.clearcoat = clearcoat;\n	material.clearcoatRoughness = clearcoatRoughness;\n	material.clearcoatF0 = vec3( 0.04 );\n	material.clearcoatF90 = 1.0;\n	#ifdef USE_CLEARCOATMAP\n		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n	#endif\n	#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n	#endif\n	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n	material.sheenTint = sheenTint;\n#endif", lights_physical_pars_fragment: "struct PhysicalMaterial {\n	vec3 diffuseColor;\n	float roughness;\n	vec3 specularColor;\n	float specularF90;\n	#ifdef USE_CLEARCOAT\n		float clearcoat;\n		float clearcoatRoughness;\n		vec3 clearcoatF0;\n		float clearcoatF90;\n	#endif\n	#ifdef USE_SHEEN\n		vec3 sheenTint;\n	#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n	return fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	return specularColor * fab.x + specularF90 * fab.y;\n}\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	vec3 FssEss = specularColor * fab.x + specularF90 * fab.y;\n	float Ess = fab.x + fab.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometry.normal;\n		vec3 viewDir = geometry.viewDir;\n		vec3 position = geometry.position;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.roughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifdef USE_CLEARCOAT\n		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = dotNLcc * directLight.color;\n		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		reflectedLight.directSpecular += irradiance * BRDF_Sheen( material.roughness, directLight.direction, geometry, material.sheenTint );\n	#else\n		reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n	#endif\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef USE_CLEARCOAT\n		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n	reflectedLight.indirectSpecular += radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}", lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n	geometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointLightInfo( pointLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		pointLightShadow = pointLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotLightInfo( spotLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		spotLightShadow = spotLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalLightInfo( directionalLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directionalLightShadow = directionalLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	irradiance += getLightProbeIrradiance( lightProbe, geometry );\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif", lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			lightMapIrradiance *= PI;\n		#endif\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n		iblIrradiance += getIBLIrradiance( geometry );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n	#ifdef USE_CLEARCOAT\n		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n	#endif\n#endif", lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif", logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif", logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif", logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n		varying float vIsPerspective;\n	#else\n		uniform float logDepthBufFC;\n	#endif\n#endif", logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n	#else\n		if ( isPerspectiveMatrix( projectionMatrix ) ) {\n			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n			gl_Position.z *= gl_Position.w;\n		}\n	#endif\n#endif", map_fragment: "#ifdef USE_MAP\n	vec4 texelColor = texture2D( map, vUv );\n	texelColor = mapTexelToLinear( texelColor );\n	diffuseColor *= texelColor;\n#endif", map_pars_fragment: "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif", map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n	vec4 mapTexel = texture2D( map, uv );\n	diffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif", map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	uniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif", metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vUv );\n	metalnessFactor *= texelMetalness.b;\n#endif", metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif", morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n	objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n	objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n	objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif", morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n	uniform float morphTargetBaseInfluence;\n	#ifndef USE_MORPHNORMALS\n		uniform float morphTargetInfluences[ 8 ];\n	#else\n		uniform float morphTargetInfluences[ 4 ];\n	#endif\n#endif", morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	transformed += morphTarget0 * morphTargetInfluences[ 0 ];\n	transformed += morphTarget1 * morphTargetInfluences[ 1 ];\n	transformed += morphTarget2 * morphTargetInfluences[ 2 ];\n	transformed += morphTarget3 * morphTargetInfluences[ 3 ];\n	#ifndef USE_MORPHNORMALS\n		transformed += morphTarget4 * morphTargetInfluences[ 4 ];\n		transformed += morphTarget5 * morphTargetInfluences[ 5 ];\n		transformed += morphTarget6 * morphTargetInfluences[ 6 ];\n		transformed += morphTarget7 * morphTargetInfluences[ 7 ];\n	#endif\n#endif", normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	#ifdef USE_TANGENT\n		vec3 tangent = normalize( vTangent );\n		vec3 bitangent = normalize( vBitangent );\n		#ifdef DOUBLE_SIDED\n			tangent = tangent * faceDirection;\n			bitangent = bitangent * faceDirection;\n		#endif\n		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n			mat3 vTBN = mat3( tangent, bitangent, normal );\n		#endif\n	#endif\n#endif\nvec3 geometryNormal = normal;", normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n	#ifdef USE_TANGENT\n		normal = normalize( vTBN * mapN );\n	#else\n		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n	#endif\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif", normal_pars_fragment: "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif", normal_pars_vertex: "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif", normal_vertex: "#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif", normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n		vec3 N = surf_norm;\n		vec3 q1perp = cross( q1, N );\n		vec3 q0perp = cross( N, q0 );\n		vec3 T = q1perp * st0.x + q0perp * st1.x;\n		vec3 B = q1perp * st0.y + q0perp * st1.y;\n		float det = max( dot( T, T ), dot( B, B ) );\n		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n	}\n#endif", clearcoat_normal_fragment_begin: "#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal = geometryNormal;\n#endif", clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n	#ifdef USE_TANGENT\n		clearcoatNormal = normalize( vTBN * clearcoatMapN );\n	#else\n		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n	#endif\n#endif", clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n	uniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif", output_fragment: "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );", packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n	vec4 r = vec4( fract( v * PackFactors ), v );\n	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n	return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}", premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif", project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n	mvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;", dithering_fragment: "#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif", dithering_pars_fragment: "#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif", roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vUv );\n	roughnessFactor *= texelRoughness.g;\n#endif", roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif", shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n	}\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n		float occlusion = 1.0;\n		vec2 distribution = texture2DDistribution( shadow, uv );\n		float hard_shadow = step( compare , distribution.x );\n		if (hard_shadow != 1.0 ) {\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n		}\n		return occlusion;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n		bool frustumTest = all( frustumTestVec );\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx = texelSize.x;\n			float dy = texelSize.y;\n			vec2 uv = shadowCoord.xy;\n			vec2 f = fract( uv * shadowMapSize + 0.5 );\n			uv -= f * texelSize;\n			shadow = (\n				texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n						  f.x ),\n					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n						  f.x ),\n					 f.y )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_VSM )\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return shadow;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n		vec3 lightToPosition = shadowCoord.xyz;\n		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;\n		vec3 bd3D = normalize( lightToPosition );\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif", shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif", shadowmap_vertex: "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		vec4 shadowWorldPosition;\n	#endif\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n#endif", shadowmask_pars_fragment: "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLightShadows[ i ];\n		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#endif\n	return shadow;\n}", skinbase_vertex: "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif", skinning_pars_vertex: "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	#ifdef BONE_TEXTURE\n		uniform highp sampler2D boneTexture;\n		uniform int boneTextureSize;\n		mat4 getBoneMatrix( const in float i ) {\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureSize ) );\n			float y = floor( j / float( boneTextureSize ) );\n			float dx = 1.0 / float( boneTextureSize );\n			float dy = 1.0 / float( boneTextureSize );\n			y = dy * ( y + 0.5 );\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n			mat4 bone = mat4( v1, v2, v3, v4 );\n			return bone;\n		}\n	#else\n		uniform mat4 boneMatrices[ MAX_BONES ];\n		mat4 getBoneMatrix( const in float i ) {\n			mat4 bone = boneMatrices[ int(i) ];\n			return bone;\n		}\n	#endif\n#endif", skinning_vertex: "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif", skinnormal_vertex: "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif", specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif", specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif", tonemapping_fragment: "#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif", tonemapping_pars_fragment: "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n	return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n	return a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	const mat3 ACESInputMat = mat3(\n		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),\n		vec3( 0.04823, 0.01566, 0.83777 )\n	);\n	const mat3 ACESOutputMat = mat3(\n		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),\n		vec3( -0.07367, -0.00605,  1.07602 )\n	);\n	color *= toneMappingExposure / 0.6;\n	color = ACESInputMat * color;\n	color = RRTAndODTFit( color );\n	color = ACESOutputMat * color;\n	return saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }", transmission_fragment: "#ifdef USE_TRANSMISSION\n	float transmissionAlpha = 1.0;\n	float transmissionFactor = transmission;\n	float thicknessFactor = thickness;\n	#ifdef USE_TRANSMISSIONMAP\n		transmissionFactor *= texture2D( transmissionMap, vUv ).r;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		thicknessFactor *= texture2D( thicknessMap, vUv ).g;\n	#endif\n	vec3 pos = vWorldPosition;\n	vec3 v = normalize( cameraPosition - pos );\n	vec3 n = inverseTransformDirection( normal, viewMatrix );\n	vec4 transmission = getIBLVolumeRefraction(\n		n, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n		attenuationTint, attenuationDistance );\n	totalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n	transmissionAlpha = transmission.a;\n#endif", transmission_pars_fragment: "#ifdef USE_TRANSMISSION\n	uniform float transmission;\n	uniform float thickness;\n	uniform float attenuationDistance;\n	uniform vec3 attenuationTint;\n	#ifdef USE_TRANSMISSIONMAP\n		uniform sampler2D transmissionMap;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		uniform sampler2D thicknessMap;\n	#endif\n	uniform vec2 transmissionSamplerSize;\n	uniform sampler2D transmissionSamplerMap;\n	uniform mat4 modelMatrix;\n	uniform mat4 projectionMatrix;\n	varying vec3 vWorldPosition;\n	vec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {\n		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n		vec3 modelScale;\n		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n		return normalize( refractionVector ) * thickness * modelScale;\n	}\n	float applyIorToRoughness( float roughness, float ior ) {\n		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n	}\n	vec4 getTransmissionSample( vec2 fragCoord, float roughness, float ior ) {\n		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n		#ifdef TEXTURE_LOD_EXT\n			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n		#else\n			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n		#endif\n	}\n	vec3 applyVolumeAttenuation( vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance ) {\n		if ( attenuationDistance == 0.0 ) {\n			return radiance;\n		} else {\n			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;\n		}\n	}\n	vec4 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 diffuseColor, vec3 specularColor, float specularF90,\n		vec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,\n		vec3 attenuationColor, float attenuationDistance ) {\n		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n		vec3 refractedRayExit = position + transmissionRay;\n		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n		vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n		refractionCoords += 1.0;\n		refractionCoords /= 2.0;\n		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n	}\n#endif", uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n	varying vec2 vUv;\n#endif", uv_pars_vertex: "#ifdef USE_UV\n	#ifdef UVS_VERTEX_ONLY\n		vec2 vUv;\n	#else\n		varying vec2 vUv;\n	#endif\n	uniform mat3 uvTransform;\n#endif", uv_vertex: "#ifdef USE_UV\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif", uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	varying vec2 vUv2;\n#endif", uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n	uniform mat3 uv2Transform;\n#endif", uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif", worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n	vec4 worldPosition = vec4( transformed, 1.0 );\n	#ifdef USE_INSTANCING\n		worldPosition = instanceMatrix * worldPosition;\n	#endif\n	worldPosition = modelMatrix * worldPosition;\n#endif", background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n	vec4 texColor = texture2D( t2D, vUv );\n	gl_FragColor = mapTexelToLinear( texColor );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}", background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}", cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n	vec3 vReflect = vWorldDirection;\n	#include <envmap_fragment>\n	gl_FragColor = envColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}", cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}", depth_frag: "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <logdepthbuf_fragment>\n	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( fragCoordZ );\n	#endif\n}", depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vHighPrecisionZW = gl_Position.zw;\n}", distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}", distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}", equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV = equirectUv( direction );\n	vec4 texColor = texture2D( tEquirect, sampleUV );\n	gl_FragColor = mapTexelToLinear( texColor );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}", equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}", linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}", linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vLineDistance = scale * lineDistance;\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}", meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinbase_vertex>\n		#include <skinnormal_vertex>\n		#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}", meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <emissivemap_fragment>\n	#ifdef DOUBLE_SIDED\n		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n	#else\n		reflectedLight.indirectDiffuse += vIndirectFront;\n	#endif\n	#include <lightmap_fragment>\n	reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n	#ifdef DOUBLE_SIDED\n		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n	#else\n		reflectedLight.directDiffuse = vLightFront;\n	#endif\n	reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <lights_lambert_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}", meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n		matcapColor = matcapTexelToLinear( matcapColor );\n	#else\n		vec4 matcapColor = vec4( 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}", meshnormal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}", meshnormal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}", meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}", meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n	#define IOR\n	#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n	uniform float ior;\n#endif\n#ifdef SPECULAR\n	uniform float specularIntensity;\n	uniform vec3 specularTint;\n	#ifdef USE_SPECULARINTENSITYMAP\n		uniform sampler2D specularIntensityMap;\n	#endif\n	#ifdef USE_SPECULARTINTMAP\n		uniform sampler2D specularTintMap;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheenTint;\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n	#include <transmission_fragment>\n	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n	#ifdef USE_CLEARCOAT\n		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n		outgoingLight = outgoingLight * ( 1.0 - clearcoat * Fcc ) + clearcoatSpecular * clearcoat;\n	#endif\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n	varying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n	vWorldPosition = worldPosition.xyz;\n#endif\n}", meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}", points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}", points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}", shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}", shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <begin_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}", sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}", sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n	vec2 scale;\n	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}"}, ii = {common: {diffuse: {value: new three_module_Color(16777215)}, opacity: {value: 1}, map: {value: null}, uvTransform: {value: new Matrix3}, uv2Transform: {value: new Matrix3}, alphaMap: {value: null}, alphaTest: {value: 0}}, specularmap: {specularMap: {value: null}}, envmap: {envMap: {value: null}, flipEnvMap: {value: -1}, reflectivity: {value: 1}, ior: {value: 1.5}, refractionRatio: {value: 0.98}, maxMipLevel: {value: 0}}, aomap: {aoMap: {value: null}, aoMapIntensity: {value: 1}}, lightmap: {lightMap: {value: null}, lightMapIntensity: {value: 1}}, emissivemap: {emissiveMap: {value: null}}, bumpmap: {bumpMap: {value: null}, bumpScale: {value: 1}}, normalmap: {normalMap: {value: null}, normalScale: {value: new Vector2(1, 1)}}, displacementmap: {displacementMap: {value: null}, displacementScale: {value: 1}, displacementBias: {value: 0}}, roughnessmap: {roughnessMap: {value: null}}, metalnessmap: {metalnessMap: {value: null}}, gradientmap: {gradientMap: {value: null}}, fog: {fogDensity: {value: 0.00025}, fogNear: {value: 1}, fogFar: {value: 2e3}, fogColor: {value: new three_module_Color(16777215)}}, lights: {ambientLightColor: {value: []}, lightProbe: {value: []}, directionalLights: {value: [], properties: {direction: {}, color: {}}}, directionalLightShadows: {value: [], properties: {shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {}}}, directionalShadowMap: {value: []}, directionalShadowMatrix: {value: []}, spotLights: {value: [], properties: {color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {}}}, spotLightShadows: {value: [], properties: {shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {}}}, spotShadowMap: {value: []}, spotShadowMatrix: {value: []}, pointLights: {value: [], properties: {color: {}, position: {}, decay: {}, distance: {}}}, pointLightShadows: {value: [], properties: {shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {}, shadowCameraNear: {}, shadowCameraFar: {}}}, pointShadowMap: {value: []}, pointShadowMatrix: {value: []}, hemisphereLights: {value: [], properties: {direction: {}, skyColor: {}, groundColor: {}}}, rectAreaLights: {value: [], properties: {color: {}, position: {}, width: {}, height: {}}}, ltc_1: {value: null}, ltc_2: {value: null}}, points: {diffuse: {value: new three_module_Color(16777215)}, opacity: {value: 1}, size: {value: 1}, scale: {value: 1}, map: {value: null}, alphaMap: {value: null}, alphaTest: {value: 0}, uvTransform: {value: new Matrix3}}, sprite: {diffuse: {value: new three_module_Color(16777215)}, opacity: {value: 1}, center: {value: new Vector2(0.5, 0.5)}, rotation: {value: 0}, map: {value: null}, alphaMap: {value: null}, alphaTest: {value: 0}, uvTransform: {value: new Matrix3}}}, ni = {basic: {uniforms: Je([ii.common, ii.specularmap, ii.envmap, ii.aomap, ii.lightmap, ii.fog]), vertexShader: ei.meshbasic_vert, fragmentShader: ei.meshbasic_frag}, lambert: {uniforms: Je([ii.common, ii.specularmap, ii.envmap, ii.aomap, ii.lightmap, ii.emissivemap, ii.fog, ii.lights, {emissive: {value: new three_module_Color(0)}}]), vertexShader: ei.meshlambert_vert, fragmentShader: ei.meshlambert_frag}, phong: {uniforms: Je([ii.common, ii.specularmap, ii.envmap, ii.aomap, ii.lightmap, ii.emissivemap, ii.bumpmap, ii.normalmap, ii.displacementmap, ii.fog, ii.lights, {emissive: {value: new three_module_Color(0)}, specular: {value: new three_module_Color(1118481)}, shininess: {value: 30}}]), vertexShader: ei.meshphong_vert, fragmentShader: ei.meshphong_frag}, standard: {uniforms: Je([ii.common, ii.envmap, ii.aomap, ii.lightmap, ii.emissivemap, ii.bumpmap, ii.normalmap, ii.displacementmap, ii.roughnessmap, ii.metalnessmap, ii.fog, ii.lights, {emissive: {value: new three_module_Color(0)}, roughness: {value: 1}, metalness: {value: 0}, envMapIntensity: {value: 1}}]), vertexShader: ei.meshphysical_vert, fragmentShader: ei.meshphysical_frag}, toon: {uniforms: Je([ii.common, ii.aomap, ii.lightmap, ii.emissivemap, ii.bumpmap, ii.normalmap, ii.displacementmap, ii.gradientmap, ii.fog, ii.lights, {emissive: {value: new three_module_Color(0)}}]), vertexShader: ei.meshtoon_vert, fragmentShader: ei.meshtoon_frag}, matcap: {uniforms: Je([ii.common, ii.bumpmap, ii.normalmap, ii.displacementmap, ii.fog, {matcap: {value: null}}]), vertexShader: ei.meshmatcap_vert, fragmentShader: ei.meshmatcap_frag}, points: {uniforms: Je([ii.points, ii.fog]), vertexShader: ei.points_vert, fragmentShader: ei.points_frag}, dashed: {uniforms: Je([ii.common, ii.fog, {scale: {value: 1}, dashSize: {value: 1}, totalSize: {value: 2}}]), vertexShader: ei.linedashed_vert, fragmentShader: ei.linedashed_frag}, depth: {uniforms: Je([ii.common, ii.displacementmap]), vertexShader: ei.depth_vert, fragmentShader: ei.depth_frag}, normal: {uniforms: Je([ii.common, ii.bumpmap, ii.normalmap, ii.displacementmap, {opacity: {value: 1}}]), vertexShader: ei.meshnormal_vert, fragmentShader: ei.meshnormal_frag}, sprite: {uniforms: Je([ii.sprite, ii.fog]), vertexShader: ei.sprite_vert, fragmentShader: ei.sprite_frag}, background: {uniforms: {uvTransform: {value: new Matrix3}, t2D: {value: null}}, vertexShader: ei.background_vert, fragmentShader: ei.background_frag}, cube: {uniforms: Je([ii.envmap, {opacity: {value: 1}}]), vertexShader: ei.cube_vert, fragmentShader: ei.cube_frag}, equirect: {uniforms: {tEquirect: {value: null}}, vertexShader: ei.equirect_vert, fragmentShader: ei.equirect_frag}, distanceRGBA: {uniforms: Je([ii.common, ii.displacementmap, {referencePosition: {value: new three_module_Vector3}, nearDistance: {value: 1}, farDistance: {value: 1e3}}]), vertexShader: ei.distanceRGBA_vert, fragmentShader: ei.distanceRGBA_frag}, shadow: {uniforms: Je([ii.lights, ii.fog, {color: {value: new three_module_Color(0)}, opacity: {value: 1}}]), vertexShader: ei.shadow_vert, fragmentShader: ei.shadow_frag}};
    function ri(t, e, i, n, r) {
      const o = new three_module_Color(0);
      let s, a, l = 0, c = null, u = 0, m = null;
      function p(t, e) {
        i.buffers.color.setClear(t.r, t.g, t.b, e, r);
      }
      return {getClearColor: function () {
        return o;
      }, setClearColor: function (t, e = 1) {
        o.set(t), l = e, p(o, l);
      }, getClearAlpha: function () {
        return l;
      }, setClearAlpha: function (t) {
        l = t, p(o, l);
      }, render: function (i, r) {
        let d = false, f = true === r.isScene ? r.background : null;
        f && f.isTexture && (f = e.get(f));
        const _ = t.xr, y = _.getSession && _.getSession();
        y && "additive" === y.environmentBlendMode && (f = null), null === f ? p(o, l) : f && f.isColor && (p(f, 1), d = true), (t.autoClear || d) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), f && (f.isCubeTexture || f.mapping === h) ? (void 0 === a && (a = new Mesh(new BoxGeometry(1, 1, 1), new ShaderMaterial({name: "BackgroundCubeMaterial", uniforms: We(ni.cube.uniforms), vertexShader: ni.cube.vertexShader, fragmentShader: ni.cube.fragmentShader, side: 1, depthTest: false, depthWrite: false, fog: false})), a.geometry.deleteAttribute("normal"), a.geometry.deleteAttribute("uv"), a.onBeforeRender = function (t, e, i) {
          this.matrixWorld.copyPosition(i.matrixWorld);
        }, Object.defineProperty(a.material, "envMap", {get: function () {
          return this.uniforms.envMap.value;
        }}), n.update(a)), a.material.uniforms.envMap.value = f, a.material.uniforms.flipEnvMap.value = f.isCubeTexture && false === f.isRenderTargetTexture ? -1 : 1, c === f && u === f.version && m === t.toneMapping || (a.material.needsUpdate = true, c = f, u = f.version, m = t.toneMapping), i.unshift(a, a.geometry, a.material, 0, 0, null)) : f && f.isTexture && (void 0 === s && (s = new Mesh(new PlaneGeometry(2, 2), new ShaderMaterial({name: "BackgroundMaterial", uniforms: We(ni.background.uniforms), vertexShader: ni.background.vertexShader, fragmentShader: ni.background.fragmentShader, side: 0, depthTest: false, depthWrite: false, fog: false})), s.geometry.deleteAttribute("normal"), Object.defineProperty(s.material, "map", {get: function () {
          return this.uniforms.t2D.value;
        }}), n.update(s)), s.material.uniforms.t2D.value = f, true === f.matrixAutoUpdate && f.updateMatrix(), s.material.uniforms.uvTransform.value.copy(f.matrix), c === f && u === f.version && m === t.toneMapping || (s.material.needsUpdate = true, c = f, u = f.version, m = t.toneMapping), i.unshift(s, s.geometry, s.material, 0, 0, null));
      }};
    }
    function oi(t, e, i, n) {
      const r = t.getParameter(34921), o = n.isWebGL2 ? null : e.get("OES_vertex_array_object"), s = n.isWebGL2 || null !== o, a = {}, l = m(null);
      let c = l;
      function h(e) {
        return n.isWebGL2 ? t.bindVertexArray(e) : o.bindVertexArrayOES(e);
      }
      function u(e) {
        return n.isWebGL2 ? t.deleteVertexArray(e) : o.deleteVertexArrayOES(e);
      }
      function m(t) {
        const e = [], i = [], n = [];
        for (let t = 0; t < r; t++) e[t] = 0, i[t] = 0, n[t] = 0;
        return {geometry: null, program: null, wireframe: false, newAttributes: e, enabledAttributes: i, attributeDivisors: n, object: t, attributes: {}, index: null};
      }
      function p() {
        const t = c.newAttributes;
        for (let e = 0, i = t.length; e < i; e++) t[e] = 0;
      }
      function d(t) {
        f(t, 0);
      }
      function f(i, r) {
        const o = c.newAttributes, s = c.enabledAttributes, a = c.attributeDivisors;
        if (o[i] = 1, 0 === s[i] && (t.enableVertexAttribArray(i), s[i] = 1), a[i] !== r) {
          (n.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[n.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](i, r), a[i] = r;
        }
      }
      function _() {
        const e = c.newAttributes, i = c.enabledAttributes;
        for (let n = 0, r = i.length; n < r; n++) i[n] !== e[n] && (t.disableVertexAttribArray(n), i[n] = 0);
      }
      function y(e, i, r, o, s, a) {
        true !== n.isWebGL2 || 5124 !== r && 5125 !== r ? t.vertexAttribPointer(e, i, r, o, s, a) : t.vertexAttribIPointer(e, i, r, s, a);
      }
      function g() {
        x(), c !== l && (c = l, h(c.object));
      }
      function x() {
        l.geometry = null, l.program = null, l.wireframe = false;
      }
      return {setup: function (r, l, u, g, x) {
        let v = false;
        if (s) {
          const e = function (e, i, r) {
            const s = true === r.wireframe;
            let l = a[e.id];
            void 0 === l && (l = {}, a[e.id] = l);
            let c = l[i.id];
            void 0 === c && (c = {}, l[i.id] = c);
            let h = c[s];
            void 0 === h && (h = m(n.isWebGL2 ? t.createVertexArray() : o.createVertexArrayOES()), c[s] = h);
            return h;
          }(g, u, l);
          c !== e && (c = e, h(c.object)), v = function (t, e) {
            const i = c.attributes, n = t.attributes;
            let r = 0;
            for (const t in n) {
              const e = i[t], o = n[t];
              if (void 0 === e) return true;
              if (e.attribute !== o) return true;
              if (e.data !== o.data) return true;
              r++;
            }
            return c.attributesNum !== r || c.index !== e;
          }(g, x), v && function (t, e) {
            const i = {}, n = t.attributes;
            let r = 0;
            for (const t in n) {
              const e = n[t], o = {};
              o.attribute = e, e.data && (o.data = e.data), i[t] = o, r++;
            }
            c.attributes = i, c.attributesNum = r, c.index = e;
          }(g, x);
        } else {
          const t = true === l.wireframe;
          c.geometry === g.id && c.program === u.id && c.wireframe === t || (c.geometry = g.id, c.program = u.id, c.wireframe = t, v = true);
        }
        true === r.isInstancedMesh && (v = true), null !== x && i.update(x, 34963), v && (!function (r, o, s, a) {
          if (false === n.isWebGL2 && (r.isInstancedMesh || a.isInstancedBufferGeometry) && null === e.get("ANGLE_instanced_arrays")) return;
          p();
          const l = a.attributes, c = s.getAttributes(), h = o.defaultAttributeValues;
          for (const e in c) {
            const n = c[e];
            if (n.location >= 0) {
              let o = l[e];
              if (void 0 === o && ("instanceMatrix" === e && r.instanceMatrix && (o = r.instanceMatrix), "instanceColor" === e && r.instanceColor && (o = r.instanceColor)), void 0 !== o) {
                const e = o.normalized, s = o.itemSize, l = i.get(o);
                if (void 0 === l) continue;
                const c = l.buffer, h = l.type, u = l.bytesPerElement;
                if (o.isInterleavedBufferAttribute) {
                  const i = o.data, l = i.stride, m = o.offset;
                  if (i && i.isInstancedInterleavedBuffer) {
                    for (let t = 0; t < n.locationSize; t++) f(n.location + t, i.meshPerAttribute);
                    true !== r.isInstancedMesh && void 0 === a._maxInstanceCount && (a._maxInstanceCount = i.meshPerAttribute * i.count);
                  } else for (let t = 0; t < n.locationSize; t++) d(n.location + t);
                  t.bindBuffer(34962, c);
                  for (let t = 0; t < n.locationSize; t++) y(n.location + t, s / n.locationSize, h, e, l * u, (m + s / n.locationSize * t) * u);
                } else {
                  if (o.isInstancedBufferAttribute) {
                    for (let t = 0; t < n.locationSize; t++) f(n.location + t, o.meshPerAttribute);
                    true !== r.isInstancedMesh && void 0 === a._maxInstanceCount && (a._maxInstanceCount = o.meshPerAttribute * o.count);
                  } else for (let t = 0; t < n.locationSize; t++) d(n.location + t);
                  t.bindBuffer(34962, c);
                  for (let t = 0; t < n.locationSize; t++) y(n.location + t, s / n.locationSize, h, e, s * u, s / n.locationSize * t * u);
                }
              } else if (void 0 !== h) {
                const i = h[e];
                if (void 0 !== i) switch (i.length) {
                  case 2:
                    t.vertexAttrib2fv(n.location, i);
                    break;
                  case 3:
                    t.vertexAttrib3fv(n.location, i);
                    break;
                  case 4:
                    t.vertexAttrib4fv(n.location, i);
                    break;
                  default:
                    t.vertexAttrib1fv(n.location, i);
                }
              }
            }
          }
          _();
        }(r, l, u, g), null !== x && t.bindBuffer(34963, i.get(x).buffer));
      }, reset: g, resetDefaultState: x, dispose: function () {
        g();
        for (const t in a) {
          const e = a[t];
          for (const t in e) {
            const i = e[t];
            for (const t in i) u(i[t].object), delete i[t];
            delete e[t];
          }
          delete a[t];
        }
      }, releaseStatesOfGeometry: function (t) {
        if (void 0 === a[t.id]) return;
        const e = a[t.id];
        for (const t in e) {
          const i = e[t];
          for (const t in i) u(i[t].object), delete i[t];
          delete e[t];
        }
        delete a[t.id];
      }, releaseStatesOfProgram: function (t) {
        for (const e in a) {
          const i = a[e];
          if (void 0 === i[t.id]) continue;
          const n = i[t.id];
          for (const t in n) u(n[t].object), delete n[t];
          delete i[t.id];
        }
      }, initAttributes: p, enableAttribute: d, disableUnusedAttributes: _};
    }
    function si(t, e, i, n) {
      const r = n.isWebGL2;
      let o;
      this.setMode = function (t) {
        o = t;
      }, this.render = function (e, n) {
        t.drawArrays(o, e, n), i.update(n, o, 1);
      }, this.renderInstances = function (n, s, a) {
        if (0 === a) return;
        let l, c;
        if (r) l = t, c = "drawArraysInstanced"; else if (l = e.get("ANGLE_instanced_arrays"), c = "drawArraysInstancedANGLE", null === l) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
        l[c](o, n, s, a), i.update(s, o, a);
      };
    }
    function ai(t, e, i) {
      let n;
      function r(e) {
        if ("highp" === e) {
          if (t.getShaderPrecisionFormat(35633, 36338).precision > 0 && t.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp";
          e = "mediump";
        }
        return "mediump" === e && t.getShaderPrecisionFormat(35633, 36337).precision > 0 && t.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp";
      }
      const o = "undefined" != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && t instanceof WebGL2ComputeRenderingContext;
      let s = void 0 !== i.precision ? i.precision : "highp";
      const a = r(s);
      a !== s && (console.warn("THREE.WebGLRenderer:", s, "not supported, using", a, "instead."), s = a);
      const l = o || e.has("WEBGL_draw_buffers"), c = true === i.logarithmicDepthBuffer, h = t.getParameter(34930), u = t.getParameter(35660), m = t.getParameter(3379), p = t.getParameter(34076), d = t.getParameter(34921), f = t.getParameter(36347), _ = t.getParameter(36348), y = t.getParameter(36349), g = u > 0, x = o || e.has("OES_texture_float");
      return {isWebGL2: o, drawBuffers: l, getMaxAnisotropy: function () {
        if (void 0 !== n) return n;
        if (true === e.has("EXT_texture_filter_anisotropic")) {
          const i = e.get("EXT_texture_filter_anisotropic");
          n = t.getParameter(i.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
        } else n = 0;
        return n;
      }, getMaxPrecision: r, precision: s, logarithmicDepthBuffer: c, maxTextures: h, maxVertexTextures: u, maxTextureSize: m, maxCubemapSize: p, maxAttributes: d, maxVertexUniforms: f, maxVaryings: _, maxFragmentUniforms: y, vertexTextures: g, floatFragmentTextures: x, floatVertexTextures: g && x, maxSamples: o ? t.getParameter(36183) : 0};
    }
    function li(t) {
      const e = this;
      let i = null, n = 0, r = false, o = false;
      const s = new Plane, a = new Matrix3, l = {value: null, needsUpdate: false};
      function c() {
        l.value !== i && (l.value = i, l.needsUpdate = n > 0), e.numPlanes = n, e.numIntersection = 0;
      }
      function h(t, i, n, r) {
        const o = null !== t ? t.length : 0;
        let c = null;
        if (0 !== o) {
          if (c = l.value, true !== r || null === c) {
            const e = n + 4 * o, r = i.matrixWorldInverse;
            a.getNormalMatrix(r), (null === c || c.length < e) && (c = new Float32Array(e));
            for (let e = 0; e !== o; ++e, i += 4) s.copy(t[e]).applyMatrix4(r, a), s.normal.toArray(c, i), c[i + 3] = s.constant;
          }
          l.value = c, l.needsUpdate = true;
        }
        return e.numPlanes = o, e.numIntersection = 0, c;
      }
      this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function (t, e, o) {
        const s = 0 !== t.length || e || 0 !== n || r;
        return r = e, i = h(t, o, 0), n = t.length, s;
      }, this.beginShadows = function () {
        o = true, h(null);
      }, this.endShadows = function () {
        o = false, c();
      }, this.setState = function (e, s, a) {
        const u = e.clippingPlanes, m = e.clipIntersection, p = e.clipShadows, d = t.get(e);
        if (!r || null === u || 0 === u.length || o && !p) o ? h(null) : c(); else {
          const t = o ? 0 : n, e = 4 * t;
          let r = d.clippingState || null;
          l.value = r, r = h(u, s, e, a);
          for (let t = 0; t !== e; ++t) r[t] = i[t];
          d.clippingState = r, this.numIntersection = m ? this.numPlanes : 0, this.numPlanes += t;
        }
      };
    }
    function ci(t) {
      let e = new WeakMap;
      function n(t) {
        const i = t.target;
        i.removeEventListener("dispose", n);
        const r = e.get(i);
        void 0 !== r && (e.delete(i), r.dispose());
      }
      return {get: function (r) {
        if (r && r.isTexture && false === r.isRenderTargetTexture) {
          const o = r.mapping;
          if (o === l || o === c) {
            if (e.has(r)) {
              return r.mapping === l ? e.get(r).texture.mapping = s : r.mapping === c && (e.get(r).texture.mapping = a), e.get(r).texture;
            }
            {
              const o = r.image;
              if (o && o.height > 0) {
                const s = t.getRenderTarget(), a = new WebGLCubeRenderTarget(o.height / 2);
                return a.fromEquirectangularTexture(t, r), e.set(r, a), t.setRenderTarget(s), r.addEventListener("dispose", n), (r.mapping === l ? a.texture.mapping = s : r.mapping === c && (a.texture.mapping = a), a.texture);
              }
              return null;
            }
          }
        }
        return r;
      }, dispose: function () {
        e = new WeakMap;
      }};
    }
    ni.physical = {uniforms: Je([ni.standard.uniforms, {clearcoat: {value: 0}, clearcoatMap: {value: null}, clearcoatRoughness: {value: 0}, clearcoatRoughnessMap: {value: null}, clearcoatNormalScale: {value: new Vector2(1, 1)}, clearcoatNormalMap: {value: null}, sheenTint: {value: new three_module_Color(0)}, transmission: {value: 0}, transmissionMap: {value: null}, transmissionSamplerSize: {value: new Vector2}, transmissionSamplerMap: {value: null}, thickness: {value: 0}, thicknessMap: {value: null}, attenuationDistance: {value: 0}, attenuationTint: {value: new three_module_Color(0)}, specularIntensity: {value: 0}, specularIntensityMap: {value: null}, specularTint: {value: new three_module_Color(1, 1, 1)}, specularTintMap: {value: null}}]), vertexShader: ei.meshphysical_vert, fragmentShader: ei.meshphysical_frag};
    class OrthographicCamera extends Camera {
      constructor(t = -1, e = 1, i = 1, n = -1, r = 0.1, o = 2e3) {
        super(), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = t, this.right = e, this.top = i, this.bottom = n, this.near = r, this.far = o, this.updateProjectionMatrix();
      }
      copy(t, e) {
        return super.copy(t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = null === t.view ? null : Object.assign({}, t.view), this;
      }
      setViewOffset(t, e, i, n, r, o) {
        null === this.view && (this.view = {enabled: true, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1}), this.view.enabled = true, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = i, this.view.offsetY = n, this.view.width = r, this.view.height = o, this.updateProjectionMatrix();
      }
      clearViewOffset() {
        null !== this.view && (this.view.enabled = false), this.updateProjectionMatrix();
      }
      updateProjectionMatrix() {
        const t = (this.right - this.left) / (2 * this.zoom), e = (this.top - this.bottom) / (2 * this.zoom), i = (this.right + this.left) / 2, n = (this.top + this.bottom) / 2;
        let r = i - t, o = i + t, s = n + e, a = n - e;
        if (null !== this.view && this.view.enabled) {
          const t = (this.right - this.left) / this.view.fullWidth / this.zoom, e = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
          r += t * this.view.offsetX, o = r + t * this.view.width, s -= e * this.view.offsetY, a = s - e * this.view.height;
        }
        this.projectionMatrix.makeOrthographic(r, o, s, a, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
      }
      toJSON(t) {
        const e = super.toJSON(t);
        return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, null !== this.view && (e.object.view = Object.assign({}, this.view)), e;
      }
    }
    OrthographicCamera.prototype.isOrthographicCamera = true;
    class RawShaderMaterial extends ShaderMaterial {
      constructor(t) {
        super(t), this.type = "RawShaderMaterial";
      }
    }
    RawShaderMaterial.prototype.isRawShaderMaterial = true;
    const hi = Math.pow(2, 8), ui = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582], mi = 5 + ui.length, pi = 20, di = {[G]: 0, [N]: 1, [O]: 2, 3004: 3, 3005: 4, 3006: 5, [z]: 6}, fi = new OrthographicCamera, {_lodPlanes: _i, _sizeLods: yi, _sigmas: gi} = Ci(), xi = new three_module_Color;
    let vi = null;
    const bi = (1 + Math.sqrt(5)) / 2, wi = 1 / bi, Si = [new three_module_Vector3(1, 1, 1), new three_module_Vector3(-1, 1, 1), new three_module_Vector3(1, 1, -1), new three_module_Vector3(-1, 1, -1), new three_module_Vector3(0, bi, wi), new three_module_Vector3(0, bi, -wi), new three_module_Vector3(wi, 0, bi), new three_module_Vector3(-wi, 0, bi), new three_module_Vector3(bi, wi, 0), new three_module_Vector3(-bi, wi, 0)];
    class PMREMGenerator {
      constructor(t) {
        this._renderer = t, this._pingPongRenderTarget = null, this._blurMaterial = function (t) {
          const e = new Float32Array(t), i = new three_module_Vector3(0, 1, 0);
          return new RawShaderMaterial({name: "SphericalGaussianBlur", defines: {n: t}, uniforms: {envMap: {value: null}, samples: {value: 1}, weights: {value: e}, latitudinal: {value: false}, dTheta: {value: 0}, mipInt: {value: 0}, poleAxis: {value: i}, inputEncoding: {value: di[3e3]}, outputEncoding: {value: di[3e3]}}, vertexShader: "\n\n		precision mediump float;\n		precision mediump int;\n\n		attribute vec3 position;\n		attribute vec2 uv;\n		attribute float faceIndex;\n\n		varying vec3 vOutputDirection;\n\n		// RH coordinate system; PMREM face-indexing convention\n		vec3 getDirection( vec2 uv, float face ) {\n\n			uv = 2.0 * uv - 1.0;\n\n			vec3 direction = vec3( uv, 1.0 );\n\n			if ( face == 0.0 ) {\n\n				direction = direction.zyx; // ( 1, v, u ) pos x\n\n			} else if ( face == 1.0 ) {\n\n				direction = direction.xzy;\n				direction.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n			} else if ( face == 2.0 ) {\n\n				direction.x *= -1.0; // ( -u, v, 1 ) pos z\n\n			} else if ( face == 3.0 ) {\n\n				direction = direction.zyx;\n				direction.xz *= -1.0; // ( -1, v, -u ) neg x\n\n			} else if ( face == 4.0 ) {\n\n				direction = direction.xzy;\n				direction.xy *= -1.0; // ( -u, -1, v ) neg y\n\n			} else if ( face == 5.0 ) {\n\n				direction.z *= -1.0; // ( u, v, -1 ) neg z\n\n			}\n\n			return direction;\n\n		}\n\n		void main() {\n\n			vOutputDirection = getDirection( uv, faceIndex );\n			gl_Position = vec4( position, 1.0 );\n\n		}\n	", fragmentShader: `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t${"\n\n		uniform int inputEncoding;\n		uniform int outputEncoding;\n\n		#include <encodings_pars_fragment>\n\n		vec4 inputTexelToLinear( vec4 value ) {\n\n			if ( inputEncoding == 0 ) {\n\n				return value;\n\n			} else if ( inputEncoding == 1 ) {\n\n				return sRGBToLinear( value );\n\n			} else if ( inputEncoding == 2 ) {\n\n				return RGBEToLinear( value );\n\n			} else if ( inputEncoding == 3 ) {\n\n				return RGBMToLinear( value, 7.0 );\n\n			} else if ( inputEncoding == 4 ) {\n\n				return RGBMToLinear( value, 16.0 );\n\n			} else if ( inputEncoding == 5 ) {\n\n				return RGBDToLinear( value, 256.0 );\n\n			} else {\n\n				return GammaToLinear( value, 2.2 );\n\n			}\n\n		}\n\n		vec4 linearToOutputTexel( vec4 value ) {\n\n			if ( outputEncoding == 0 ) {\n\n				return value;\n\n			} else if ( outputEncoding == 1 ) {\n\n				return LinearTosRGB( value );\n\n			} else if ( outputEncoding == 2 ) {\n\n				return LinearToRGBE( value );\n\n			} else if ( outputEncoding == 3 ) {\n\n				return LinearToRGBM( value, 7.0 );\n\n			} else if ( outputEncoding == 4 ) {\n\n				return LinearToRGBM( value, 16.0 );\n\n			} else if ( outputEncoding == 5 ) {\n\n				return LinearToRGBD( value, 256.0 );\n\n			} else {\n\n				return LinearToGamma( value, 2.2 );\n\n			}\n\n		}\n\n		vec4 envMapTexelToLinear( vec4 color ) {\n\n			return inputTexelToLinear( color );\n\n		}\n	"}\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`, blending: 0, depthTest: false, depthWrite: false});
        }(pi), this._equirectShader = null, this._cubemapShader = null, this._compileMaterial(this._blurMaterial);
      }
      fromScene(t, e = 0, i = 0.1, n = 100) {
        vi = this._renderer.getRenderTarget();
        const r = this._allocateTargets();
        return this._sceneToCubeUV(t, i, n, r), e > 0 && this._blur(r, 0, 0, e), this._applyPMREM(r), this._cleanup(r), r;
      }
      fromEquirectangular(t) {
        return this._fromTexture(t);
      }
      fromCubemap(t) {
        return this._fromTexture(t);
      }
      compileCubemapShader() {
        null === this._cubemapShader && (this._cubemapShader = Li(), this._compileMaterial(this._cubemapShader));
      }
      compileEquirectangularShader() {
        null === this._equirectShader && (this._equirectShader = Ei(), this._compileMaterial(this._equirectShader));
      }
      dispose() {
        this._blurMaterial.dispose(), null !== this._cubemapShader && this._cubemapShader.dispose(), null !== this._equirectShader && this._equirectShader.dispose();
        for (let t = 0; t < _i.length; t++) _i[t].dispose();
      }
      _cleanup(t) {
        this._pingPongRenderTarget.dispose(), this._renderer.setRenderTarget(vi), t.scissorTest = false, Ti(t, 0, 0, t.width, t.height);
      }
      _fromTexture(t) {
        vi = this._renderer.getRenderTarget();
        const e = this._allocateTargets(t);
        return this._textureToCubeUV(t, e), this._applyPMREM(e), this._cleanup(e), e;
      }
      _allocateTargets(t) {
        const e = {magFilter: f, minFilter: f, generateMipmaps: false, type: v, format: 1023, encoding: void 0 !== t && t.type === v && (t.encoding === G || t.encoding === N || t.encoding === z) ? t.encoding : O, depthBuffer: false}, i = Ai(e);
        return i.depthBuffer = !t, this._pingPongRenderTarget = Ai(e), i;
      }
      _compileMaterial(t) {
        const e = new Mesh(_i[0], t);
        this._renderer.compile(e, fi);
      }
      _sceneToCubeUV(t, e, i, n) {
        const r = new PerspectiveCamera(90, 1, e, i), o = [1, -1, 1, 1, 1, 1], s = [1, 1, 1, -1, -1, -1], a = this._renderer, l = a.autoClear, c = a.outputEncoding, h = a.toneMapping;
        a.getClearColor(xi), a.toneMapping = 0, a.outputEncoding = G, a.autoClear = false;
        const u = new MeshBasicMaterial({name: "PMREM.Background", side: 1, depthWrite: false, depthTest: false}), m = new Mesh(new BoxGeometry, u);
        let p = false;
        const d = t.background;
        d ? d.isColor && (u.color.copy(d), t.background = null, p = true) : (u.color.copy(xi), p = true);
        for (let e = 0; e < 6; e++) {
          const i = e % 3;
          0 == i ? (r.up.set(0, o[e], 0), r.lookAt(s[e], 0, 0)) : 1 == i ? (r.up.set(0, 0, o[e]), r.lookAt(0, s[e], 0)) : (r.up.set(0, o[e], 0), r.lookAt(0, 0, s[e])), Ti(n, i * hi, e > 2 ? hi : 0, hi, hi), a.setRenderTarget(n), p && a.render(m, r), a.render(t, r);
        }
        m.geometry.dispose(), m.material.dispose(), a.toneMapping = h, a.outputEncoding = c, a.autoClear = l, t.background = d;
      }
      _textureToCubeUV(t, e) {
        const i = this._renderer;
        t.isCubeTexture ? null == this._cubemapShader && (this._cubemapShader = Li()) : null == this._equirectShader && (this._equirectShader = Ei());
        const n = t.isCubeTexture ? this._cubemapShader : this._equirectShader, r = new Mesh(_i[0], n), o = n.uniforms;
        o.envMap.value = t, t.isCubeTexture || o.texelSize.value.set(1 / t.image.width, 1 / t.image.height), o.inputEncoding.value = di[t.encoding], o.outputEncoding.value = di[e.texture.encoding], Ti(e, 0, 0, 3 * hi, 2 * hi), i.setRenderTarget(e), i.render(r, fi);
      }
      _applyPMREM(t) {
        const e = this._renderer, i = e.autoClear;
        e.autoClear = false;
        for (let e = 1; e < mi; e++) {
          const i = Math.sqrt(gi[e] * gi[e] - gi[e - 1] * gi[e - 1]), n = Si[(e - 1) % Si.length];
          this._blur(t, e - 1, e, i, n);
        }
        e.autoClear = i;
      }
      _blur(t, e, i, n, r) {
        const o = this._pingPongRenderTarget;
        this._halfBlur(t, o, e, i, n, "latitudinal", r), this._halfBlur(o, t, i, i, n, "longitudinal", r);
      }
      _halfBlur(t, e, i, n, r, o, s) {
        const a = this._renderer, l = this._blurMaterial;
        "latitudinal" !== o && "longitudinal" !== o && console.error("blur direction must be either latitudinal or longitudinal!");
        const c = new Mesh(_i[n], l), h = l.uniforms, u = yi[i] - 1, m = isFinite(r) ? Math.PI / (2 * u) : 2 * Math.PI / 39, p = r / m, d = isFinite(r) ? 1 + Math.floor(3 * p) : pi;
        d > pi && console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${d} samples when the maximum is set to 20`);
        const f = [];
        let _ = 0;
        for (let t = 0; t < pi; ++t) {
          const e = t / p, i = Math.exp(-e * e / 2);
          f.push(i), 0 == t ? _ += i : t < d && (_ += 2 * i);
        }
        for (let t = 0; t < f.length; t++) f[t] = f[t] / _;
        h.envMap.value = t.texture, h.samples.value = d, h.weights.value = f, h.latitudinal.value = "latitudinal" === o, s && (h.poleAxis.value = s), h.dTheta.value = m, h.mipInt.value = 8 - i, h.inputEncoding.value = di[t.texture.encoding], h.outputEncoding.value = di[t.texture.encoding];
        const y = yi[n];
        Ti(e, 3 * Math.max(0, hi - 2 * y), (0 === n ? 0 : 2 * hi) + 2 * y * (n > 4 ? n - 8 + 4 : 0), 3 * y, 2 * y), a.setRenderTarget(e), a.render(c, fi);
      }
    }
    function Ci() {
      const t = [], e = [], i = [];
      let n = 8;
      for (let r = 0; r < mi; r++) {
        const o = Math.pow(2, n);
        e.push(o);
        let s = 1 / o;
        r > 4 ? s = ui[r - 8 + 4 - 1] : 0 == r && (s = 0), i.push(s);
        const a = 1 / (o - 1), l = -a / 2, c = 1 + a / 2, h = [l, l, c, l, c, c, l, l, c, c, l, c], u = 6, m = 6, p = 3, d = 2, f = 1, _ = new Float32Array(p * m * u), y = new Float32Array(d * m * u), g = new Float32Array(f * m * u);
        for (let t = 0; t < u; t++) {
          const e = t % 3 * 2 / 3 - 1, i = t > 2 ? 0 : -1, n = [e, i, 0, e + 0.6666666666666666, i, 0, e + 0.6666666666666666, i + 1, 0, e, i, 0, e + 0.6666666666666666, i + 1, 0, e, i + 1, 0];
          _.set(n, p * m * t), y.set(h, d * m * t);
          const r = [t, t, t, t, t, t];
          g.set(r, f * m * t);
        }
        const x = new BufferGeometry;
        x.setAttribute("position", new BufferAttribute(_, p)), x.setAttribute("uv", new BufferAttribute(y, d)), x.setAttribute("faceIndex", new BufferAttribute(g, f)), t.push(x), n > 4 && n--;
      }
      return {_lodPlanes: t, _sizeLods: e, _sigmas: i};
    }
    function Ai(t) {
      const e = new WebGLRenderTarget(3 * hi, 3 * hi, t);
      return e.texture.mapping = h, e.texture.name = "PMREM.cubeUv", e.scissorTest = true, e;
    }
    function Ti(t, e, i, n, r) {
      t.viewport.set(e, i, n, r), t.scissor.set(e, i, n, r);
    }
    function Ei() {
      const t = new Vector2(1, 1);
      return new RawShaderMaterial({name: "EquirectangularToCubeUV", uniforms: {envMap: {value: null}, texelSize: {value: t}, inputEncoding: {value: di[3e3]}, outputEncoding: {value: di[3e3]}}, vertexShader: "\n\n		precision mediump float;\n		precision mediump int;\n\n		attribute vec3 position;\n		attribute vec2 uv;\n		attribute float faceIndex;\n\n		varying vec3 vOutputDirection;\n\n		// RH coordinate system; PMREM face-indexing convention\n		vec3 getDirection( vec2 uv, float face ) {\n\n			uv = 2.0 * uv - 1.0;\n\n			vec3 direction = vec3( uv, 1.0 );\n\n			if ( face == 0.0 ) {\n\n				direction = direction.zyx; // ( 1, v, u ) pos x\n\n			} else if ( face == 1.0 ) {\n\n				direction = direction.xzy;\n				direction.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n			} else if ( face == 2.0 ) {\n\n				direction.x *= -1.0; // ( -u, v, 1 ) pos z\n\n			} else if ( face == 3.0 ) {\n\n				direction = direction.zyx;\n				direction.xz *= -1.0; // ( -1, v, -u ) neg x\n\n			} else if ( face == 4.0 ) {\n\n				direction = direction.xzy;\n				direction.xy *= -1.0; // ( -u, -1, v ) neg y\n\n			} else if ( face == 5.0 ) {\n\n				direction.z *= -1.0; // ( u, v, -1 ) neg z\n\n			}\n\n			return direction;\n\n		}\n\n		void main() {\n\n			vOutputDirection = getDirection( uv, faceIndex );\n			gl_Position = vec4( position, 1.0 );\n\n		}\n	", fragmentShader: `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t${"\n\n		uniform int inputEncoding;\n		uniform int outputEncoding;\n\n		#include <encodings_pars_fragment>\n\n		vec4 inputTexelToLinear( vec4 value ) {\n\n			if ( inputEncoding == 0 ) {\n\n				return value;\n\n			} else if ( inputEncoding == 1 ) {\n\n				return sRGBToLinear( value );\n\n			} else if ( inputEncoding == 2 ) {\n\n				return RGBEToLinear( value );\n\n			} else if ( inputEncoding == 3 ) {\n\n				return RGBMToLinear( value, 7.0 );\n\n			} else if ( inputEncoding == 4 ) {\n\n				return RGBMToLinear( value, 16.0 );\n\n			} else if ( inputEncoding == 5 ) {\n\n				return RGBDToLinear( value, 256.0 );\n\n			} else {\n\n				return GammaToLinear( value, 2.2 );\n\n			}\n\n		}\n\n		vec4 linearToOutputTexel( vec4 value ) {\n\n			if ( outputEncoding == 0 ) {\n\n				return value;\n\n			} else if ( outputEncoding == 1 ) {\n\n				return LinearTosRGB( value );\n\n			} else if ( outputEncoding == 2 ) {\n\n				return LinearToRGBE( value );\n\n			} else if ( outputEncoding == 3 ) {\n\n				return LinearToRGBM( value, 7.0 );\n\n			} else if ( outputEncoding == 4 ) {\n\n				return LinearToRGBM( value, 16.0 );\n\n			} else if ( outputEncoding == 5 ) {\n\n				return LinearToRGBD( value, 256.0 );\n\n			} else {\n\n				return LinearToGamma( value, 2.2 );\n\n			}\n\n		}\n\n		vec4 envMapTexelToLinear( vec4 color ) {\n\n			return inputTexelToLinear( color );\n\n		}\n	"}\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`, blending: 0, depthTest: false, depthWrite: false});
    }
    function Li() {
      return new RawShaderMaterial({name: "CubemapToCubeUV", uniforms: {envMap: {value: null}, inputEncoding: {value: di[3e3]}, outputEncoding: {value: di[3e3]}}, vertexShader: "\n\n		precision mediump float;\n		precision mediump int;\n\n		attribute vec3 position;\n		attribute vec2 uv;\n		attribute float faceIndex;\n\n		varying vec3 vOutputDirection;\n\n		// RH coordinate system; PMREM face-indexing convention\n		vec3 getDirection( vec2 uv, float face ) {\n\n			uv = 2.0 * uv - 1.0;\n\n			vec3 direction = vec3( uv, 1.0 );\n\n			if ( face == 0.0 ) {\n\n				direction = direction.zyx; // ( 1, v, u ) pos x\n\n			} else if ( face == 1.0 ) {\n\n				direction = direction.xzy;\n				direction.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n			} else if ( face == 2.0 ) {\n\n				direction.x *= -1.0; // ( -u, v, 1 ) pos z\n\n			} else if ( face == 3.0 ) {\n\n				direction = direction.zyx;\n				direction.xz *= -1.0; // ( -1, v, -u ) neg x\n\n			} else if ( face == 4.0 ) {\n\n				direction = direction.xzy;\n				direction.xy *= -1.0; // ( -u, -1, v ) neg y\n\n			} else if ( face == 5.0 ) {\n\n				direction.z *= -1.0; // ( u, v, -1 ) neg z\n\n			}\n\n			return direction;\n\n		}\n\n		void main() {\n\n			vOutputDirection = getDirection( uv, faceIndex );\n			gl_Position = vec4( position, 1.0 );\n\n		}\n	", fragmentShader: `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\t${"\n\n		uniform int inputEncoding;\n		uniform int outputEncoding;\n\n		#include <encodings_pars_fragment>\n\n		vec4 inputTexelToLinear( vec4 value ) {\n\n			if ( inputEncoding == 0 ) {\n\n				return value;\n\n			} else if ( inputEncoding == 1 ) {\n\n				return sRGBToLinear( value );\n\n			} else if ( inputEncoding == 2 ) {\n\n				return RGBEToLinear( value );\n\n			} else if ( inputEncoding == 3 ) {\n\n				return RGBMToLinear( value, 7.0 );\n\n			} else if ( inputEncoding == 4 ) {\n\n				return RGBMToLinear( value, 16.0 );\n\n			} else if ( inputEncoding == 5 ) {\n\n				return RGBDToLinear( value, 256.0 );\n\n			} else {\n\n				return GammaToLinear( value, 2.2 );\n\n			}\n\n		}\n\n		vec4 linearToOutputTexel( vec4 value ) {\n\n			if ( outputEncoding == 0 ) {\n\n				return value;\n\n			} else if ( outputEncoding == 1 ) {\n\n				return LinearTosRGB( value );\n\n			} else if ( outputEncoding == 2 ) {\n\n				return LinearToRGBE( value );\n\n			} else if ( outputEncoding == 3 ) {\n\n				return LinearToRGBM( value, 7.0 );\n\n			} else if ( outputEncoding == 4 ) {\n\n				return LinearToRGBM( value, 16.0 );\n\n			} else if ( outputEncoding == 5 ) {\n\n				return LinearToRGBD( value, 256.0 );\n\n			} else {\n\n				return LinearToGamma( value, 2.2 );\n\n			}\n\n		}\n\n		vec4 envMapTexelToLinear( vec4 color ) {\n\n			return inputTexelToLinear( color );\n\n		}\n	"}\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`, blending: 0, depthTest: false, depthWrite: false});
    }
    function Bi(t) {
      let e = new WeakMap, i = null;
      function n(t) {
        const i = t.target;
        i.removeEventListener("dispose", n);
        const r = e.get(i);
        void 0 !== r && (e.delete(i), r.dispose());
      }
      return {get: function (r) {
        if (r && r.isTexture && false === r.isRenderTargetTexture) {
          const o = r.mapping, h = o === l || o === c, u = o === s || o === a;
          if (h || u) {
            if (e.has(r)) return e.get(r).texture;
            {
              const o = r.image;
              if (h && o && o.height > 0 || u && o && function (t) {
                let e = 0;
                const i = 6;
                for (let n = 0; n < i; n++) void 0 !== t[n] && e++;
                return e === i;
              }(o)) {
                const o = t.getRenderTarget();
                null === i && (i = new PMREMGenerator(t));
                const s = h ? i.fromEquirectangular(r) : i.fromCubemap(r);
                return e.set(r, s), t.setRenderTarget(o), r.addEventListener("dispose", n), s.texture;
              }
              return null;
            }
          }
        }
        return r;
      }, dispose: function () {
        e = new WeakMap, null !== i && (i.dispose(), i = null);
      }};
    }
    function Ri(t) {
      const e = {};
      function i(i) {
        if (void 0 !== e[i]) return e[i];
        let n;
        switch (i) {
          case "WEBGL_depth_texture":
            n = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture");
            break;
          case "EXT_texture_filter_anisotropic":
            n = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
            break;
          case "WEBGL_compressed_texture_s3tc":
            n = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
            break;
          case "WEBGL_compressed_texture_pvrtc":
            n = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
            break;
          default:
            n = t.getExtension(i);
        }
        return e[i] = n, n;
      }
      return {has: function (t) {
        return null !== i(t);
      }, init: function (t) {
        t.isWebGL2 ? i("EXT_color_buffer_float") : (i("WEBGL_depth_texture"), i("OES_texture_float"), i("OES_texture_half_float"), i("OES_texture_half_float_linear"), i("OES_standard_derivatives"), i("OES_element_index_uint"), i("OES_vertex_array_object"), i("ANGLE_instanced_arrays")), i("OES_texture_float_linear"), i("EXT_color_buffer_half_float");
      }, get: function (t) {
        const e = i(t);
        return null === e && console.warn("THREE.WebGLRenderer: " + t + " extension not supported."), e;
      }};
    }
    function Pi(t, e, i, n) {
      const r = {}, o = new WeakMap;
      function s(t) {
        const a = t.target;
        null !== a.index && e.remove(a.index);
        for (const t in a.attributes) e.remove(a.attributes[t]);
        a.removeEventListener("dispose", s), delete r[a.id];
        const l = o.get(a);
        l && (e.remove(l), o.delete(a)), n.releaseStatesOfGeometry(a), true === a.isInstancedBufferGeometry && delete a._maxInstanceCount, i.memory.geometries--;
      }
      function a(t) {
        const i = [], n = t.index, r = t.attributes.position;
        let s = 0;
        if (null !== n) {
          const t = n.array;
          s = n.version;
          for (let e = 0, n = t.length; e < n; e += 3) {
            const n = t[e + 0], r = t[e + 1], o = t[e + 2];
            i.push(n, r, r, o, o, n);
          }
        } else {
          const t = r.array;
          s = r.version;
          for (let e = 0, n = t.length / 3 - 1; e < n; e += 3) {
            const t = e + 0, n = e + 1, r = e + 2;
            i.push(t, n, n, r, r, t);
          }
        }
        const a = new (ge(i) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(i, 1);
        a.version = s;
        const l = o.get(t);
        l && e.remove(l), o.set(t, a);
      }
      return {get: function (t, e) {
        return true === r[e.id] || (e.addEventListener("dispose", s), r[e.id] = true, i.memory.geometries++), e;
      }, update: function (t) {
        const i = t.attributes;
        for (const t in i) e.update(i[t], 34962);
        const n = t.morphAttributes;
        for (const t in n) {
          const i = n[t];
          for (let t = 0, n = i.length; t < n; t++) e.update(i[t], 34962);
        }
      }, getWireframeAttribute: function (t) {
        const e = o.get(t);
        if (e) {
          const i = t.index;
          null !== i && e.version < i.version && a(t);
        } else a(t);
        return o.get(t);
      }};
    }
    function Ii(t, e, i, n) {
      const r = n.isWebGL2;
      let o, s, a;
      this.setMode = function (t) {
        o = t;
      }, this.setIndex = function (t) {
        s = t.type, a = t.bytesPerElement;
      }, this.render = function (e, n) {
        t.drawElements(o, n, s, e * a), i.update(n, o, 1);
      }, this.renderInstances = function (n, l, c) {
        if (0 === c) return;
        let h, u;
        if (r) h = t, u = "drawElementsInstanced"; else if (h = e.get("ANGLE_instanced_arrays"), u = "drawElementsInstancedANGLE", null === h) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
        h[u](o, l, s, n * a, c), i.update(l, o, c);
      };
    }
    function Fi(t) {
      const e = {frame: 0, calls: 0, triangles: 0, points: 0, lines: 0};
      return {memory: {geometries: 0, textures: 0}, render: e, programs: null, autoReset: true, reset: function () {
        e.frame++, e.calls = 0, e.triangles = 0, e.points = 0, e.lines = 0;
      }, update: function (t, i, n) {
        switch (e.calls++, i) {
          case 4:
            e.triangles += n * (t / 3);
            break;
          case 1:
            e.lines += n * (t / 2);
            break;
          case 3:
            e.lines += n * (t - 1);
            break;
          case 2:
            e.lines += n * t;
            break;
          case 0:
            e.points += n * t;
            break;
          default:
            console.error("THREE.WebGLInfo: Unknown draw mode:", i);
        }
      }};
    }
    function zi(t) {
      const e = {}, i = new Float32Array(8), n = [];
      for (let t = 0; t < 8; t++) n[t] = [t, 0];
      return {update: function (r, o, s, a) {
        const l = r.morphTargetInfluences, c = void 0 === l ? 0 : l.length;
        let h = e[o.id];
        if (void 0 === h || h.length !== c) {
          h = [];
          for (let t = 0; t < c; t++) h[t] = [t, 0];
          e[o.id] = h;
        }
        for (let t = 0; t < c; t++) {
          const e = h[t];
          e[0] = t, e[1] = l[t];
        }
        h.sort(Ni);
        for (let t = 0; t < 8; t++) t < c && h[t][1] ? (n[t][0] = h[t][0], n[t][1] = h[t][1]) : (n[t][0] = Number.MAX_SAFE_INTEGER, n[t][1] = 0);
        n.sort(Gi);
        const u = o.morphAttributes.position, m = o.morphAttributes.normal;
        let p = 0;
        for (let t = 0; t < 8; t++) {
          const e = n[t], r = e[0], s = e[1];
          r !== Number.MAX_SAFE_INTEGER && s ? (u && o.getAttribute("morphTarget" + t) !== u[r] && o.setAttribute("morphTarget" + t, u[r]), m && o.getAttribute("morphNormal" + t) !== m[r] && o.setAttribute("morphNormal" + t, m[r]), i[t] = s, p += s) : (u && true === o.hasAttribute("morphTarget" + t) && o.deleteAttribute("morphTarget" + t), m && true === o.hasAttribute("morphNormal" + t) && o.deleteAttribute("morphNormal" + t), i[t] = 0);
        }
        const d = o.morphTargetsRelative ? 1 : 1 - p;
        a.getUniforms().setValue(t, "morphTargetBaseInfluence", d), a.getUniforms().setValue(t, "morphTargetInfluences", i);
      }};
    }
    function Oi(t, e, i, n) {
      let r = new WeakMap;
      function o(t) {
        const e = t.target;
        e.removeEventListener("dispose", o), i.remove(e.instanceMatrix), null !== e.instanceColor && i.remove(e.instanceColor);
      }
      return {update: function (t) {
        const s = n.render.frame, a = t.geometry, l = e.get(t, a);
        return r.get(l) !== s && (e.update(l), r.set(l, s)), t.isInstancedMesh && (false === t.hasEventListener("dispose", o) && t.addEventListener("dispose", o), i.update(t.instanceMatrix, 34962), null !== t.instanceColor && i.update(t.instanceColor, 34962)), l;
      }, dispose: function () {
        r = new WeakMap;
      }};
    }
    class DataTexture2DArray extends Texture {
      constructor(t = null, e = 1, i = 1, n = 1) {
        super(null), this.image = {data: t, width: e, height: i, depth: n}, this.magFilter = f, this.minFilter = f, this.wrapR = p, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1, this.needsUpdate = true;
      }
    }
    DataTexture2DArray.prototype.isDataTexture2DArray = true;
    class DataTexture3D extends Texture {
      constructor(t = null, e = 1, i = 1, n = 1) {
        super(null), this.image = {data: t, width: e, height: i, depth: n}, this.magFilter = f, this.minFilter = f, this.wrapR = p, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1, this.needsUpdate = true;
      }
    }
    DataTexture3D.prototype.isDataTexture3D = true;
    const Ui = new Texture, ki = new DataTexture2DArray, Hi = new DataTexture3D, Wi = new CubeTexture, Ji = [], ji = [], Xi = new Float32Array(16), qi = new Float32Array(9), Yi = new Float32Array(4);
    function Zi(t, e, i) {
      const n = t[0];
      if (n <= 0 || n > 0) return t;
      const r = e * i;
      let o = Ji[r];
      if (void 0 === o && (o = new Float32Array(r), Ji[r] = o), 0 !== e) {
        n.toArray(o, 0);
        for (let n = 1, r = 0; n !== e; ++n) r += i, t[n].toArray(o, r);
      }
      return o;
    }
    function Ki(t, e) {
      if (t.length !== e.length) return false;
      for (let i = 0, n = t.length; i < n; i++) if (t[i] !== e[i]) return false;
      return true;
    }
    function Qi(t, e) {
      for (let i = 0, n = e.length; i < n; i++) t[i] = e[i];
    }
    function $i(t, e) {
      let i = ji[e];
      void 0 === i && (i = new Int32Array(e), ji[e] = i);
      for (let n = 0; n !== e; ++n) i[n] = t.allocateTextureUnit();
      return i;
    }
    function tn(t, e) {
      const i = this.cache;
      i[0] !== e && (t.uniform1f(this.addr, e), i[0] = e);
    }
    function en(t, e) {
      const i = this.cache;
      if (void 0 !== e.x) i[0] === e.x && i[1] === e.y || (t.uniform2f(this.addr, e.x, e.y), i[0] = e.x, i[1] = e.y); else {
        if (Ki(i, e)) return;
        t.uniform2fv(this.addr, e), Qi(i, e);
      }
    }
    function nn(t, e) {
      const i = this.cache;
      if (void 0 !== e.x) i[0] === e.x && i[1] === e.y && i[2] === e.z || (t.uniform3f(this.addr, e.x, e.y, e.z), i[0] = e.x, i[1] = e.y, i[2] = e.z); else if (void 0 !== e.r) i[0] === e.r && i[1] === e.g && i[2] === e.b || (t.uniform3f(this.addr, e.r, e.g, e.b), i[0] = e.r, i[1] = e.g, i[2] = e.b); else {
        if (Ki(i, e)) return;
        t.uniform3fv(this.addr, e), Qi(i, e);
      }
    }
    function rn(t, e) {
      const i = this.cache;
      if (void 0 !== e.x) i[0] === e.x && i[1] === e.y && i[2] === e.z && i[3] === e.w || (t.uniform4f(this.addr, e.x, e.y, e.z, e.w), i[0] = e.x, i[1] = e.y, i[2] = e.z, i[3] = e.w); else {
        if (Ki(i, e)) return;
        t.uniform4fv(this.addr, e), Qi(i, e);
      }
    }
    function on(t, e) {
      const i = this.cache, n = e.elements;
      if (void 0 === n) {
        if (Ki(i, e)) return;
        t.uniformMatrix2fv(this.addr, false, e), Qi(i, e);
      } else {
        if (Ki(i, n)) return;
        Yi.set(n), t.uniformMatrix2fv(this.addr, false, Yi), Qi(i, n);
      }
    }
    function sn(t, e) {
      const i = this.cache, n = e.elements;
      if (void 0 === n) {
        if (Ki(i, e)) return;
        t.uniformMatrix3fv(this.addr, false, e), Qi(i, e);
      } else {
        if (Ki(i, n)) return;
        qi.set(n), t.uniformMatrix3fv(this.addr, false, qi), Qi(i, n);
      }
    }
    function an(t, e) {
      const i = this.cache, n = e.elements;
      if (void 0 === n) {
        if (Ki(i, e)) return;
        t.uniformMatrix4fv(this.addr, false, e), Qi(i, e);
      } else {
        if (Ki(i, n)) return;
        Xi.set(n), t.uniformMatrix4fv(this.addr, false, Xi), Qi(i, n);
      }
    }
    function ln(t, e) {
      const i = this.cache;
      i[0] !== e && (t.uniform1i(this.addr, e), i[0] = e);
    }
    function cn(t, e) {
      const i = this.cache;
      Ki(i, e) || (t.uniform2iv(this.addr, e), Qi(i, e));
    }
    function hn(t, e) {
      const i = this.cache;
      Ki(i, e) || (t.uniform3iv(this.addr, e), Qi(i, e));
    }
    function un(t, e) {
      const i = this.cache;
      Ki(i, e) || (t.uniform4iv(this.addr, e), Qi(i, e));
    }
    function mn(t, e) {
      const i = this.cache;
      i[0] !== e && (t.uniform1ui(this.addr, e), i[0] = e);
    }
    function pn(t, e) {
      const i = this.cache;
      Ki(i, e) || (t.uniform2uiv(this.addr, e), Qi(i, e));
    }
    function dn(t, e) {
      const i = this.cache;
      Ki(i, e) || (t.uniform3uiv(this.addr, e), Qi(i, e));
    }
    function fn(t, e) {
      const i = this.cache;
      Ki(i, e) || (t.uniform4uiv(this.addr, e), Qi(i, e));
    }
    function _n(t, e, i) {
      const n = this.cache, r = i.allocateTextureUnit();
      n[0] !== r && (t.uniform1i(this.addr, r), n[0] = r), i.safeSetTexture2D(e || Ui, r);
    }
    function yn(t, e, i) {
      const n = this.cache, r = i.allocateTextureUnit();
      n[0] !== r && (t.uniform1i(this.addr, r), n[0] = r), i.setTexture3D(e || Hi, r);
    }
    function gn(t, e, i) {
      const n = this.cache, r = i.allocateTextureUnit();
      n[0] !== r && (t.uniform1i(this.addr, r), n[0] = r), i.safeSetTextureCube(e || Wi, r);
    }
    function xn(t, e, i) {
      const n = this.cache, r = i.allocateTextureUnit();
      n[0] !== r && (t.uniform1i(this.addr, r), n[0] = r), i.setTexture2DArray(e || ki, r);
    }
    function vn(t, e) {
      t.uniform1fv(this.addr, e);
    }
    function bn(t, e) {
      const i = Zi(e, this.size, 2);
      t.uniform2fv(this.addr, i);
    }
    function wn(t, e) {
      const i = Zi(e, this.size, 3);
      t.uniform3fv(this.addr, i);
    }
    function Sn(t, e) {
      const i = Zi(e, this.size, 4);
      t.uniform4fv(this.addr, i);
    }
    function Mn(t, e) {
      const i = Zi(e, this.size, 4);
      t.uniformMatrix2fv(this.addr, false, i);
    }
    function Cn(t, e) {
      const i = Zi(e, this.size, 9);
      t.uniformMatrix3fv(this.addr, false, i);
    }
    function An(t, e) {
      const i = Zi(e, this.size, 16);
      t.uniformMatrix4fv(this.addr, false, i);
    }
    function Tn(t, e) {
      t.uniform1iv(this.addr, e);
    }
    function En(t, e) {
      t.uniform2iv(this.addr, e);
    }
    function Ln(t, e) {
      t.uniform3iv(this.addr, e);
    }
    function Dn(t, e) {
      t.uniform4iv(this.addr, e);
    }
    function Vn(t, e) {
      t.uniform1uiv(this.addr, e);
    }
    function Bn(t, e) {
      t.uniform2uiv(this.addr, e);
    }
    function Rn(t, e) {
      t.uniform3uiv(this.addr, e);
    }
    function Pn(t, e) {
      t.uniform4uiv(this.addr, e);
    }
    function In(t, e, i) {
      const n = e.length, r = $i(i, n);
      t.uniform1iv(this.addr, r);
      for (let t = 0; t !== n; ++t) i.safeSetTexture2D(e[t] || Ui, r[t]);
    }
    function Fn(t, e, i) {
      const n = e.length, r = $i(i, n);
      t.uniform1iv(this.addr, r);
      for (let t = 0; t !== n; ++t) i.safeSetTextureCube(e[t] || Wi, r[t]);
    }
    function Gn(t, e, i) {
      this.id = t, this.addr = i, this.cache = [], this.setValue = function (t) {
        switch (t) {
          case 5126:
            return tn;
          case 35664:
            return en;
          case 35665:
            return nn;
          case 35666:
            return rn;
          case 35674:
            return on;
          case 35675:
            return sn;
          case 35676:
            return an;
          case 5124:
          case 35670:
            return ln;
          case 35667:
          case 35671:
            return cn;
          case 35668:
          case 35672:
            return hn;
          case 35669:
          case 35673:
            return un;
          case 5125:
            return mn;
          case 36294:
            return pn;
          case 36295:
            return dn;
          case 36296:
            return fn;
          case 35678:
          case 36198:
          case 36298:
          case 36306:
          case 35682:
            return _n;
          case 35679:
          case 36299:
          case 36307:
            return yn;
          case 35680:
          case 36300:
          case 36308:
          case 36293:
            return gn;
          case 36289:
          case 36303:
          case 36311:
          case 36292:
            return xn;
        }
      }(e.type);
    }
    function Nn(t, e, i) {
      this.id = t, this.addr = i, this.cache = [], this.size = e.size, this.setValue = function (t) {
        switch (t) {
          case 5126:
            return vn;
          case 35664:
            return bn;
          case 35665:
            return wn;
          case 35666:
            return Sn;
          case 35674:
            return Mn;
          case 35675:
            return Cn;
          case 35676:
            return An;
          case 5124:
          case 35670:
            return Tn;
          case 35667:
          case 35671:
            return En;
          case 35668:
          case 35672:
            return Ln;
          case 35669:
          case 35673:
            return Dn;
          case 5125:
            return Vn;
          case 36294:
            return Bn;
          case 36295:
            return Rn;
          case 36296:
            return Pn;
          case 35678:
          case 36198:
          case 36298:
          case 36306:
          case 35682:
            return In;
          case 35680:
          case 36300:
          case 36308:
          case 36293:
            return Fn;
        }
      }(e.type);
    }
    function zn(t) {
      this.id = t, this.seq = [], this.map = {};
    }
    Nn.prototype.updateCache = function (t) {
      const e = this.cache;
      t instanceof Float32Array && e.length !== t.length && (this.cache = new Float32Array(t.length)), Qi(e, t);
    }, zn.prototype.setValue = function (t, e, i) {
      const n = this.seq;
      for (let r = 0, o = n.length; r !== o; ++r) {
        const o = n[r];
        o.setValue(t, e[o.id], i);
      }
    };
    const On = /(\w+)(\])?(\[|\.)?/g;
    function Un(t, e) {
      t.seq.push(e), t.map[e.id] = e;
    }
    function kn(t, e, i) {
      const n = t.name, r = n.length;
      for (On.lastIndex = 0;;) {
        const o = On.exec(n), s = On.lastIndex;
        let a = o[1];
        const l = "]" === o[2], c = o[3];
        if (l && (a |= 0), void 0 === c || "[" === c && s + 2 === r) {
          Un(i, void 0 === c ? new Gn(a, t, e) : new Nn(a, t, e));
          break;
        }
        {
          let t = i.map[a];
          void 0 === t && (t = new zn(a), Un(i, t)), i = t;
        }
      }
    }
    function Hn(t, e) {
      this.seq = [], this.map = {};
      const i = t.getProgramParameter(e, 35718);
      for (let n = 0; n < i; ++n) {
        const i = t.getActiveUniform(e, n);
        kn(i, t.getUniformLocation(e, i.name), this);
      }
    }
    function Wn(t, e, i) {
      const n = t.createShader(e);
      return t.shaderSource(n, i), t.compileShader(n), n;
    }
    Hn.prototype.setValue = function (t, e, i, n) {
      const r = this.map[e];
      void 0 !== r && r.setValue(t, i, n);
    }, Hn.prototype.setOptional = function (t, e, i) {
      const n = e[i];
      void 0 !== n && this.setValue(t, i, n);
    }, Hn.upload = function (t, e, i, n) {
      for (let r = 0, o = e.length; r !== o; ++r) {
        const o = e[r], s = i[o.id];
        false !== s.needsUpdate && o.setValue(t, s.value, n);
      }
    }, Hn.seqWithValue = function (t, e) {
      const i = [];
      for (let n = 0, r = t.length; n !== r; ++n) {
        const r = t[n];
        r.id in e && i.push(r);
      }
      return i;
    };
    let Jn = 0;
    function jn(t) {
      switch (t) {
        case G:
          return ["Linear", "( value )"];
        case N:
          return ["sRGB", "( value )"];
        case O:
          return ["RGBE", "( value )"];
        case 3004:
          return ["RGBM", "( value, 7.0 )"];
        case 3005:
          return ["RGBM", "( value, 16.0 )"];
        case 3006:
          return ["RGBD", "( value, 256.0 )"];
        case z:
          return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
        case 3003:
          return ["LogLuv", "( value )"];
        default:
          return console.warn("THREE.WebGLProgram: Unsupported encoding:", t), ["Linear", "( value )"];
      }
    }
    function Xn(t, e, i) {
      const n = t.getShaderParameter(e, 35713), r = t.getShaderInfoLog(e).trim();
      return n && "" === r ? "" : i.toUpperCase() + "\n\n" + r + "\n\n" + function (t) {
        const e = t.split("\n");
        for (let t = 0; t < e.length; t++) e[t] = t + 1 + ": " + e[t];
        return e.join("\n");
      }(t.getShaderSource(e));
    }
    function qn(t, e) {
      const i = jn(e);
      return "vec4 " + t + "( vec4 value ) { return " + i[0] + "ToLinear" + i[1] + "; }";
    }
    function Yn(t, e) {
      const i = jn(e);
      return "vec4 " + t + "( vec4 value ) { return LinearTo" + i[0] + i[1] + "; }";
    }
    function Zn(t, e) {
      let i;
      switch (e) {
        case 1:
          i = "Linear";
          break;
        case 2:
          i = "Reinhard";
          break;
        case 3:
          i = "OptimizedCineon";
          break;
        case 4:
          i = "ACESFilmic";
          break;
        case 5:
          i = "Custom";
          break;
        default:
          console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), i = "Linear";
      }
      return "vec3 " + t + "( vec3 color ) { return " + i + "ToneMapping( color ); }";
    }
    const tr = /^[ \t]*#include +<([\w\d./]+)>/gm;
    function ir(t, e) {
      const i = ei[e];
      if (void 0 === i) throw new Error("Can not resolve #include <" + e + ">");
      return i.replace(tr, ir);
    }
    const nr = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g, rr = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
    function ar(t, e, i, n) {
      let r = "";
      for (let t = parseInt(e); t < parseInt(i); t++) r += n.replace(/\[\s*i\s*\]/g, "[ " + t + " ]").replace(/UNROLLED_LOOP_INDEX/g, t);
      return r;
    }
    function lr(t) {
      let e = "precision " + t.precision + " float;\nprecision " + t.precision + " int;";
      return "highp" === t.precision ? e += "\n#define HIGH_PRECISION" : "mediump" === t.precision ? e += "\n#define MEDIUM_PRECISION" : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"), e;
    }
    function cr(t, e, i, n) {
      const r = t.getContext(), o = i.defines;
      let l = i.vertexShader, c = i.fragmentShader;
      const m = function (t) {
        let e = "SHADOWMAP_TYPE_BASIC";
        return 1 === t.shadowMapType ? e = "SHADOWMAP_TYPE_PCF" : 2 === t.shadowMapType ? e = "SHADOWMAP_TYPE_PCF_SOFT" : 3 === t.shadowMapType && (e = "SHADOWMAP_TYPE_VSM"), e;
      }(i), p = function (t) {
        let e = "ENVMAP_TYPE_CUBE";
        if (t.envMap) switch (t.envMapMode) {
          case s:
          case a:
            e = "ENVMAP_TYPE_CUBE";
            break;
          case h:
          case u:
            e = "ENVMAP_TYPE_CUBE_UV";
        }
        return e;
      }(i), d = function (t) {
        let e = "ENVMAP_MODE_REFLECTION";
        if (t.envMap) switch (t.envMapMode) {
          case a:
          case u:
            e = "ENVMAP_MODE_REFRACTION";
        }
        return e;
      }(i), f = function (t) {
        let e = "ENVMAP_BLENDING_NONE";
        if (t.envMap) switch (t.combine) {
          case 0:
            e = "ENVMAP_BLENDING_MULTIPLY";
            break;
          case 1:
            e = "ENVMAP_BLENDING_MIX";
            break;
          case 2:
            e = "ENVMAP_BLENDING_ADD";
        }
        return e;
      }(i), _ = t.gammaFactor > 0 ? t.gammaFactor : 1, y = i.isWebGL2 ? "" : function (t) {
        return [t.extensionDerivatives || t.envMapCubeUV || t.bumpMap || t.tangentSpaceNormalMap || t.clearcoatNormalMap || t.flatShading || "physical" === t.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (t.extensionFragDepth || t.logarithmicDepthBuffer) && t.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", t.extensionDrawBuffers && t.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (t.extensionShaderTextureLOD || t.envMap || t.transmission) && t.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Kn).join("\n");
      }(i), g = function (t) {
        const e = [];
        for (const i in t) {
          const n = t[i];
          false !== n && e.push("#define " + i + " " + n);
        }
        return e.join("\n");
      }(o), x = r.createProgram();
      let v, b, w = i.glslVersion ? "#version " + i.glslVersion + "\n" : "";
      i.isRawShaderMaterial ? (v = [g].filter(Kn).join("\n"), v.length > 0 && (v += "\n"), b = [y, g].filter(Kn).join("\n"), b.length > 0 && (b += "\n")) : (v = [lr(i), "#define SHADER_NAME " + i.shaderName, g, i.instancing ? "#define USE_INSTANCING" : "", i.instancingColor ? "#define USE_INSTANCING_COLOR" : "", i.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + _, "#define MAX_BONES " + i.maxBones, i.useFog && i.fog ? "#define USE_FOG" : "", i.useFog && i.fogExp2 ? "#define FOG_EXP2" : "", i.map ? "#define USE_MAP" : "", i.envMap ? "#define USE_ENVMAP" : "", i.envMap ? "#define " + d : "", i.lightMap ? "#define USE_LIGHTMAP" : "", i.aoMap ? "#define USE_AOMAP" : "", i.emissiveMap ? "#define USE_EMISSIVEMAP" : "", i.bumpMap ? "#define USE_BUMPMAP" : "", i.normalMap ? "#define USE_NORMALMAP" : "", i.normalMap && i.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", i.normalMap && i.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", i.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", i.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", i.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", i.displacementMap && i.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", i.specularMap ? "#define USE_SPECULARMAP" : "", i.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", i.specularTintMap ? "#define USE_SPECULARTINTMAP" : "", i.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", i.metalnessMap ? "#define USE_METALNESSMAP" : "", i.alphaMap ? "#define USE_ALPHAMAP" : "", i.transmission ? "#define USE_TRANSMISSION" : "", i.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", i.thicknessMap ? "#define USE_THICKNESSMAP" : "", i.vertexTangents ? "#define USE_TANGENT" : "", i.vertexColors ? "#define USE_COLOR" : "", i.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", i.vertexUvs ? "#define USE_UV" : "", i.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", i.flatShading ? "#define FLAT_SHADED" : "", i.skinning ? "#define USE_SKINNING" : "", i.useVertexTexture ? "#define BONE_TEXTURE" : "", i.morphTargets ? "#define USE_MORPHTARGETS" : "", i.morphNormals && false === i.flatShading ? "#define USE_MORPHNORMALS" : "", i.doubleSided ? "#define DOUBLE_SIDED" : "", i.flipSided ? "#define FLIP_SIDED" : "", i.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", i.shadowMapEnabled ? "#define " + m : "", i.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", i.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", i.logarithmicDepthBuffer && i.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "	attribute vec3 morphTarget0;", "	attribute vec3 morphTarget1;", "	attribute vec3 morphTarget2;", "	attribute vec3 morphTarget3;", "	#ifdef USE_MORPHNORMALS", "		attribute vec3 morphNormal0;", "		attribute vec3 morphNormal1;", "		attribute vec3 morphNormal2;", "		attribute vec3 morphNormal3;", "	#else", "		attribute vec3 morphTarget4;", "		attribute vec3 morphTarget5;", "		attribute vec3 morphTarget6;", "		attribute vec3 morphTarget7;", "	#endif", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", "\n"].filter(Kn).join("\n"), b = [y, lr(i), "#define SHADER_NAME " + i.shaderName, g, "#define GAMMA_FACTOR " + _, i.useFog && i.fog ? "#define USE_FOG" : "", i.useFog && i.fogExp2 ? "#define FOG_EXP2" : "", i.map ? "#define USE_MAP" : "", i.matcap ? "#define USE_MATCAP" : "", i.envMap ? "#define USE_ENVMAP" : "", i.envMap ? "#define " + p : "", i.envMap ? "#define " + d : "", i.envMap ? "#define " + f : "", i.lightMap ? "#define USE_LIGHTMAP" : "", i.aoMap ? "#define USE_AOMAP" : "", i.emissiveMap ? "#define USE_EMISSIVEMAP" : "", i.bumpMap ? "#define USE_BUMPMAP" : "", i.normalMap ? "#define USE_NORMALMAP" : "", i.normalMap && i.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", i.normalMap && i.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", i.clearcoat ? "#define USE_CLEARCOAT" : "", i.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", i.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", i.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", i.specularMap ? "#define USE_SPECULARMAP" : "", i.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", i.specularTintMap ? "#define USE_SPECULARTINTMAP" : "", i.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", i.metalnessMap ? "#define USE_METALNESSMAP" : "", i.alphaMap ? "#define USE_ALPHAMAP" : "", i.alphaTest ? "#define USE_ALPHATEST" : "", i.sheenTint ? "#define USE_SHEEN" : "", i.transmission ? "#define USE_TRANSMISSION" : "", i.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", i.thicknessMap ? "#define USE_THICKNESSMAP" : "", i.vertexTangents ? "#define USE_TANGENT" : "", i.vertexColors || i.instancingColor ? "#define USE_COLOR" : "", i.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", i.vertexUvs ? "#define USE_UV" : "", i.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", i.gradientMap ? "#define USE_GRADIENTMAP" : "", i.flatShading ? "#define FLAT_SHADED" : "", i.doubleSided ? "#define DOUBLE_SIDED" : "", i.flipSided ? "#define FLIP_SIDED" : "", i.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", i.shadowMapEnabled ? "#define " + m : "", i.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", i.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", i.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", i.logarithmicDepthBuffer && i.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (i.extensionShaderTextureLOD || i.envMap) && i.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", 0 !== i.toneMapping ? "#define TONE_MAPPING" : "", 0 !== i.toneMapping ? ei.tonemapping_pars_fragment : "", 0 !== i.toneMapping ? Zn("toneMapping", i.toneMapping) : "", i.dithering ? "#define DITHERING" : "", i.format === A ? "#define OPAQUE" : "", ei.encodings_pars_fragment, i.map ? qn("mapTexelToLinear", i.mapEncoding) : "", i.matcap ? qn("matcapTexelToLinear", i.matcapEncoding) : "", i.envMap ? qn("envMapTexelToLinear", i.envMapEncoding) : "", i.emissiveMap ? qn("emissiveMapTexelToLinear", i.emissiveMapEncoding) : "", i.specularTintMap ? qn("specularTintMapTexelToLinear", i.specularTintMapEncoding) : "", i.lightMap ? qn("lightMapTexelToLinear", i.lightMapEncoding) : "", Yn("linearToOutputTexel", i.outputEncoding), i.depthPacking ? "#define DEPTH_PACKING " + i.depthPacking : "", "\n"].filter(Kn).join("\n")), l = l.replace(tr, ir), l = l.replace(/NUM_DIR_LIGHTS/g, i.numDirLights).replace(/NUM_SPOT_LIGHTS/g, i.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, i.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, i.numPointLights).replace(/NUM_HEMI_LIGHTS/g, i.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, i.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, i.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, i.numPointLightShadows), l = l.replace(/NUM_CLIPPING_PLANES/g, i.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, i.numClippingPlanes - i.numClipIntersection), c = c.replace(tr, ir), c = c.replace(/NUM_DIR_LIGHTS/g, i.numDirLights).replace(/NUM_SPOT_LIGHTS/g, i.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, i.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, i.numPointLights).replace(/NUM_HEMI_LIGHTS/g, i.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, i.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, i.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, i.numPointLightShadows), c = c.replace(/NUM_CLIPPING_PLANES/g, i.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, i.numClippingPlanes - i.numClipIntersection), l = l.replace(rr, ar).replace(nr, sr), c = c.replace(rr, ar).replace(nr, sr), i.isWebGL2 && true !== i.isRawShaderMaterial && (w = "#version 300 es\n", v = ["#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + v, b = ["#define varying in", i.glslVersion === W ? "" : "out highp vec4 pc_fragColor;", i.glslVersion === W ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + b);
      const S = w + b + c, M = Wn(r, 35633, w + v + l), C = Wn(r, 35632, S);
      if (r.attachShader(x, M), r.attachShader(x, C), void 0 !== i.index0AttributeName ? r.bindAttribLocation(x, 0, i.index0AttributeName) : true === i.morphTargets && r.bindAttribLocation(x, 0, "position"), r.linkProgram(x), t.debug.checkShaderErrors) {
        const t = r.getProgramInfoLog(x).trim(), e = r.getShaderInfoLog(M).trim(), i = r.getShaderInfoLog(C).trim();
        let n = true, o = true;
        if (false === r.getProgramParameter(x, 35714)) {
          n = false;
          const e = Xn(r, M, "vertex"), i = Xn(r, C, "fragment");
          console.error("THREE.WebGLProgram: Shader Error " + r.getError() + " - VALIDATE_STATUS " + r.getProgramParameter(x, 35715) + "\n\nProgram Info Log: " + t + "\n" + e + "\n" + i);
        } else "" !== t ? console.warn("THREE.WebGLProgram: Program Info Log:", t) : "" !== e && "" !== i || (o = false);
        o && (this.diagnostics = {runnable: n, programLog: t, vertexShader: {log: e, prefix: v}, fragmentShader: {log: i, prefix: b}});
      }
      let T, E;
      return r.deleteShader(M), r.deleteShader(C), this.getUniforms = function () {
        return void 0 === T && (T = new Hn(r, x)), T;
      }, this.getAttributes = function () {
        return void 0 === E && (E = function (t, e) {
          const i = {}, n = t.getProgramParameter(e, 35721);
          for (let r = 0; r < n; r++) {
            const n = t.getActiveAttrib(e, r), o = n.name;
            let s = 1;
            35674 === n.type && (s = 2), 35675 === n.type && (s = 3), 35676 === n.type && (s = 4), i[o] = {type: n.type, location: t.getAttribLocation(e, o), locationSize: s};
          }
          return i;
        }(r, x)), E;
      }, this.destroy = function () {
        n.releaseStatesOfProgram(this), r.deleteProgram(x), this.program = void 0;
      }, this.name = i.shaderName, this.id = Jn++, this.cacheKey = e, this.usedTimes = 1, this.program = x, this.vertexShader = M, this.fragmentShader = C, this;
    }
    function hr(t, e, i, n, r, o, s) {
      const a = [], l = r.isWebGL2, c = r.logarithmicDepthBuffer, m = r.floatVertexTextures, p = r.maxVertexUniforms, d = r.vertexTextures;
      let f = r.precision;
      const _ = {MeshDepthMaterial: "depth", MeshDistanceMaterial: "distanceRGBA", MeshNormalMaterial: "normal", MeshBasicMaterial: "basic", MeshLambertMaterial: "lambert", MeshPhongMaterial: "phong", MeshToonMaterial: "toon", MeshStandardMaterial: "physical", MeshPhysicalMaterial: "physical", MeshMatcapMaterial: "matcap", LineBasicMaterial: "basic", LineDashedMaterial: "dashed", PointsMaterial: "points", ShadowMaterial: "shadow", SpriteMaterial: "sprite"}, y = ["precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing", "instancingColor", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV", "lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoat", "clearcoatMap", "clearcoatRoughnessMap", "clearcoatNormalMap", "displacementMap", "specularMap", "specularIntensityMap", "specularTintMap", "specularTintMapEncoding", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "alphaTest", "combine", "vertexColors", "vertexAlphas", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "format", "sheenTint", "transmission", "transmissionMap", "thicknessMap"];
      function g(t) {
        let e;
        return t && t.isTexture ? e = t.encoding : t && t.isWebGLRenderTarget ? (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), e = t.texture.encoding) : e = G, e;
      }
      return {getParameters: function (o, a, y, x, v) {
        const b = x.fog, w = o.isMeshStandardMaterial ? x.environment : null, S = (o.isMeshStandardMaterial ? i : e).get(o.envMap || w), M = _[o.type], C = v.isSkinnedMesh ? function (t) {
          const e = t.skeleton.bones;
          if (m) return 1024;
          {
            const t = p, i = Math.floor((t - 20) / 4), n = Math.min(i, e.length);
            return n < e.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + e.length + " bones. This GPU supports " + n + "."), 0) : n;
          }
        }(v) : 0;
        let A, T;
        if (null !== o.precision && (f = r.getMaxPrecision(o.precision), f !== o.precision && console.warn("THREE.WebGLProgram.getParameters:", o.precision, "not supported, using", f, "instead.")), M) {
          const t = ni[M];
          A = t.vertexShader, T = t.fragmentShader;
        } else A = o.vertexShader, T = o.fragmentShader;
        const E = t.getRenderTarget(), L = o.alphaTest > 0, D = o.clearcoat > 0;
        return {isWebGL2: l, shaderID: M, shaderName: o.type, vertexShader: A, fragmentShader: T, defines: o.defines, isRawShaderMaterial: true === o.isRawShaderMaterial, glslVersion: o.glslVersion, precision: f, instancing: true === v.isInstancedMesh, instancingColor: true === v.isInstancedMesh && null !== v.instanceColor, supportsVertexTextures: d, outputEncoding: null !== E ? g(E.texture) : t.outputEncoding, map: !!o.map, mapEncoding: g(o.map), matcap: !!o.matcap, matcapEncoding: g(o.matcap), envMap: !!S, envMapMode: S && S.mapping, envMapEncoding: g(S), envMapCubeUV: !!S && (S.mapping === h || S.mapping === u), lightMap: !!o.lightMap, lightMapEncoding: g(o.lightMap), aoMap: !!o.aoMap, emissiveMap: !!o.emissiveMap, emissiveMapEncoding: g(o.emissiveMap), bumpMap: !!o.bumpMap, normalMap: !!o.normalMap, objectSpaceNormalMap: 1 === o.normalMapType, tangentSpaceNormalMap: 0 === o.normalMapType, clearcoat: D, clearcoatMap: D && !!o.clearcoatMap, clearcoatRoughnessMap: D && !!o.clearcoatRoughnessMap, clearcoatNormalMap: D && !!o.clearcoatNormalMap, displacementMap: !!o.displacementMap, roughnessMap: !!o.roughnessMap, metalnessMap: !!o.metalnessMap, specularMap: !!o.specularMap, specularIntensityMap: !!o.specularIntensityMap, specularTintMap: !!o.specularTintMap, specularTintMapEncoding: g(o.specularTintMap), alphaMap: !!o.alphaMap, alphaTest: L, gradientMap: !!o.gradientMap, sheenTint: !!o.sheenTint && (o.sheenTint.r > 0 || o.sheenTint.g > 0 || o.sheenTint.b > 0), transmission: o.transmission > 0, transmissionMap: !!o.transmissionMap, thicknessMap: !!o.thicknessMap, combine: o.combine, vertexTangents: !!o.normalMap && !!v.geometry && !!v.geometry.attributes.tangent, vertexColors: o.vertexColors, vertexAlphas: true === o.vertexColors && !!v.geometry && !!v.geometry.attributes.color && 4 === v.geometry.attributes.color.itemSize, vertexUvs: !!(o.map || o.bumpMap || o.normalMap || o.specularMap || o.alphaMap || o.emissiveMap || o.roughnessMap || o.metalnessMap || o.clearcoatMap || o.clearcoatRoughnessMap || o.clearcoatNormalMap || o.displacementMap || o.transmissionMap || o.thicknessMap || o.specularIntensityMap || o.specularTintMap), uvsVertexOnly: !(o.map || o.bumpMap || o.normalMap || o.specularMap || o.alphaMap || o.emissiveMap || o.roughnessMap || o.metalnessMap || o.clearcoatNormalMap || o.transmission > 0 || o.transmissionMap || o.thicknessMap || o.specularIntensityMap || o.specularTintMap || !o.displacementMap), fog: !!b, useFog: o.fog, fogExp2: b && b.isFogExp2, flatShading: !!o.flatShading, sizeAttenuation: o.sizeAttenuation, logarithmicDepthBuffer: c, skinning: true === v.isSkinnedMesh && C > 0, maxBones: C, useVertexTexture: m, morphTargets: !!v.geometry && !!v.geometry.morphAttributes.position, morphNormals: !!v.geometry && !!v.geometry.morphAttributes.normal, numDirLights: a.directional.length, numPointLights: a.point.length, numSpotLights: a.spot.length, numRectAreaLights: a.rectArea.length, numHemiLights: a.hemi.length, numDirLightShadows: a.directionalShadowMap.length, numPointLightShadows: a.pointShadowMap.length, numSpotLightShadows: a.spotShadowMap.length, numClippingPlanes: s.numPlanes, numClipIntersection: s.numIntersection, format: o.format, dithering: o.dithering, shadowMapEnabled: t.shadowMap.enabled && y.length > 0, shadowMapType: t.shadowMap.type, toneMapping: o.toneMapped ? t.toneMapping : 0, physicallyCorrectLights: t.physicallyCorrectLights, premultipliedAlpha: o.premultipliedAlpha, doubleSided: 2 === o.side, flipSided: 1 === o.side, depthPacking: void 0 !== o.depthPacking && o.depthPacking, index0AttributeName: o.index0AttributeName, extensionDerivatives: o.extensions && o.extensions.derivatives, extensionFragDepth: o.extensions && o.extensions.fragDepth, extensionDrawBuffers: o.extensions && o.extensions.drawBuffers, extensionShaderTextureLOD: o.extensions && o.extensions.shaderTextureLOD, rendererExtensionFragDepth: l || n.has("EXT_frag_depth"), rendererExtensionDrawBuffers: l || n.has("WEBGL_draw_buffers"), rendererExtensionShaderTextureLod: l || n.has("EXT_shader_texture_lod"), customProgramCacheKey: o.customProgramCacheKey()};
      }, getProgramCacheKey: function (e) {
        const i = [];
        if (e.shaderID ? i.push(e.shaderID) : (i.push(e.fragmentShader), i.push(e.vertexShader)), void 0 !== e.defines) for (const t in e.defines) i.push(t), i.push(e.defines[t]);
        if (false === e.isRawShaderMaterial) {
          for (let t = 0; t < y.length; t++) i.push(e[y[t]]);
          i.push(t.outputEncoding), i.push(t.gammaFactor);
        }
        return i.push(e.customProgramCacheKey), i.join();
      }, getUniforms: function (t) {
        const e = _[t.type];
        let i;
        if (e) {
          const t = ni[e];
          i = je.clone(t.uniforms);
        } else i = t.uniforms;
        return i;
      }, acquireProgram: function (e, i) {
        let n;
        for (let t = 0, e = a.length; t < e; t++) {
          const e = a[t];
          if (e.cacheKey === i) {
            n = e, ++n.usedTimes;
            break;
          }
        }
        return void 0 === n && (n = new cr(t, i, e, o), a.push(n)), n;
      }, releaseProgram: function (t) {
        if (0 == --t.usedTimes) {
          const e = a.indexOf(t);
          a[e] = a[a.length - 1], a.pop(), t.destroy();
        }
      }, programs: a};
    }
    function ur() {
      let t = new WeakMap;
      return {get: function (e) {
        let i = t.get(e);
        return void 0 === i && (i = {}, t.set(e, i)), i;
      }, remove: function (e) {
        t.delete(e);
      }, update: function (e, i, n) {
        t.get(e)[i] = n;
      }, dispose: function () {
        t = new WeakMap;
      }};
    }
    function mr(t, e) {
      return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.program !== e.program ? t.program.id - e.program.id : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id;
    }
    function pr(t, e) {
      return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id;
    }
    function dr(t) {
      const e = [];
      let i = 0;
      const n = [], r = [], o = [], s = {id: -1};
      function a(n, r, o, a, l, c) {
        let h = e[i];
        const u = t.get(o);
        return void 0 === h ? (h = {id: n.id, object: n, geometry: r, material: o, program: u.program || s, groupOrder: a, renderOrder: n.renderOrder, z: l, group: c}, e[i] = h) : (h.id = n.id, h.object = n, h.geometry = r, h.material = o, h.program = u.program || s, h.groupOrder = a, h.renderOrder = n.renderOrder, h.z = l, h.group = c), i++, h;
      }
      return {opaque: n, transmissive: r, transparent: o, init: function () {
        i = 0, n.length = 0, r.length = 0, o.length = 0;
      }, push: function (t, e, i, s, l, c) {
        const h = a(t, e, i, s, l, c);
        i.transmission > 0 ? r.push(h) : true === i.transparent ? o.push(h) : n.push(h);
      }, unshift: function (t, e, i, s, l, c) {
        const h = a(t, e, i, s, l, c);
        i.transmission > 0 ? r.unshift(h) : true === i.transparent ? o.unshift(h) : n.unshift(h);
      }, finish: function () {
        for (let t = i, n = e.length; t < n; t++) {
          const i = e[t];
          if (null === i.id) break;
          i.id = null, i.object = null, i.geometry = null, i.material = null, i.program = null, i.group = null;
        }
      }, sort: function (t, e) {
        n.length > 1 && n.sort(t || mr), r.length > 1 && r.sort(e || pr), o.length > 1 && o.sort(e || pr);
      }};
    }
    function fr(t) {
      let e = new WeakMap;
      return {get: function (i, n) {
        let r;
        return false === e.has(i) ? (r = new dr(t), e.set(i, [r])) : n >= e.get(i).length ? (r = new dr(t), e.get(i).push(r)) : r = e.get(i)[n], r;
      }, dispose: function () {
        e = new WeakMap;
      }};
    }
    function _r() {
      const t = {};
      return {get: function (e) {
        if (void 0 !== t[e.id]) return t[e.id];
        let i;
        switch (e.type) {
          case "DirectionalLight":
            i = {direction: new three_module_Vector3, color: new three_module_Color};
            break;
          case "SpotLight":
            i = {position: new three_module_Vector3, direction: new three_module_Vector3, color: new three_module_Color, distance: 0, coneCos: 0, penumbraCos: 0, decay: 0};
            break;
          case "PointLight":
            i = {position: new three_module_Vector3, color: new three_module_Color, distance: 0, decay: 0};
            break;
          case "HemisphereLight":
            i = {direction: new three_module_Vector3, skyColor: new three_module_Color, groundColor: new three_module_Color};
            break;
          case "RectAreaLight":
            i = {color: new three_module_Color, position: new three_module_Vector3, halfWidth: new three_module_Vector3, halfHeight: new three_module_Vector3};
        }
        return t[e.id] = i, i;
      }};
    }
    let yr = 0;
    function xr(t, e) {
      const i = new _r, n = function () {
        const t = {};
        return {get: function (e) {
          if (void 0 !== t[e.id]) return t[e.id];
          let i;
          switch (e.type) {
            case "DirectionalLight":
            case "SpotLight":
              i = {shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new Vector2};
              break;
            case "PointLight":
              i = {shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new Vector2, shadowCameraNear: 1, shadowCameraFar: 1e3};
          }
          return t[e.id] = i, i;
        }};
      }(), r = {version: 0, hash: {directionalLength: -1, pointLength: -1, spotLength: -1, rectAreaLength: -1, hemiLength: -1, numDirectionalShadows: -1, numPointShadows: -1, numSpotShadows: -1}, ambient: [0, 0, 0], probe: [], directional: [], directionalShadow: [], directionalShadowMap: [], directionalShadowMatrix: [], spot: [], spotShadow: [], spotShadowMap: [], spotShadowMatrix: [], rectArea: [], rectAreaLTC1: null, rectAreaLTC2: null, point: [], pointShadow: [], pointShadowMap: [], pointShadowMatrix: [], hemi: []};
      for (let t = 0; t < 9; t++) r.probe.push(new three_module_Vector3);
      const o = new three_module_Vector3, s = new Matrix4, a = new Matrix4;
      return {setup: function (o, s) {
        let a = 0, l = 0, c = 0;
        for (let t = 0; t < 9; t++) r.probe[t].set(0, 0, 0);
        let h = 0, u = 0, m = 0, p = 0, d = 0, f = 0, _ = 0, y = 0;
        o.sort(gr);
        const g = true !== s ? Math.PI : 1;
        for (let t = 0, e = o.length; t < e; t++) {
          const e = o[t], s = e.color, x = e.intensity, v = e.distance, b = e.shadow && e.shadow.map ? e.shadow.map.texture : null;
          if (e.isAmbientLight) a += s.r * x * g, l += s.g * x * g, c += s.b * x * g; else if (e.isLightProbe) for (let t = 0; t < 9; t++) r.probe[t].addScaledVector(e.sh.coefficients[t], x); else if (e.isDirectionalLight) {
            const t = i.get(e);
            if (t.color.copy(e.color).multiplyScalar(e.intensity * g), e.castShadow) {
              const t = e.shadow, i = n.get(e);
              i.shadowBias = t.bias, i.shadowNormalBias = t.normalBias, i.shadowRadius = t.radius, i.shadowMapSize = t.mapSize, r.directionalShadow[h] = i, r.directionalShadowMap[h] = b, r.directionalShadowMatrix[h] = e.shadow.matrix, f++;
            }
            r.directional[h] = t, h++;
          } else if (e.isSpotLight) {
            const t = i.get(e);
            if (t.position.setFromMatrixPosition(e.matrixWorld), t.color.copy(s).multiplyScalar(x * g), t.distance = v, t.coneCos = Math.cos(e.angle), t.penumbraCos = Math.cos(e.angle * (1 - e.penumbra)), t.decay = e.decay, e.castShadow) {
              const t = e.shadow, i = n.get(e);
              i.shadowBias = t.bias, i.shadowNormalBias = t.normalBias, i.shadowRadius = t.radius, i.shadowMapSize = t.mapSize, r.spotShadow[m] = i, r.spotShadowMap[m] = b, r.spotShadowMatrix[m] = e.shadow.matrix, y++;
            }
            r.spot[m] = t, m++;
          } else if (e.isRectAreaLight) {
            const t = i.get(e);
            t.color.copy(s).multiplyScalar(x), t.halfWidth.set(0.5 * e.width, 0, 0), t.halfHeight.set(0, 0.5 * e.height, 0), r.rectArea[p] = t, p++;
          } else if (e.isPointLight) {
            const t = i.get(e);
            if (t.color.copy(e.color).multiplyScalar(e.intensity * g), t.distance = e.distance, t.decay = e.decay, e.castShadow) {
              const t = e.shadow, i = n.get(e);
              i.shadowBias = t.bias, i.shadowNormalBias = t.normalBias, i.shadowRadius = t.radius, i.shadowMapSize = t.mapSize, i.shadowCameraNear = t.camera.near, i.shadowCameraFar = t.camera.far, r.pointShadow[u] = i, r.pointShadowMap[u] = b, r.pointShadowMatrix[u] = e.shadow.matrix, _++;
            }
            r.point[u] = t, u++;
          } else if (e.isHemisphereLight) {
            const t = i.get(e);
            t.skyColor.copy(e.color).multiplyScalar(x * g), t.groundColor.copy(e.groundColor).multiplyScalar(x * g), r.hemi[d] = t, d++;
          }
        }
        p > 0 && (e.isWebGL2 || true === t.has("OES_texture_float_linear") ? (r.rectAreaLTC1 = ii.LTC_FLOAT_1, r.rectAreaLTC2 = ii.LTC_FLOAT_2) : true === t.has("OES_texture_half_float_linear") ? (r.rectAreaLTC1 = ii.LTC_HALF_1, r.rectAreaLTC2 = ii.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), r.ambient[0] = a, r.ambient[1] = l, r.ambient[2] = c;
        const x = r.hash;
        x.directionalLength === h && x.pointLength === u && x.spotLength === m && x.rectAreaLength === p && x.hemiLength === d && x.numDirectionalShadows === f && x.numPointShadows === _ && x.numSpotShadows === y || (r.directional.length = h, r.spot.length = m, r.rectArea.length = p, r.point.length = u, r.hemi.length = d, r.directionalShadow.length = f, r.directionalShadowMap.length = f, r.pointShadow.length = _, r.pointShadowMap.length = _, r.spotShadow.length = y, r.spotShadowMap.length = y, r.directionalShadowMatrix.length = f, r.pointShadowMatrix.length = _, r.spotShadowMatrix.length = y, x.directionalLength = h, x.pointLength = u, x.spotLength = m, x.rectAreaLength = p, x.hemiLength = d, x.numDirectionalShadows = f, x.numPointShadows = _, x.numSpotShadows = y, r.version = yr++);
      }, setupView: function (t, e) {
        let i = 0, n = 0, l = 0, c = 0, h = 0;
        const u = e.matrixWorldInverse;
        for (let e = 0, m = t.length; e < m; e++) {
          const m = t[e];
          if (m.isDirectionalLight) {
            const t = r.directional[i];
            t.direction.setFromMatrixPosition(m.matrixWorld), o.setFromMatrixPosition(m.target.matrixWorld), t.direction.sub(o), t.direction.transformDirection(u), i++;
          } else if (m.isSpotLight) {
            const t = r.spot[l];
            t.position.setFromMatrixPosition(m.matrixWorld), t.position.applyMatrix4(u), t.direction.setFromMatrixPosition(m.matrixWorld), o.setFromMatrixPosition(m.target.matrixWorld), t.direction.sub(o), t.direction.transformDirection(u), l++;
          } else if (m.isRectAreaLight) {
            const t = r.rectArea[c];
            t.position.setFromMatrixPosition(m.matrixWorld), t.position.applyMatrix4(u), a.identity(), s.copy(m.matrixWorld), s.premultiply(u), a.extractRotation(s), t.halfWidth.set(0.5 * m.width, 0, 0), t.halfHeight.set(0, 0.5 * m.height, 0), t.halfWidth.applyMatrix4(a), t.halfHeight.applyMatrix4(a), c++;
          } else if (m.isPointLight) {
            const t = r.point[n];
            t.position.setFromMatrixPosition(m.matrixWorld), t.position.applyMatrix4(u), n++;
          } else if (m.isHemisphereLight) {
            const t = r.hemi[h];
            t.direction.setFromMatrixPosition(m.matrixWorld), t.direction.transformDirection(u), t.direction.normalize(), h++;
          }
        }
      }, state: r};
    }
    function vr(t, e) {
      const i = new xr(t, e), n = [], r = [];
      return {init: function () {
        n.length = 0, r.length = 0;
      }, state: {lightsArray: n, shadowsArray: r, lights: i}, setupLights: function (t) {
        i.setup(n, t);
      }, setupLightsView: function (t) {
        i.setupView(n, t);
      }, pushLight: function (t) {
        n.push(t);
      }, pushShadow: function (t) {
        r.push(t);
      }};
    }
    function br(t, e) {
      let i = new WeakMap;
      return {get: function (n, r = 0) {
        let o;
        return false === i.has(n) ? (o = new vr(t, e), i.set(n, [o])) : r >= i.get(n).length ? (o = new vr(t, e), i.get(n).push(o)) : o = i.get(n)[r], o;
      }, dispose: function () {
        i = new WeakMap;
      }};
    }
    class MeshDepthMaterial extends Material {
      constructor(t) {
        super(), this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = false, this.wireframeLinewidth = 1, this.fog = false, this.setValues(t);
      }
      copy(t) {
        return super.copy(t), this.depthPacking = t.depthPacking, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this;
      }
    }
    MeshDepthMaterial.prototype.isMeshDepthMaterial = true;
    class MeshDistanceMaterial extends Material {
      constructor(t) {
        super(), this.type = "MeshDistanceMaterial", this.referencePosition = new three_module_Vector3, this.nearDistance = 1, this.farDistance = 1e3, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = false, this.setValues(t);
      }
      copy(t) {
        return super.copy(t), this.referencePosition.copy(t.referencePosition), this.nearDistance = t.nearDistance, this.farDistance = t.farDistance, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this;
      }
    }
    MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;
    function wr(t, e, i) {
      let n = new Frustum;
      const r = new Vector2, o = new Vector2, s = new Vector4, a = new MeshDepthMaterial({depthPacking: 3201}), l = new MeshDistanceMaterial, c = {}, h = i.maxTextureSize, u = {0: 1, 1: 0, 2: 2}, m = new ShaderMaterial({uniforms: {shadow_pass: {value: null}, resolution: {value: new Vector2}, radius: {value: 4}, samples: {value: 8}}, vertexShader: "void main() {\n	gl_Position = vec4( position, 1.0 );\n}", fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\nuniform float samples;\n#include <packing>\nvoid main() {\n	float mean = 0.0;\n	float squared_mean = 0.0;\n	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n	for ( float i = 0.0; i < samples; i ++ ) {\n		float uvOffset = uvStart + i * uvStride;\n		#ifdef HORIZONTAL_PASS\n			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n			mean += distribution.x;\n			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n		#else\n			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n			mean += depth;\n			squared_mean += depth * depth;\n		#endif\n	}\n	mean = mean / samples;\n	squared_mean = squared_mean / samples;\n	float std_dev = sqrt( squared_mean - mean * mean );\n	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"}), p = m.clone();
      p.defines.HORIZONTAL_PASS = 1;
      const d = new BufferGeometry;
      d.setAttribute("position", new BufferAttribute(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
      const _ = new Mesh(d, m), y = this;
      function x(i, n) {
        const r = e.update(_);
        m.uniforms.shadow_pass.value = i.map.texture, m.uniforms.resolution.value = i.mapSize, m.uniforms.radius.value = i.radius, m.uniforms.samples.value = i.blurSamples, t.setRenderTarget(i.mapPass), t.clear(), t.renderBufferDirect(n, null, r, m, _, null), p.uniforms.shadow_pass.value = i.mapPass.texture, p.uniforms.resolution.value = i.mapSize, p.uniforms.radius.value = i.radius, p.uniforms.samples.value = i.blurSamples, t.setRenderTarget(i.map), t.clear(), t.renderBufferDirect(n, null, r, p, _, null);
      }
      function v(e, i, n, r, o, s, h) {
        let m = null;
        const p = true === r.isPointLight ? e.customDistanceMaterial : e.customDepthMaterial;
        if (m = void 0 !== p ? p : true === r.isPointLight ? l : a, t.localClippingEnabled && true === n.clipShadows && 0 !== n.clippingPlanes.length || n.displacementMap && 0 !== n.displacementScale || n.alphaMap && n.alphaTest > 0) {
          const t = m.uuid, e = n.uuid;
          let i = c[t];
          void 0 === i && (i = {}, c[t] = i);
          let r = i[e];
          void 0 === r && (r = m.clone(), i[e] = r), m = r;
        }
        return m.visible = n.visible, m.wireframe = n.wireframe, m.side = 3 === h ? null !== n.shadowSide ? n.shadowSide : n.side : null !== n.shadowSide ? n.shadowSide : u[n.side], m.alphaMap = n.alphaMap, m.alphaTest = n.alphaTest, m.clipShadows = n.clipShadows, m.clippingPlanes = n.clippingPlanes, m.clipIntersection = n.clipIntersection, m.displacementMap = n.displacementMap, m.displacementScale = n.displacementScale, m.displacementBias = n.displacementBias, m.wireframeLinewidth = n.wireframeLinewidth, m.linewidth = n.linewidth, true === r.isPointLight && true === m.isMeshDistanceMaterial && (m.referencePosition.setFromMatrixPosition(r.matrixWorld), m.nearDistance = o, m.farDistance = s), m;
      }
      function b(i, r, o, s, a) {
        if (false === i.visible) return;
        if (i.layers.test(r.layers) && (i.isMesh || i.isLine || i.isPoints) && (i.castShadow || i.receiveShadow && 3 === a) && (!i.frustumCulled || n.intersectsObject(i))) {
          i.modelViewMatrix.multiplyMatrices(o.matrixWorldInverse, i.matrixWorld);
          const n = e.update(i), r = i.material;
          if (Array.isArray(r)) {
            const e = n.groups;
            for (let l = 0, c = e.length; l < c; l++) {
              const c = e[l], h = r[c.materialIndex];
              if (h && h.visible) {
                const e = v(i, 0, h, s, o.near, o.far, a);
                t.renderBufferDirect(o, null, n, e, i, c);
              }
            }
          } else if (r.visible) {
            const e = v(i, 0, r, s, o.near, o.far, a);
            t.renderBufferDirect(o, null, n, e, i, null);
          }
        }
        const l = i.children;
        for (let t = 0, e = l.length; t < e; t++) b(l[t], r, o, s, a);
      }
      this.enabled = false, this.autoUpdate = true, this.needsUpdate = false, this.type = 1, this.render = function (e, i, a) {
        if (false === y.enabled) return;
        if (false === y.autoUpdate && false === y.needsUpdate) return;
        if (0 === e.length) return;
        const l = t.getRenderTarget(), c = t.getActiveCubeFace(), u = t.getActiveMipmapLevel(), m = t.state;
        m.setBlending(0), m.buffers.color.setClear(1, 1, 1, 1), m.buffers.depth.setTest(true), m.setScissorTest(false);
        for (let l = 0, c = e.length; l < c; l++) {
          const c = e[l], u = c.shadow;
          if (void 0 === u) {
            console.warn("THREE.WebGLShadowMap:", c, "has no shadow.");
            continue;
          }
          if (false === u.autoUpdate && false === u.needsUpdate) continue;
          r.copy(u.mapSize);
          const p = u.getFrameExtents();
          if (r.multiply(p), o.copy(u.mapSize), (r.x > h || r.y > h) && (r.x > h && (o.x = Math.floor(h / p.x), r.x = o.x * p.x, u.mapSize.x = o.x), r.y > h && (o.y = Math.floor(h / p.y), r.y = o.y * p.y, u.mapSize.y = o.y)), null === u.map && !u.isPointLightShadow && 3 === this.type) {
            const t = {minFilter: g, magFilter: g, format: T};
            u.map = new WebGLRenderTarget(r.x, r.y, t), u.map.texture.name = c.name + ".shadowMap", u.mapPass = new WebGLRenderTarget(r.x, r.y, t), u.camera.updateProjectionMatrix();
          }
          if (null === u.map) {
            const t = {minFilter: f, magFilter: f, format: T};
            u.map = new WebGLRenderTarget(r.x, r.y, t), u.map.texture.name = c.name + ".shadowMap", u.camera.updateProjectionMatrix();
          }
          t.setRenderTarget(u.map), t.clear();
          const d = u.getViewportCount();
          for (let t = 0; t < d; t++) {
            const e = u.getViewport(t);
            s.set(o.x * e.x, o.y * e.y, o.x * e.z, o.y * e.w), m.viewport(s), u.updateMatrices(c, t), n = u.getFrustum(), b(i, a, u.camera, c, this.type);
          }
          u.isPointLightShadow || 3 !== this.type || x(u, a), u.needsUpdate = false;
        }
        y.needsUpdate = false, t.setRenderTarget(l, c, u);
      };
    }
    function Sr(t, e, i) {
      const n = i.isWebGL2;
      const r = new function () {
        let e = false;
        const i = new Vector4;
        let n = null;
        const r = new Vector4(0, 0, 0, 0);
        return {setMask: function (i) {
          n === i || e || (t.colorMask(i, i, i, i), n = i);
        }, setLocked: function (t) {
          e = t;
        }, setClear: function (e, n, o, s, a) {
          true === a && (e *= s, n *= s, o *= s), i.set(e, n, o, s), false === r.equals(i) && (t.clearColor(e, n, o, s), r.copy(i));
        }, reset: function () {
          e = false, n = null, r.set(-1, 0, 0, 0);
        }};
      }, s = new function () {
        let e = false, i = null, n = null, r = null;
        return {setTest: function (t) {
          t ? N(2929) : z(2929);
        }, setMask: function (n) {
          i === n || e || (t.depthMask(n), i = n);
        }, setFunc: function (e) {
          if (n !== e) {
            if (e) switch (e) {
              case 0:
                t.depthFunc(512);
                break;
              case 1:
                t.depthFunc(519);
                break;
              case 2:
                t.depthFunc(513);
                break;
              case 3:
                t.depthFunc(515);
                break;
              case 4:
                t.depthFunc(514);
                break;
              case 5:
                t.depthFunc(518);
                break;
              case 6:
                t.depthFunc(516);
                break;
              case 7:
                t.depthFunc(517);
                break;
              default:
                t.depthFunc(515);
            } else t.depthFunc(515);
            n = e;
          }
        }, setLocked: function (t) {
          e = t;
        }, setClear: function (e) {
          r !== e && (t.clearDepth(e), r = e);
        }, reset: function () {
          e = false, i = null, n = null, r = null;
        }};
      }, a = new function () {
        let e = false, i = null, n = null, r = null, o = null, s = null, a = null, l = null, c = null;
        return {setTest: function (t) {
          e || (t ? N(2960) : z(2960));
        }, setMask: function (n) {
          i === n || e || (t.stencilMask(n), i = n);
        }, setFunc: function (e, i, s) {
          n === e && r === i && o === s || (t.stencilFunc(e, i, s), n = e, r = i, o = s);
        }, setOp: function (e, i, n) {
          s === e && a === i && l === n || (t.stencilOp(e, i, n), s = e, a = i, l = n);
        }, setLocked: function (t) {
          e = t;
        }, setClear: function (e) {
          c !== e && (t.clearStencil(e), c = e);
        }, reset: function () {
          e = false, i = null, n = null, r = null, o = null, s = null, a = null, l = null, c = null;
        }};
      };
      let l = {}, c = null, h = {}, u = null, m = false, p = null, d = null, f = null, _ = null, y = null, g = null, x = null, v = false, b = null, w = null, S = null, M = null, C = null;
      const A = t.getParameter(35661);
      let T = false, E = 0;
      const L = t.getParameter(7938);
      -1 !== L.indexOf("WebGL") ? (E = parseFloat(/^WebGL (\d)/.exec(L)[1]), T = E >= 1) : -1 !== L.indexOf("OpenGL ES") && (E = parseFloat(/^OpenGL ES (\d)/.exec(L)[1]), T = E >= 2);
      let D = null, V = {};
      const B = t.getParameter(3088), R = t.getParameter(2978), P = (new Vector4).fromArray(B), I = (new Vector4).fromArray(R);
      function F(e, i, n) {
        const r = new Uint8Array(4), o = t.createTexture();
        t.bindTexture(e, o), t.texParameteri(e, 10241, 9728), t.texParameteri(e, 10240, 9728);
        for (let e = 0; e < n; e++) t.texImage2D(i + e, 0, 6408, 1, 1, 0, 6408, 5121, r);
        return o;
      }
      const G = {};
      function N(e) {
        true !== l[e] && (t.enable(e), l[e] = true);
      }
      function z(e) {
        false !== l[e] && (t.disable(e), l[e] = false);
      }
      G[3553] = F(3553, 3553, 1), G[34067] = F(34067, 34069, 6), r.setClear(0, 0, 0, 1), s.setClear(1), a.setClear(0), N(2929), s.setFunc(3), H(false), W(1), N(2884), k(0);
      const O = {[o]: 32774, 101: 32778, 102: 32779};
      if (n) O[103] = 32775, O[104] = 32776; else {
        const t = e.get("EXT_blend_minmax");
        null !== t && (O[103] = t.MIN_EXT, O[104] = t.MAX_EXT);
      }
      const U = {200: 0, 201: 1, 202: 768, 204: 770, 210: 776, 208: 774, 206: 772, 203: 769, 205: 771, 209: 775, 207: 773};
      function k(e, i, n, r, s, a, l, c) {
        if (0 !== e) {
          if (false === m && (N(3042), m = true), 5 === e) s = s || i, a = a || n, l = l || r, i === d && s === y || (t.blendEquationSeparate(O[i], O[s]), d = i, y = s), n === f && r === _ && a === g && l === x || (t.blendFuncSeparate(U[n], U[r], U[a], U[l]), f = n, _ = r, g = a, x = l), p = e, v = null; else if (e !== p || c !== v) {
            if (d === o && y === o || (t.blendEquation(32774), d = o, y = o), c) switch (e) {
              case 1:
                t.blendFuncSeparate(1, 771, 1, 771);
                break;
              case 2:
                t.blendFunc(1, 1);
                break;
              case 3:
                t.blendFuncSeparate(0, 0, 769, 771);
                break;
              case 4:
                t.blendFuncSeparate(0, 768, 0, 770);
                break;
              default:
                console.error("THREE.WebGLState: Invalid blending: ", e);
            } else switch (e) {
              case 1:
                t.blendFuncSeparate(770, 771, 1, 771);
                break;
              case 2:
                t.blendFunc(770, 1);
                break;
              case 3:
                t.blendFunc(0, 769);
                break;
              case 4:
                t.blendFunc(0, 768);
                break;
              default:
                console.error("THREE.WebGLState: Invalid blending: ", e);
            }
            f = null, _ = null, g = null, x = null, p = e, v = c;
          }
        } else true === m && (z(3042), m = false);
      }
      function H(e) {
        b !== e && (e ? t.frontFace(2304) : t.frontFace(2305), b = e);
      }
      function W(e) {
        0 !== e ? (N(2884), e !== w && (1 === e ? t.cullFace(1029) : 2 === e ? t.cullFace(1028) : t.cullFace(1032))) : z(2884), w = e;
      }
      function J(e, i, n) {
        e ? (N(32823), M === i && C === n || (t.polygonOffset(i, n), M = i, C = n)) : z(32823);
      }
      function j(e) {
        void 0 === e && (e = 33984 + A - 1), D !== e && (t.activeTexture(e), D = e);
      }
      return {buffers: {color: r, depth: s, stencil: a}, enable: N, disable: z, bindFramebuffer: function (e, i) {
        return null === i && null !== c && (i = c), h[e] !== i && (t.bindFramebuffer(e, i), h[e] = i, n && (36009 === e && (h[36160] = i), 36160 === e && (h[36009] = i)), true);
      }, bindXRFramebuffer: function (e) {
        e !== c && (t.bindFramebuffer(36160, e), c = e);
      }, useProgram: function (e) {
        return u !== e && (t.useProgram(e), u = e, true);
      }, setBlending: k, setMaterial: function (t, e) {
        2 === t.side ? z(2884) : N(2884);
        let i = 1 === t.side;
        e && (i = !i), H(i), 1 === t.blending && false === t.transparent ? k(0) : k(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.premultipliedAlpha), s.setFunc(t.depthFunc), s.setTest(t.depthTest), s.setMask(t.depthWrite), r.setMask(t.colorWrite);
        const n = t.stencilWrite;
        a.setTest(n), n && (a.setMask(t.stencilWriteMask), a.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask), a.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)), J(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits), true === t.alphaToCoverage ? N(32926) : z(32926);
      }, setFlipSided: H, setCullFace: W, setLineWidth: function (e) {
        e !== S && (T && t.lineWidth(e), S = e);
      }, setPolygonOffset: J, setScissorTest: function (t) {
        t ? N(3089) : z(3089);
      }, activeTexture: j, bindTexture: function (e, i) {
        null === D && j();
        let n = V[D];
        void 0 === n && (n = {type: void 0, texture: void 0}, V[D] = n), n.type === e && n.texture === i || (t.bindTexture(e, i || G[e]), n.type = e, n.texture = i);
      }, unbindTexture: function () {
        const e = V[D];
        void 0 !== e && void 0 !== e.type && (t.bindTexture(e.type, null), e.type = void 0, e.texture = void 0);
      }, compressedTexImage2D: function () {
        try {
          t.compressedTexImage2D.apply(t, arguments);
        } catch (t) {
          console.error("THREE.WebGLState:", t);
        }
      }, texImage2D: function () {
        try {
          t.texImage2D.apply(t, arguments);
        } catch (t) {
          console.error("THREE.WebGLState:", t);
        }
      }, texImage3D: function () {
        try {
          t.texImage3D.apply(t, arguments);
        } catch (t) {
          console.error("THREE.WebGLState:", t);
        }
      }, scissor: function (e) {
        false === P.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), P.copy(e));
      }, viewport: function (e) {
        false === I.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), I.copy(e));
      }, reset: function () {
        t.disable(3042), t.disable(2884), t.disable(2929), t.disable(32823), t.disable(3089), t.disable(2960), t.disable(32926), t.blendEquation(32774), t.blendFunc(1, 0), t.blendFuncSeparate(1, 0, 1, 0), t.colorMask(true, true, true, true), t.clearColor(0, 0, 0, 0), t.depthMask(true), t.depthFunc(513), t.clearDepth(1), t.stencilMask(4294967295), t.stencilFunc(519, 0, 4294967295), t.stencilOp(7680, 7680, 7680), t.clearStencil(0), t.cullFace(1029), t.frontFace(2305), t.polygonOffset(0, 0), t.activeTexture(33984), t.bindFramebuffer(36160, null), true === n && (t.bindFramebuffer(36009, null), t.bindFramebuffer(36008, null)), t.useProgram(null), t.lineWidth(1), t.scissor(0, 0, t.canvas.width, t.canvas.height), t.viewport(0, 0, t.canvas.width, t.canvas.height), l = {}, D = null, V = {}, c = null, h = {}, u = null, m = false, p = null, d = null, f = null, _ = null, y = null, g = null, x = null, v = false, b = null, w = null, S = null, M = null, C = null, P.set(0, 0, t.canvas.width, t.canvas.height), I.set(0, 0, t.canvas.width, t.canvas.height), r.reset(), s.reset(), a.reset();
      }};
    }
    function Mr(t, e, i, n, r, o, s) {
      const a = r.isWebGL2, l = r.maxTextures, c = r.maxCubemapSize, h = r.maxTextureSize, u = r.maxSamples, v = new WeakMap;
      let D, V = false;
      try {
        V = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d");
      } catch (t) {}
      function B(t, e) {
        return V ? new OffscreenCanvas(t, e) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
      }
      function R(t, e, i, n) {
        let r = 1;
        if ((t.width > n || t.height > n) && (r = n / Math.max(t.width, t.height)), r < 1 || true === e) {
          if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap) {
            const n = e ? $ : Math.floor, o = "__private_" + e++ + "_" + r * t.width, s = "__private_" + e++ + "_" + r * t.height;
            void 0 === D && (D = B(o, s));
            const a = i ? B(o, s) : D;
            a.width = o, a.height = s;
            return a.getContext("2d").drawImage(t, 0, 0, o, s), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + t.width + "x" + t.height + ") to (" + o + "x" + s + ")."), a;
          }
          return "data" in t && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + t.width + "x" + t.height + ")."), t;
        }
        return t;
      }
      function F(e, i, r, o, s = 1) {
        t.generateMipmap(e);
        n.get(i).__maxMipLevel = Math.log2(Math.max(r, o, s));
      }
      function G(i, n, r) {
        if (false === a) return n;
        if (null !== i) {
          if (void 0 !== t[i]) return t[i];
          console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + i + "'");
        }
        return 6403 === n && (5126 === r && (o = 33326), 5131 === r && (o = 33325), 5121 === r && (o = 33321)), 6407 === n && (5126 === r && (o = 34837), 5131 === r && (o = 34843), 5121 === r && (o = 32849)), 6408 === n && (5126 === r && (o = 34836), 5131 === r && (o = 34842), 5121 === r && (o = 32856)), 33325 !== o && 33326 !== o && 34842 !== o && 34836 !== o || e.get("EXT_color_buffer_float"), o;
      }
      function N(t) {
        return t === f || t === _ || t === y ? 9728 : 9729;
      }
      function z(e) {
        const i = e.target;
        i.removeEventListener("dispose", z), function (e) {
          const i = n.get(e);
          if (void 0 === i.__webglInit) return;
          t.deleteTexture(i.__webglTexture), n.remove(e);
        }(i), i.isVideoTexture && v.delete(i), s.memory.textures--;
      }
      function O(e) {
        const i = e.target;
        i.removeEventListener("dispose", O), function (e) {
          const i = e.texture, r = n.get(e), o = n.get(i);
          if (!e) return;
          void 0 !== o.__webglTexture && (t.deleteTexture(o.__webglTexture), s.memory.textures--);
          e.depthTexture && e.depthTexture.dispose();
          if (e.isWebGLCubeRenderTarget) for (let e = 0; e < 6; e++) t.deleteFramebuffer(r.__webglFramebuffer[e]), r.__webglDepthbuffer && t.deleteRenderbuffer(r.__webglDepthbuffer[e]); else t.deleteFramebuffer(r.__webglFramebuffer), r.__webglDepthbuffer && t.deleteRenderbuffer(r.__webglDepthbuffer), r.__webglMultisampledFramebuffer && t.deleteFramebuffer(r.__webglMultisampledFramebuffer), r.__webglColorRenderbuffer && t.deleteRenderbuffer(r.__webglColorRenderbuffer), r.__webglDepthRenderbuffer && t.deleteRenderbuffer(r.__webglDepthRenderbuffer);
          if (e.isWebGLMultipleRenderTargets) for (let e = 0, r = i.length; e < r; e++) {
            const r = n.get(i[e]);
            r.__webglTexture && (t.deleteTexture(r.__webglTexture), s.memory.textures--), n.remove(i[e]);
          }
          n.remove(i), n.remove(e);
        }(i);
      }
      let U = 0;
      function k(t, e) {
        const r = n.get(t);
        if (t.isVideoTexture && function (t) {
          const e = s.render.frame;
          v.get(t) !== e && (v.set(t, e), t.update());
        }(t), t.version > 0 && r.__version !== t.version) {
          const i = t.image;
          if (void 0 === i) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined"); else {
            if (false !== i.complete) return void q(r, t, e);
            console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
          }
        }
        i.activeTexture(33984 + e), i.bindTexture(3553, r.__webglTexture);
      }
      function H(e, r) {
        const s = n.get(e);
        e.version > 0 && s.__version !== e.version ? function (e, n, r) {
          if (6 !== n.image.length) return;
          X(e, n), i.activeTexture(33984 + r), i.bindTexture(34067, e.__webglTexture), t.pixelStorei(37440, n.flipY), t.pixelStorei(37441, n.premultiplyAlpha), t.pixelStorei(3317, n.unpackAlignment), t.pixelStorei(37443, 0);
          const s = n && (n.isCompressedTexture || n.image[0].isCompressedTexture), l = n.image[0] && n.image[0].isDataTexture, h = [];
          for (let t = 0; t < 6; t++) h[t] = s || l ? l ? n.image[t].image : n.image[t] : R(n.image[t], false, true, c);
          const u = h[0], m = 0 == (u.width & u.width - 1) && 0 !== u.width && (0 == (u.height & u.height - 1) && 0 !== u.height) || a, p = o.convert(n.format), d = o.convert(n.type), f = G(n.internalFormat, p, d);
          let _;
          if (j(34067, n, m), s) {
            for (let t = 0; t < 6; t++) {
              _ = h[t].mipmaps;
              for (let e = 0; e < _.length; e++) {
                const r = _[e];
                n.format !== T && n.format !== A ? null !== p ? i.compressedTexImage2D(34069 + t, e, f, r.width, r.height, 0, r.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : i.texImage2D(34069 + t, e, f, r.width, r.height, 0, p, d, r.data);
              }
            }
            e.__maxMipLevel = _.length - 1;
          } else {
            _ = n.mipmaps;
            for (let t = 0; t < 6; t++) if (l) {
              i.texImage2D(34069 + t, 0, f, h[t].width, h[t].height, 0, p, d, h[t].data);
              for (let e = 0; e < _.length; e++) {
                const n = _[e].image[t].image;
                i.texImage2D(34069 + t, e + 1, f, n.width, n.height, 0, p, d, n.data);
              }
            } else {
              i.texImage2D(34069 + t, 0, f, p, d, h[t]);
              for (let e = 0; e < _.length; e++) {
                const n = _[e];
                i.texImage2D(34069 + t, e + 1, f, p, d, n.image[t]);
              }
            }
            e.__maxMipLevel = _.length;
          }
          n.generateMipmaps && m && n.minFilter !== f && n.minFilter !== g && F(34067, n, u.width, u.height);
          e.__version = n.version, n.onUpdate && n.onUpdate(n);
        }(s, e, r) : (i.activeTexture(33984 + r), i.bindTexture(34067, s.__webglTexture));
      }
      const W = {[m]: 10497, [p]: 33071, [d]: 33648}, J = {[f]: 9728, [_]: 9984, [y]: 9986, [g]: 9729, 1007: 9985, [x]: 9987};
      function j(i, o, s) {
        if (s ? (t.texParameteri(i, 10242, W[o.wrapS]), t.texParameteri(i, 10243, W[o.wrapT]), 32879 !== i && 35866 !== i || t.texParameteri(i, 32882, W[o.wrapR]), t.texParameteri(i, 10240, J[o.magFilter]), t.texParameteri(i, 10241, J[o.minFilter])) : (t.texParameteri(i, 10242, 33071), t.texParameteri(i, 10243, 33071), 32879 !== i && 35866 !== i || t.texParameteri(i, 32882, 33071), o.wrapS === p && o.wrapT === p || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), t.texParameteri(i, 10240, N(o.magFilter)), t.texParameteri(i, 10241, N(o.minFilter)), o.minFilter !== f && o.minFilter !== g && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), true === e.has("EXT_texture_filter_anisotropic")) {
          const s = e.get("EXT_texture_filter_anisotropic");
          if (o.type === S && false === e.has("OES_texture_float_linear")) return;
          if (false === a && o.type === M && false === e.has("OES_texture_half_float_linear")) return;
          (o.anisotropy > 1 || n.get(o).__currentAnisotropy) && (t.texParameterf(i, s.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(o.anisotropy, r.getMaxAnisotropy())), n.get(o).__currentAnisotropy = o.anisotropy);
        }
      }
      function X(e, i) {
        void 0 === e.__webglInit && (e.__webglInit = true, i.addEventListener("dispose", z), e.__webglTexture = t.createTexture(), s.memory.textures++);
      }
      function q(e, n, r) {
        let s = 3553;
        n.isDataTexture2DArray && (s = 35866), n.isDataTexture3D && (s = 32879), X(e, n), i.activeTexture(33984 + r), i.bindTexture(s, e.__webglTexture), t.pixelStorei(37440, n.flipY), t.pixelStorei(37441, n.premultiplyAlpha), t.pixelStorei(3317, n.unpackAlignment), t.pixelStorei(37443, 0);
        const l = function (t) {
          return !a && (t.wrapS !== p || t.wrapT !== p || t.minFilter !== f && t.minFilter !== g);
        }(n) && false === (0 == (n.image.width & n.image.width - 1) && 0 !== n.image.width && (0 == (n.image.height & n.image.height - 1) && 0 !== n.image.height)), c = R(n.image, l, false, h), u = 0 == (c.width & c.width - 1) && 0 !== c.width && (0 == (c.height & c.height - 1) && 0 !== c.height) || a, m = o.convert(n.format);
        let d, _ = o.convert(n.type), y = G(n.internalFormat, m, _);
        j(s, n, u);
        const x = n.mipmaps;
        if (n.isDepthTexture) y = 6402, a ? y = n.type === S ? 36012 : n.type === w ? 33190 : n.type === C ? 35056 : 33189 : n.type === S && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), n.format === E && 6402 === y && n.type !== b && n.type !== w && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), n.type = b, _ = o.convert(n.type)), n.format === L && 6402 === y && (y = 34041, n.type !== C && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), n.type = C, _ = o.convert(n.type))), i.texImage2D(3553, 0, y, c.width, c.height, 0, m, _, null); else if (n.isDataTexture) if (x.length > 0 && u) {
          for (let t = 0, e = x.length; t < e; t++) d = x[t], i.texImage2D(3553, t, y, d.width, d.height, 0, m, _, d.data);
          n.generateMipmaps = false, e.__maxMipLevel = x.length - 1;
        } else i.texImage2D(3553, 0, y, c.width, c.height, 0, m, _, c.data), e.__maxMipLevel = 0; else if (n.isCompressedTexture) {
          for (let t = 0, e = x.length; t < e; t++) d = x[t], n.format !== T && n.format !== A ? null !== m ? i.compressedTexImage2D(3553, t, y, d.width, d.height, 0, d.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : i.texImage2D(3553, t, y, d.width, d.height, 0, m, _, d.data);
          e.__maxMipLevel = x.length - 1;
        } else if (n.isDataTexture2DArray) i.texImage3D(35866, 0, y, c.width, c.height, c.depth, 0, m, _, c.data), e.__maxMipLevel = 0; else if (n.isDataTexture3D) i.texImage3D(32879, 0, y, c.width, c.height, c.depth, 0, m, _, c.data), e.__maxMipLevel = 0; else if (x.length > 0 && u) {
          for (let t = 0, e = x.length; t < e; t++) d = x[t], i.texImage2D(3553, t, y, m, _, d);
          n.generateMipmaps = false, e.__maxMipLevel = x.length - 1;
        } else i.texImage2D(3553, 0, y, m, _, c), e.__maxMipLevel = 0;
        n.generateMipmaps && u && n.minFilter !== f && n.minFilter !== g && F(s, n, c.width, c.height), e.__version = n.version, n.onUpdate && n.onUpdate(n);
      }
      function Y(e, r, s, a, l) {
        const c = o.convert(s.format), h = o.convert(s.type), u = G(s.internalFormat, c, h);
        32879 === l || 35866 === l ? i.texImage3D(l, 0, u, r.width, r.height, r.depth, 0, c, h, null) : i.texImage2D(l, 0, u, r.width, r.height, 0, c, h, null), i.bindFramebuffer(36160, e), t.framebufferTexture2D(36160, a, l, n.get(s).__webglTexture, 0), i.bindFramebuffer(36160, null);
      }
      function Z(e, i, n) {
        if (t.bindRenderbuffer(36161, e), i.depthBuffer && !i.stencilBuffer) {
          let r = 33189;
          if (n) {
            const e = i.depthTexture;
            e && e.isDepthTexture && (e.type === S ? r = 36012 : e.type === w && (r = 33190));
            const n = tt(i);
            t.renderbufferStorageMultisample(36161, n, r, i.width, i.height);
          } else t.renderbufferStorage(36161, r, i.width, i.height);
          t.framebufferRenderbuffer(36160, 36096, 36161, e);
        } else if (i.depthBuffer && i.stencilBuffer) {
          if (n) {
            const e = tt(i);
            t.renderbufferStorageMultisample(36161, e, 35056, i.width, i.height);
          } else t.renderbufferStorage(36161, 34041, i.width, i.height);
          t.framebufferRenderbuffer(36160, 33306, 36161, e);
        } else {
          const e = true === i.isWebGLMultipleRenderTargets ? i.texture[0] : i.texture, r = o.convert(e.format), s = o.convert(e.type), a = G(e.internalFormat, r, s);
          if (n) {
            const e = tt(i);
            t.renderbufferStorageMultisample(36161, e, a, i.width, i.height);
          } else t.renderbufferStorage(36161, a, i.width, i.height);
        }
        t.bindRenderbuffer(36161, null);
      }
      function K(e) {
        const r = n.get(e), o = true === e.isWebGLCubeRenderTarget;
        if (e.depthTexture) {
          if (o) throw new Error("target.depthTexture not supported in Cube render targets");
          !function (e, r) {
            if (r && r.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
            if (i.bindFramebuffer(36160, e), !r.depthTexture || !r.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
            n.get(r.depthTexture).__webglTexture && r.depthTexture.image.width === r.width && r.depthTexture.image.height === r.height || (r.depthTexture.image.width = r.width, r.depthTexture.image.height = r.height, r.depthTexture.needsUpdate = true), k(r.depthTexture, 0);
            const o = n.get(r.depthTexture).__webglTexture;
            if (r.depthTexture.format === E) t.framebufferTexture2D(36160, 36096, 3553, o, 0); else {
              if (r.depthTexture.format !== L) throw new Error("Unknown depthTexture format");
              t.framebufferTexture2D(36160, 33306, 3553, o, 0);
            }
          }(r.__webglFramebuffer, e);
        } else if (o) {
          r.__webglDepthbuffer = [];
          for (let n = 0; n < 6; n++) i.bindFramebuffer(36160, r.__webglFramebuffer[n]), r.__webglDepthbuffer[n] = t.createRenderbuffer(), (r.__webglDepthbuffer[n] % e + e) % e;
        } else i.bindFramebuffer(36160, r.__webglFramebuffer), r.__webglDepthbuffer = t.createRenderbuffer(), (r.__webglDepthbuffer % e + e) % e;
        i.bindFramebuffer(36160, null);
      }
      function tt(t) {
        return a && t.isWebGLMultisampleRenderTarget ? Math.min(u, t.samples) : 0;
      }
      let et = false, it = false;
      this.allocateTextureUnit = function () {
        const t = U;
        return t >= l && console.warn("THREE.WebGLTextures: Trying to use " + t + " texture units while this GPU supports only " + l), U += 1, t;
      }, this.resetTextureUnits = function () {
        U = 0;
      }, this.setTexture2D = k, this.setTexture2DArray = function (t, e) {
        const r = n.get(t);
        t.version > 0 && r.__version !== t.version ? q(r, t, e) : (i.activeTexture(33984 + e), i.bindTexture(35866, r.__webglTexture));
      }, this.setTexture3D = function (t, e) {
        const r = n.get(t);
        t.version > 0 && r.__version !== t.version ? q(r, t, e) : (i.activeTexture(33984 + e), i.bindTexture(32879, r.__webglTexture));
      }, this.setTextureCube = H, this.setupRenderTarget = function (e) {
        const l = e.texture, c = n.get(e), h = n.get(l);
        e.addEventListener("dispose", O), true !== e.isWebGLMultipleRenderTargets && (h.__webglTexture = t.createTexture(), h.__version = l.version, s.memory.textures++);
        const u = true === e.isWebGLCubeRenderTarget, m = true === e.isWebGLMultipleRenderTargets, p = true === e.isWebGLMultisampleRenderTarget, d = l.isDataTexture3D || l.isDataTexture2DArray, f = 0 == (e.width & e.width - 1) && 0 !== e.width && (0 == (e.height & e.height - 1) && 0 !== e.height) || a;
        if (!a || l.format !== A || l.type !== S && l.type !== M || (l.format = T, console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")), u) {
          c.__webglFramebuffer = [];
          for (let e = 0; e < 6; e++) c.__webglFramebuffer[e] = t.createFramebuffer();
        } else if (c.__webglFramebuffer = t.createFramebuffer(), m) if (r.drawBuffers) {
          const i = e.texture;
          for (let e = 0, r = i.length; e < r; e++) {
            const r = n.get(i[e]);
            void 0 === r.__webglTexture && (r.__webglTexture = t.createTexture(), s.memory.textures++);
          }
        } else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension."); else if (p) if (a) {
          c.__webglMultisampledFramebuffer = t.createFramebuffer(), c.__webglColorRenderbuffer = t.createRenderbuffer(), t.bindRenderbuffer(36161, c.__webglColorRenderbuffer);
          const n = o.convert(l.format), r = o.convert(l.type), s = G(l.internalFormat, n, r), a = tt(e);
          t.renderbufferStorageMultisample(36161, a, s, e.width, e.height), i.bindFramebuffer(36160, c.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(36160, 36064, 36161, c.__webglColorRenderbuffer), t.bindRenderbuffer(36161, null), e.depthBuffer && (c.__webglDepthRenderbuffer = t.createRenderbuffer(), (c.__webglDepthRenderbuffer % e + e) % e), i.bindFramebuffer(36160, null);
        } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
        if (u) {
          i.bindTexture(34067, h.__webglTexture), j(34067, l, f);
          for (let t = 0; t < 6; t++) Math.max(e, Math.min(l, c.__webglFramebuffer[t]));
          l.generateMipmaps && f && l.minFilter !== f && l.minFilter !== g && F(34067, l, e.width, e.height), i.unbindTexture();
        } else if (m) {
          const t = e.texture;
          for (let r = 0, o = t.length; r < o; r++) {
            const o = t[r], s = n.get(o);
            i.bindTexture(3553, s.__webglTexture), j(3553, o, f), Math.max(e, Math.min(o, c.__webglFramebuffer)), o.generateMipmaps && f && o.minFilter !== f && o.minFilter !== g && F(3553, o, e.width, e.height);
          }
          i.unbindTexture();
        } else {
          let t = 3553;
          if (d) if (a) {
            t = l.isDataTexture3D ? 32879 : 35866;
          } else console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.");
          i.bindTexture(t, h.__webglTexture), j(t, l, f), Math.max(e, Math.min(l, c.__webglFramebuffer)), l.generateMipmaps && f && l.minFilter !== f && l.minFilter !== g && F(t, l, e.width, e.height, e.depth), i.unbindTexture();
        }
        e.depthBuffer && (1 - i) * e + i * e;
      }, this.updateRenderTargetMipmap = function (t) {
        const e = 0 == (t.width & t.width - 1) && 0 !== t.width && (0 == (t.height & t.height - 1) && 0 !== t.height) || a, r = true === t.isWebGLMultipleRenderTargets ? t.texture : [t.texture];
        for (let o = 0, s = r.length; o < s; o++) {
          const s = r[o];
          if (s.generateMipmaps && e && s.minFilter !== f && s.minFilter !== g) {
            const e = t.isWebGLCubeRenderTarget ? 34067 : 3553, r = n.get(s).__webglTexture;
            i.bindTexture(e, r), F(e, s, t.width, t.height), i.unbindTexture();
          }
        }
      }, this.updateMultisampleRenderTarget = function (e) {
        if (e.isWebGLMultisampleRenderTarget) if (a) {
          const r = e.width, o = e.height;
          let s = 16384;
          e.depthBuffer && (s |= 256), e.stencilBuffer && (s |= 1024);
          const a = n.get(e);
          i.bindFramebuffer(36008, a.__webglMultisampledFramebuffer), i.bindFramebuffer(36009, a.__webglFramebuffer), t.blitFramebuffer(0, 0, r, o, 0, 0, r, o, s, 9728), i.bindFramebuffer(36008, null), i.bindFramebuffer(36009, a.__webglMultisampledFramebuffer);
        } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
      }, this.safeSetTexture2D = function (t, e) {
        t && t.isWebGLRenderTarget && (false === et && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), et = true), t = t.texture), k(t, e);
      }, this.safeSetTextureCube = function (t, e) {
        t && t.isWebGLCubeRenderTarget && (false === it && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), it = true), t = t.texture), H(t, e);
      };
    }
    function Cr(t, e, i) {
      const n = i.isWebGL2;
      return {convert: function (t) {
        let i;
        if (t === v) return 5121;
        if (1017 === t) return 32819;
        if (1018 === t) return 32820;
        if (1019 === t) return 33635;
        if (1010 === t) return 5120;
        if (1011 === t) return 5122;
        if (t === b) return 5123;
        if (1013 === t) return 5124;
        if (t === w) return 5125;
        if (t === S) return 5126;
        if (t === M) return n ? 5131 : (i = e.get("OES_texture_half_float"), null !== i ? i.HALF_FLOAT_OES : null);
        if (1021 === t) return 6406;
        if (t === A) return 6407;
        if (t === T) return 6408;
        if (1024 === t) return 6409;
        if (1025 === t) return 6410;
        if (t === E) return 6402;
        if (t === L) return 34041;
        if (1028 === t) return 6403;
        if (1029 === t) return 36244;
        if (1030 === t) return 33319;
        if (1031 === t) return 33320;
        if (1032 === t) return 36248;
        if (1033 === t) return 36249;
        if (33776 === t || 33777 === t || 33778 === t || 33779 === t) {
          if (i = e.get("WEBGL_compressed_texture_s3tc"), null === i) return null;
          if (33776 === t) return i.COMPRESSED_RGB_S3TC_DXT1_EXT;
          if (33777 === t) return i.COMPRESSED_RGBA_S3TC_DXT1_EXT;
          if (33778 === t) return i.COMPRESSED_RGBA_S3TC_DXT3_EXT;
          if (33779 === t) return i.COMPRESSED_RGBA_S3TC_DXT5_EXT;
        }
        if (35840 === t || 35841 === t || 35842 === t || 35843 === t) {
          if (i = e.get("WEBGL_compressed_texture_pvrtc"), null === i) return null;
          if (35840 === t) return i.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
          if (35841 === t) return i.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
          if (35842 === t) return i.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
          if (35843 === t) return i.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
        }
        if (36196 === t) return i = e.get("WEBGL_compressed_texture_etc1"), null !== i ? i.COMPRESSED_RGB_ETC1_WEBGL : null;
        if ((37492 === t || 37496 === t) && (i = e.get("WEBGL_compressed_texture_etc"), null !== i)) {
          if (37492 === t) return i.COMPRESSED_RGB8_ETC2;
          if (37496 === t) return i.COMPRESSED_RGBA8_ETC2_EAC;
        }
        return 37808 === t || 37809 === t || 37810 === t || 37811 === t || 37812 === t || 37813 === t || 37814 === t || 37815 === t || 37816 === t || 37817 === t || 37818 === t || 37819 === t || 37820 === t || 37821 === t || 37840 === t || 37841 === t || 37842 === t || 37843 === t || 37844 === t || 37845 === t || 37846 === t || 37847 === t || 37848 === t || 37849 === t || 37850 === t || 37851 === t || 37852 === t || 37853 === t ? (i = e.get("WEBGL_compressed_texture_astc"), null !== i ? t : null) : 36492 === t ? (i = e.get("EXT_texture_compression_bptc"), null !== i ? t : null) : t === C ? n ? 34042 : (i = e.get("WEBGL_depth_texture"), null !== i ? i.UNSIGNED_INT_24_8_WEBGL : null) : void 0;
      }};
    }
    class ArrayCamera extends PerspectiveCamera {
      constructor(t = []) {
        super(), this.cameras = t;
      }
    }
    ArrayCamera.prototype.isArrayCamera = true;
    class Group extends Object3D {
      constructor() {
        super(), this.type = "Group";
      }
    }
    Group.prototype.isGroup = true;
    const Ar = {type: "move"};
    class WebXRController {
      constructor() {
        this._targetRay = null, this._grip = null, this._hand = null;
      }
      getHandSpace() {
        return null === this._hand && (this._hand = new Group, this._hand.matrixAutoUpdate = false, this._hand.visible = false, this._hand.joints = {}, this._hand.inputState = {pinching: false}), this._hand;
      }
      getTargetRaySpace() {
        return null === this._targetRay && (this._targetRay = new Group, this._targetRay.matrixAutoUpdate = false, this._targetRay.visible = false, this._targetRay.hasLinearVelocity = false, this._targetRay.linearVelocity = new three_module_Vector3, this._targetRay.hasAngularVelocity = false, this._targetRay.angularVelocity = new three_module_Vector3), this._targetRay;
      }
      getGripSpace() {
        return null === this._grip && (this._grip = new Group, this._grip.matrixAutoUpdate = false, this._grip.visible = false, this._grip.hasLinearVelocity = false, this._grip.linearVelocity = new three_module_Vector3, this._grip.hasAngularVelocity = false, this._grip.angularVelocity = new three_module_Vector3), this._grip;
      }
      dispatchEvent(t) {
        return null !== this._targetRay && this._targetRay.dispatchEvent(t), null !== this._grip && this._grip.dispatchEvent(t), null !== this._hand && this._hand.dispatchEvent(t), this;
      }
      disconnect(t) {
        return this.dispatchEvent({type: "disconnected", data: t}), null !== this._targetRay && (this._targetRay.visible = false), null !== this._grip && (this._grip.visible = false), null !== this._hand && (this._hand.visible = false), this;
      }
      update(t, e, i) {
        let n = null, r = null, o = null;
        const s = this._targetRay, a = this._grip, l = this._hand;
        if (t && "visible-blurred" !== e.session.visibilityState) if (null !== s && (n = e.getPose(t.targetRaySpace, i), null !== n && (s.matrix.fromArray(n.transform.matrix), s.matrix.decompose(s.position, s.rotation, s.scale), n.linearVelocity ? (s.hasLinearVelocity = true, s.linearVelocity.copy(n.linearVelocity)) : s.hasLinearVelocity = false, n.angularVelocity ? (s.hasAngularVelocity = true, s.angularVelocity.copy(n.angularVelocity)) : s.hasAngularVelocity = false, this.dispatchEvent(Ar))), l && t.hand) {
          o = true;
          for (const n of t.hand.values()) {
            const t = e.getJointPose(n, i);
            if (void 0 === l.joints[n.jointName]) {
              const t = new Group;
              t.matrixAutoUpdate = false, t.visible = false, l.joints[n.jointName] = t, l.add(t);
            }
            const r = l.joints[n.jointName];
            null !== t && (r.matrix.fromArray(t.transform.matrix), r.matrix.decompose(r.position, r.rotation, r.scale), r.jointRadius = t.radius), r.visible = null !== t;
          }
          const n = l.joints["index-finger-tip"], r = l.joints["thumb-tip"], s = n.position.distanceTo(r.position), a = 0.02, c = 0.005;
          l.inputState.pinching && s > a + c ? (l.inputState.pinching = false, this.dispatchEvent({type: "pinchend", handedness: t.handedness, target: this})) : !l.inputState.pinching && s <= a - c && (l.inputState.pinching = true, this.dispatchEvent({type: "pinchstart", handedness: t.handedness, target: this}));
        } else null !== a && t.gripSpace && (r = e.getPose(t.gripSpace, i), null !== r && (a.matrix.fromArray(r.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), r.linearVelocity ? (a.hasLinearVelocity = true, a.linearVelocity.copy(r.linearVelocity)) : a.hasLinearVelocity = false, r.angularVelocity ? (a.hasAngularVelocity = true, a.angularVelocity.copy(r.angularVelocity)) : a.hasAngularVelocity = false));
        return null !== s && (s.visible = null !== n), null !== a && (a.visible = null !== r), null !== l && (l.visible = null !== o), this;
      }
    }
    class WebXRManager extends EventDispatcher {
      constructor(t, e) {
        super();
        const i = this, n = t.state;
        let r = null, o = 1, s = null, a = "local-floor", l = null, c = null, h = null, u = null, m = null, p = false, d = null, f = null, _ = null, y = null, g = null, x = null;
        const v = [], b = new Map, w = new PerspectiveCamera;
        w.layers.enable(1), w.viewport = new Vector4;
        const S = new PerspectiveCamera;
        S.layers.enable(2), S.viewport = new Vector4;
        const M = [w, S], C = new ArrayCamera;
        C.layers.enable(1), C.layers.enable(2);
        let A = null, T = null;
        function E(t) {
          const e = b.get(t.inputSource);
          e && e.dispatchEvent({type: t.type, data: t.inputSource});
        }
        function L() {
          b.forEach(function (t, e) {
            t.disconnect(e);
          }), b.clear(), A = null, T = null, n.bindXRFramebuffer(null), t.setRenderTarget(t.getRenderTarget()), h && e.deleteFramebuffer(h), d && e.deleteFramebuffer(d), f && e.deleteRenderbuffer(f), _ && e.deleteRenderbuffer(_), h = null, d = null, f = null, _ = null, m = null, u = null, c = null, r = null, I.stop(), i.isPresenting = false, i.dispatchEvent({type: "sessionend"});
        }
        function D(t) {
          const e = r.inputSources;
          for (let t = 0; t < v.length; t++) b.set(e[t], v[t]);
          for (let e = 0; e < t.removed.length; e++) {
            const i = t.removed[e], n = b.get(i);
            n && (n.dispatchEvent({type: "disconnected", data: i}), b.delete(i));
          }
          for (let e = 0; e < t.added.length; e++) {
            const i = t.added[e], n = b.get(i);
            n && n.dispatchEvent({type: "connected", data: i});
          }
        }
        this.cameraAutoUpdate = true, this.enabled = false, this.isPresenting = false, this.getController = function (t) {
          let e = v[t];
          return void 0 === e && (e = new WebXRController, v[t] = e), e.getTargetRaySpace();
        }, this.getControllerGrip = function (t) {
          let e = v[t];
          return void 0 === e && (e = new WebXRController, v[t] = e), e.getGripSpace();
        }, this.getHand = function (t) {
          let e = v[t];
          return void 0 === e && (e = new WebXRController, v[t] = e), e.getHandSpace();
        }, this.setFramebufferScaleFactor = function (t) {
          o = t, true === i.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
        }, this.setReferenceSpaceType = function (t) {
          a = t, true === i.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
        }, this.getReferenceSpace = function () {
          return s;
        }, this.getBaseLayer = function () {
          return null !== u ? u : m;
        }, this.getBinding = function () {
          return c;
        }, this.getFrame = function () {
          return y;
        }, this.getSession = function () {
          return r;
        }, this.setSession = async function (t) {
          if (r = t, null !== r) {
            r.addEventListener("select", E), r.addEventListener("selectstart", E), r.addEventListener("selectend", E), r.addEventListener("squeeze", E), r.addEventListener("squeezestart", E), r.addEventListener("squeezeend", E), r.addEventListener("end", L), r.addEventListener("inputsourceschange", D);
            const t = e.getContextAttributes();
            if (true !== t.xrCompatible && await e.makeXRCompatible(), void 0 === r.renderState.layers) {
              const i = {antialias: t.antialias, alpha: t.alpha, depth: t.depth, stencil: t.stencil, framebufferScaleFactor: o};
              m = new XRWebGLLayer(r, e, i), r.updateRenderState({baseLayer: m});
            } else if (e instanceof WebGLRenderingContext) {
              const i = {antialias: true, alpha: t.alpha, depth: t.depth, stencil: t.stencil, framebufferScaleFactor: o};
              m = new XRWebGLLayer(r, e, i), r.updateRenderState({layers: [m]});
            } else {
              p = t.antialias;
              let i = null;
              t.depth && (x = 256, t.stencil && (x |= 1024), g = t.stencil ? 33306 : 36096, i = t.stencil ? 35056 : 33190);
              const s = {colorFormat: t.alpha ? 32856 : 32849, depthFormat: i, scaleFactor: o};
              c = new XRWebGLBinding(r, e), u = c.createProjectionLayer(s), h = e.createFramebuffer(), r.updateRenderState({layers: [u]}), p && (d = e.createFramebuffer(), f = e.createRenderbuffer(), e.bindRenderbuffer(36161, f), e.renderbufferStorageMultisample(36161, 4, 32856, u.textureWidth, u.textureHeight), n.bindFramebuffer(36160, d), e.framebufferRenderbuffer(36160, 36064, 36161, f), e.bindRenderbuffer(36161, null), null !== i && (_ = e.createRenderbuffer(), e.bindRenderbuffer(36161, _), e.renderbufferStorageMultisample(36161, 4, i, u.textureWidth, u.textureHeight), e.framebufferRenderbuffer(36160, g, 36161, _), e.bindRenderbuffer(36161, null)), n.bindFramebuffer(36160, null));
            }
            s = await r.requestReferenceSpace(a), I.setContext(r), I.start(), i.isPresenting = true, i.dispatchEvent({type: "sessionstart"});
          }
        };
        const V = new three_module_Vector3, B = new three_module_Vector3;
        function R(t, e) {
          null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix), t.matrixWorldInverse.copy(t.matrixWorld).invert();
        }
        this.updateCamera = function (t) {
          if (null === r) return;
          C.near = S.near = w.near = t.near, C.far = S.far = w.far = t.far, A === C.near && T === C.far || (r.updateRenderState({depthNear: C.near, depthFar: C.far}), A = C.near, T = C.far);
          const e = t.parent, i = C.cameras;
          R(C, e);
          for (let t = 0; t < i.length; t++) R(i[t], e);
          C.matrixWorld.decompose(C.position, C.quaternion, C.scale), t.position.copy(C.position), t.quaternion.copy(C.quaternion), t.scale.copy(C.scale), t.matrix.copy(C.matrix), t.matrixWorld.copy(C.matrixWorld);
          const n = t.children;
          for (let t = 0, e = n.length; t < e; t++) n[t].updateMatrixWorld(true);
          2 === i.length ? function (t, e, i) {
            V.setFromMatrixPosition(e.matrixWorld), B.setFromMatrixPosition(i.matrixWorld);
            const n = V.distanceTo(B), r = e.projectionMatrix.elements, o = i.projectionMatrix.elements, s = r[14] / (r[10] - 1), a = r[14] / (r[10] + 1), l = (r[9] + 1) / r[5], c = (r[9] - 1) / r[5], h = (r[8] - 1) / r[0], u = (o[8] + 1) / o[0], m = s * h, p = s * u, d = n / (-h + u), f = d * -h;
            e.matrixWorld.decompose(t.position, t.quaternion, t.scale), t.translateX(f), t.translateZ(d), t.matrixWorld.compose(t.position, t.quaternion, t.scale), t.matrixWorldInverse.copy(t.matrixWorld).invert();
            const _ = s + d, y = a + d, g = m - f, x = p + (n - f), v = l * a / y * _, b = c * a / y * _;
            t.projectionMatrix.makePerspective(g, x, v, b, _, y);
          }(C, w, S) : C.projectionMatrix.copy(w.projectionMatrix);
        }, this.getCamera = function () {
          return C;
        }, this.getFoveation = function () {
          return null !== u ? u.fixedFoveation : null !== m ? m.fixedFoveation : void 0;
        }, this.setFoveation = function (t) {
          null !== u && (u.fixedFoveation = t), null !== m && void 0 !== m.fixedFoveation && (m.fixedFoveation = t);
        };
        let P = null;
        const I = new $e;
        I.setAnimationLoop(function (t, i) {
          if (l = i.getViewerPose(s), y = i, null !== l) {
            const t = l.views;
            null !== m && n.bindXRFramebuffer(m.framebuffer);
            let i = false;
            t.length !== C.cameras.length && (C.cameras.length = 0, i = true);
            for (let r = 0; r < t.length; r++) {
              const o = t[r];
              let s = null;
              if (null !== m) s = m.getViewport(o); else {
                const t = c.getViewSubImage(u, o);
                n.bindXRFramebuffer(h), void 0 !== t.depthStencilTexture && e.framebufferTexture2D(36160, g, 3553, t.depthStencilTexture, 0), e.framebufferTexture2D(36160, 36064, 3553, t.colorTexture, 0), s = t.viewport;
              }
              const a = M[r];
              a.matrix.fromArray(o.transform.matrix), a.projectionMatrix.fromArray(o.projectionMatrix), a.viewport.set(s.x, s.y, s.width, s.height), 0 === r && C.matrix.copy(a.matrix), true === i && C.cameras.push(a);
            }
            p && (n.bindXRFramebuffer(d), null !== x && e.clear(x));
          }
          const o = r.inputSources;
          for (let t = 0; t < v.length; t++) {
            const e = v[t], n = o[t];
            e.update(n, i, s);
          }
          if (P && P(t, i), p) {
            const t = u.textureWidth, i = u.textureHeight;
            n.bindFramebuffer(36008, d), n.bindFramebuffer(36009, h), e.invalidateFramebuffer(36008, [g]), e.invalidateFramebuffer(36009, [g]), e.blitFramebuffer(0, 0, t, i, 0, 0, t, i, 16384, 9728), e.invalidateFramebuffer(36008, [36064]), n.bindFramebuffer(36008, null), n.bindFramebuffer(36009, null), n.bindFramebuffer(36160, d);
          }
          y = null;
        }), this.setAnimationLoop = function (t) {
          P = t;
        }, this.dispose = function () {};
      }
    }
    function Tr(t) {
      function e(e, i) {
        e.opacity.value = i.opacity, i.color && e.diffuse.value.copy(i.color), i.emissive && e.emissive.value.copy(i.emissive).multiplyScalar(i.emissiveIntensity), i.map && (e.map.value = i.map), i.alphaMap && (e.alphaMap.value = i.alphaMap), i.specularMap && (e.specularMap.value = i.specularMap), i.alphaTest > 0 && (e.alphaTest.value = i.alphaTest);
        const n = t.get(i).envMap;
        if (n) {
          e.envMap.value = n, e.flipEnvMap.value = n.isCubeTexture && false === n.isRenderTargetTexture ? -1 : 1, e.reflectivity.value = i.reflectivity, e.ior.value = i.ior, e.refractionRatio.value = i.refractionRatio;
          const r = t.get(n).__maxMipLevel;
          void 0 !== r && (e.maxMipLevel.value = r);
        }
        let r, o;
        i.lightMap && (e.lightMap.value = i.lightMap, e.lightMapIntensity.value = i.lightMapIntensity), i.aoMap && (e.aoMap.value = i.aoMap, e.aoMapIntensity.value = i.aoMapIntensity), i.map ? r = i.map : i.specularMap ? r = i.specularMap : i.displacementMap ? r = i.displacementMap : i.normalMap ? r = i.normalMap : i.bumpMap ? r = i.bumpMap : i.roughnessMap ? r = i.roughnessMap : i.metalnessMap ? r = i.metalnessMap : i.alphaMap ? r = i.alphaMap : i.emissiveMap ? r = i.emissiveMap : i.clearcoatMap ? r = i.clearcoatMap : i.clearcoatNormalMap ? r = i.clearcoatNormalMap : i.clearcoatRoughnessMap ? r = i.clearcoatRoughnessMap : i.specularIntensityMap ? r = i.specularIntensityMap : i.specularTintMap ? r = i.specularTintMap : i.transmissionMap ? r = i.transmissionMap : i.thicknessMap && (r = i.thicknessMap), void 0 !== r && (r.isWebGLRenderTarget && (r = r.texture), true === r.matrixAutoUpdate && r.updateMatrix(), e.uvTransform.value.copy(r.matrix)), i.aoMap ? o = i.aoMap : i.lightMap && (o = i.lightMap), void 0 !== o && (o.isWebGLRenderTarget && (o = o.texture), true === o.matrixAutoUpdate && o.updateMatrix(), e.uv2Transform.value.copy(o.matrix));
      }
      function i(e, i) {
        e.roughness.value = i.roughness, e.metalness.value = i.metalness, i.roughnessMap && (e.roughnessMap.value = i.roughnessMap), i.metalnessMap && (e.metalnessMap.value = i.metalnessMap), i.emissiveMap && (e.emissiveMap.value = i.emissiveMap), i.bumpMap && (e.bumpMap.value = i.bumpMap, e.bumpScale.value = i.bumpScale, 1 === i.side && (e.bumpScale.value *= -1)), i.normalMap && (e.normalMap.value = i.normalMap, e.normalScale.value.copy(i.normalScale), 1 === i.side && e.normalScale.value.negate()), i.displacementMap && (e.displacementMap.value = i.displacementMap, e.displacementScale.value = i.displacementScale, e.displacementBias.value = i.displacementBias);
        t.get(i).envMap && (e.envMapIntensity.value = i.envMapIntensity);
      }
      return {refreshFogUniforms: function (t, e) {
        t.fogColor.value.copy(e.color), e.isFog ? (t.fogNear.value = e.near, t.fogFar.value = e.far) : e.isFogExp2 && (t.fogDensity.value = e.density);
      }, refreshMaterialUniforms: function (t, n, r, o, s) {
        n.isMeshBasicMaterial ? e(t, n) : n.isMeshLambertMaterial ? (e(t, n), function (t, e) {
          e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
        }(t, n)) : n.isMeshToonMaterial ? (e(t, n), function (t, e) {
          e.gradientMap && (t.gradientMap.value = e.gradientMap);
          e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
          e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1));
          e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate());
          e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias);
        }(t, n)) : n.isMeshPhongMaterial ? (e(t, n), function (t, e) {
          t.specular.value.copy(e.specular), t.shininess.value = Math.max(e.shininess, 0.0001), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
          e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1));
          e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate());
          e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias);
        }(t, n)) : n.isMeshStandardMaterial ? (e(t, n), n.isMeshPhysicalMaterial ? function (t, e, n) {
          i(t, e), t.ior.value = e.ior, e.sheenTint && t.sheenTint.value.copy(e.sheenTint);
          e.clearcoat > 0 && (t.clearcoat.value = e.clearcoat, t.clearcoatRoughness.value = e.clearcoatRoughness, e.clearcoatMap && (t.clearcoatMap.value = e.clearcoatMap), e.clearcoatRoughnessMap && (t.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap), e.clearcoatNormalMap && (t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale), t.clearcoatNormalMap.value = e.clearcoatNormalMap, 1 === e.side && t.clearcoatNormalScale.value.negate()));
          e.transmission > 0 && (t.transmission.value = e.transmission, t.transmissionSamplerMap.value = n.texture, t.transmissionSamplerSize.value.set(n.width, n.height), e.transmissionMap && (t.transmissionMap.value = e.transmissionMap), t.thickness.value = e.thickness, e.thicknessMap && (t.thicknessMap.value = e.thicknessMap), t.attenuationDistance.value = e.attenuationDistance, t.attenuationTint.value.copy(e.attenuationTint));
          t.specularIntensity.value = e.specularIntensity, t.specularTint.value.copy(e.specularTint), e.specularIntensityMap && (t.specularIntensityMap.value = e.specularIntensityMap);
          e.specularTintMap && (t.specularTintMap.value = e.specularTintMap);
        }(t, n, s) : i(t, n)) : n.isMeshMatcapMaterial ? (e(t, n), function (t, e) {
          e.matcap && (t.matcap.value = e.matcap);
          e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1));
          e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate());
          e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias);
        }(t, n)) : n.isMeshDepthMaterial ? (e(t, n), function (t, e) {
          e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias);
        }(t, n)) : n.isMeshDistanceMaterial ? (e(t, n), function (t, e) {
          e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias);
          t.referencePosition.value.copy(e.referencePosition), t.nearDistance.value = e.nearDistance, t.farDistance.value = e.farDistance;
        }(t, n)) : n.isMeshNormalMaterial ? (e(t, n), function (t, e) {
          e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1));
          e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate());
          e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias);
        }(t, n)) : n.isLineBasicMaterial ? (function (t, e) {
          t.diffuse.value.copy(e.color), t.opacity.value = e.opacity;
        }(t, n), n.isLineDashedMaterial && function (t, e) {
          t.dashSize.value = e.dashSize, t.totalSize.value = e.dashSize + e.gapSize, t.scale.value = e.scale;
        }(t, n)) : n.isPointsMaterial ? function (t, e, i, n) {
          t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.size.value = e.size * i, t.scale.value = 0.5 * n, e.map && (t.map.value = e.map);
          e.alphaMap && (t.alphaMap.value = e.alphaMap);
          e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest);
          let r;
          e.map ? r = e.map : e.alphaMap && (r = e.alphaMap);
          void 0 !== r && (true === r.matrixAutoUpdate && r.updateMatrix(), t.uvTransform.value.copy(r.matrix));
        }(t, n, r, o) : n.isSpriteMaterial ? function (t, e) {
          t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.rotation.value = e.rotation, e.map && (t.map.value = e.map);
          e.alphaMap && (t.alphaMap.value = e.alphaMap);
          e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest);
          let i;
          e.map ? i = e.map : e.alphaMap && (i = e.alphaMap);
          void 0 !== i && (true === i.matrixAutoUpdate && i.updateMatrix(), t.uvTransform.value.copy(i.matrix));
        }(t, n) : n.isShadowMaterial ? (t.color.value.copy(n.color), t.opacity.value = n.opacity) : n.isShaderMaterial && (n.uniformsNeedUpdate = false);
      }};
    }
    function Er(t = {}) {
      const e = void 0 !== t.canvas ? t.canvas : function () {
        const t = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
        return t.style.display = "block", t;
      }(), i = void 0 !== t.context ? t.context : null, n = void 0 !== t.alpha && t.alpha, r = void 0 === t.depth || t.depth, o = void 0 === t.stencil || t.stencil, s = void 0 !== t.antialias && t.antialias, a = void 0 === t.premultipliedAlpha || t.premultipliedAlpha, l = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer, c = void 0 !== t.powerPreference ? t.powerPreference : "default", h = void 0 !== t.failIfMajorPerformanceCaveat && t.failIfMajorPerformanceCaveat;
      let u = null, m = null;
      const d = [], _ = [];
      this.domElement = e, this.debug = {checkShaderErrors: true}, this.autoClear = true, this.autoClearColor = true, this.autoClearDepth = true, this.autoClearStencil = true, this.sortObjects = true, this.clippingPlanes = [], this.localClippingEnabled = false, this.gammaFactor = 2, this.outputEncoding = G, this.physicallyCorrectLights = false, this.toneMapping = 0, this.toneMappingExposure = 1;
      const y = this;
      let g = false, b = 0, w = 0, C = null, A = -1, E = null;
      const L = new Vector4, D = new Vector4;
      let V = null, B = e.width, R = e.height, P = 1, I = null, F = null;
      const N = new Vector4(0, 0, B, R), z = new Vector4(0, 0, B, R);
      let O = false;
      const U = [], k = new Frustum;
      let H = false, W = false, J = null;
      const j = new Matrix4, X = new three_module_Vector3, q = {background: null, fog: null, environment: null, overrideMaterial: null, isScene: true};
      function Y() {
        return null === C ? P : 1;
      }
      let Z, K, Q, $, tt, et, it, nt, rt, ot, st, at, lt, ct, ht, ut, mt, pt, dt, ft, _t, yt, gt, xt = i;
      function vt(t, i) {
        for (let n = 0; n < t.length; n++) {
          const r = t[n], o = e.getContext(r, i);
          if (null !== o) return o;
        }
        return null;
      }
      try {
        const t = {alpha: n, depth: r, stencil: o, antialias: s, premultipliedAlpha: a, preserveDrawingBuffer: l, powerPreference: c, failIfMajorPerformanceCaveat: h};
        if (e.addEventListener("webglcontextlost", St, false), e.addEventListener("webglcontextrestored", Mt, false), null === xt) {
          const e = ["webgl2", "webgl", "experimental-webgl"];
          if (true === y.isWebGL1Renderer && e.shift(), xt = vt(e, t), null === xt) throw vt(e) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
        }
        void 0 === xt.getShaderPrecisionFormat && (xt.getShaderPrecisionFormat = function () {
          return {rangeMin: 1, rangeMax: 1, precision: 1};
        });
      } catch (t) {
        throw console.error("THREE.WebGLRenderer: " + t.message), t;
      }
      function bt() {
        Z = new Ri(xt), K = new ai(xt, Z, t), Z.init(K), yt = new Cr(xt, Z, K), Q = new Sr(xt, Z, K), U[0] = 1029, $ = new Fi(xt), tt = new ur, et = new Mr(xt, Z, Q, tt, K, yt, $), it = new ci(y), nt = new Bi(y), rt = new ti(xt, K), gt = new oi(xt, Z, rt, K), ot = new Pi(xt, rt, $, gt), st = new Oi(xt, ot, rt, $), dt = new zi(xt), ut = new li(tt), at = new hr(y, it, nt, Z, K, gt, ut), lt = new Tr(tt), ct = new fr(tt), ht = new br(Z, K), pt = new ri(y, it, Q, st, a), mt = new wr(y, st, K), ft = new si(xt, Z, $, K), _t = new Ii(xt, Z, $, K), $.programs = at.programs, y.capabilities = K, y.extensions = Z, y.properties = tt, y.renderLists = ct, y.shadowMap = mt, y.state = Q, y.info = $;
      }
      bt();
      const wt = new WebXRManager(y, xt);
      function St(t) {
        t.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), g = true;
      }
      function Mt() {
        console.log("THREE.WebGLRenderer: Context Restored."), g = false;
        const t = $.autoReset, e = mt.enabled, i = mt.autoUpdate, n = mt.needsUpdate, r = mt.type;
        bt(), $.autoReset = t, mt.enabled = e, mt.autoUpdate = i, mt.needsUpdate = n, mt.type = r;
      }
      function Ct(t) {
        const e = t.target;
        e.removeEventListener("dispose", Ct), function (t) {
          (function (t) {
            const e = tt.get(t).programs;
            void 0 !== e && e.forEach(function (t) {
              at.releaseProgram(t);
            });
          }(t), tt.remove(t));
        }(e);
      }
      this.xr = wt, this.getContext = function () {
        return xt;
      }, this.getContextAttributes = function () {
        return xt.getContextAttributes();
      }, this.forceContextLoss = function () {
        const t = Z.get("WEBGL_lose_context");
        t && t.loseContext();
      }, this.forceContextRestore = function () {
        const t = Z.get("WEBGL_lose_context");
        t && t.restoreContext();
      }, this.getPixelRatio = function () {
        return P;
      }, this.setPixelRatio = function (t) {
        void 0 !== t && (P = t, this.setSize(B, R, false));
      }, this.getSize = function (t) {
        return t.set(B, R);
      }, this.setSize = function (t, i, n) {
        wt.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (B = t, R = i, e.width = Math.floor(t * P), e.height = Math.floor(i * P), false !== n && (e.style.width = t + "px", e.style.height = i + "px"), this.setViewport(0, 0, t, i));
      }, this.getDrawingBufferSize = function (t) {
        return t.set(B * P, R * P).floor();
      }, this.setDrawingBufferSize = function (t, i, n) {
        B = t, R = i, P = n, e.width = Math.floor(t * n), e.height = Math.floor(i * n), this.setViewport(0, 0, t, i);
      }, this.getCurrentViewport = function (t) {
        return t.copy(L);
      }, this.getViewport = function (t) {
        return t.copy(N);
      }, this.setViewport = function (t, e, i, n) {
        t.isVector4 ? N.set(t.x, t.y, t.z, t.w) : N.set(t, e, i, n), Q.viewport(L.copy(N).multiplyScalar(P).floor());
      }, this.getScissor = function (t) {
        return t.copy(z);
      }, this.setScissor = function (t, e, i, n) {
        t.isVector4 ? z.set(t.x, t.y, t.z, t.w) : z.set(t, e, i, n), Q.scissor(D.copy(z).multiplyScalar(P).floor());
      }, this.getScissorTest = function () {
        return O;
      }, this.setScissorTest = function (t) {
        Q.setScissorTest(O = t);
      }, this.setOpaqueSort = function (t) {
        I = t;
      }, this.setTransparentSort = function (t) {
        F = t;
      }, this.getClearColor = function (t) {
        return t.copy(pt.getClearColor());
      }, this.setClearColor = function () {
        pt.setClearColor.apply(pt, arguments);
      }, this.getClearAlpha = function () {
        return pt.getClearAlpha();
      }, this.setClearAlpha = function () {
        pt.setClearAlpha.apply(pt, arguments);
      }, this.clear = function (t, e, i) {
        let n = 0;
        (void 0 === t || t) && (n |= 16384), (void 0 === e || e) && (n |= 256), (void 0 === i || i) && (n |= 1024), xt.clear(n);
      }, this.clearColor = function () {
        this.clear(true, false, false);
      }, this.clearDepth = function () {
        this.clear(false, true, false);
      }, this.clearStencil = function () {
        this.clear(false, false, true);
      }, this.dispose = function () {
        e.removeEventListener("webglcontextlost", St, false), e.removeEventListener("webglcontextrestored", Mt, false), ct.dispose(), ht.dispose(), tt.dispose(), it.dispose(), nt.dispose(), st.dispose(), gt.dispose(), wt.dispose(), wt.removeEventListener("sessionstart", Tt), wt.removeEventListener("sessionend", Et), J && (J.dispose(), J = null), Lt.stop();
      }, this.renderBufferImmediate = function (t, e) {
        gt.initAttributes();
        const i = tt.get(t);
        t.hasPositions && !i.position && (i.position = xt.createBuffer()), t.hasNormals && !i.normal && (i.normal = xt.createBuffer()), t.hasUvs && !i.uv && (i.uv = xt.createBuffer()), t.hasColors && !i.color && (i.color = xt.createBuffer());
        const n = e.getAttributes();
        t.hasPositions && (xt.bindBuffer(34962, i.position), xt.bufferData(34962, t.positionArray, 35048), gt.enableAttribute(n.position.location), xt.vertexAttribPointer(n.position.location, 3, 5126, false, 0, 0)), t.hasNormals && (xt.bindBuffer(34962, i.normal), xt.bufferData(34962, t.normalArray, 35048), gt.enableAttribute(n.normal.location), xt.vertexAttribPointer(n.normal.location, 3, 5126, false, 0, 0)), t.hasUvs && (xt.bindBuffer(34962, i.uv), xt.bufferData(34962, t.uvArray, 35048), gt.enableAttribute(n.uv.location), xt.vertexAttribPointer(n.uv.location, 2, 5126, false, 0, 0)), t.hasColors && (xt.bindBuffer(34962, i.color), xt.bufferData(34962, t.colorArray, 35048), gt.enableAttribute(n.color.location), xt.vertexAttribPointer(n.color.location, 3, 5126, false, 0, 0)), gt.disableUnusedAttributes(), xt.drawArrays(4, 0, t.count), t.count = 0;
      }, this.renderBufferDirect = function (t, e, i, n, r, o) {
        null === e && (e = q);
        const s = r.isMesh && r.matrixWorld.determinant() < 0, a = Ft(t, e, n, r);
        Q.setMaterial(n, s);
        let l = i.index;
        const c = i.attributes.position;
        if (null === l) {
          if (void 0 === c || 0 === c.count) return;
        } else if (0 === l.count) return;
        let h, u = 1;
        true === n.wireframe && (l = ot.getWireframeAttribute(i), u = 2), void 0 === i.morphAttributes.position && void 0 === i.morphAttributes.normal || dt.update(r, i, n, a), gt.setup(r, n, a, i, l);
        let m = ft;
        null !== l && (h = rt.get(l), m = _t, m.setIndex(h));
        const p = null !== l ? l.count : c.count, d = i.drawRange.start * u, f = i.drawRange.count * u, _ = null !== o ? o.start * u : 0, y = null !== o ? o.count * u : Infinity, g = Math.max(d, _), x = Math.min(p, d + f, _ + y) - 1, v = Math.max(0, x - g + 1);
        if (0 !== v) {
          if (r.isMesh) true === n.wireframe ? (Q.setLineWidth(n.wireframeLinewidth * Math.max(e, Math.min(i, t))), m.setMode(1)) : m.setMode(4); else if (r.isLine) {
            let t = n.linewidth;
            void 0 === t && (t = 1), Q.setLineWidth(t * Math.max(e, Math.min(i, t))), r.isLineSegments ? m.setMode(1) : r.isLineLoop ? m.setMode(2) : m.setMode(3);
          } else r.isPoints ? m.setMode(0) : r.isSprite && m.setMode(4);
          if (r.isInstancedMesh) m.renderInstances(g, v, r.count); else if (i.isInstancedBufferGeometry) {
            const t = Math.min(i.instanceCount, i._maxInstanceCount);
            m.renderInstances(g, v, t);
          } else m.render(g, v);
        }
      }, this.compile = function (t, e) {
        m = ht.get(t), m.init(), _.push(m), t.traverseVisible(function (t) {
          t.isLight && t.layers.test(e.layers) && (m.pushLight(t), t.castShadow && m.pushShadow(t));
        }), m.setupLights(y.physicallyCorrectLights), t.traverse(function (e) {
          const i = e.material;
          if (i) if (Array.isArray(i)) for (let n = 0; n < i.length; n++) {
            Pt(i[n], t, e);
          } else Pt(i, t, e);
        }), _.pop(), m = null;
      };
      let At = null;
      function Tt() {
        Lt.stop();
      }
      function Et() {
        Lt.start();
      }
      const Lt = new $e;
      function Dt(t, e, i, n) {
        if (false === t.visible) return;
        if (t.layers.test(e.layers)) if (t.isGroup) i = t.renderOrder; else if (t.isLOD) true === t.autoUpdate && t.update(e); else if (t.isLight) m.pushLight(t), t.castShadow && m.pushShadow(t); else if (t.isSprite) {
          if (!t.frustumCulled || k.intersectsSprite(t)) {
            n && X.setFromMatrixPosition(t.matrixWorld).applyMatrix4(j);
            const e = st.update(t), r = t.material;
            r.visible && u.push(t, e, r, i, X.z, null);
          }
        } else if (t.isImmediateRenderObject) n && X.setFromMatrixPosition(t.matrixWorld).applyMatrix4(j), u.push(t, null, t.material, i, X.z, null); else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.frame !== $.render.frame && (t.skeleton.update(), t.skeleton.frame = $.render.frame), !t.frustumCulled || k.intersectsObject(t))) {
          n && X.setFromMatrixPosition(t.matrixWorld).applyMatrix4(j);
          const e = st.update(t), r = t.material;
          if (Array.isArray(r)) {
            const n = e.groups;
            for (let o = 0, s = n.length; o < s; o++) {
              const s = n[o], a = r[s.materialIndex];
              a && a.visible && u.push(t, e, a, i, X.z, s);
            }
          } else r.visible && u.push(t, e, r, i, X.z, null);
        }
        const r = t.children;
        for (let t = 0, o = r.length; t < o; t++) Dt(r[t], e, i, n);
      }
      function Vt(t, e, i, n) {
        const r = t.opaque, o = t.transmissive, a = t.transparent;
        m.setupLightsView(i), o.length > 0 && function (t, e, i) {
          if (null === J) {
            const t = true === s && true === K.isWebGL2;
            J = new (t ? WebGLMultisampleRenderTarget : WebGLRenderTarget)(1024, 1024, {generateMipmaps: true, type: null !== yt.convert(M) ? M : v, minFilter: x, magFilter: f, wrapS: p, wrapT: p});
          }
          const n = y.getRenderTarget();
          y.setRenderTarget(J), y.clear();
          const r = y.toneMapping;
          y.toneMapping = 0, Bt(t, e, i), y.toneMapping = r, et.updateMultisampleRenderTarget(J), et.updateRenderTargetMipmap(J), y.setRenderTarget(n);
        }(r, e, i), n && Q.viewport(L.copy(n)), r.length > 0 && Bt(r, e, i), o.length > 0 && Bt(o, e, i), a.length > 0 && Bt(a, e, i);
      }
      function Bt(t, e, i) {
        const n = true === e.isScene ? e.overrideMaterial : null;
        for (let r = 0, o = t.length; r < o; r++) {
          const o = t[r], s = o.object, a = o.geometry, l = null === n ? o.material : n, c = o.group;
          s.layers.test(i.layers) && Rt(s, e, i, a, l, c);
        }
      }
      function Rt(t, e, i, n, r, o) {
        if (t.onBeforeRender(y, e, i, n, r, o), t.modelViewMatrix.multiplyMatrices(i.matrixWorldInverse, t.matrixWorld), t.normalMatrix.getNormalMatrix(t.modelViewMatrix), t.isImmediateRenderObject) {
          const n = Ft(i, e, r, t);
          Q.setMaterial(r), gt.reset(), function (t, e) {
            t.render(function (t) {
              y.renderBufferImmediate(t, e);
            });
          }(t, n);
        } else true === r.transparent && 2 === r.side ? (r.side = 1, r.needsUpdate = true, y.renderBufferDirect(i, e, n, r, t, o), r.side = 0, r.needsUpdate = true, y.renderBufferDirect(i, e, n, r, t, o), r.side = 2) : y.renderBufferDirect(i, e, n, r, t, o);
        t.onAfterRender(y, e, i, n, r, o);
      }
      function Pt(t, e, i) {
        true !== e.isScene && (e = q);
        const n = tt.get(t), r = m.state.lights, o = m.state.shadowsArray, s = r.state.version, a = at.getParameters(t, r.state, o, e, i), l = at.getProgramCacheKey(a);
        let c = n.programs;
        n.environment = t.isMeshStandardMaterial ? e.environment : null, n.fog = e.fog, n.envMap = (t.isMeshStandardMaterial ? nt : it).get(t.envMap || n.environment), void 0 === c && (t.addEventListener("dispose", Ct), c = new Map, n.programs = c);
        let h = c.get(l);
        if (void 0 !== h) {
          if (n.currentProgram === h && n.lightsStateVersion === s) return It(t, a), h;
        } else a.uniforms = at.getUniforms(t), t.onBuild(a, y), t.onBeforeCompile(a, y), h = at.acquireProgram(a, l), c.set(l, h), n.uniforms = a.uniforms;
        const u = n.uniforms;
        (t.isShaderMaterial || t.isRawShaderMaterial) && true !== t.clipping || (u.clippingPlanes = ut.uniform), It(t, a), n.needsLights = function (t) {
          return t.isMeshLambertMaterial || t.isMeshToonMaterial || t.isMeshPhongMaterial || t.isMeshStandardMaterial || t.isShadowMaterial || t.isShaderMaterial && true === t.lights;
        }(t), n.lightsStateVersion = s, n.needsLights && (u.ambientLightColor.value = r.state.ambient, u.lightProbe.value = r.state.probe, u.directionalLights.value = r.state.directional, u.directionalLightShadows.value = r.state.directionalShadow, u.spotLights.value = r.state.spot, u.spotLightShadows.value = r.state.spotShadow, u.rectAreaLights.value = r.state.rectArea, u.ltc_1.value = r.state.rectAreaLTC1, u.ltc_2.value = r.state.rectAreaLTC2, u.pointLights.value = r.state.point, u.pointLightShadows.value = r.state.pointShadow, u.hemisphereLights.value = r.state.hemi, u.directionalShadowMap.value = r.state.directionalShadowMap, u.directionalShadowMatrix.value = r.state.directionalShadowMatrix, u.spotShadowMap.value = r.state.spotShadowMap, u.spotShadowMatrix.value = r.state.spotShadowMatrix, u.pointShadowMap.value = r.state.pointShadowMap, u.pointShadowMatrix.value = r.state.pointShadowMatrix);
        const p = h.getUniforms(), d = Hn.seqWithValue(p.seq, u);
        return n.currentProgram = h, n.uniformsList = d, h;
      }
      function It(t, e) {
        const i = tt.get(t);
        i.outputEncoding = e.outputEncoding, i.instancing = e.instancing, i.skinning = e.skinning, i.morphTargets = e.morphTargets, i.morphNormals = e.morphNormals, i.numClippingPlanes = e.numClippingPlanes, i.numIntersection = e.numClipIntersection, i.vertexAlphas = e.vertexAlphas, i.vertexTangents = e.vertexTangents;
      }
      function Ft(t, e, i, n) {
        true !== e.isScene && (e = q), et.resetTextureUnits();
        const r = e.fog, o = i.isMeshStandardMaterial ? e.environment : null, s = null === C ? y.outputEncoding : C.texture.encoding, a = (i.isMeshStandardMaterial ? nt : it).get(i.envMap || o), l = true === i.vertexColors && !!n.geometry && !!n.geometry.attributes.color && 4 === n.geometry.attributes.color.itemSize, c = !!n.geometry && !!n.geometry.attributes.tangent, h = !!n.geometry && !!n.geometry.morphAttributes.position, u = !!n.geometry && !!n.geometry.morphAttributes.normal, p = tt.get(i), d = m.state.lights;
        if (true === H && (true === W || t !== E)) {
          const e = t === E && i.id === A;
          ut.setState(i, t, e);
        }
        let f = false;
        i.version === p.__version ? p.needsLights && p.lightsStateVersion !== d.state.version || p.outputEncoding !== s || n.isInstancedMesh && false === p.instancing ? f = true : n.isInstancedMesh || true !== p.instancing ? n.isSkinnedMesh && false === p.skinning ? f = true : n.isSkinnedMesh || true !== p.skinning ? p.envMap !== a || i.fog && p.fog !== r ? f = true : void 0 === p.numClippingPlanes || p.numClippingPlanes === ut.numPlanes && p.numIntersection === ut.numIntersection ? (p.vertexAlphas !== l || p.vertexTangents !== c || p.morphTargets !== h || p.morphNormals !== u) && (f = true) : f = true : f = true : f = true : (f = true, p.__version = i.version);
        let _ = p.currentProgram;
        true === f && (_ = Pt(i, e, n));
        let g = false, x = false, v = false;
        const b = _.getUniforms(), w = p.uniforms;
        if (Q.useProgram(_.program) && (g = true, x = true, v = true), i.id !== A && (A = i.id, x = true), g || E !== t) {
          if (b.setValue(xt, "projectionMatrix", t.projectionMatrix), K.logarithmicDepthBuffer && b.setValue(xt, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), E !== t && (E = t, x = true, v = true), i.isShaderMaterial || i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshStandardMaterial || i.envMap) {
            const e = b.map.cameraPosition;
            void 0 !== e && e.setValue(xt, X.setFromMatrixPosition(t.matrixWorld));
          }
          (i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial) && b.setValue(xt, "isOrthographic", true === t.isOrthographicCamera), (i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial || i.isShadowMaterial || n.isSkinnedMesh) && b.setValue(xt, "viewMatrix", t.matrixWorldInverse);
        }
        if (n.isSkinnedMesh) {
          b.setOptional(xt, n, "bindMatrix"), b.setOptional(xt, n, "bindMatrixInverse");
          const t = n.skeleton;
          t && (K.floatVertexTextures ? (null === t.boneTexture && t.computeBoneTexture(), b.setValue(xt, "boneTexture", t.boneTexture, et), b.setValue(xt, "boneTextureSize", t.boneTextureSize)) : b.setOptional(xt, t, "boneMatrices"));
        }
        var S, M;
        return (x || p.receiveShadow !== n.receiveShadow) && (p.receiveShadow = n.receiveShadow, b.setValue(xt, "receiveShadow", n.receiveShadow)), x && (b.setValue(xt, "toneMappingExposure", y.toneMappingExposure), p.needsLights && (M = v, (S = w).ambientLightColor.needsUpdate = M, S.lightProbe.needsUpdate = M, S.directionalLights.needsUpdate = M, S.directionalLightShadows.needsUpdate = M, S.pointLights.needsUpdate = M, S.pointLightShadows.needsUpdate = M, S.spotLights.needsUpdate = M, S.spotLightShadows.needsUpdate = M, S.rectAreaLights.needsUpdate = M, S.hemisphereLights.needsUpdate = M), r && i.fog && lt.refreshFogUniforms(w, r), lt.refreshMaterialUniforms(w, i, P, R, J), Hn.upload(xt, p.uniformsList, w, et)), i.isShaderMaterial && true === i.uniformsNeedUpdate && (Hn.upload(xt, p.uniformsList, w, et), i.uniformsNeedUpdate = false), i.isSpriteMaterial && b.setValue(xt, "center", n.center), b.setValue(xt, "modelViewMatrix", n.modelViewMatrix), b.setValue(xt, "normalMatrix", n.normalMatrix), b.setValue(xt, "modelMatrix", n.matrixWorld), _;
      }
      Lt.setAnimationLoop(function (t) {
        At && At(t);
      }), "undefined" != typeof window && Lt.setContext(window), this.setAnimationLoop = function (t) {
        At = t, wt.setAnimationLoop(t), null === t ? Lt.stop() : Lt.start();
      }, wt.addEventListener("sessionstart", Tt), wt.addEventListener("sessionend", Et), this.render = function (t, e) {
        if (void 0 !== e && true !== e.isCamera) return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
        if (true === g) return;
        true === t.autoUpdate && t.updateMatrixWorld(), null === e.parent && e.updateMatrixWorld(), true === wt.enabled && true === wt.isPresenting && (true === wt.cameraAutoUpdate && wt.updateCamera(e), e = wt.getCamera()), true === t.isScene && t.onBeforeRender(y, t, e, C), m = ht.get(t, _.length), m.init(), _.push(m), j.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), k.setFromProjectionMatrix(j), W = this.localClippingEnabled, H = ut.init(this.clippingPlanes, W, e), u = ct.get(t, d.length), u.init(), d.push(u), Dt(t, e, 0, y.sortObjects), u.finish(), true === y.sortObjects && u.sort(I, F), true === H && ut.beginShadows();
        const i = m.state.shadowsArray;
        if (mt.render(i, t, e), true === H && ut.endShadows(), true === this.info.autoReset && this.info.reset(), pt.render(u, t), m.setupLights(y.physicallyCorrectLights), e.isArrayCamera) {
          const i = e.cameras;
          for (let e = 0, n = i.length; e < n; e++) {
            const n = i[e];
            Vt(u, t, n, n.viewport);
          }
        } else Vt(u, t, e);
        null !== C && (et.updateMultisampleRenderTarget(C), et.updateRenderTargetMipmap(C)), true === t.isScene && t.onAfterRender(y, t, e), Q.buffers.depth.setTest(true), Q.buffers.depth.setMask(true), Q.buffers.color.setMask(true), Q.setPolygonOffset(false), gt.resetDefaultState(), A = -1, E = null, _.pop(), m = _.length > 0 ? _[_.length - 1] : null, d.pop(), u = d.length > 0 ? d[d.length - 1] : null;
      }, this.getActiveCubeFace = function () {
        return b;
      }, this.getActiveMipmapLevel = function () {
        return w;
      }, this.getRenderTarget = function () {
        return C;
      }, this.setRenderTarget = function (t, e = 0, i = 0) {
        C = t, b = e, w = i, t && void 0 === tt.get(t).__webglFramebuffer && et.setupRenderTarget(t);
        let n = null, r = false, o = false;
        if (t) {
          const i = t.texture;
          (i.isDataTexture3D || i.isDataTexture2DArray) && (o = true);
          const s = tt.get(t).__webglFramebuffer;
          t.isWebGLCubeRenderTarget ? (n = s[e], r = true) : n = t.isWebGLMultisampleRenderTarget ? tt.get(t).__webglMultisampledFramebuffer : s, L.copy(t.viewport), D.copy(t.scissor), V = t.scissorTest;
        } else L.copy(N).multiplyScalar(P).floor(), D.copy(z).multiplyScalar(P).floor(), V = O;
        if (Q.bindFramebuffer(36160, n) && K.drawBuffers) {
          let e = false;
          if (t) if (t.isWebGLMultipleRenderTargets) {
            const i = t.texture;
            if (U.length !== i.length || 36064 !== U[0]) {
              for (let t = 0, e = i.length; t < e; t++) U[t] = 36064 + t;
              U.length = i.length, e = true;
            }
          } else 1 === U.length && 36064 === U[0] || (U[0] = 36064, U.length = 1, e = true); else 1 === U.length && 1029 === U[0] || (U[0] = 1029, U.length = 1, e = true);
          e && (K.isWebGL2 ? xt.drawBuffers(U) : Z.get("WEBGL_draw_buffers").drawBuffersWEBGL(U));
        }
        if (Q.viewport(L), Q.scissor(D), Q.setScissorTest(V), r) {
          const n = tt.get(t.texture);
          xt.framebufferTexture2D(36160, 36064, 34069 + e, n.__webglTexture, i);
        } else if (o) {
          const n = tt.get(t.texture), r = e || 0;
          xt.framebufferTextureLayer(36160, 36064, n.__webglTexture, i || 0, r);
        }
        A = -1;
      }, this.readRenderTargetPixels = function (t, e, i, n, r, o, s) {
        if (!t || !t.isWebGLRenderTarget) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
        let a = tt.get(t).__webglFramebuffer;
        if (t.isWebGLCubeRenderTarget && void 0 !== s && (a = a[s]), a) {
          Q.bindFramebuffer(36160, a);
          try {
            const s = t.texture, a = s.format, l = s.type;
            if (a !== T && yt.convert(a) !== xt.getParameter(35739)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
            const c = l === M && (Z.has("EXT_color_buffer_half_float") || K.isWebGL2 && Z.has("EXT_color_buffer_float"));
            if (!(l === v || yt.convert(l) === xt.getParameter(35738) || l === S && (K.isWebGL2 || Z.has("OES_texture_float") || Z.has("WEBGL_color_buffer_float")) || c)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
            36053 === xt.checkFramebufferStatus(36160) ? e >= 0 && e <= t.width - n && i >= 0 && i <= t.height - r && xt.readPixels(e, i, n, r, yt.convert(a), yt.convert(l), o) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.");
          } finally {
            const t = null !== C ? tt.get(C).__webglFramebuffer : null;
            Q.bindFramebuffer(36160, t);
          }
        }
      }, this.copyFramebufferToTexture = function (t, e, i = 0) {
        const n = Math.pow(2, -i), r = Math.floor(e.image.width * n), o = Math.floor(e.image.height * n);
        let s = yt.convert(e.format);
        K.isWebGL2 && (6407 === s && (s = 32849), 6408 === s && (s = 32856)), et.setTexture2D(e, 0), xt.copyTexImage2D(3553, i, s, t.x, t.y, r, o, 0), Q.unbindTexture();
      }, this.copyTextureToTexture = function (t, e, i, n = 0) {
        const r = e.image.width, o = e.image.height, s = yt.convert(i.format), a = yt.convert(i.type);
        et.setTexture2D(i, 0), xt.pixelStorei(37440, i.flipY), xt.pixelStorei(37441, i.premultiplyAlpha), xt.pixelStorei(3317, i.unpackAlignment), e.isDataTexture ? xt.texSubImage2D(3553, n, t.x, t.y, r, o, s, a, e.image.data) : e.isCompressedTexture ? xt.compressedTexSubImage2D(3553, n, t.x, t.y, e.mipmaps[0].width, e.mipmaps[0].height, s, e.mipmaps[0].data) : xt.texSubImage2D(3553, n, t.x, t.y, s, a, e.image), 0 === n && i.generateMipmaps && xt.generateMipmap(3553), Q.unbindTexture();
      }, this.copyTextureToTexture3D = function (t, e, i, n, r = 0) {
        if (y.isWebGL1Renderer) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
        const o = t.max.x - t.min.x + 1, s = t.max.y - t.min.y + 1, a = t.max.z - t.min.z + 1, l = yt.convert(n.format), c = yt.convert(n.type);
        let h;
        if (n.isDataTexture3D) et.setTexture3D(n, 0), h = 32879; else {
          if (!n.isDataTexture2DArray) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
          et.setTexture2DArray(n, 0), h = 35866;
        }
        xt.pixelStorei(37440, n.flipY), xt.pixelStorei(37441, n.premultiplyAlpha), xt.pixelStorei(3317, n.unpackAlignment);
        const u = xt.getParameter(3314), m = xt.getParameter(32878), p = xt.getParameter(3316), d = xt.getParameter(3315), f = xt.getParameter(32877), _ = i.isCompressedTexture ? i.mipmaps[0] : i.image;
        xt.pixelStorei(3314, _.width), xt.pixelStorei(32878, _.height), xt.pixelStorei(3316, t.min.x), xt.pixelStorei(3315, t.min.y), xt.pixelStorei(32877, t.min.z), i.isDataTexture || i.isDataTexture3D ? xt.texSubImage3D(h, r, e.x, e.y, e.z, o, s, a, l, c, _.data) : i.isCompressedTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), xt.compressedTexSubImage3D(h, r, e.x, e.y, e.z, o, s, a, l, _.data)) : xt.texSubImage3D(h, r, e.x, e.y, e.z, o, s, a, l, c, _), xt.pixelStorei(3314, u), xt.pixelStorei(32878, m), xt.pixelStorei(3316, p), xt.pixelStorei(3315, d), xt.pixelStorei(32877, f), 0 === r && n.generateMipmaps && xt.generateMipmap(h), Q.unbindTexture();
      }, this.initTexture = function (t) {
        et.setTexture2D(t, 0), Q.unbindTexture();
      }, this.resetState = function () {
        b = 0, w = 0, C = null, Q.reset(), gt.reset();
      }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {detail: this}));
    }
    (class WebGL1Renderer extends Er {}.prototype.isWebGL1Renderer = true);
    class FogExp2 {
      constructor(t, e = 0.00025) {
        this.name = "", this.color = new three_module_Color(t), this.density = e;
      }
      clone() {
        return new FogExp2(this.color, this.density);
      }
      toJSON() {
        return {type: "FogExp2", color: this.color.getHex(), density: this.density};
      }
    }
    FogExp2.prototype.isFogExp2 = true;
    class Fog {
      constructor(t, e = 1, i = 1e3) {
        this.name = "", this.color = new three_module_Color(t), this.near = e, this.far = i;
      }
      clone() {
        return new Fog(this.color, this.near, this.far);
      }
      toJSON() {
        return {type: "Fog", color: this.color.getHex(), near: this.near, far: this.far};
      }
    }
    Fog.prototype.isFog = true;
    class Scene extends Object3D {
      constructor() {
        super(), this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = true, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {detail: this}));
      }
      copy(t, e) {
        return super.copy(t, e), null !== t.background && (this.background = t.background.clone()), null !== t.environment && (this.environment = t.environment.clone()), null !== t.fog && (this.fog = t.fog.clone()), null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()), this.autoUpdate = t.autoUpdate, this.matrixAutoUpdate = t.matrixAutoUpdate, this;
      }
      toJSON(t) {
        const e = super.toJSON(t);
        return null !== this.fog && (e.object.fog = this.fog.toJSON()), e;
      }
    }
    Scene.prototype.isScene = true;
    class InterleavedBuffer {
      constructor(t, e) {
        this.array = t, this.stride = e, this.count = void 0 !== t ? t.length / e : 0, this.usage = k, this.updateRange = {offset: 0, count: -1}, this.version = 0, this.uuid = q();
      }
      onUploadCallback() {}
      set needsUpdate (t) {
        true === t && this.version++;
      }
      setUsage(t) {
        return this.usage = t, this;
      }
      copy(t) {
        return this.array = new t.array.constructor(t.array), this.count = t.count, this.stride = t.stride, this.usage = t.usage, this;
      }
      copyAt(t, e, i) {
        t *= this.stride, i *= e.stride;
        for (let n = 0, r = this.stride; n < r; n++) this.array[t + n] = e.array[i + n];
        return this;
      }
      set(t, e = 0) {
        return this.array.set(t, e), this;
      }
      clone(t) {
        void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = q()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
        const e = new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]), i = new this.constructor(e, this.stride);
        return i.setUsage(this.usage), i;
      }
      onUpload(t) {
        return this.onUploadCallback = t, this;
      }
      toJSON(t) {
        return void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = q()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))), {uuid: this.uuid, buffer: this.array.buffer._uuid, type: this.array.constructor.name, stride: this.stride};
      }
    }
    InterleavedBuffer.prototype.isInterleavedBuffer = true;
    const Lr = new three_module_Vector3;
    class InterleavedBufferAttribute {
      constructor(t, e, i, n = false) {
        this.name = "", this.data = t, this.itemSize = e, this.offset = i, this.normalized = true === n;
      }
      get count() {
        return this.data.count;
      }
      get array() {
        return this.data.array;
      }
      set needsUpdate (t) {
        this.data.needsUpdate = t;
      }
      applyMatrix4(t) {
        for (let e = 0, i = this.data.count; e < i; e++) Lr.x = this.getX(e), Lr.y = this.getY(e), Lr.z = this.getZ(e), Lr.applyMatrix4(t), this.setXYZ(e, Lr.x, Lr.y, Lr.z);
        return this;
      }
      applyNormalMatrix(t) {
        for (let e = 0, i = this.count; e < i; e++) Lr.x = this.getX(e), Lr.y = this.getY(e), Lr.z = this.getZ(e), Lr.applyNormalMatrix(t), this.setXYZ(e, Lr.x, Lr.y, Lr.z);
        return this;
      }
      transformDirection(t) {
        for (let e = 0, i = this.count; e < i; e++) Lr.x = this.getX(e), Lr.y = this.getY(e), Lr.z = this.getZ(e), Lr.transformDirection(t), this.setXYZ(e, Lr.x, Lr.y, Lr.z);
        return this;
      }
      setX(t, e) {
        return this.data.array[t * this.data.stride + this.offset] = e, this;
      }
      setY(t, e) {
        return this.data.array[t * this.data.stride + this.offset + 1] = e, this;
      }
      setZ(t, e) {
        return this.data.array[t * this.data.stride + this.offset + 2] = e, this;
      }
      setW(t, e) {
        return this.data.array[t * this.data.stride + this.offset + 3] = e, this;
      }
      getX(t) {
        return this.data.array[t * this.data.stride + this.offset];
      }
      getY(t) {
        return this.data.array[t * this.data.stride + this.offset + 1];
      }
      getZ(t) {
        return this.data.array[t * this.data.stride + this.offset + 2];
      }
      getW(t) {
        return this.data.array[t * this.data.stride + this.offset + 3];
      }
      setXY(t, e, i) {
        return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = i, this;
      }
      setXYZ(t, e, i, n) {
        return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = i, this.data.array[t + 2] = n, this;
      }
      setXYZW(t, e, i, n, r) {
        return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = i, this.data.array[t + 2] = n, this.data.array[t + 3] = r, this;
      }
      clone(t) {
        if (void 0 === t) {
          console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
          const t = [];
          for (let e = 0; e < this.count; e++) {
            const i = e * this.data.stride + this.offset;
            for (let e = 0; e < this.itemSize; e++) t.push(this.data.array[i + e]);
          }
          return new BufferAttribute(new this.array.constructor(t), this.itemSize, this.normalized);
        }
        return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)), new InterleavedBufferAttribute(t.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
      }
      toJSON(t) {
        if (void 0 === t) {
          console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
          const t = [];
          for (let e = 0; e < this.count; e++) {
            const i = e * this.data.stride + this.offset;
            for (let e = 0; e < this.itemSize; e++) t.push(this.data.array[i + e]);
          }
          return {itemSize: this.itemSize, type: this.array.constructor.name, array: t, normalized: this.normalized};
        }
        return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)), {isInterleavedBufferAttribute: true, itemSize: this.itemSize, data: this.data.uuid, offset: this.offset, normalized: this.normalized};
      }
    }
    InterleavedBufferAttribute.prototype.isInterleavedBufferAttribute = true;
    class SpriteMaterial extends Material {
      constructor(t) {
        super(), this.type = "SpriteMaterial", this.color = new three_module_Color(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = true, this.transparent = true, this.setValues(t);
      }
      copy(t) {
        return super.copy(t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.rotation = t.rotation, this.sizeAttenuation = t.sizeAttenuation, this;
      }
    }
    let Dr;
    SpriteMaterial.prototype.isSpriteMaterial = true;
    const Vr = new three_module_Vector3, Br = new three_module_Vector3, Rr = new three_module_Vector3, Pr = new Vector2, Ir = new Vector2, Fr = new Matrix4, Gr = new three_module_Vector3, Nr = new three_module_Vector3, zr = new three_module_Vector3, Or = new Vector2, Ur = new Vector2, kr = new Vector2;
    class Sprite extends Object3D {
      constructor(t) {
        if (super(), this.type = "Sprite", void 0 === Dr) {
          Dr = new BufferGeometry;
          const t = new Float32Array([-0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1]), e = new InterleavedBuffer(t, 5);
          Dr.setIndex([0, 1, 2, 0, 2, 3]), Dr.setAttribute("position", new InterleavedBufferAttribute(e, 3, 0, false)), Dr.setAttribute("uv", new InterleavedBufferAttribute(e, 2, 3, false));
        }
        this.geometry = Dr, this.material = void 0 !== t ? t : new SpriteMaterial, this.center = new Vector2(0.5, 0.5);
      }
      raycast(t, e) {
        null === t.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), Br.setFromMatrixScale(this.matrixWorld), Fr.copy(t.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse, this.matrixWorld), Rr.setFromMatrixPosition(this.modelViewMatrix), t.camera.isPerspectiveCamera && false === this.material.sizeAttenuation && Br.multiplyScalar(-Rr.z);
        const i = this.material.rotation;
        let n, r;
        0 !== i && (r = Math.cos(i), n = Math.sin(i));
        const o = this.center;
        Hr(Gr.set(-0.5, -0.5, 0), Rr, o, Br, n, r), Hr(Nr.set(0.5, -0.5, 0), Rr, o, Br, n, r), Hr(zr.set(0.5, 0.5, 0), Rr, o, Br, n, r), Or.set(0, 0), Ur.set(1, 0), kr.set(1, 1);
        let s = t.ray.intersectTriangle(Gr, Nr, zr, false, Vr);
        if (null === s && (Hr(Nr.set(-0.5, 0.5, 0), Rr, o, Br, n, r), Ur.set(0, 1), s = t.ray.intersectTriangle(Gr, zr, Nr, false, Vr), null === s)) return;
        const a = t.ray.origin.distanceTo(Vr);
        a < t.near || a > t.far || e.push({distance: a, point: Vr.clone(), uv: Triangle.getUV(Vr, Gr, Nr, zr, Or, Ur, kr, new Vector2), face: null, object: this});
      }
      copy(t) {
        return super.copy(t), void 0 !== t.center && this.center.copy(t.center), this.material = t.material, this;
      }
    }
    function Hr(t, e, i, n, r, o) {
      Pr.subVectors(t, i).addScalar(0.5).multiply(n), void 0 !== r ? (Ir.x = o * Pr.x - r * Pr.y, Ir.y = r * Pr.x + o * Pr.y) : Ir.copy(Pr), t.copy(e), t.x += Ir.x, t.y += Ir.y, t.applyMatrix4(Fr);
    }
    Sprite.prototype.isSprite = true;
    const Wr = new three_module_Vector3, Jr = new Vector4, jr = new Vector4, Xr = new three_module_Vector3, qr = new Matrix4;
    class SkinnedMesh extends Mesh {
      constructor(t, e) {
        super(t, e), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new Matrix4, this.bindMatrixInverse = new Matrix4;
      }
      copy(t) {
        return super.copy(t), this.bindMode = t.bindMode, this.bindMatrix.copy(t.bindMatrix), this.bindMatrixInverse.copy(t.bindMatrixInverse), this.skeleton = t.skeleton, this;
      }
      bind(t, e) {
        this.skeleton = t, void 0 === e && (this.updateMatrixWorld(true), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.copy(e).invert();
      }
      pose() {
        this.skeleton.pose();
      }
      normalizeSkinWeights() {
        const t = new Vector4, e = this.geometry.attributes.skinWeight;
        for (let i = 0, n = e.count; i < n; i++) {
          t.x = e.getX(i), t.y = e.getY(i), t.z = e.getZ(i), t.w = e.getW(i);
          const n = 1 / t.manhattanLength();
          n !== Infinity ? t.multiplyScalar(n) : t.set(1, 0, 0, 0), e.setXYZW(i, t.x, t.y, t.z, t.w);
        }
      }
      updateMatrixWorld(t) {
        super.updateMatrixWorld(t), "attached" === this.bindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
      }
      boneTransform(t, e) {
        const i = this.skeleton, n = this.geometry;
        Jr.fromBufferAttribute(n.attributes.skinIndex, t), jr.fromBufferAttribute(n.attributes.skinWeight, t), Wr.fromBufferAttribute(n.attributes.position, t).applyMatrix4(this.bindMatrix), e.set(0, 0, 0);
        for (let t = 0; t < 4; t++) {
          const n = jr.getComponent(t);
          if (0 !== n) {
            const r = Jr.getComponent(t);
            qr.multiplyMatrices(i.bones[r].matrixWorld, i.boneInverses[r]), e.addScaledVector(Xr.copy(Wr).applyMatrix4(qr), n);
          }
        }
        return e.applyMatrix4(this.bindMatrixInverse);
      }
    }
    SkinnedMesh.prototype.isSkinnedMesh = true;
    class Bone extends Object3D {
      constructor() {
        super(), this.type = "Bone";
      }
    }
    Bone.prototype.isBone = true;
    class DataTexture extends Texture {
      constructor(t = null, e = 1, i = 1, n, r, o, s, a, l = 1003, c = 1003, h, u) {
        super(null, o, s, a, l, c, n, r, h, u), this.image = {data: t, width: e, height: i}, this.magFilter = l, this.minFilter = c, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1, this.needsUpdate = true;
      }
    }
    DataTexture.prototype.isDataTexture = true;
    class InstancedBufferAttribute extends BufferAttribute {
      constructor(t, e, i, n = 1) {
        "number" == typeof i && (n = i, i = false, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), super(t, e, i), this.meshPerAttribute = n;
      }
      copy(t) {
        return super.copy(t), this.meshPerAttribute = t.meshPerAttribute, this;
      }
      toJSON() {
        const t = super.toJSON();
        return t.meshPerAttribute = this.meshPerAttribute, t.isInstancedBufferAttribute = true, t;
      }
    }
    InstancedBufferAttribute.prototype.isInstancedBufferAttribute = true;
    const Yr = new Matrix4, Zr = new Matrix4, Kr = [], Qr = new Mesh;
    class InstancedMesh extends Mesh {
      constructor(t, e, i) {
        super(t, e), this.instanceMatrix = new InstancedBufferAttribute(new Float32Array(16 * i), 16), this.instanceColor = null, this.count = i, this.frustumCulled = false;
      }
      copy(t) {
        return super.copy(t), this.instanceMatrix.copy(t.instanceMatrix), null !== t.instanceColor && (this.instanceColor = t.instanceColor.clone()), this.count = t.count, this;
      }
      getColorAt(t, e) {
        e.fromArray(this.instanceColor.array, 3 * t);
      }
      getMatrixAt(t, e) {
        e.fromArray(this.instanceMatrix.array, 16 * t);
      }
      raycast(t, e) {
        const i = this.matrixWorld, n = this.count;
        if (Qr.geometry = this.geometry, Qr.material = this.material, void 0 !== Qr.material) for (let r = 0; r < n; r++) {
          this.getMatrixAt(r, Yr), Zr.multiplyMatrices(i, Yr), Qr.matrixWorld = Zr, Qr.raycast(t, Kr);
          for (let t = 0, i = Kr.length; t < i; t++) {
            const i = Kr[t];
            i.instanceId = r, i.object = this, e.push(i);
          }
          Kr.length = 0;
        }
      }
      setColorAt(t, e) {
        null === this.instanceColor && (this.instanceColor = new InstancedBufferAttribute(new Float32Array(3 * this.instanceMatrix.count), 3)), e.toArray(this.instanceColor.array, 3 * t);
      }
      setMatrixAt(t, e) {
        e.toArray(this.instanceMatrix.array, 16 * t);
      }
      updateMorphTargets() {}
      dispose() {
        this.dispatchEvent({type: "dispose"});
      }
    }
    InstancedMesh.prototype.isInstancedMesh = true;
    class LineBasicMaterial extends Material {
      constructor(t) {
        super(), this.type = "LineBasicMaterial", this.color = new three_module_Color(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.setValues(t);
      }
      copy(t) {
        return super.copy(t), this.color.copy(t.color), this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this;
      }
    }
    LineBasicMaterial.prototype.isLineBasicMaterial = true;
    const $r = new three_module_Vector3, to = new three_module_Vector3, eo = new Matrix4, io = new Ray, no = new Sphere;
    class Line extends Object3D {
      constructor(t = new BufferGeometry, e = new LineBasicMaterial) {
        super(), this.type = "Line", this.geometry = t, this.material = e, this.updateMorphTargets();
      }
      copy(t) {
        return super.copy(t), this.material = t.material, this.geometry = t.geometry, this;
      }
      computeLineDistances() {
        const t = this.geometry;
        if (t.isBufferGeometry) if (null === t.index) {
          const e = t.attributes.position, i = [0];
          for (let t = 1, n = e.count; t < n; t++) $r.fromBufferAttribute(e, t - 1), to.fromBufferAttribute(e, t), i[t] = i[t - 1], i[t] += $r.distanceTo(to);
          t.setAttribute("lineDistance", new Float32BufferAttribute(i, 1));
        } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); else t.isGeometry && console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
        return this;
      }
      raycast(t, e) {
        const i = this.geometry, n = this.matrixWorld, r = t.params.Line.threshold, o = i.drawRange;
        if (null === i.boundingSphere && i.computeBoundingSphere(), no.copy(i.boundingSphere), no.applyMatrix4(n), no.radius += r, false === t.ray.intersectsSphere(no)) return;
        eo.copy(n).invert(), io.copy(t.ray).applyMatrix4(eo);
        const s = r / ((this.scale.x + this.scale.y + this.scale.z) / 3), a = s * s, l = new three_module_Vector3, c = new three_module_Vector3, h = new three_module_Vector3, u = new three_module_Vector3, m = this.isLineSegments ? 2 : 1;
        if (i.isBufferGeometry) {
          const n = i.index, r = i.attributes.position;
          if (null !== n) {
            for (let i = Math.max(0, o.start), s = Math.min(n.count, o.start + o.count) - 1; i < s; i += m) {
              const o = n.getX(i), s = n.getX(i + 1);
              l.fromBufferAttribute(r, o), c.fromBufferAttribute(r, s);
              if (io.distanceSqToSegment(l, c, u, h) > a) continue;
              u.applyMatrix4(this.matrixWorld);
              const m = t.ray.origin.distanceTo(u);
              m < t.near || m > t.far || e.push({distance: m, point: h.clone().applyMatrix4(this.matrixWorld), index: i, face: null, faceIndex: null, object: this});
            }
          } else {
            for (let i = Math.max(0, o.start), n = Math.min(r.count, o.start + o.count) - 1; i < n; i += m) {
              l.fromBufferAttribute(r, i), c.fromBufferAttribute(r, i + 1);
              if (io.distanceSqToSegment(l, c, u, h) > a) continue;
              u.applyMatrix4(this.matrixWorld);
              const n = t.ray.origin.distanceTo(u);
              n < t.near || n > t.far || e.push({distance: n, point: h.clone().applyMatrix4(this.matrixWorld), index: i, face: null, faceIndex: null, object: this});
            }
          }
        } else i.isGeometry && console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
      updateMorphTargets() {
        const t = this.geometry;
        if (t.isBufferGeometry) {
          const e = t.morphAttributes, i = Object.keys(e);
          if (i.length > 0) {
            const t = e[i[0]];
            if (void 0 !== t) {
              this.morphTargetInfluences = [], this.morphTargetDictionary = {};
              for (let e = 0, i = t.length; e < i; e++) {
                const i = t[e].name || String(e);
                this.morphTargetInfluences.push(0), this.morphTargetDictionary[i] = e;
              }
            }
          }
        } else {
          const e = t.morphTargets;
          void 0 !== e && e.length > 0 && console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
        }
      }
    }
    Line.prototype.isLine = true;
    const ro = new three_module_Vector3, oo = new three_module_Vector3;
    class LineSegments extends Line {
      constructor(t, e) {
        super(t, e), this.type = "LineSegments";
      }
      computeLineDistances() {
        const t = this.geometry;
        if (t.isBufferGeometry) if (null === t.index) {
          const e = t.attributes.position, i = [];
          for (let t = 0, n = e.count; t < n; t += 2) ro.fromBufferAttribute(e, t), oo.fromBufferAttribute(e, t + 1), i[t] = 0 === t ? 0 : i[t - 1], i[t + 1] = i[t] + ro.distanceTo(oo);
          t.setAttribute("lineDistance", new Float32BufferAttribute(i, 1));
        } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); else t.isGeometry && console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
        return this;
      }
    }
    LineSegments.prototype.isLineSegments = true;
    class LineLoop extends Line {
      constructor(t, e) {
        super(t, e), this.type = "LineLoop";
      }
    }
    LineLoop.prototype.isLineLoop = true;
    class PointsMaterial extends Material {
      constructor(t) {
        super(), this.type = "PointsMaterial", this.color = new three_module_Color(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = true, this.setValues(t);
      }
      copy(t) {
        return super.copy(t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this;
      }
    }
    PointsMaterial.prototype.isPointsMaterial = true;
    const so = new Matrix4, ao = new Ray, lo = new Sphere, co = new three_module_Vector3;
    class Points extends Object3D {
      constructor(t = new BufferGeometry, e = new PointsMaterial) {
        super(), this.type = "Points", this.geometry = t, this.material = e, this.updateMorphTargets();
      }
      copy(t) {
        return super.copy(t), this.material = t.material, this.geometry = t.geometry, this;
      }
      raycast(t, e) {
        const i = this.geometry, n = this.matrixWorld, r = t.params.Points.threshold, o = i.drawRange;
        if (null === i.boundingSphere && i.computeBoundingSphere(), lo.copy(i.boundingSphere), lo.applyMatrix4(n), lo.radius += r, false === t.ray.intersectsSphere(lo)) return;
        so.copy(n).invert(), ao.copy(t.ray).applyMatrix4(so);
        const s = r / ((this.scale.x + this.scale.y + this.scale.z) / 3), a = s * s;
        if (i.isBufferGeometry) {
          const r = i.index, s = i.attributes.position;
          if (null !== r) {
            for (let i = Math.max(0, o.start), l = Math.min(r.count, o.start + o.count); i < l; i++) {
              const o = r.getX(i);
              co.fromBufferAttribute(s, o), ho(co, o, a, n, t, e, this);
            }
          } else {
            for (let i = Math.max(0, o.start), r = Math.min(s.count, o.start + o.count); i < r; i++) co.fromBufferAttribute(s, i), ho(co, i, a, n, t, e, this);
          }
        } else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
      updateMorphTargets() {
        const t = this.geometry;
        if (t.isBufferGeometry) {
          const e = t.morphAttributes, i = Object.keys(e);
          if (i.length > 0) {
            const t = e[i[0]];
            if (void 0 !== t) {
              this.morphTargetInfluences = [], this.morphTargetDictionary = {};
              for (let e = 0, i = t.length; e < i; e++) {
                const i = t[e].name || String(e);
                this.morphTargetInfluences.push(0), this.morphTargetDictionary[i] = e;
              }
            }
          }
        } else {
          const e = t.morphTargets;
          void 0 !== e && e.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
        }
      }
    }
    function ho(t, e, i, n, r, o, s) {
      const a = ao.distanceSqToPoint(t);
      if (a < i) {
        const i = new three_module_Vector3;
        ao.closestPointToPoint(t, i), i.applyMatrix4(n);
        const l = r.ray.origin.distanceTo(i);
        if (l < r.near || l > r.far) return;
        o.push({distance: l, distanceToRay: Math.sqrt(a), point: i, index: e, face: null, object: s});
      }
    }
    Points.prototype.isPoints = true;
    (class VideoTexture extends Texture {
      constructor(t, e, i, n, r, o, s, a, l) {
        super(t, e, i, n, r, o, s, a, l), this.format = void 0 !== s ? s : A, this.minFilter = void 0 !== o ? o : g, this.magFilter = void 0 !== r ? r : g, this.generateMipmaps = false;
        const c = this;
        "requestVideoFrameCallback" in t && t.requestVideoFrameCallback(function e() {
          c.needsUpdate = true, t.requestVideoFrameCallback(e);
        });
      }
      clone() {
        return new this.constructor(this.image).copy(this);
      }
      update() {
        const t = this.image;
        false === "requestVideoFrameCallback" in t && t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = true);
      }
    }.prototype.isVideoTexture = true);
    class CompressedTexture extends Texture {
      constructor(t, e, i, n, r, o, s, a, l, c, h, u) {
        super(null, o, s, a, l, c, n, r, h, u), this.image = {width: e, height: i}, this.mipmaps = t, this.flipY = false, this.generateMipmaps = false;
      }
    }
    CompressedTexture.prototype.isCompressedTexture = true;
    (class CanvasTexture extends Texture {
      constructor(t, e, i, n, r, o, s, a, l) {
        super(t, e, i, n, r, o, s, a, l), this.needsUpdate = true;
      }
    }.prototype.isCanvasTexture = true);
    (class DepthTexture extends Texture {
      constructor(t, e, i, n, r, o, s, a, l, c) {
        if ((c = void 0 !== c ? c : E) !== E && c !== L) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        void 0 === i && c === E && (i = b), void 0 === i && c === L && (i = C), super(null, n, r, o, s, a, c, i, l), this.image = {width: t, height: e}, this.magFilter = void 0 !== s ? s : f, this.minFilter = void 0 !== a ? a : f, this.flipY = false, this.generateMipmaps = false;
      }
    }.prototype.isDepthTexture = true);
    new three_module_Vector3, new three_module_Vector3, new three_module_Vector3, new Triangle;
    class Curve {
      constructor() {
        this.type = "Curve", this.arcLengthDivisions = 200;
      }
      getPoint() {
        return console.warn("THREE.Curve: .getPoint() not implemented."), null;
      }
      getPointAt(t, e) {
        const i = this.getUtoTmapping(t);
        return this.getPoint(i, e);
      }
      getPoints(t = 5) {
        const e = [];
        for (let i = 0; i <= t; i++) e.push(this.getPoint(i / t));
        return e;
      }
      getSpacedPoints(t = 5) {
        const e = [];
        for (let i = 0; i <= t; i++) e.push(this.getPointAt(i / t));
        return e;
      }
      getLength() {
        const t = this.getLengths();
        return t[t.length - 1];
      }
      getLengths(t = this.arcLengthDivisions) {
        if (this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this.cacheArcLengths;
        this.needsUpdate = false;
        const e = [];
        let i, n = this.getPoint(0), r = 0;
        e.push(0);
        for (let o = 1; o <= t; o++) i = this.getPoint(o / t), r += i.distanceTo(n), e.push(r), n = i;
        return this.cacheArcLengths = e, e;
      }
      updateArcLengths() {
        this.needsUpdate = true, this.getLengths();
      }
      getUtoTmapping(t, e) {
        const i = this.getLengths();
        let n = 0;
        const r = i.length;
        let o;
        o = e || t * i[r - 1];
        let s, a = 0, l = r - 1;
        for (; a <= l;) if (n = Math.floor(a + (l - a) / 2), s = i[n] - o, s < 0) a = n + 1; else {
          if (!(s > 0)) {
            l = n;
            break;
          }
          l = n - 1;
        }
        if (n = l, i[n] === o) return n / (r - 1);
        const c = i[n];
        return (n + (o - c) / (i[n + 1] - c)) / (r - 1);
      }
      getTangent(t, e) {
        const i = 0.0001;
        let n = t - i, r = t + i;
        n < 0 && (n = 0), r > 1 && (r = 1);
        const o = this.getPoint(n), s = this.getPoint(r), a = e || (o.isVector2 ? new Vector2 : new three_module_Vector3);
        return a.copy(s).sub(o).normalize(), a;
      }
      getTangentAt(t, e) {
        const i = this.getUtoTmapping(t);
        return this.getTangent(i, e);
      }
      computeFrenetFrames(t, e) {
        const i = new three_module_Vector3, n = [], r = [], o = [], s = new three_module_Vector3, a = new Matrix4;
        for (let e = 0; e <= t; e++) {
          const i = e / t;
          n[e] = this.getTangentAt(i, new three_module_Vector3), n[e].normalize();
        }
        r[0] = new three_module_Vector3, o[0] = new three_module_Vector3;
        let l = Number.MAX_VALUE;
        const c = Math.abs(n[0].x), h = Math.abs(n[0].y), u = Math.abs(n[0].z);
        c <= l && (l = c, i.set(1, 0, 0)), h <= l && (l = h, i.set(0, 1, 0)), u <= l && i.set(0, 0, 1), s.crossVectors(n[0], i).normalize(), r[0].crossVectors(n[0], s), o[0].crossVectors(n[0], r[0]);
        for (let e = 1; e <= t; e++) {
          if (r[e] = r[e - 1].clone(), o[e] = o[e - 1].clone(), s.crossVectors(n[e - 1], n[e]), s.length() > Number.EPSILON) {
            s.normalize();
            const t = Math.acos(Math.max(-1, Math.min(1, n[e - 1].dot(n[e]))));
            r[e].applyMatrix4(a.makeRotationAxis(s, t));
          }
          o[e].crossVectors(n[e], r[e]);
        }
        if (true === e) {
          let e = Math.acos(Math.max(-1, Math.min(1, r[0].dot(r[t]))));
          e /= t, n[0].dot(s.crossVectors(r[0], r[t])) > 0 && (e = -e);
          for (let i = 1; i <= t; i++) r[i].applyMatrix4(a.makeRotationAxis(n[i], e * i)), o[i].crossVectors(n[i], r[i]);
        }
        return {tangents: n, normals: r, binormals: o};
      }
      clone() {
        return (new this.constructor).copy(this);
      }
      copy(t) {
        return this.arcLengthDivisions = t.arcLengthDivisions, this;
      }
      toJSON() {
        const t = {metadata: {version: 4.5, type: "Curve", generator: "Curve.toJSON"}};
        return t.arcLengthDivisions = this.arcLengthDivisions, t.type = this.type, t;
      }
      fromJSON(t) {
        return this.arcLengthDivisions = t.arcLengthDivisions, this;
      }
    }
    class EllipseCurve extends Curve {
      constructor(t = 0, e = 0, i = 1, n = 1, r = 0, o = 2 * Math.PI, s = false, a = 0) {
        super(), this.type = "EllipseCurve", this.aX = t, this.aY = e, this.xRadius = i, this.yRadius = n, this.aStartAngle = r, this.aEndAngle = o, this.aClockwise = s, this.aRotation = a;
      }
      getPoint(t, e) {
        const i = e || new Vector2, n = 2 * Math.PI;
        let r = this.aEndAngle - this.aStartAngle;
        const o = Math.abs(r) < Number.EPSILON;
        for (; r < 0;) r += n;
        for (; r > n;) r -= n;
        r < Number.EPSILON && (r = o ? 0 : n), true !== this.aClockwise || o || (r === n ? r = -n : r -= n);
        const s = this.aStartAngle + t * r;
        let a = this.aX + this.xRadius * Math.cos(s), l = this.aY + this.yRadius * Math.sin(s);
        if (0 !== this.aRotation) {
          const t = Math.cos(this.aRotation), e = Math.sin(this.aRotation), i = a - this.aX, n = l - this.aY;
          a = i * t - n * e + this.aX, l = i * e + n * t + this.aY;
        }
        return i.set(a, l);
      }
      copy(t) {
        return super.copy(t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this;
      }
      toJSON() {
        const t = super.toJSON();
        return t.aX = this.aX, t.aY = this.aY, t.xRadius = this.xRadius, t.yRadius = this.yRadius, t.aStartAngle = this.aStartAngle, t.aEndAngle = this.aEndAngle, t.aClockwise = this.aClockwise, t.aRotation = this.aRotation, t;
      }
      fromJSON(t) {
        return super.fromJSON(t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this;
      }
    }
    EllipseCurve.prototype.isEllipseCurve = true;
    class ArcCurve extends EllipseCurve {
      constructor(t, e, i, n, r, o) {
        super(t, e, i, i, n, r, o), this.type = "ArcCurve";
      }
    }
    function uo() {
      let t = 0, e = 0, i = 0, n = 0;
      function r(r, o, s, a) {
        t = r, e = s, i = -3 * r + 3 * o - 2 * s - a, n = 2 * r - 2 * o + s + a;
      }
      return {initCatmullRom: function (t, e, i, n, o) {
        r(e, i, o * (i - t), o * (n - e));
      }, initNonuniformCatmullRom: function (t, e, i, n, o, s, a) {
        let l = (e - t) / o - (i - t) / (o + s) + (i - e) / s, c = (i - e) / s - (n - e) / (s + a) + (n - i) / a;
        l *= s, c *= s, r(e, i, l, c);
      }, calc: function (r) {
        const o = r * r;
        return t + e * r + i * o + n * (o * r);
      }};
    }
    ArcCurve.prototype.isArcCurve = true;
    const mo = new three_module_Vector3, po = new uo, fo = new uo, _o = new uo;
    class CatmullRomCurve3 extends Curve {
      constructor(t = [], e = false, i = "centripetal", n = 0.5) {
        super(), this.type = "CatmullRomCurve3", this.points = t, this.closed = e, this.curveType = i, this.tension = n;
      }
      getPoint(t, e = new three_module_Vector3) {
        const i = e, n = this.points, r = n.length, o = (r - (this.closed ? 0 : 1)) * t;
        let s, a, l = Math.floor(o), c = o - l;
        this.closed ? l += l > 0 ? 0 : (Math.floor(Math.abs(l) / r) + 1) * r : 0 === c && l === r - 1 && (l = r - 2, c = 1), this.closed || l > 0 ? s = n[(l - 1) % r] : (mo.subVectors(n[0], n[1]).add(n[0]), s = mo);
        const h = n[l % r], u = n[(l + 1) % r];
        if (this.closed || l + 2 < r ? a = n[(l + 2) % r] : (mo.subVectors(n[r - 1], n[r - 2]).add(n[r - 1]), a = mo), "centripetal" === this.curveType || "chordal" === this.curveType) {
          const t = "chordal" === this.curveType ? 0.5 : 0.25;
          let e = Math.pow(s.distanceToSquared(h), t), i = Math.pow(h.distanceToSquared(u), t), n = Math.pow(u.distanceToSquared(a), t);
          i < 0.0001 && (i = 1), e < 0.0001 && (e = i), n < 0.0001 && (n = i), po.initNonuniformCatmullRom(s.x, h.x, u.x, a.x, e, i, n), fo.initNonuniformCatmullRom(s.y, h.y, u.y, a.y, e, i, n), _o.initNonuniformCatmullRom(s.z, h.z, u.z, a.z, e, i, n);
        } else "catmullrom" === this.curveType && (po.initCatmullRom(s.x, h.x, u.x, a.x, this.tension), fo.initCatmullRom(s.y, h.y, u.y, a.y, this.tension), _o.initCatmullRom(s.z, h.z, u.z, a.z, this.tension));
        return i.set(po.calc(c), fo.calc(c), _o.calc(c)), i;
      }
      copy(t) {
        super.copy(t), this.points = [];
        for (let e = 0, i = t.points.length; e < i; e++) {
          const i = t.points[e];
          this.points.push(i.clone());
        }
        return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this;
      }
      toJSON() {
        const t = super.toJSON();
        t.points = [];
        for (let e = 0, i = this.points.length; e < i; e++) {
          const i = this.points[e];
          t.points.push(i.toArray());
        }
        return t.closed = this.closed, t.curveType = this.curveType, t.tension = this.tension, t;
      }
      fromJSON(t) {
        super.fromJSON(t), this.points = [];
        for (let e = 0, i = t.points.length; e < i; e++) {
          const i = t.points[e];
          this.points.push((new three_module_Vector3).fromArray(i));
        }
        return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this;
      }
    }
    function yo(t, e, i, n, r) {
      const o = 0.5 * (n - e), s = 0.5 * (r - i), a = t * t;
      return (2 * i - 2 * n + o + s) * (t * a) + (-3 * i + 3 * n - 2 * o - s) * a + o * t + i;
    }
    function go(t, e, i, n) {
      return function (t, e) {
        const i = 1 - t;
        return i * i * e;
      }(t, e) + function (t, e) {
        return 2 * (1 - t) * t * e;
      }(t, i) + function (t, e) {
        return t * t * e;
      }(t, n);
    }
    function xo(t, e, i, n, r) {
      return function (t, e) {
        const i = 1 - t;
        return i * i * i * e;
      }(t, e) + function (t, e) {
        const i = 1 - t;
        return 3 * i * i * t * e;
      }(t, i) + function (t, e) {
        return 3 * (1 - t) * t * t * e;
      }(t, n) + function (t, e) {
        return t * t * t * e;
      }(t, r);
    }
    CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;
    class CubicBezierCurve extends Curve {
      constructor(t = new Vector2, e = new Vector2, i = new Vector2, n = new Vector2) {
        super(), this.type = "CubicBezierCurve", this.v0 = t, this.v1 = e, this.v2 = i, this.v3 = n;
      }
      getPoint(t, e = new Vector2) {
        const i = e, n = this.v0, r = this.v1, o = this.v2, s = this.v3;
        return i.set(xo(t, n.x, r.x, o.x, s.x), xo(t, n.y, r.y, o.y, s.y)), i;
      }
      copy(t) {
        return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this;
      }
      toJSON() {
        const t = super.toJSON();
        return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t;
      }
      fromJSON(t) {
        return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this;
      }
    }
    CubicBezierCurve.prototype.isCubicBezierCurve = true;
    class CubicBezierCurve3 extends Curve {
      constructor(t = new three_module_Vector3, e = new three_module_Vector3, i = new three_module_Vector3, n = new three_module_Vector3) {
        super(), this.type = "CubicBezierCurve3", this.v0 = t, this.v1 = e, this.v2 = i, this.v3 = n;
      }
      getPoint(t, e = new three_module_Vector3) {
        const i = e, n = this.v0, r = this.v1, o = this.v2, s = this.v3;
        return i.set(xo(t, n.x, r.x, o.x, s.x), xo(t, n.y, r.y, o.y, s.y), xo(t, n.z, r.z, o.z, s.z)), i;
      }
      copy(t) {
        return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this;
      }
      toJSON() {
        const t = super.toJSON();
        return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t;
      }
      fromJSON(t) {
        return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this;
      }
    }
    CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;
    class LineCurve extends Curve {
      constructor(t = new Vector2, e = new Vector2) {
        super(), this.type = "LineCurve", this.v1 = t, this.v2 = e;
      }
      getPoint(t, e = new Vector2) {
        const i = e;
        return 1 === t ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(t).add(this.v1)), i;
      }
      getPointAt(t, e) {
        return this.getPoint(t, e);
      }
      getTangent(t, e) {
        const i = e || new Vector2;
        return i.copy(this.v2).sub(this.v1).normalize(), i;
      }
      copy(t) {
        return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
      }
      toJSON() {
        const t = super.toJSON();
        return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t;
      }
      fromJSON(t) {
        return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
      }
    }
    LineCurve.prototype.isLineCurve = true;
    class QuadraticBezierCurve extends Curve {
      constructor(t = new Vector2, e = new Vector2, i = new Vector2) {
        super(), this.type = "QuadraticBezierCurve", this.v0 = t, this.v1 = e, this.v2 = i;
      }
      getPoint(t, e = new Vector2) {
        const i = e, n = this.v0, r = this.v1, o = this.v2;
        return i.set(go(t, n.x, r.x, o.x), go(t, n.y, r.y, o.y)), i;
      }
      copy(t) {
        return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
      }
      toJSON() {
        const t = super.toJSON();
        return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t;
      }
      fromJSON(t) {
        return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
      }
    }
    QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;
    class QuadraticBezierCurve3 extends Curve {
      constructor(t = new three_module_Vector3, e = new three_module_Vector3, i = new three_module_Vector3) {
        super(), this.type = "QuadraticBezierCurve3", this.v0 = t, this.v1 = e, this.v2 = i;
      }
      getPoint(t, e = new three_module_Vector3) {
        const i = e, n = this.v0, r = this.v1, o = this.v2;
        return i.set(go(t, n.x, r.x, o.x), go(t, n.y, r.y, o.y), go(t, n.z, r.z, o.z)), i;
      }
      copy(t) {
        return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
      }
      toJSON() {
        const t = super.toJSON();
        return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t;
      }
      fromJSON(t) {
        return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
      }
    }
    QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;
    class SplineCurve extends Curve {
      constructor(t = []) {
        super(), this.type = "SplineCurve", this.points = t;
      }
      getPoint(t, e = new Vector2) {
        const i = e, n = this.points, r = (n.length - 1) * t, o = Math.floor(r), s = r - o, a = n[0 === o ? o : o - 1], l = n[o], c = n[o > n.length - 2 ? n.length - 1 : o + 1], h = n[o > n.length - 3 ? n.length - 1 : o + 2];
        return i.set(yo(s, a.x, l.x, c.x, h.x), yo(s, a.y, l.y, c.y, h.y)), i;
      }
      copy(t) {
        super.copy(t), this.points = [];
        for (let e = 0, i = t.points.length; e < i; e++) {
          const i = t.points[e];
          this.points.push(i.clone());
        }
        return this;
      }
      toJSON() {
        const t = super.toJSON();
        t.points = [];
        for (let e = 0, i = this.points.length; e < i; e++) {
          const i = this.points[e];
          t.points.push(i.toArray());
        }
        return t;
      }
      fromJSON(t) {
        super.fromJSON(t), this.points = [];
        for (let e = 0, i = t.points.length; e < i; e++) {
          const i = t.points[e];
          this.points.push((new Vector2).fromArray(i));
        }
        return this;
      }
    }
    SplineCurve.prototype.isSplineCurve = true;
    var vo = Object.freeze({__proto__: null, ArcCurve, CatmullRomCurve3, CubicBezierCurve, CubicBezierCurve3, EllipseCurve, LineCurve, LineCurve3: class LineCurve3 extends Curve {
      constructor(t = new three_module_Vector3, e = new three_module_Vector3) {
        super(), this.type = "LineCurve3", this.isLineCurve3 = true, this.v1 = t, this.v2 = e;
      }
      getPoint(t, e = new three_module_Vector3) {
        const i = e;
        return 1 === t ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(t).add(this.v1)), i;
      }
      getPointAt(t, e) {
        return this.getPoint(t, e);
      }
      copy(t) {
        return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
      }
      toJSON() {
        const t = super.toJSON();
        return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t;
      }
      fromJSON(t) {
        return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
      }
    }, QuadraticBezierCurve, QuadraticBezierCurve3, SplineCurve});
    const bo = function (t, e, i = 2) {
      const n = e && e.length, r = n ? e[0] * i : t.length;
      let o = wo(t, 0, r, i, true);
      const s = [];
      if (!o || o.next === o.prev) return s;
      let a, l, c, h, u, m, p;
      if (n && (o = function (t, e, i, n) {
        const r = [];
        let o, s, a, l, c;
        for (o = 0, s = e.length; o < s; o++) a = e[o] * n, l = o < s - 1 ? e[o + 1] * n : t.length, c = wo(t, a, l, n, false), c === c.next && (c.steiner = true), r.push(Ro(c));
        for (r.sort(Lo), o = 0; o < r.length; o++) Do(r[o], i), i = So(i, i.next);
        return i;
      }(t, e, o, i)), t.length > 80 * i) {
        a = c = t[0], l = h = t[1];
        for (let e = i; e < r; e += i) u = t[e], m = t[e + 1], u < a && (a = u), m < l && (l = m), u > c && (c = u), m > h && (h = m);
        p = Math.max(c - a, h - l), p = 0 !== p ? 1 / p : 0;
      }
      return Mo(o, s, i, a, l, p), s;
    };
    function wo(t, e, i, n, r) {
      let o, s;
      if (r === function (t, e, i, n) {
        let r = 0;
        for (let o = e, s = i - n; o < i; o += n) r += (t[s] - t[o]) * (t[o + 1] + t[s + 1]), s = o;
        return r;
      }(t, e, i, n) > 0) for (o = e; o < i; o += n) s = Ho(o, t[o], t[o + 1], s); else for (o = i - n; o >= e; o -= n) s = Ho(o, t[o], t[o + 1], s);
      return s && (s.x === s.next.x && s.y === s.next.y) && (Wo(s), s = s.next), s;
    }
    function So(t, e) {
      if (!t) return t;
      e || (e = t);
      let i, n = t;
      do {
        if (i = false, n.steiner || !(n.x === n.next.x && n.y === n.next.y) && 0 !== (n.y - n.prev.y) * (n.next.x - n.x) - (n.x - n.prev.x) * (n.next.y - n.y)) n = n.next; else {
          if (Wo(n), n = e = n.prev, n === n.next) break;
          i = true;
        }
      } while (i || n !== e);
      return e;
    }
    function Mo(t, e, i, n, r, o, s) {
      if (!t) return;
      !s && o && function (t, e, i, n) {
        let r = t;
        do {
          null === r.z && (r.z = (r.x = 1431655765 & ((r.x = 858993459 & ((r.x = 252645135 & ((r.x = 16711935 & ((r.x = 32767 * (r.x - e) * n) | r.x << 8)) | r.x << 4)) | r.x << 2)) | r.x << 1)) | (r.y = 1431655765 & ((r.y = 858993459 & ((r.y = 252645135 & ((r.y = 16711935 & ((r.y = 32767 * (r.y - i) * n) | r.y << 8)) | r.y << 4)) | r.y << 2)) | r.y << 1)) << 1), r.prevZ = r.prev, r.nextZ = r.next, r = r.next;
        } while (r !== t);
        r.prevZ.nextZ = null, r.prevZ = null, function (t) {
          let e, i, n, r, o, s, a, l, c = 1;
          do {
            for (i = t, t = null, o = null, s = 0; i;) {
              for (s++, n = i, a = 0, e = 0; e < c && (a++, n = n.nextZ, n); e++) ;
              for (l = c; a > 0 || l > 0 && n;) 0 !== a && (0 === l || !n || i.z <= n.z) ? (r = i, i = i.nextZ, a--) : (r = n, n = n.nextZ, l--), o ? o.nextZ = r : t = r, r.prevZ = o, o = r;
              i = n;
            }
            o.nextZ = null, c *= 2;
          } while (s > 1);
        }(r);
      }(t, n, r, o);
      let a, l, c = t;
      for (; t.prev !== t.next;) if (a = t.prev, l = t.next, o ? Ao(t, n, r, o) : Co(t)) e.push(a.i / i), e.push(t.i / i), e.push(l.i / i), Wo(t), t = l.next, c = l.next; else if ((t = l) === c) {
        s ? 1 === s ? Mo(t = To(So(t), e, i), e, i, n, r, o, 2) : 2 === s && Eo(t, e, i, n, r, o) : Mo(So(t), e, i, n, r, o, 1);
        break;
      }
    }
    function Co(t) {
      const e = t.prev, i = t, n = t.next;
      if ((i.y - e.y) * (n.x - i.x) - (i.x - e.x) * (n.y - i.y) >= 0) return false;
      let r = t.next.next;
      for (; r !== t.prev;) {
        if ((n.x - r.x) * (e.y - r.y) - (e.x - r.x) * (n.y - r.y) >= 0 && (e.x - r.x) * (i.y - r.y) - (i.x - r.x) * (e.y - r.y) >= 0 && (i.x - r.x) * (n.y - r.y) - (n.x - r.x) * (i.y - r.y) >= 0 && (r.y - r.prev.y) * (r.next.x - r.x) - (r.x - r.prev.x) * (r.next.y - r.y) >= 0) return false;
        r = r.next;
      }
      return true;
    }
    function Ao(t, e, i, n) {
      const r = t.prev, o = t, s = t.next;
      if ((o.y - r.y) * (s.x - o.x) - (o.x - r.x) * (s.y - o.y) >= 0) return false;
      const a = r.x < o.x ? r.x < s.x ? r.x : s.x : o.x < s.x ? o.x : s.x, l = r.y < o.y ? r.y < s.y ? r.y : s.y : o.y < s.y ? o.y : s.y, c = r.x > o.x ? r.x > s.x ? r.x : s.x : o.x > s.x ? o.x : s.x, h = r.y > o.y ? r.y > s.y ? r.y : s.y : o.y > s.y ? o.y : s.y, u = (a = 1431655765 & ((a = 858993459 & ((a = 252645135 & ((a = 16711935 & ((a = 32767 * (a - e) * n) | a << 8)) | a << 4)) | a << 2)) | a << 1)) | (l = 1431655765 & ((l = 858993459 & ((l = 252645135 & ((l = 16711935 & ((l = 32767 * (l - i) * n) | l << 8)) | l << 4)) | l << 2)) | l << 1)) << 1, m = (c = 1431655765 & ((c = 858993459 & ((c = 252645135 & ((c = 16711935 & ((c = 32767 * (c - e) * n) | c << 8)) | c << 4)) | c << 2)) | c << 1)) | (h = 1431655765 & ((h = 858993459 & ((h = 252645135 & ((h = 16711935 & ((h = 32767 * (h - i) * n) | h << 8)) | h << 4)) | h << 2)) | h << 1)) << 1;
      let p = t.prevZ, d = t.nextZ;
      for (; p && p.z >= u && d && d.z <= m;) {
        if (p !== t.prev && p !== t.next && ((s.x - p.x) * (r.y - p.y) - (r.x - p.x) * (s.y - p.y) >= 0 && (r.x - p.x) * (o.y - p.y) - (o.x - p.x) * (r.y - p.y) >= 0 && (o.x - p.x) * (s.y - p.y) - (s.x - p.x) * (o.y - p.y) >= 0) && (p.y - p.prev.y) * (p.next.x - p.x) - (p.x - p.prev.x) * (p.next.y - p.y) >= 0) return false;
        if (p = p.prevZ, d !== t.prev && d !== t.next && ((s.x - d.x) * (r.y - d.y) - (r.x - d.x) * (s.y - d.y) >= 0 && (r.x - d.x) * (o.y - d.y) - (o.x - d.x) * (r.y - d.y) >= 0 && (o.x - d.x) * (s.y - d.y) - (s.x - d.x) * (o.y - d.y) >= 0) && (d.y - d.prev.y) * (d.next.x - d.x) - (d.x - d.prev.x) * (d.next.y - d.y) >= 0) return false;
        d = d.nextZ;
      }
      for (; p && p.z >= u;) {
        if (p !== t.prev && p !== t.next && ((s.x - p.x) * (r.y - p.y) - (r.x - p.x) * (s.y - p.y) >= 0 && (r.x - p.x) * (o.y - p.y) - (o.x - p.x) * (r.y - p.y) >= 0 && (o.x - p.x) * (s.y - p.y) - (s.x - p.x) * (o.y - p.y) >= 0) && (p.y - p.prev.y) * (p.next.x - p.x) - (p.x - p.prev.x) * (p.next.y - p.y) >= 0) return false;
        p = p.prevZ;
      }
      for (; d && d.z <= m;) {
        if (d !== t.prev && d !== t.next && ((s.x - d.x) * (r.y - d.y) - (r.x - d.x) * (s.y - d.y) >= 0 && (r.x - d.x) * (o.y - d.y) - (o.x - d.x) * (r.y - d.y) >= 0 && (o.x - d.x) * (s.y - d.y) - (s.x - d.x) * (o.y - d.y) >= 0) && (d.y - d.prev.y) * (d.next.x - d.x) - (d.x - d.prev.x) * (d.next.y - d.y) >= 0) return false;
        d = d.nextZ;
      }
      return true;
    }
    function To(t, e, i) {
      let n = t;
      do {
        const r = n.prev, o = n.next.next;
        !(r.x === o.x && r.y === o.y) && No(r, n, n.next, o) && Uo(r, o) && Uo(o, r) && (e.push(r.i / i), e.push(n.i / i), e.push(o.i / i), Wo(n), Wo(n.next), n = t = o), n = n.next;
      } while (n !== t);
      return So(n);
    }
    function Eo(t, e, i, n, r, o) {
      let s = t;
      do {
        let t = s.next.next;
        for (; t !== s.prev;) {
          if (s.i !== t.i && Io(s, t)) {
            let a = ko(s, t);
            return s = So(s, s.next), a = So(a, a.next), Mo(s, e, i, n, r, o), void Mo(a, e, i, n, r, o);
          }
          t = t.next;
        }
        s = s.next;
      } while (s !== t);
    }
    function Do(t, e) {
      if (e = function (t, e) {
        let i = e;
        const n = t.x, r = t.y;
        let o, s = -Infinity;
        do {
          if (r <= i.y && r >= i.next.y && i.next.y !== i.y) {
            const t = i.x + (r - i.y) * (i.next.x - i.x) / (i.next.y - i.y);
            if (t <= n && t > s) {
              if (s = t, t === n) {
                if (r === i.y) return i;
                if (r === i.next.y) return i.next;
              }
              o = i.x < i.next.x ? i : i.next;
            }
          }
          i = i.next;
        } while (i !== e);
        if (!o) return null;
        if (n === s) return o;
        const a = o, l = o.x, c = o.y;
        let h, u = Infinity;
        i = o;
        do {
          n >= i.x && i.x >= l && n !== i.x && (((r < c ? s : n) - i.x) * (r - i.y) - ((r < c ? n : s) - i.x) * (r - i.y) >= 0 && ((r < c ? n : s) - i.x) * (c - i.y) - (l - i.x) * (r - i.y) >= 0 && (l - i.x) * (r - i.y) - ((r < c ? s : n) - i.x) * (c - i.y) >= 0) && (h = Math.abs(r - i.y) / (n - i.x), Uo(i, t) && (h < u || h === u && (i.x > o.x || i.x === o.x && ((o.y - o.prev.y) * (i.prev.x - o.x) - (o.x - o.prev.x) * (i.prev.y - o.y) < 0 && (o.y - i.next.y) * (o.next.x - o.x) - (o.x - i.next.x) * (o.next.y - o.y) < 0))) && (o = i, u = h)), i = i.next;
        } while (i !== a);
        return o;
      }(t, e)) {
        const i = ko(e, t);
        So(e, e.next), So(i, i.next);
      }
    }
    function Ro(t) {
      let e = t, i = t;
      do {
        (e.x < i.x || e.x === i.x && e.y < i.y) && (i = e), e = e.next;
      } while (e !== t);
      return i;
    }
    function Io(t, e) {
      return t.next.i !== e.i && t.prev.i !== e.i && !function (t, e) {
        let i = t;
        do {
          if (i.i !== t.i && i.next.i !== t.i && i.i !== e.i && i.next.i !== e.i && No(i, i.next, t, e)) return true;
          i = i.next;
        } while (i !== t);
        return false;
      }(t, e) && (Uo(t, e) && Uo(e, t) && function (t, e) {
        let i = t, n = false;
        const r = (t.x + e.x) / 2, o = (t.y + e.y) / 2;
        do {
          i.y > o != i.next.y > o && i.next.y !== i.y && r < (i.next.x - i.x) * (o - i.y) / (i.next.y - i.y) + i.x && (n = !n), i = i.next;
        } while (i !== t);
        return n;
      }(t, e) && ((t.y - t.prev.y) * (e.prev.x - t.x) - (t.x - t.prev.x) * (e.prev.y - t.y) || (e.prev.y - t.y) * (e.x - e.prev.x) - (e.prev.x - t.x) * (e.y - e.prev.y)) || t.x === e.x && t.y === e.y && (t.y - t.prev.y) * (t.next.x - t.x) - (t.x - t.prev.x) * (t.next.y - t.y) > 0 && (e.y - e.prev.y) * (e.next.x - e.x) - (e.x - e.prev.x) * (e.next.y - e.y) > 0);
    }
    function No(t, e, i, n) {
      const r = Oo((e.y - t.y) * (i.x - e.x) - (e.x - t.x) * (i.y - e.y)), o = Oo((e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)), s = Oo((n.y - i.y) * (t.x - n.x) - (n.x - i.x) * (t.y - n.y)), a = Oo((n.y - i.y) * (e.x - n.x) - (n.x - i.x) * (e.y - n.y));
      return r !== o && s !== a || (!(0 !== r || !(i.x <= Math.max(t.x, e.x) && i.x >= Math.min(t.x, e.x) && i.y <= Math.max(t.y, e.y) && i.y >= Math.min(t.y, e.y))) || (!(0 !== o || !(n.x <= Math.max(t.x, e.x) && n.x >= Math.min(t.x, e.x) && n.y <= Math.max(t.y, e.y) && n.y >= Math.min(t.y, e.y))) || (!(0 !== s || !(t.x <= Math.max(i.x, n.x) && t.x >= Math.min(i.x, n.x) && t.y <= Math.max(i.y, n.y) && t.y >= Math.min(i.y, n.y))) || !(0 !== a || !(e.x <= Math.max(i.x, n.x) && e.x >= Math.min(i.x, n.x) && e.y <= Math.max(i.y, n.y) && e.y >= Math.min(i.y, n.y))))));
    }
    function Oo(t) {
      return t > 0 ? 1 : t < 0 ? -1 : 0;
    }
    function Uo(t, e) {
      return (t.y - t.prev.y) * (t.next.x - t.x) - (t.x - t.prev.x) * (t.next.y - t.y) < 0 ? (e.y - t.y) * (t.next.x - e.x) - (e.x - t.x) * (t.next.y - e.y) >= 0 && (t.prev.y - t.y) * (e.x - t.prev.x) - (t.prev.x - t.x) * (e.y - t.prev.y) >= 0 : (e.y - t.y) * (t.prev.x - e.x) - (e.x - t.x) * (t.prev.y - e.y) < 0 || (t.next.y - t.y) * (e.x - t.next.x) - (t.next.x - t.x) * (e.y - t.next.y) < 0;
    }
    function ko(t, e) {
      const i = new Jo(t.i, t.x, t.y), n = new Jo(e.i, e.x, e.y), r = t.next, o = e.prev;
      return t.next = e, e.prev = t, i.next = r, r.prev = i, n.next = i, i.prev = n, o.next = n, n.prev = o, n;
    }
    function Ho(t, e, i, n) {
      const r = new Jo(t, e, i);
      return n ? (r.next = n.next, r.prev = n, n.next.prev = r, n.next = r) : (r.prev = r, r.next = r), r;
    }
    function Wo(t) {
      t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ);
    }
    function Jo(t, e, i) {
      this.i = t, this.x = e, this.y = i, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = false;
    }
    class ShapeUtils {
      static area(t) {
        const e = t.length;
        let i = 0;
        for (let n = e - 1, r = 0; r < e; n = r++) i += t[n].x * t[r].y - t[r].x * t[n].y;
        return 0.5 * i;
      }
      static isClockWise(t) {
        return ShapeUtils.area(t) < 0;
      }
      static triangulateShape(t, e) {
        const i = [], n = [], r = [];
        jo(t), Xo(i, t);
        let o = t.length;
        e.forEach(jo);
        for (let t = 0; t < e.length; t++) n.push(o), o += e[t].length, Xo(i, e[t]);
        const s = bo(i, n);
        for (let t = 0; t < s.length; t += 3) r.push(s.slice(t, t + 3));
        return r;
      }
    }
    function jo(t) {
      const e = t.length;
      e > 2 && t[e - 1].equals(t[0]) && t.pop();
    }
    function Xo(t, e) {
      for (let i = 0; i < e.length; i++) t.push(e[i].x), t.push(e[i].y);
    }
    class ExtrudeGeometry extends BufferGeometry {
      constructor(t, e) {
        super(), this.type = "ExtrudeGeometry", this.parameters = {shapes: t, options: e}, t = Array.isArray(t) ? t : [t];
        const i = this, n = [], r = [];
        for (let e = 0, i = t.length; e < i; e++) {
          o(t[e]);
        }
        function o(t) {
          const o = [], s = void 0 !== e.curveSegments ? e.curveSegments : 12, a = void 0 !== e.steps ? e.steps : 1;
          let l = void 0 !== e.depth ? e.depth : 100, c = void 0 === e.bevelEnabled || e.bevelEnabled, h = void 0 !== e.bevelThickness ? e.bevelThickness : 6, u = void 0 !== e.bevelSize ? e.bevelSize : h - 2, m = void 0 !== e.bevelOffset ? e.bevelOffset : 0, p = void 0 !== e.bevelSegments ? e.bevelSegments : 3;
          const d = e.extrudePath, f = void 0 !== e.UVGenerator ? e.UVGenerator : qo;
          void 0 !== e.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), l = e.amount);
          let _, y, g, x, v, b = false;
          d && (_ = d.getSpacedPoints(a), b = true, c = false, y = d.computeFrenetFrames(a, false), g = new three_module_Vector3, x = new three_module_Vector3, v = new three_module_Vector3), c || (p = 0, h = 0, u = 0, m = 0);
          const w = t.extractPoints(s);
          let S = w.shape;
          const M = w.holes;
          if (!ShapeUtils.isClockWise(S)) {
            S = S.reverse();
            for (let t = 0, e = M.length; t < e; t++) {
              const e = M[t];
              ShapeUtils.isClockWise(e) && (M[t] = e.reverse());
            }
          }
          const C = ShapeUtils.triangulateShape(S, M), A = S;
          for (let t = 0, e = M.length; t < e; t++) {
            const e = M[t];
            S = S.concat(e);
          }
          const E = S.length, L = C.length;
          function D(t, e, i) {
            let n, r, o;
            const s = t.x - e.x, a = t.y - e.y, l = i.x - t.x, c = i.y - t.y, h = s * s + a * a, u = s * c - a * l;
            if (Math.abs(u) > Number.EPSILON) {
              const u = Math.sqrt(h), m = Math.sqrt(l * l + c * c), p = e.x - a / u, d = e.y + s / u, f = ((i.x - c / m - p) * c - (i.y + l / m - d) * l) / (s * c - a * l);
              n = p + s * f - t.x, r = d + a * f - t.y;
              const _ = n * n + r * r;
              if (_ <= 2) return new Vector2(n, r);
              o = Math.sqrt(_ / 2);
            } else {
              let t = false;
              s > Number.EPSILON ? l > Number.EPSILON && (t = true) : s < -Number.EPSILON ? l < -Number.EPSILON && (t = true) : Math.sign(a) === Math.sign(c) && (t = true), t ? (n = -a, r = s, o = Math.sqrt(h)) : (n = s, r = a, o = Math.sqrt(h / 2));
            }
            return new Vector2(n / o, r / o);
          }
          const V = [];
          for (let t = 0, e = A.length, i = e - 1, n = t + 1; t < e; t++, i++, n++) i === e && (i = 0), n === e && (n = 0), V[t] = D(A[t], A[i], A[n]);
          const B = [];
          let R, P = V.concat();
          for (let t = 0, e = M.length; t < e; t++) {
            const e = M[t];
            R = [];
            for (let t = 0, i = e.length, n = i - 1, r = t + 1; t < i; t++, n++, r++) n === i && (n = 0), r === i && (r = 0), R[t] = D(e[t], e[n], e[r]);
            B.push(R), P = P.concat(R);
          }
          for (let t = 0; t < p; t++) {
            const e = t / p, i = h * Math.cos(e * Math.PI / 2), n = u * Math.sin(e * Math.PI / 2) + m;
            for (let t = 0, e = A.length; t < e; t++) {
              const e = (V[t] || console.error("THREE.ExtrudeGeometry: vec does not exist"), V[t].clone().multiplyScalar(n).add(A[t]));
              G(e.x, e.y, -i);
            }
            for (let t = 0, e = M.length; t < e; t++) {
              const e = M[t];
              R = B[t];
              for (let t = 0, r = e.length; t < r; t++) {
                const r = (R[t] || console.error("THREE.ExtrudeGeometry: vec does not exist"), R[t].clone().multiplyScalar(n).add(e[t]));
                G(r.x, r.y, -i);
              }
            }
          }
          const I = u + m;
          for (let t = 0; t < E; t++) {
            const e = c ? (P[t] || console.error("THREE.ExtrudeGeometry: vec does not exist"), P[t].clone().multiplyScalar(I).add(S[t])) : S[t];
            b ? (x.copy(y.normals[0]).multiplyScalar(e.x), g.copy(y.binormals[0]).multiplyScalar(e.y), v.copy(_[0]).add(x).add(g), G(v.x, v.y, v.z)) : G(e.x, e.y, 0);
          }
          for (let t = 1; t <= a; t++) for (let e = 0; e < E; e++) {
            const i = c ? (P[e] || console.error("THREE.ExtrudeGeometry: vec does not exist"), P[e].clone().multiplyScalar(I).add(S[e])) : S[e];
            b ? (x.copy(y.normals[t]).multiplyScalar(i.x), g.copy(y.binormals[t]).multiplyScalar(i.y), v.copy(_[t]).add(x).add(g), G(v.x, v.y, v.z)) : G(i.x, i.y, l / a * t);
          }
          for (let t = p - 1; t >= 0; t--) {
            const e = t / p, i = h * Math.cos(e * Math.PI / 2), n = u * Math.sin(e * Math.PI / 2) + m;
            for (let t = 0, e = A.length; t < e; t++) {
              const e = (V[t] || console.error("THREE.ExtrudeGeometry: vec does not exist"), V[t].clone().multiplyScalar(n).add(A[t]));
              G(e.x, e.y, l + i);
            }
            for (let t = 0, e = M.length; t < e; t++) {
              const e = M[t];
              R = B[t];
              for (let t = 0, r = e.length; t < r; t++) {
                const r = (R[t] || console.error("THREE.ExtrudeGeometry: vec does not exist"), R[t].clone().multiplyScalar(n).add(e[t]));
                b ? G(r.x, r.y + _[a - 1].y, _[a - 1].x + i) : G(r.x, r.y, l + i);
              }
            }
          }
          function F(t, e) {
            let i = t.length;
            for (; --i >= 0;) {
              const n = i;
              let r = i - 1;
              r < 0 && (r = t.length - 1);
              for (let t = 0, i = a + 2 * p; t < i; t++) {
                const i = E * t, o = E * (t + 1);
                z(e + n + i, e + r + i, e + r + o, e + n + o);
              }
            }
          }
          function G(t, e, i) {
            o.push(t), o.push(e), o.push(i);
          }
          function N(t, e, r) {
            O(t), O(e), O(r);
            const o = n.length / 3, s = f.generateTopUV(i, n, o - 3, o - 2, o - 1);
            U(s[0]), U(s[1]), U(s[2]);
          }
          function z(t, e, r, o) {
            O(t), O(e), O(o), O(e), O(r), O(o);
            const s = n.length / 3, a = f.generateSideWallUV(i, n, s - 6, s - 3, s - 2, s - 1);
            U(a[0]), U(a[1]), U(a[3]), U(a[1]), U(a[2]), U(a[3]);
          }
          function O(t) {
            n.push(o[3 * t + 0]), n.push(o[3 * t + 1]), n.push(o[3 * t + 2]);
          }
          function U(t) {
            r.push(t.x), r.push(t.y);
          }
          !function () {
            const t = n.length / 3;
            if (c) {
              let t = 0, e = E * t;
              for (let t = 0; t < L; t++) {
                const i = C[t];
                N(i[2] + e, i[1] + e, i[0] + e);
              }
              t = a + 2 * p, e = E * t;
              for (let t = 0; t < L; t++) {
                const i = C[t];
                N(i[0] + e, i[1] + e, i[2] + e);
              }
            } else {
              for (let t = 0; t < L; t++) {
                const e = C[t];
                N(e[2], e[1], e[0]);
              }
              for (let t = 0; t < L; t++) {
                const e = C[t];
                N(e[0] + E * a, e[1] + E * a, e[2] + E * a);
              }
            }
            i.addGroup(t, n.length / 3 - t, 0);
          }(), function () {
            const t = n.length / 3;
            let e = 0;
            F(A, e), e += A.length;
            for (let t = 0, i = M.length; t < i; t++) {
              const i = M[t];
              F(i, e), e += i.length;
            }
            i.addGroup(t, n.length / 3 - t, 1);
          }();
        }
        this.setAttribute("position", new Float32BufferAttribute(n, 3)), this.setAttribute("uv", new Float32BufferAttribute(r, 2)), this.computeVertexNormals();
      }
      toJSON() {
        const t = super.toJSON();
        return function (t, e, i) {
          if (i.shapes = [], Array.isArray(t)) for (let e = 0, n = t.length; e < n; e++) {
            const n = t[e];
            i.shapes.push(n.uuid);
          } else i.shapes.push(t.uuid);
          void 0 !== e.extrudePath && (i.options.extrudePath = e.extrudePath.toJSON());
          return i;
        }(this.parameters.shapes, this.parameters.options, t);
      }
      static fromJSON(t, e) {
        const i = [];
        for (let n = 0, r = t.shapes.length; n < r; n++) {
          const r = e[t.shapes[n]];
          i.push(r);
        }
        const n = t.options.extrudePath;
        return void 0 !== n && (t.options.extrudePath = (new vo[n.type]).fromJSON(n)), new ExtrudeGeometry(i, t.options);
      }
    }
    const qo = {generateTopUV: function (t, e, i, n, r) {
      const o = e[3 * i], s = e[3 * i + 1], a = e[3 * n], l = e[3 * n + 1], c = e[3 * r], h = e[3 * r + 1];
      return [new Vector2(o, s), new Vector2(a, l), new Vector2(c, h)];
    }, generateSideWallUV: function (t, e, i, n, r, o) {
      const s = e[3 * i], a = e[3 * i + 1], l = e[3 * i + 2], c = e[3 * n], h = e[3 * n + 1], u = e[3 * n + 2], m = e[3 * r], p = e[3 * r + 1], d = e[3 * r + 2], f = e[3 * o], _ = e[3 * o + 1], y = e[3 * o + 2];
      return Math.abs(a - h) < Math.abs(s - c) ? [new Vector2(s, 1 - l), new Vector2(c, 1 - u), new Vector2(m, 1 - d), new Vector2(f, 1 - y)] : [new Vector2(a, 1 - l), new Vector2(h, 1 - u), new Vector2(p, 1 - d), new Vector2(_, 1 - y)];
    }};
    class ShapeGeometry extends BufferGeometry {
      constructor(t, e = 12) {
        super(), this.type = "ShapeGeometry", this.parameters = {shapes: t, curveSegments: e};
        const i = [], n = [], r = [], o = [];
        let s = 0, a = 0;
        if (false === Array.isArray(t)) l(t); else for (let e = 0; e < t.length; e++) l(t[e]), this.addGroup(s, a, e), s += a, a = 0;
        function l(t) {
          const s = n.length / 3, l = t.extractPoints(e);
          let c = l.shape;
          const h = l.holes;
          false === ShapeUtils.isClockWise(c) && (c = c.reverse());
          for (let t = 0, e = h.length; t < e; t++) {
            const e = h[t];
            true === ShapeUtils.isClockWise(e) && (h[t] = e.reverse());
          }
          const u = ShapeUtils.triangulateShape(c, h);
          for (let t = 0, e = h.length; t < e; t++) {
            const e = h[t];
            c = c.concat(e);
          }
          for (let t = 0, e = c.length; t < e; t++) {
            const e = c[t];
            n.push(e.x, e.y, 0), r.push(0, 0, 1), o.push(e.x, e.y);
          }
          for (let t = 0, e = u.length; t < e; t++) {
            const e = u[t], n = e[0] + s, r = e[1] + s, o = e[2] + s;
            i.push(n, r, o), a += 3;
          }
        }
        this.setIndex(i), this.setAttribute("position", new Float32BufferAttribute(n, 3)), this.setAttribute("normal", new Float32BufferAttribute(r, 3)), this.setAttribute("uv", new Float32BufferAttribute(o, 2));
      }
      toJSON() {
        const t = super.toJSON();
        return function (t, e) {
          if (e.shapes = [], Array.isArray(t)) for (let i = 0, n = t.length; i < n; i++) {
            const n = t[i];
            e.shapes.push(n.uuid);
          } else e.shapes.push(t.uuid);
          return e;
        }(this.parameters.shapes, t);
      }
      static fromJSON(t, e) {
        const i = [];
        for (let n = 0, r = t.shapes.length; n < r; n++) {
          const r = e[t.shapes[n]];
          i.push(r);
        }
        return new ShapeGeometry(i, t.curveSegments);
      }
    }
    class ShadowMaterial extends Material {
      constructor(t) {
        super(), this.type = "ShadowMaterial", this.color = new three_module_Color(0), this.transparent = true, this.setValues(t);
      }
      copy(t) {
        return super.copy(t), this.color.copy(t.color), this;
      }
    }
    ShadowMaterial.prototype.isShadowMaterial = true;
    class MeshStandardMaterial extends Material {
      constructor(t) {
        super(), this.defines = {STANDARD: ""}, this.type = "MeshStandardMaterial", this.color = new three_module_Color(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new three_module_Color(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new Vector2(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = false, this.setValues(t);
      }
      copy(t) {
        return super.copy(t), this.defines = {STANDARD: ""}, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapIntensity = t.envMapIntensity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.flatShading = t.flatShading, this;
      }
    }
    MeshStandardMaterial.prototype.isMeshStandardMaterial = true;
    var Yo = "__private_" + e++ + "_" + "clearcoat", Zo = "__private_" + e++ + "_" + "transmission";
    class MeshPhysicalMaterial extends MeshStandardMaterial {
      constructor(t) {
        super(), Object.defineProperty(this, Yo, {writable: true, value: 0}), Object.defineProperty(this, Zo, {writable: true, value: 0}), this.defines = {STANDARD: "", PHYSICAL: ""}, this.type = "MeshPhysicalMaterial", this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new Vector2(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {get: function () {
          return Math.max(0, Math.min(1, 2.5 * (this.ior - 1) / (this.ior + 1)));
        }, set: function (t) {
          this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
        }}), this.sheenTint = new three_module_Color(0), this.transmission = 0, this.transmissionMap = null, this.thickness = 0.01, this.thicknessMap = null, this.attenuationDistance = 0, this.attenuationTint = new three_module_Color(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularTint = new three_module_Color(1, 1, 1), this.specularTintMap = null, this.setValues(t);
      }
      get clearcoat() {
        return t(this, Yo)[Yo];
      }
      set clearcoat (e) {
        t(this, Yo)[Yo] > 0 != e > 0 && this.version++, t(this, Yo)[Yo] = e;
      }
      get transmission() {
        return t(this, Zo)[Zo];
      }
      set transmission (e) {
        t(this, Zo)[Zo] > 0 != e > 0 && this.version++, t(this, Zo)[Zo] = e;
      }
      copy(t) {
        return super.copy(t), this.defines = {STANDARD: "", PHYSICAL: ""}, this.clearcoat = t.clearcoat, this.clearcoatMap = t.clearcoatMap, this.clearcoatRoughness = t.clearcoatRoughness, this.clearcoatRoughnessMap = t.clearcoatRoughnessMap, this.clearcoatNormalMap = t.clearcoatNormalMap, this.clearcoatNormalScale.copy(t.clearcoatNormalScale), this.ior = t.ior, this.sheenTint.copy(t.sheenTint), this.transmission = t.transmission, this.transmissionMap = t.transmissionMap, this.thickness = t.thickness, this.thicknessMap = t.thicknessMap, this.attenuationDistance = t.attenuationDistance, this.attenuationTint.copy(t.attenuationTint), this.specularIntensity = t.specularIntensity, this.specularIntensityMap = t.specularIntensityMap, this.specularTint.copy(t.specularTint), this.specularTintMap = t.specularTintMap, this;
      }
    }
    MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;
    class MeshPhongMaterial extends Material {
      constructor(t) {
        super(), this.type = "MeshPhongMaterial", this.color = new three_module_Color(16777215), this.specular = new three_module_Color(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new three_module_Color(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new Vector2(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = false, this.setValues(t);
      }
      copy(t) {
        return super.copy(t), this.color.copy(t.color), this.specular.copy(t.specular), this.shininess = t.shininess, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.flatShading = t.flatShading, this;
      }
    }
    MeshPhongMaterial.prototype.isMeshPhongMaterial = true;
    class MeshToonMaterial extends Material {
      constructor(t) {
        super(), this.defines = {TOON: ""}, this.type = "MeshToonMaterial", this.color = new three_module_Color(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new three_module_Color(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new Vector2(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(t);
      }
      copy(t) {
        return super.copy(t), this.color.copy(t.color), this.map = t.map, this.gradientMap = t.gradientMap, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this;
      }
    }
    MeshToonMaterial.prototype.isMeshToonMaterial = true;
    class MeshNormalMaterial extends Material {
      constructor(t) {
        super(), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new Vector2(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = false, this.wireframeLinewidth = 1, this.fog = false, this.flatShading = false, this.setValues(t);
      }
      copy(t) {
        return super.copy(t), this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.flatShading = t.flatShading, this;
      }
    }
    MeshNormalMaterial.prototype.isMeshNormalMaterial = true;
    class MeshLambertMaterial extends Material {
      constructor(t) {
        super(), this.type = "MeshLambertMaterial", this.color = new three_module_Color(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new three_module_Color(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(t);
      }
      copy(t) {
        return super.copy(t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this;
      }
    }
    MeshLambertMaterial.prototype.isMeshLambertMaterial = true;
    class MeshMatcapMaterial extends Material {
      constructor(t) {
        super(), this.defines = {MATCAP: ""}, this.type = "MeshMatcapMaterial", this.color = new three_module_Color(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new Vector2(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = false, this.setValues(t);
      }
      copy(t) {
        return super.copy(t), this.defines = {MATCAP: ""}, this.color.copy(t.color), this.matcap = t.matcap, this.map = t.map, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.flatShading = t.flatShading, this;
      }
    }
    MeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;
    class LineDashedMaterial extends LineBasicMaterial {
      constructor(t) {
        super(), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(t);
      }
      copy(t) {
        return super.copy(t), this.scale = t.scale, this.dashSize = t.dashSize, this.gapSize = t.gapSize, this;
      }
    }
    LineDashedMaterial.prototype.isLineDashedMaterial = true;
    const Ko = {arraySlice: function (t, e, i) {
      return Ko.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== i ? i : t.length)) : t.slice(e, i);
    }, convertArray: function (t, e, i) {
      return !t || !i && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t);
    }, isTypedArray: function (t) {
      return ArrayBuffer.isView(t) && !(t instanceof DataView);
    }, getKeyframeOrder: function (t) {
      const e = t.length, i = new Array(e);
      for (let t = 0; t !== e; ++t) i[t] = t;
      return i.sort(function (e, i) {
        return t[e] - t[i];
      }), i;
    }, sortedArray: function (t, e, i) {
      const n = t.length, r = new t.constructor(n);
      for (let o = 0, s = 0; s !== n; ++o) {
        const n = i[o] * e;
        for (let i = 0; i !== e; ++i) r[s++] = t[n + i];
      }
      return r;
    }, flattenJSON: function (t, e, i, n) {
      let r = 1, o = t[0];
      for (; void 0 !== o && void 0 === o[n];) o = t[r++];
      if (void 0 === o) return;
      let s = o[n];
      if (void 0 !== s) if (Array.isArray(s)) do {
        s = o[n], void 0 !== s && (e.push(o.time), i.push.apply(i, s)), o = t[r++];
      } while (void 0 !== o); else if (void 0 !== s.toArray) do {
        s = o[n], void 0 !== s && (e.push(o.time), s.toArray(i, i.length)), o = t[r++];
      } while (void 0 !== o); else do {
        s = o[n], void 0 !== s && (e.push(o.time), i.push(s)), o = t[r++];
      } while (void 0 !== o);
    }, subclip: function (t, e, i, n, r = 30) {
      const o = t.clone();
      o.name = e;
      const s = [];
      for (let t = 0; t < o.tracks.length; ++t) {
        const e = o.tracks[t], a = e.getValueSize(), l = [], c = [];
        for (let t = 0; t < e.times.length; ++t) {
          const o = e.times[t] * r;
          if (!(o < i || o >= n)) {
            l.push(e.times[t]);
            for (let i = 0; i < a; ++i) c.push(e.values[t * a + i]);
          }
        }
        0 !== l.length && (e.times = Ko.convertArray(l, e.times.constructor), e.values = Ko.convertArray(c, e.values.constructor), s.push(e));
      }
      o.tracks = s;
      let a = Infinity;
      for (let t = 0; t < o.tracks.length; ++t) a > o.tracks[t].times[0] && (a = o.tracks[t].times[0]);
      for (let t = 0; t < o.tracks.length; ++t) o.tracks[t].shift(-1 * a);
      return o.resetDuration(), o;
    }, makeClipAdditive: function (t, e = 0, i = t, n = 30) {
      n <= 0 && (n = 30);
      const r = i.tracks.length, o = e / n;
      for (let e = 0; e < r; ++e) {
        const n = i.tracks[e], r = n.ValueTypeName;
        if ("bool" === r || "string" === r) continue;
        const s = t.tracks.find(function (t) {
          return t.name === n.name && t.ValueTypeName === r;
        });
        if (void 0 === s) continue;
        let a = 0;
        const l = n.getValueSize();
        n.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (a = l / 3);
        let c = 0;
        const h = s.getValueSize();
        s.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (c = h / 3);
        const u = n.times.length - 1;
        let m;
        if (o <= n.times[0]) {
          const t = a, e = l - a;
          m = Ko.arraySlice(n.values, t, e);
        } else if (o >= n.times[u]) {
          const t = u * l + a, e = t + l - a;
          m = Ko.arraySlice(n.values, t, e);
        } else {
          const t = n.createInterpolant(), e = a, i = l - a;
          t.evaluate(o), m = Ko.arraySlice(t.resultBuffer, e, i);
        }
        if ("quaternion" === r) {
          (new Quaternion).fromArray(m).normalize().conjugate().toArray(m);
        }
        const p = s.times.length;
        for (let t = 0; t < p; ++t) {
          const e = t * h + c;
          if ("quaternion" === r) Quaternion.multiplyQuaternionsFlat(s.values, e, m, 0, s.values, e); else {
            const t = h - 2 * c;
            for (let i = 0; i < t; ++i) s.values[e + i] -= m[i];
          }
        }
      }
      return t.blendMode = 2501, t;
    }};
    class Interpolant {
      constructor(t, e, i, n) {
        this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = void 0 !== n ? n : new e.constructor(i), this.sampleValues = e, this.valueSize = i, this.settings = null, this.DefaultSettings_ = {};
      }
      evaluate(t) {
        const e = this.parameterPositions;
        let i = this._cachedIndex, n = e[i], r = e[i - 1];
        t: {
          e: {
            let o;
            i: {
              n: if (!(t < n)) {
                for (let o = i + 2;;) {
                  if (void 0 === n) {
                    if (t < r) break n;
                    return i = e.length, this._cachedIndex = i, this.afterEnd_(i - 1, t, r);
                  }
                  if (i === o) break;
                  if (r = n, n = e[++i], t < n) break e;
                }
                o = e.length;
                break i;
              }
              if (t >= r) break t;
              {
                const s = e[1];
                t < s && (i = 2, r = s);
                for (let o = i - 2;;) {
                  if (void 0 === r) return this._cachedIndex = 0, this.beforeStart_(0, t, n);
                  if (i === o) break;
                  if (n = r, r = e[--i - 1], t >= r) break e;
                }
                o = i, i = 0;
              }
            }
            for (; i < o;) {
              const n = i + o >>> 1;
              t < e[n] ? o = n : i = n + 1;
            }
            if (n = e[i], r = e[i - 1], void 0 === r) return this._cachedIndex = 0, this.beforeStart_(0, t, n);
            if (void 0 === n) return i = e.length, this._cachedIndex = i, this.afterEnd_(i - 1, r, t);
          }
          this._cachedIndex = i, this.intervalChanged_(i, r, n);
        }
        return this.interpolate_(i, r, t, n);
      }
      getSettings_() {
        return this.settings || this.DefaultSettings_;
      }
      copySampleValue_(t) {
        const e = this.resultBuffer, i = this.sampleValues, n = this.valueSize, r = t * n;
        for (let t = 0; t !== n; ++t) e[t] = i[r + t];
        return e;
      }
      interpolate_() {
        throw new Error("call to abstract method");
      }
      intervalChanged_() {}
    }
    Interpolant.prototype.beforeStart_ = Interpolant.prototype.copySampleValue_, Interpolant.prototype.afterEnd_ = Interpolant.prototype.copySampleValue_;
    class CubicInterpolant extends Interpolant {
      constructor(t, e, i, n) {
        super(t, e, i, n), this._weightPrev = 0, this._offsetPrev = 0, this._weightNext = 0, this._offsetNext = 0, this.DefaultSettings_ = {endingStart: R, endingEnd: R};
      }
      intervalChanged_(t, e, i) {
        const n = this.parameterPositions;
        let r = t - 2, o = t + 1, s = n[r], a = n[o];
        if (void 0 === s) switch (this.getSettings_().endingStart) {
          case P:
            r = t, s = 2 * e - i;
            break;
          case I:
            r = n.length - 2, s = e + n[r] - n[r + 1];
            break;
          default:
            r = t, s = i;
        }
        if (void 0 === a) switch (this.getSettings_().endingEnd) {
          case P:
            o = t, a = 2 * i - e;
            break;
          case I:
            o = 1, a = i + n[1] - n[0];
            break;
          default:
            o = t - 1, a = e;
        }
        const l = 0.5 * (i - e), c = this.valueSize;
        this._weightPrev = l / (e - s), this._weightNext = l / (a - i), this._offsetPrev = r * c, this._offsetNext = o * c;
      }
      interpolate_(t, e, i, n) {
        const r = this.resultBuffer, o = this.sampleValues, s = this.valueSize, a = t * s, l = a - s, c = this._offsetPrev, h = this._offsetNext, u = this._weightPrev, m = this._weightNext, p = (i - e) / (n - e), d = p * p, f = d * p, _ = -u * f + 2 * u * d - u * p, y = (1 + u) * f + (-1.5 - 2 * u) * d + (-0.5 + u) * p + 1, g = (-1 - m) * f + (1.5 + m) * d + 0.5 * p, x = m * f - m * d;
        for (let t = 0; t !== s; ++t) r[t] = _ * o[c + t] + y * o[l + t] + g * o[a + t] + x * o[h + t];
        return r;
      }
    }
    class LinearInterpolant extends Interpolant {
      constructor(t, e, i, n) {
        super(t, e, i, n);
      }
      interpolate_(t, e, i, n) {
        const r = this.resultBuffer, o = this.sampleValues, s = this.valueSize, a = t * s, l = a - s, c = (i - e) / (n - e), h = 1 - c;
        for (let t = 0; t !== s; ++t) r[t] = o[l + t] * h + o[a + t] * c;
        return r;
      }
    }
    class DiscreteInterpolant extends Interpolant {
      constructor(t, e, i, n) {
        super(t, e, i, n);
      }
      interpolate_(t) {
        return this.copySampleValue_(t - 1);
      }
    }
    class KeyframeTrack {
      constructor(t, e, i, n) {
        if (void 0 === t) throw new Error("THREE.KeyframeTrack: track name is undefined");
        if (void 0 === e || 0 === e.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
        this.name = t, this.times = Ko.convertArray(e, this.TimeBufferType), this.values = Ko.convertArray(i, this.ValueBufferType), this.setInterpolation(n || this.DefaultInterpolation);
      }
      static toJSON(t) {
        const e = t.constructor;
        let i;
        if (e.toJSON !== this.toJSON) i = e.toJSON(t); else {
          i = {name: t.name, times: Ko.convertArray(t.times, Array), values: Ko.convertArray(t.values, Array)};
          const e = t.getInterpolation();
          e !== t.DefaultInterpolation && (i.interpolation = e);
        }
        return i.type = t.ValueTypeName, i;
      }
      InterpolantFactoryMethodDiscrete(t) {
        return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), t);
      }
      InterpolantFactoryMethodLinear(t) {
        return new LinearInterpolant(this.times, this.values, this.getValueSize(), t);
      }
      InterpolantFactoryMethodSmooth(t) {
        return new CubicInterpolant(this.times, this.values, this.getValueSize(), t);
      }
      setInterpolation(t) {
        let e;
        switch (t) {
          case D:
            e = this.InterpolantFactoryMethodDiscrete;
            break;
          case V:
            e = this.InterpolantFactoryMethodLinear;
            break;
          case B:
            e = this.InterpolantFactoryMethodSmooth;
        }
        if (void 0 === e) {
          const e = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
          if (void 0 === this.createInterpolant) {
            if (t === this.DefaultInterpolation) throw new Error(e);
            this.setInterpolation(this.DefaultInterpolation);
          }
          return console.warn("THREE.KeyframeTrack:", e), this;
        }
        return this.createInterpolant = e, this;
      }
      getInterpolation() {
        switch (this.createInterpolant) {
          case this.InterpolantFactoryMethodDiscrete:
            return D;
          case this.InterpolantFactoryMethodLinear:
            return V;
          case this.InterpolantFactoryMethodSmooth:
            return B;
        }
      }
      getValueSize() {
        return this.values.length / this.times.length;
      }
      shift(t) {
        if (0 !== t) {
          const e = this.times;
          for (let i = 0, n = e.length; i !== n; ++i) e[i] += t;
        }
        return this;
      }
      scale(t) {
        if (1 !== t) {
          const e = this.times;
          for (let i = 0, n = e.length; i !== n; ++i) e[i] *= t;
        }
        return this;
      }
      trim(t, e) {
        const i = this.times, n = i.length;
        let r = 0, o = n - 1;
        for (; r !== n && i[r] < t;) ++r;
        for (; -1 !== o && i[o] > e;) --o;
        if (++o, 0 !== r || o !== n) {
          r >= o && (o = Math.max(o, 1), r = o - 1);
          const t = this.getValueSize();
          this.times = Ko.arraySlice(i, r, o), this.values = Ko.arraySlice(this.values, r * t, o * t);
        }
        return this;
      }
      validate() {
        let t = true;
        const e = this.getValueSize();
        e - Math.floor(e) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t = false);
        const i = this.times, n = this.values, r = i.length;
        0 === r && (console.error("THREE.KeyframeTrack: Track is empty.", this), t = false);
        let o = null;
        for (let e = 0; e !== r; e++) {
          const n = i[e];
          if ("number" == typeof n && isNaN(n)) {
            console.error("THREE.KeyframeTrack: Time is not a valid number.", this, e, n), t = false;
            break;
          }
          if (null !== o && o > n) {
            console.error("THREE.KeyframeTrack: Out of order keys.", this, e, n, o), t = false;
            break;
          }
          o = n;
        }
        if (void 0 !== n && Ko.isTypedArray(n)) for (let e = 0, i = n.length; e !== i; ++e) {
          const i = n[e];
          if (isNaN(i)) {
            console.error("THREE.KeyframeTrack: Value is not a valid number.", this, e, i), t = false;
            break;
          }
        }
        return t;
      }
      optimize() {
        const t = Ko.arraySlice(this.times), e = Ko.arraySlice(this.values), i = this.getValueSize(), n = this.getInterpolation() === B, r = t.length - 1;
        let o = 1;
        for (let s = 1; s < r; ++s) {
          let r = false;
          const a = t[s];
          if (a !== t[s + 1] && (1 !== s || a !== t[0])) if (n) r = true; else {
            const t = s * i, n = t - i, o = t + i;
            for (let s = 0; s !== i; ++s) {
              const i = e[t + s];
              if (i !== e[n + s] || i !== e[o + s]) {
                r = true;
                break;
              }
            }
          }
          if (r) {
            if (s !== o) {
              t[o] = t[s];
              const n = s * i, r = o * i;
              for (let t = 0; t !== i; ++t) e[r + t] = e[n + t];
            }
            ++o;
          }
        }
        if (r > 0) {
          t[o] = t[r];
          for (let t = r * i, n = o * i, s = 0; s !== i; ++s) e[n + s] = e[t + s];
          ++o;
        }
        return o !== t.length ? (this.times = Ko.arraySlice(t, 0, o), this.values = Ko.arraySlice(e, 0, o * i)) : (this.times = t, this.values = e), this;
      }
      clone() {
        const t = Ko.arraySlice(this.times, 0), e = Ko.arraySlice(this.values, 0), i = new (0, this.constructor)(this.name, t, e);
        return i.createInterpolant = this.createInterpolant, i;
      }
    }
    KeyframeTrack.prototype.TimeBufferType = Float32Array, KeyframeTrack.prototype.ValueBufferType = Float32Array, KeyframeTrack.prototype.DefaultInterpolation = V;
    class BooleanKeyframeTrack extends KeyframeTrack {}
    BooleanKeyframeTrack.prototype.ValueTypeName = "bool", BooleanKeyframeTrack.prototype.ValueBufferType = Array, BooleanKeyframeTrack.prototype.DefaultInterpolation = D, BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0, BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
    class ColorKeyframeTrack extends KeyframeTrack {}
    ColorKeyframeTrack.prototype.ValueTypeName = "color";
    class NumberKeyframeTrack extends KeyframeTrack {}
    NumberKeyframeTrack.prototype.ValueTypeName = "number";
    class QuaternionLinearInterpolant extends Interpolant {
      constructor(t, e, i, n) {
        super(t, e, i, n);
      }
      interpolate_(t, e, i, n) {
        const r = this.resultBuffer, o = this.sampleValues, s = this.valueSize, a = (i - e) / (n - e);
        let l = t * s;
        for (let t = l + s; l !== t; l += 4) Quaternion.slerpFlat(r, 0, o, l - s, o, l, a);
        return r;
      }
    }
    class QuaternionKeyframeTrack extends KeyframeTrack {
      InterpolantFactoryMethodLinear(t) {
        return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), t);
      }
    }
    QuaternionKeyframeTrack.prototype.ValueTypeName = "quaternion", QuaternionKeyframeTrack.prototype.DefaultInterpolation = V, QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
    class StringKeyframeTrack extends KeyframeTrack {}
    StringKeyframeTrack.prototype.ValueTypeName = "string", StringKeyframeTrack.prototype.ValueBufferType = Array, StringKeyframeTrack.prototype.DefaultInterpolation = D, StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0, StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
    class VectorKeyframeTrack extends KeyframeTrack {}
    VectorKeyframeTrack.prototype.ValueTypeName = "vector";
    class AnimationClip {
      constructor(t, e = -1, i, n = 2500) {
        this.name = t, this.tracks = i, this.duration = e, this.blendMode = n, this.uuid = q(), this.duration < 0 && this.resetDuration();
      }
      static parse(t) {
        const e = [], i = t.tracks, n = 1 / (t.fps || 1);
        for (let t = 0, r = i.length; t !== r; ++t) e.push(Qo(i[t]).scale(n));
        const r = new this(t.name, t.duration, e, t.blendMode);
        return r.uuid = t.uuid, r;
      }
      static toJSON(t) {
        const e = [], i = t.tracks, n = {name: t.name, duration: t.duration, tracks: e, uuid: t.uuid, blendMode: t.blendMode};
        for (let t = 0, n = i.length; t !== n; ++t) e.push(KeyframeTrack.toJSON(i[t]));
        return n;
      }
      static CreateFromMorphTargetSequence(t, e, i, n) {
        const r = e.length, o = [];
        for (let t = 0; t < r; t++) {
          let s = [], a = [];
          s.push((t + r - 1) % r, t, (t + 1) % r), a.push(0, 1, 0);
          const l = Ko.getKeyframeOrder(s);
          s = Ko.sortedArray(s, 1, l), a = Ko.sortedArray(a, 1, l), n || 0 !== s[0] || (s.push(r), a.push(a[0])), o.push(new NumberKeyframeTrack(".morphTargetInfluences[" + e[t].name + "]", s, a).scale(1 / i));
        }
        return new this(t, -1, o);
      }
      static findByName(t, e) {
        let i = t;
        if (!Array.isArray(t)) {
          const e = t;
          i = e.geometry && e.geometry.animations || e.animations;
        }
        for (let t = 0; t < i.length; t++) if (i[t].name === e) return i[t];
        return null;
      }
      static CreateClipsFromMorphTargetSequences(t, e, i) {
        const n = {}, r = /^([\w-]*?)([\d]+)$/;
        for (let e = 0, i = t.length; e < i; e++) {
          const i = t[e], o = i.name.match(r);
          if (o && o.length > 1) {
            const t = o[1];
            let e = n[t];
            e || (n[t] = e = []), e.push(i);
          }
        }
        const o = [];
        for (const t in n) o.push(this.CreateFromMorphTargetSequence(t, n[t], e, i));
        return o;
      }
      static parseAnimation(t, e) {
        if (!t) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
        const i = function (t, e, i, n, r) {
          if (0 !== i.length) {
            const o = [], s = [];
            Ko.flattenJSON(i, o, s, n), 0 !== o.length && r.push(new t(e, o, s));
          }
        }, n = [], r = t.name || "default", o = t.fps || 30, s = t.blendMode;
        let a = t.length || -1;
        const l = t.hierarchy || [];
        for (let t = 0; t < l.length; t++) {
          const r = l[t].keys;
          if (r && 0 !== r.length) if (r[0].morphTargets) {
            const t = {};
            let e;
            for (e = 0; e < r.length; e++) if (r[e].morphTargets) for (let i = 0; i < r[e].morphTargets.length; i++) t[r[e].morphTargets[i]] = -1;
            for (const i in t) {
              const t = [], o = [];
              for (let n = 0; n !== r[e].morphTargets.length; ++n) {
                const n = r[e];
                t.push(n.time), o.push(n.morphTarget === i ? 1 : 0);
              }
              n.push(new NumberKeyframeTrack(".morphTargetInfluence[" + i + "]", t, o));
            }
            a = t.length * (o || 1);
          } else {
            const o = ".bones[" + e[t].name + "]";
            i(VectorKeyframeTrack, o + ".position", r, "pos", n), i(QuaternionKeyframeTrack, o + ".quaternion", r, "rot", n), i(VectorKeyframeTrack, o + ".scale", r, "scl", n);
          }
        }
        if (0 === n.length) return null;
        return new this(r, a, n, s);
      }
      resetDuration() {
        let t = 0;
        for (let e = 0, i = this.tracks.length; e !== i; ++e) {
          const i = this.tracks[e];
          t = Math.max(t, i.times[i.times.length - 1]);
        }
        return this.duration = t, this;
      }
      trim() {
        for (let t = 0; t < this.tracks.length; t++) this.tracks[t].trim(0, this.duration);
        return this;
      }
      validate() {
        let t = true;
        for (let e = 0; e < this.tracks.length; e++) t = t && this.tracks[e].validate();
        return t;
      }
      optimize() {
        for (let t = 0; t < this.tracks.length; t++) this.tracks[t].optimize();
        return this;
      }
      clone() {
        const t = [];
        for (let e = 0; e < this.tracks.length; e++) t.push(this.tracks[e].clone());
        return new this.constructor(this.name, this.duration, t, this.blendMode);
      }
      toJSON() {
        return this.constructor.toJSON(this);
      }
    }
    function Qo(t) {
      if (void 0 === t.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
      const e = function (t) {
        switch (t.toLowerCase()) {
          case "scalar":
          case "double":
          case "float":
          case "number":
          case "integer":
            return NumberKeyframeTrack;
          case "vector":
          case "vector2":
          case "vector3":
          case "vector4":
            return VectorKeyframeTrack;
          case "color":
            return ColorKeyframeTrack;
          case "quaternion":
            return QuaternionKeyframeTrack;
          case "bool":
          case "boolean":
            return BooleanKeyframeTrack;
          case "string":
            return StringKeyframeTrack;
        }
        throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t);
      }(t.type);
      if (void 0 === t.times) {
        const e = [], i = [];
        Ko.flattenJSON(t.keys, e, i, "value"), t.times = e, t.values = i;
      }
      return void 0 !== e.parse ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation);
    }
    const $o = {enabled: false, files: {}, add: function (t, e) {
      false !== this.enabled && (this.files[t] = e);
    }, get: function (t) {
      if (false !== this.enabled) return this.files[t];
    }, remove: function (t) {
      delete this.files[t];
    }, clear: function () {
      this.files = {};
    }};
    class LoadingManager {
      constructor(t, e, i) {
        const n = this;
        let r, o = false, s = 0, a = 0;
        const l = [];
        this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = i, this.itemStart = function (t) {
          a++, false === o && void 0 !== n.onStart && n.onStart(t, s, a), o = true;
        }, this.itemEnd = function (t) {
          s++, void 0 !== n.onProgress && n.onProgress(t, s, a), s === a && (o = false, void 0 !== n.onLoad && n.onLoad());
        }, this.itemError = function (t) {
          void 0 !== n.onError && n.onError(t);
        }, this.resolveURL = function (t) {
          return r ? r(t) : t;
        }, this.setURLModifier = function (t) {
          return r = t, this;
        }, this.addHandler = function (t, e) {
          return l.push(t, e), this;
        }, this.removeHandler = function (t) {
          const e = l.indexOf(t);
          return -1 !== e && l.splice(e, 2), this;
        }, this.getHandler = function (t) {
          for (let e = 0, i = l.length; e < i; e += 2) {
            const i = l[e], n = l[e + 1];
            if (i.global && (i.lastIndex = 0), i.test(t)) return n;
          }
          return null;
        };
      }
    }
    const ts = new LoadingManager;
    class Loader {
      constructor(t) {
        this.manager = void 0 !== t ? t : ts, this.crossOrigin = "anonymous", this.withCredentials = false, this.path = "", this.resourcePath = "", this.requestHeader = {};
      }
      load() {}
      loadAsync(t, e) {
        const i = this;
        return new Promise(function (n, r) {
          i.load(t, n, e, r);
        });
      }
      parse() {}
      setCrossOrigin(t) {
        return this.crossOrigin = t, this;
      }
      setWithCredentials(t) {
        return this.withCredentials = t, this;
      }
      setPath(t) {
        return this.path = t, this;
      }
      setResourcePath(t) {
        return this.resourcePath = t, this;
      }
      setRequestHeader(t) {
        return this.requestHeader = t, this;
      }
    }
    const es = {};
    class FileLoader extends Loader {
      constructor(t) {
        super(t);
      }
      load(t, e, i, n) {
        void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
        const r = this, o = $o.get(t);
        if (void 0 !== o) return r.manager.itemStart(t), setTimeout(function () {
          e && e(o), r.manager.itemEnd(t);
        }, 0), o;
        if (void 0 !== es[t]) return void es[t].push({onLoad: e, onProgress: i, onError: n});
        const s = t.match(/^data:(.*?)(;base64)?,(.*)$/);
        let a;
        if (s) {
          const i = s[1], o = !!s[2];
          let a = s[3];
          a = decodeURIComponent(a), o && (a = atob(a));
          try {
            let n;
            const o = (this.responseType || "").toLowerCase();
            switch (o) {
              case "arraybuffer":
              case "blob":
                const t = new Uint8Array(a.length);
                for (let e = 0; e < a.length; e++) t[e] = a.charCodeAt(e);
                n = "blob" === o ? new Blob([t.buffer], {type: i}) : t.buffer;
                break;
              case "document":
                const e = new DOMParser;
                n = e.parseFromString(a, i);
                break;
              case "json":
                n = JSON.parse(a);
                break;
              default:
                n = a;
            }
            setTimeout(function () {
              e && e(n), r.manager.itemEnd(t);
            }, 0);
          } catch (e) {
            setTimeout(function () {
              n && "__private_" + e++ + "_" + e, r.manager.itemError(t), r.manager.itemEnd(t);
            }, 0);
          }
        } else {
          es[t] = [], es[t].push({onLoad: e, onProgress: i, onError: n}), a = new XMLHttpRequest, a.open("GET", t, true), a.addEventListener("load", function (e) {
            const i = this.response, n = es[t];
            if (delete es[t], 200 === this.status || 0 === this.status) {
              0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), $o.add(t, i);
              for (let t = 0, e = n.length; t < e; t++) {
                const e = n[t];
                e.onLoad && e.onLoad(i);
              }
              r.manager.itemEnd(t);
            } else {
              for (let t = 0, i = n.length; t < i; t++) {
                const i = n[t];
                i.onError && i.onError(e);
              }
              r.manager.itemError(t), r.manager.itemEnd(t);
            }
          }, false), a.addEventListener("progress", function (e) {
            const i = es[t];
            for (let t = 0, n = i.length; t < n; t++) {
              const n = i[t];
              n.onProgress && n.onProgress(e);
            }
          }, false), a.addEventListener("error", function (e) {
            const i = es[t];
            delete es[t];
            for (let t = 0, n = i.length; t < n; t++) {
              const n = i[t];
              n.onError && n.onError(e);
            }
            r.manager.itemError(t), r.manager.itemEnd(t);
          }, false), a.addEventListener("abort", function (e) {
            const i = es[t];
            delete es[t];
            for (let t = 0, n = i.length; t < n; t++) {
              const n = i[t];
              n.onError && n.onError(e);
            }
            r.manager.itemError(t), r.manager.itemEnd(t);
          }, false), void 0 !== this.responseType && (a.responseType = this.responseType), void 0 !== this.withCredentials && (a.withCredentials = this.withCredentials), a.overrideMimeType && a.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain");
          for (const t in this.requestHeader) a.setRequestHeader(t, this.requestHeader[t]);
          a.send(null);
        }
        return r.manager.itemStart(t), a;
      }
      setResponseType(t) {
        return this.responseType = t, this;
      }
      setMimeType(t) {
        return this.mimeType = t, this;
      }
    }
    class ImageLoader extends Loader {
      constructor(t) {
        super(t);
      }
      load(t, e, i, n) {
        void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
        const r = this, o = $o.get(t);
        if (void 0 !== o) return r.manager.itemStart(t), setTimeout(function () {
          e && e(o), r.manager.itemEnd(t);
        }, 0), o;
        const s = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
        function a() {
          s.removeEventListener("load", a, false), s.removeEventListener("error", l, false), $o.add(t, this), e && e(this), r.manager.itemEnd(t);
        }
        function l(e) {
          s.removeEventListener("load", a, false), s.removeEventListener("error", l, false), n && "__private_" + e++ + "_" + e, r.manager.itemError(t), r.manager.itemEnd(t);
        }
        return s.addEventListener("load", a, false), s.addEventListener("error", l, false), "data:" !== t.substr(0, 5) && void 0 !== this.crossOrigin && (s.crossOrigin = this.crossOrigin), r.manager.itemStart(t), s.src = t, s;
      }
    }
    class CubeTextureLoader extends Loader {
      constructor(t) {
        super(t);
      }
      load(t, e, i, n) {
        const r = new CubeTexture, o = new ImageLoader(this.manager);
        o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
        let s = 0;
        function a(i) {
          o.load(t[i], function (t) {
            r.images[i] = t, s++, 6 === s && (r.needsUpdate = true, e && e(r));
          }, void 0, n);
        }
        for (let e = 0; e < t.length; ++e) a(e);
        return r;
      }
    }
    class TextureLoader extends Loader {
      constructor(t) {
        super(t);
      }
      load(t, e, i, n) {
        const r = new Texture, o = new ImageLoader(this.manager);
        return o.setCrossOrigin(this.crossOrigin), o.setPath(this.path), o.load(t, function (i) {
          r.image = i;
          const n = t.search(/\.jpe?g($|\?)/i) > 0 || 0 === t.search(/^data\:image\/jpeg/);
          r.format = n ? A : T, r.needsUpdate = true, void 0 !== e && e(r);
        }, i, n), r;
      }
    }
    class CurvePath extends Curve {
      constructor() {
        super(), this.type = "CurvePath", this.curves = [], this.autoClose = false;
      }
      add(t) {
        this.curves.push(t);
      }
      closePath() {
        const t = this.curves[0].getPoint(0), e = this.curves[this.curves.length - 1].getPoint(1);
        t.equals(e) || this.curves.push(new LineCurve(e, t));
      }
      getPoint(t) {
        const e = t * this.getLength(), i = this.getCurveLengths();
        let n = 0;
        for (; n < i.length;) {
          if (i[n] >= e) {
            const t = i[n] - e, r = this.curves[n], o = r.getLength(), s = 0 === o ? 0 : 1 - t / o;
            return r.getPointAt(s);
          }
          n++;
        }
        return null;
      }
      getLength() {
        const t = this.getCurveLengths();
        return t[t.length - 1];
      }
      updateArcLengths() {
        this.needsUpdate = true, this.cacheLengths = null, this.getCurveLengths();
      }
      getCurveLengths() {
        if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
        const t = [];
        let e = 0;
        for (let i = 0, n = this.curves.length; i < n; i++) e += this.curves[i].getLength(), t.push(e);
        return this.cacheLengths = t, t;
      }
      getSpacedPoints(t = 40) {
        const e = [];
        for (let i = 0; i <= t; i++) e.push(this.getPoint(i / t));
        return this.autoClose && e.push(e[0]), e;
      }
      getPoints(t = 12) {
        const e = [];
        let i;
        for (let n = 0, r = this.curves; n < r.length; n++) {
          const o = r[n], s = o && o.isEllipseCurve ? 2 * t : o && (o.isLineCurve || o.isLineCurve3) ? 1 : o && o.isSplineCurve ? t * o.points.length : t, a = o.getPoints(s);
          for (let t = 0; t < a.length; t++) {
            const n = a[t];
            i && i.equals(n) || (e.push(n), i = n);
          }
        }
        return this.autoClose && e.length > 1 && !e[e.length - 1].equals(e[0]) && e.push(e[0]), e;
      }
      copy(t) {
        super.copy(t), this.curves = [];
        for (let e = 0, i = t.curves.length; e < i; e++) {
          const i = t.curves[e];
          this.curves.push(i.clone());
        }
        return this.autoClose = t.autoClose, this;
      }
      toJSON() {
        const t = super.toJSON();
        t.autoClose = this.autoClose, t.curves = [];
        for (let e = 0, i = this.curves.length; e < i; e++) {
          const i = this.curves[e];
          t.curves.push(i.toJSON());
        }
        return t;
      }
      fromJSON(t) {
        super.fromJSON(t), this.autoClose = t.autoClose, this.curves = [];
        for (let e = 0, i = t.curves.length; e < i; e++) {
          const i = t.curves[e];
          this.curves.push((new vo[i.type]).fromJSON(i));
        }
        return this;
      }
    }
    class Path extends CurvePath {
      constructor(t) {
        super(), this.type = "Path", this.currentPoint = new Vector2, t && this.setFromPoints(t);
      }
      setFromPoints(t) {
        this.moveTo(t[0].x, t[0].y);
        for (let e = 1, i = t.length; e < i; e++) this.lineTo(t[e].x, t[e].y);
        return this;
      }
      moveTo(t, e) {
        return this.currentPoint.set(t, e), this;
      }
      lineTo(t, e) {
        const i = new LineCurve(this.currentPoint.clone(), new Vector2(t, e));
        return this.curves.push(i), this.currentPoint.set(t, e), this;
      }
      quadraticCurveTo(t, e, i, n) {
        const r = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(t, e), new Vector2(i, n));
        return this.curves.push(r), this.currentPoint.set(i, n), this;
      }
      bezierCurveTo(t, e, i, n, r, o) {
        const s = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(t, e), new Vector2(i, n), new Vector2(r, o));
        return this.curves.push(s), this.currentPoint.set(r, o), this;
      }
      splineThru(t) {
        const e = [this.currentPoint.clone()].concat(t), i = new SplineCurve(e);
        return this.curves.push(i), this.currentPoint.copy(t[t.length - 1]), this;
      }
      arc(t, e, i, n, r, o) {
        const s = this.currentPoint.x, a = this.currentPoint.y;
        return this.absarc(t + s, e + a, i, n, r, o), this;
      }
      absarc(t, e, i, n, r, o) {
        return this.absellipse(t, e, i, i, n, r, o), this;
      }
      ellipse(t, e, i, n, r, o, s, a) {
        const l = this.currentPoint.x, c = this.currentPoint.y;
        return this.absellipse(t + l, e + c, i, n, r, o, s, a), this;
      }
      absellipse(t, e, i, n, r, o, s, a) {
        const l = new EllipseCurve(t, e, i, n, r, o, s, a);
        if (this.curves.length > 0) {
          const t = l.getPoint(0);
          t.equals(this.currentPoint) || this.lineTo(t.x, t.y);
        }
        this.curves.push(l);
        const c = l.getPoint(1);
        return this.currentPoint.copy(c), this;
      }
      copy(t) {
        return super.copy(t), this.currentPoint.copy(t.currentPoint), this;
      }
      toJSON() {
        const t = super.toJSON();
        return t.currentPoint = this.currentPoint.toArray(), t;
      }
      fromJSON(t) {
        return super.fromJSON(t), this.currentPoint.fromArray(t.currentPoint), this;
      }
    }
    class Shape extends Path {
      constructor(t) {
        super(t), this.uuid = q(), this.type = "Shape", this.holes = [];
      }
      getPointsHoles(t) {
        const e = [];
        for (let i = 0, n = this.holes.length; i < n; i++) e[i] = this.holes[i].getPoints(t);
        return e;
      }
      extractPoints(t) {
        return {shape: this.getPoints(t), holes: this.getPointsHoles(t)};
      }
      copy(t) {
        super.copy(t), this.holes = [];
        for (let e = 0, i = t.holes.length; e < i; e++) {
          const i = t.holes[e];
          this.holes.push(i.clone());
        }
        return this;
      }
      toJSON() {
        const t = super.toJSON();
        t.uuid = this.uuid, t.holes = [];
        for (let e = 0, i = this.holes.length; e < i; e++) {
          const i = this.holes[e];
          t.holes.push(i.toJSON());
        }
        return t;
      }
      fromJSON(t) {
        super.fromJSON(t), this.uuid = t.uuid, this.holes = [];
        for (let e = 0, i = t.holes.length; e < i; e++) {
          const i = t.holes[e];
          this.holes.push((new Path).fromJSON(i));
        }
        return this;
      }
    }
    class Light extends Object3D {
      constructor(t, e = 1) {
        super(), this.type = "Light", this.color = new three_module_Color(t), this.intensity = e;
      }
      dispose() {}
      copy(t) {
        return super.copy(t), this.color.copy(t.color), this.intensity = t.intensity, this;
      }
      toJSON(t) {
        const e = super.toJSON(t);
        return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (e.object.distance = this.distance), void 0 !== this.angle && (e.object.angle = this.angle), void 0 !== this.decay && (e.object.decay = this.decay), void 0 !== this.penumbra && (e.object.penumbra = this.penumbra), void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()), e;
      }
    }
    Light.prototype.isLight = true;
    class HemisphereLight extends Light {
      constructor(t, e, i) {
        super(t, i), this.type = "HemisphereLight", this.position.copy(Object3D.DefaultUp), this.updateMatrix(), this.groundColor = new three_module_Color(e);
      }
      copy(t) {
        return Light.prototype.copy.call(this, t), this.groundColor.copy(t.groundColor), this;
      }
    }
    HemisphereLight.prototype.isHemisphereLight = true;
    const is = new Matrix4, ns = new three_module_Vector3, rs = new three_module_Vector3;
    class LightShadow {
      constructor(t) {
        this.camera = t, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new Vector2(512, 512), this.map = null, this.mapPass = null, this.matrix = new Matrix4, this.autoUpdate = true, this.needsUpdate = false, this._frustum = new Frustum, this._frameExtents = new Vector2(1, 1), this._viewportCount = 1, this._viewports = [new Vector4(0, 0, 1, 1)];
      }
      getViewportCount() {
        return this._viewportCount;
      }
      getFrustum() {
        return this._frustum;
      }
      updateMatrices(t) {
        const e = this.camera, i = this.matrix;
        ns.setFromMatrixPosition(t.matrixWorld), e.position.copy(ns), rs.setFromMatrixPosition(t.target.matrixWorld), e.lookAt(rs), e.updateMatrixWorld(), is.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), this._frustum.setFromProjectionMatrix(is), i.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1), i.multiply(e.projectionMatrix), i.multiply(e.matrixWorldInverse);
      }
      getViewport(t) {
        return this._viewports[t];
      }
      getFrameExtents() {
        return this._frameExtents;
      }
      dispose() {
        this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
      }
      copy(t) {
        return this.camera = t.camera.clone(), this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this;
      }
      clone() {
        return (new this.constructor).copy(this);
      }
      toJSON() {
        const t = {};
        return 0 !== this.bias && (t.bias = this.bias), 0 !== this.normalBias && (t.normalBias = this.normalBias), 1 !== this.radius && (t.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(false).object, delete t.camera.matrix, t;
      }
    }
    class SpotLightShadow extends LightShadow {
      constructor() {
        super(new PerspectiveCamera(50, 1, 0.5, 500)), this.focus = 1;
      }
      updateMatrices(t) {
        const e = this.camera, i = 2 * X * t.angle * this.focus, n = this.mapSize.width / this.mapSize.height, r = t.distance || e.far;
        i === e.fov && n === e.aspect && r === e.far || (e.fov = i, e.aspect = n, e.far = r, e.updateProjectionMatrix()), super.updateMatrices(t);
      }
      copy(t) {
        return super.copy(t), this.focus = t.focus, this;
      }
    }
    SpotLightShadow.prototype.isSpotLightShadow = true;
    class SpotLight extends Light {
      constructor(t, e, i = 0, n = Math.PI / 3, r = 0, o = 1) {
        super(t, e), this.type = "SpotLight", this.position.copy(Object3D.DefaultUp), this.updateMatrix(), this.target = new Object3D, this.distance = i, this.angle = n, this.penumbra = r, this.decay = o, this.shadow = new SpotLightShadow;
      }
      get power() {
        return this.intensity * Math.PI;
      }
      set power (t) {
        this.intensity = t / Math.PI;
      }
      dispose() {
        this.shadow.dispose();
      }
      copy(t) {
        return super.copy(t), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this;
      }
    }
    SpotLight.prototype.isSpotLight = true;
    const os = new Matrix4, ss = new three_module_Vector3, as = new three_module_Vector3;
    class PointLightShadow extends LightShadow {
      constructor() {
        super(new PerspectiveCamera(90, 1, 0.5, 500)), this._frameExtents = new Vector2(4, 2), this._viewportCount = 6, this._viewports = [new Vector4(2, 1, 1, 1), new Vector4(0, 1, 1, 1), new Vector4(3, 1, 1, 1), new Vector4(1, 1, 1, 1), new Vector4(3, 0, 1, 1), new Vector4(1, 0, 1, 1)], this._cubeDirections = [new three_module_Vector3(1, 0, 0), new three_module_Vector3(-1, 0, 0), new three_module_Vector3(0, 0, 1), new three_module_Vector3(0, 0, -1), new three_module_Vector3(0, 1, 0), new three_module_Vector3(0, -1, 0)], this._cubeUps = [new three_module_Vector3(0, 1, 0), new three_module_Vector3(0, 1, 0), new three_module_Vector3(0, 1, 0), new three_module_Vector3(0, 1, 0), new three_module_Vector3(0, 0, 1), new three_module_Vector3(0, 0, -1)];
      }
      updateMatrices(t, e = 0) {
        const i = this.camera, n = this.matrix, r = t.distance || i.far;
        r !== i.far && (i.far = r, i.updateProjectionMatrix()), ss.setFromMatrixPosition(t.matrixWorld), i.position.copy(ss), as.copy(i.position), as.add(this._cubeDirections[e]), i.up.copy(this._cubeUps[e]), i.lookAt(as), i.updateMatrixWorld(), n.makeTranslation(-ss.x, -ss.y, -ss.z), os.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse), this._frustum.setFromProjectionMatrix(os);
      }
    }
    PointLightShadow.prototype.isPointLightShadow = true;
    class PointLight extends Light {
      constructor(t, e, i = 0, n = 1) {
        super(t, e), this.type = "PointLight", this.distance = i, this.decay = n, this.shadow = new PointLightShadow;
      }
      get power() {
        return 4 * this.intensity * Math.PI;
      }
      set power (t) {
        this.intensity = t / (4 * Math.PI);
      }
      dispose() {
        this.shadow.dispose();
      }
      copy(t) {
        return super.copy(t), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this;
      }
    }
    PointLight.prototype.isPointLight = true;
    class DirectionalLightShadow extends LightShadow {
      constructor() {
        super(new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
      }
    }
    DirectionalLightShadow.prototype.isDirectionalLightShadow = true;
    class DirectionalLight extends Light {
      constructor(t, e) {
        super(t, e), this.type = "DirectionalLight", this.position.copy(Object3D.DefaultUp), this.updateMatrix(), this.target = new Object3D, this.shadow = new DirectionalLightShadow;
      }
      dispose() {
        this.shadow.dispose();
      }
      copy(t) {
        return super.copy(t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this;
      }
    }
    DirectionalLight.prototype.isDirectionalLight = true;
    class AmbientLight extends Light {
      constructor(t, e) {
        super(t, e), this.type = "AmbientLight";
      }
    }
    AmbientLight.prototype.isAmbientLight = true;
    class RectAreaLight extends Light {
      constructor(t, e, i = 10, n = 10) {
        super(t, e), this.type = "RectAreaLight", this.width = i, this.height = n;
      }
      get power() {
        return this.intensity * this.width * this.height * Math.PI;
      }
      set power (t) {
        this.intensity = t / (this.width * this.height * Math.PI);
      }
      copy(t) {
        return super.copy(t), this.width = t.width, this.height = t.height, this;
      }
      toJSON(t) {
        const e = super.toJSON(t);
        return e.object.width = this.width, e.object.height = this.height, e;
      }
    }
    RectAreaLight.prototype.isRectAreaLight = true;
    class SphericalHarmonics3 {
      constructor() {
        this.coefficients = [];
        for (let t = 0; t < 9; t++) this.coefficients.push(new three_module_Vector3);
      }
      set(t) {
        for (let e = 0; e < 9; e++) this.coefficients[e].copy(t[e]);
        return this;
      }
      zero() {
        for (let t = 0; t < 9; t++) this.coefficients[t].set(0, 0, 0);
        return this;
      }
      getAt(t, e) {
        const i = t.x, n = t.y, r = t.z, o = this.coefficients;
        return e.copy(o[0]).multiplyScalar(0.282095), e.addScaledVector(o[1], 0.488603 * n), e.addScaledVector(o[2], 0.488603 * r), e.addScaledVector(o[3], 0.488603 * i), e.addScaledVector(o[4], i * n * 1.092548), e.addScaledVector(o[5], n * r * 1.092548), e.addScaledVector(o[6], 0.315392 * (3 * r * r - 1)), e.addScaledVector(o[7], i * r * 1.092548), e.addScaledVector(o[8], 0.546274 * (i * i - n * n)), e;
      }
      getIrradianceAt(t, e) {
        const i = t.x, n = t.y, r = t.z, o = this.coefficients;
        return e.copy(o[0]).multiplyScalar(0.886227), e.addScaledVector(o[1], 1.023328 * n), e.addScaledVector(o[2], 1.023328 * r), e.addScaledVector(o[3], 1.023328 * i), e.addScaledVector(o[4], 0.858086 * i * n), e.addScaledVector(o[5], 0.858086 * n * r), e.addScaledVector(o[6], 0.743125 * r * r - 0.247708), e.addScaledVector(o[7], 0.858086 * i * r), e.addScaledVector(o[8], 0.429043 * (i * i - n * n)), e;
      }
      add(t) {
        for (let e = 0; e < 9; e++) this.coefficients[e].add(t.coefficients[e]);
        return this;
      }
      addScaledSH(t, e) {
        for (let i = 0; i < 9; i++) this.coefficients[i].addScaledVector(t.coefficients[i], e);
        return this;
      }
      scale(t) {
        for (let e = 0; e < 9; e++) this.coefficients[e].multiplyScalar(t);
        return this;
      }
      lerp(t, e) {
        for (let i = 0; i < 9; i++) this.coefficients[i].lerp(t.coefficients[i], e);
        return this;
      }
      equals(t) {
        for (let e = 0; e < 9; e++) if (!this.coefficients[e].equals(t.coefficients[e])) return false;
        return true;
      }
      copy(t) {
        return this.set(t.coefficients);
      }
      clone() {
        return (new this.constructor).copy(this);
      }
      fromArray(t, e = 0) {
        const i = this.coefficients;
        for (let n = 0; n < 9; n++) i[n].fromArray(t, e + 3 * n);
        return this;
      }
      toArray(t = [], e = 0) {
        const i = this.coefficients;
        for (let n = 0; n < 9; n++) i[n].toArray(t, e + 3 * n);
        return t;
      }
      static getBasisAt(t, e) {
        const i = t.x, n = t.y, r = t.z;
        e[0] = 0.282095, e[1] = 0.488603 * n, e[2] = 0.488603 * r, e[3] = 0.488603 * i, e[4] = 1.092548 * i * n, e[5] = 1.092548 * n * r, e[6] = 0.315392 * (3 * r * r - 1), e[7] = 1.092548 * i * r, e[8] = 0.546274 * (i * i - n * n);
      }
    }
    SphericalHarmonics3.prototype.isSphericalHarmonics3 = true;
    class LightProbe extends Light {
      constructor(t = new SphericalHarmonics3, e = 1) {
        super(void 0, e), this.sh = t;
      }
      copy(t) {
        return super.copy(t), this.sh.copy(t.sh), this;
      }
      fromJSON(t) {
        return this.intensity = t.intensity, this.sh.fromArray(t.sh), this;
      }
      toJSON(t) {
        const e = super.toJSON(t);
        return e.object.sh = this.sh.toArray(), e;
      }
    }
    LightProbe.prototype.isLightProbe = true;
    class LoaderUtils {
      static decodeText(t) {
        if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(t);
        let e = "";
        for (let i = 0, n = t.length; i < n; i++) e += String.fromCharCode(t[i]);
        try {
          return decodeURIComponent(escape(e));
        } catch (t) {
          return e;
        }
      }
      static extractUrlBase(t) {
        const e = t.lastIndexOf("/");
        return -1 === e ? "./" : t.substr(0, e + 1);
      }
    }
    class InstancedBufferGeometry extends BufferGeometry {
      constructor() {
        super(), this.type = "InstancedBufferGeometry", this.instanceCount = Infinity;
      }
      copy(t) {
        return super.copy(t), this.instanceCount = t.instanceCount, this;
      }
      clone() {
        return (new this.constructor).copy(this);
      }
      toJSON() {
        const t = super.toJSON(this);
        return t.instanceCount = this.instanceCount, t.isInstancedBufferGeometry = true, t;
      }
    }
    InstancedBufferGeometry.prototype.isInstancedBufferGeometry = true;
    (class ImageBitmapLoader extends Loader {
      constructor(t) {
        super(t), "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = {premultiplyAlpha: "none"};
      }
      setOptions(t) {
        return this.options = t, this;
      }
      load(t, e, i, n) {
        void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
        const r = this, o = $o.get(t);
        if (void 0 !== o) return r.manager.itemStart(t), setTimeout(function () {
          e && e(o), r.manager.itemEnd(t);
        }, 0), o;
        const s = {};
        s.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include", s.headers = this.requestHeader, fetch(t, s).then(function (t) {
          return t.blob();
        }).then(function (t) {
          return createImageBitmap(t, Object.assign(r.options, {colorSpaceConversion: "none"}));
        }).then(function (i) {
          $o.add(t, i), e && e(i), r.manager.itemEnd(t);
        }).catch(function (e) {
          n && "__private_" + e++ + "_" + e, r.manager.itemError(t), r.manager.itemEnd(t);
        }), r.manager.itemStart(t);
      }
    }.prototype.isImageBitmapLoader = true);
    class ShapePath {
      constructor() {
        this.type = "ShapePath", this.color = new three_module_Color, this.subPaths = [], this.currentPath = null;
      }
      moveTo(t, e) {
        return this.currentPath = new Path, this.subPaths.push(this.currentPath), this.currentPath.moveTo(t, e), this;
      }
      lineTo(t, e) {
        return this.currentPath.lineTo(t, e), this;
      }
      quadraticCurveTo(t, e, i, n) {
        return this.currentPath.quadraticCurveTo(t, e, i, n), this;
      }
      bezierCurveTo(t, e, i, n, r, o) {
        return this.currentPath.bezierCurveTo(t, e, i, n, r, o), this;
      }
      splineThru(t) {
        return this.currentPath.splineThru(t), this;
      }
      toShapes(t, e) {
        function i(t) {
          const e = [];
          for (let i = 0, n = t.length; i < n; i++) {
            const n = t[i], r = new Shape;
            r.curves = n.curves, e.push(r);
          }
          return e;
        }
        function n(t, e) {
          const i = e.length;
          let n = false;
          for (let r = i - 1, o = 0; o < i; r = o++) {
            let i = e[r], s = e[o], a = s.x - i.x, l = s.y - i.y;
            if (Math.abs(l) > Number.EPSILON) {
              if (l < 0 && (i = e[o], a = -a, s = e[r], l = -l), t.y < i.y || t.y > s.y) continue;
              if (t.y === i.y) {
                if (t.x === i.x) return true;
              } else {
                const e = l * (t.x - i.x) - a * (t.y - i.y);
                if (0 === e) return true;
                if (e < 0) continue;
                n = !n;
              }
            } else {
              if (t.y !== i.y) continue;
              if (s.x <= t.x && t.x <= i.x || i.x <= t.x && t.x <= s.x) return true;
            }
          }
          return n;
        }
        const r = ShapeUtils.isClockWise, o = this.subPaths;
        if (0 === o.length) return [];
        if (true === e) return i(o);
        let s, a, l;
        const c = [];
        if (1 === o.length) return a = o[0], l = new Shape, l.curves = a.curves, c.push(l), c;
        let h = !r(o[0].getPoints());
        h = t ? !h : h;
        const u = [], m = [];
        let p, d, f = [], _ = 0;
        m[_] = void 0, f[_] = [];
        for (let e = 0, i = o.length; e < i; e++) a = o[e], p = a.getPoints(), s = r(p), s = t ? !s : s, s ? (!h && m[_] && _++, m[_] = {s: new Shape, p}, m[_].s.curves = a.curves, h && _++, f[_] = []) : f[_].push({h: a, p: p[0]});
        if (!m[0]) return i(o);
        if (m.length > 1) {
          let t = false;
          const e = [];
          for (let t = 0, e = m.length; t < e; t++) u[t] = [];
          for (let i = 0, r = m.length; i < r; i++) {
            const r = f[i];
            for (let o = 0; o < r.length; o++) {
              const s = r[o];
              let a = true;
              for (let r = 0; r < m.length; r++) "__private_" + e++ + "_" + s.p && (i !== r && e.push({froms: i, tos: r, hole: o}), a ? (a = false, u[r].push(s)) : t = true);
              a && u[i].push(s);
            }
          }
          e.length > 0 && (t || (f = u));
        }
        for (let t = 0, e = m.length; t < e; t++) {
          l = m[t].s, c.push(l), d = f[t];
          for (let t = 0, e = d.length; t < e; t++) l.holes.push(d[t].h);
        }
        return c;
      }
    }
    class Font {
      constructor(t) {
        this.type = "Font", this.data = t;
      }
      generateShapes(t, e = 100) {
        const i = [], n = function (t, e, i) {
          const n = Array.from(t), r = e / i.resolution, o = (i.boundingBox.yMax - i.boundingBox.yMin + i.underlineThickness) * r, s = [];
          let a = 0, l = 0;
          for (let t = 0; t < n.length; t++) {
            const e = n[t];
            if ("\n" === e) a = 0, l -= o; else {
              const t = ls(e, r, a, l, i);
              a += t.offsetX, s.push(t.path);
            }
          }
          return s;
        }(t, e, this.data);
        for (let t = 0, e = n.length; t < e; t++) Array.prototype.push.apply(i, n[t].toShapes());
        return i;
      }
    }
    function ls(t, e, i, n, r) {
      const o = r.glyphs[t] || r.glyphs["?"];
      if (!o) return void console.error('THREE.Font: character "' + t + '" does not exists in font family ' + r.familyName + ".");
      const s = new ShapePath;
      let a, l, c, h, u, m, p, d;
      if (o.o) {
        const t = o._cachedOutline || (o._cachedOutline = o.o.split(" "));
        for (let r = 0, o = t.length; r < o;) {
          switch (t[r++]) {
            case "m":
              a = t[r++] * e + i, l = t[r++] * e + n, s.moveTo(a, l);
              break;
            case "l":
              a = t[r++] * e + i, l = t[r++] * e + n, s.lineTo(a, l);
              break;
            case "q":
              c = t[r++] * e + i, h = t[r++] * e + n, u = t[r++] * e + i, m = t[r++] * e + n, s.quadraticCurveTo(u, m, c, h);
              break;
            case "b":
              c = t[r++] * e + i, h = t[r++] * e + n, u = t[r++] * e + i, m = t[r++] * e + n, p = t[r++] * e + i, d = t[r++] * e + n, s.bezierCurveTo(u, m, p, d, c, h);
          }
        }
      }
      return {offsetX: o.ha * e, path: s};
    }
    Font.prototype.isFont = true;
    let cs;
    class AudioLoader extends Loader {
      constructor(t) {
        super(t);
      }
      load(t, e, i, n) {
        const r = this, o = new FileLoader(this.manager);
        o.setResponseType("arraybuffer"), o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(t, function (i) {
          try {
            const t = i.slice(0);
            (void 0 === cs && (cs = new (window.AudioContext || window.webkitAudioContext)), cs).decodeAudioData(t, function (t) {
              e(t);
            });
          } catch (e) {
            n ? "__private_" + e++ + "_" + e : console.error(e), r.manager.itemError(t);
          }
        }, i, n);
      }
    }
    (class HemisphereLightProbe extends LightProbe {
      constructor(t, e, i = 1) {
        super(void 0, i);
        const n = (new three_module_Color).set(t), r = (new three_module_Color).set(e), o = new three_module_Vector3(n.r, n.g, n.b), s = new three_module_Vector3(r.r, r.g, r.b), a = Math.sqrt(Math.PI), l = a * Math.sqrt(0.75);
        this.sh.coefficients[0].copy(o).add(s).multiplyScalar(a), this.sh.coefficients[1].copy(o).sub(s).multiplyScalar(l);
      }
    }.prototype.isHemisphereLightProbe = true);
    (class AmbientLightProbe extends LightProbe {
      constructor(t, e = 1) {
        super(void 0, e);
        const i = (new three_module_Color).set(t);
        this.sh.coefficients[0].set(i.r, i.g, i.b).multiplyScalar(2 * Math.sqrt(Math.PI));
      }
    }.prototype.isAmbientLightProbe = true);
    class Audio extends Object3D {
      constructor(t) {
        super(), this.type = "Audio", this.listener = t, this.context = t.context, this.gain = this.context.createGain(), this.gain.connect(t.getInput()), this.autoplay = false, this.buffer = null, this.detune = 0, this.loop = false, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = false, this.hasPlaybackControl = true, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = false, this.filters = [];
      }
      getOutput() {
        return this.gain;
      }
      setNodeSource(t) {
        return this.hasPlaybackControl = false, this.sourceType = "audioNode", this.source = t, this.connect(), this;
      }
      setMediaElementSource(t) {
        return this.hasPlaybackControl = false, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(t), this.connect(), this;
      }
      setMediaStreamSource(t) {
        return this.hasPlaybackControl = false, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(t), this.connect(), this;
      }
      setBuffer(t) {
        return this.buffer = t, this.sourceType = "buffer", this.autoplay && this.play(), this;
      }
      play(t = 0) {
        if (true === this.isPlaying) return void console.warn("THREE.Audio: Audio is already playing.");
        if (false === this.hasPlaybackControl) return void console.warn("THREE.Audio: this Audio has no playback control.");
        this._startedAt = this.context.currentTime + t;
        const e = this.context.createBufferSource();
        return e.buffer = this.buffer, e.loop = this.loop, e.loopStart = this.loopStart, e.loopEnd = this.loopEnd, e.onended = this.onEnded.bind(this), e.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = true, this.source = e, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect();
      }
      pause() {
        if (false !== this.hasPlaybackControl) return true === this.isPlaying && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, true === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = false), this;
        console.warn("THREE.Audio: this Audio has no playback control.");
      }
      stop() {
        if (false !== this.hasPlaybackControl) return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = false, this;
        console.warn("THREE.Audio: this Audio has no playback control.");
      }
      connect() {
        if (this.filters.length > 0) {
          this.source.connect(this.filters[0]);
          for (let t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].connect(this.filters[t]);
          this.filters[this.filters.length - 1].connect(this.getOutput());
        } else this.source.connect(this.getOutput());
        return this._connected = true, this;
      }
      disconnect() {
        if (this.filters.length > 0) {
          this.source.disconnect(this.filters[0]);
          for (let t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].disconnect(this.filters[t]);
          this.filters[this.filters.length - 1].disconnect(this.getOutput());
        } else this.source.disconnect(this.getOutput());
        return this._connected = false, this;
      }
      getFilters() {
        return this.filters;
      }
      setFilters(t) {
        return t || (t = []), true === this._connected ? (this.disconnect(), this.filters = t.slice(), this.connect()) : this.filters = t.slice(), this;
      }
      setDetune(t) {
        if (this.detune = t, void 0 !== this.source.detune) return true === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01), this;
      }
      getDetune() {
        return this.detune;
      }
      getFilter() {
        return this.getFilters()[0];
      }
      setFilter(t) {
        return this.setFilters(t ? [t] : []);
      }
      setPlaybackRate(t) {
        if (false !== this.hasPlaybackControl) return this.playbackRate = t, true === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01), this;
        console.warn("THREE.Audio: this Audio has no playback control.");
      }
      getPlaybackRate() {
        return this.playbackRate;
      }
      onEnded() {
        this.isPlaying = false;
      }
      getLoop() {
        return false === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), false) : this.loop;
      }
      setLoop(t) {
        if (false !== this.hasPlaybackControl) return this.loop = t, true === this.isPlaying && (this.source.loop = this.loop), this;
        console.warn("THREE.Audio: this Audio has no playback control.");
      }
      setLoopStart(t) {
        return this.loopStart = t, this;
      }
      setLoopEnd(t) {
        return this.loopEnd = t, this;
      }
      getVolume() {
        return this.gain.gain.value;
      }
      setVolume(t) {
        return this.gain.gain.setTargetAtTime(t, this.context.currentTime, 0.01), this;
      }
    }
    class PropertyMixer {
      constructor(t, e, i) {
        let n, r, o;
        switch (this.binding = t, this.valueSize = i, e) {
          case "quaternion":
            n = this._slerp, r = this._slerpAdditive, o = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * i), this._workIndex = 5;
            break;
          case "string":
          case "bool":
            n = this._select, r = this._select, o = this._setAdditiveIdentityOther, this.buffer = new Array(5 * i);
            break;
          default:
            n = this._lerp, r = this._lerpAdditive, o = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * i);
        }
        this._mixBufferRegion = n, this._mixBufferRegionAdditive = r, this._setIdentity = o, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0;
      }
      accumulate(t, e) {
        const i = this.buffer, n = this.valueSize, r = t * n + n;
        let o = this.cumulativeWeight;
        if (0 === o) {
          for (let t = 0; t !== n; ++t) i[r + t] = i[t];
          o = e;
        } else {
          o += e;
          const t = e / o;
          this._mixBufferRegion(i, r, 0, t, n);
        }
        this.cumulativeWeight = o;
      }
      accumulateAdditive(t) {
        const e = this.buffer, i = this.valueSize, n = i * this._addIndex;
        0 === this.cumulativeWeightAdditive && this._setIdentity(), this._mixBufferRegionAdditive(e, n, 0, t, i), this.cumulativeWeightAdditive += t;
      }
      apply(t) {
        const e = this.valueSize, i = this.buffer, n = t * e + e, r = this.cumulativeWeight, o = this.cumulativeWeightAdditive, s = this.binding;
        if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, r < 1) {
          const t = e * this._origIndex;
          this._mixBufferRegion(i, n, t, 1 - r, e);
        }
        o > 0 && this._mixBufferRegionAdditive(i, n, this._addIndex * e, 1, e);
        for (let t = e, r = e + e; t !== r; ++t) if (i[t] !== i[t + e]) {
          s.setValue(i, n);
          break;
        }
      }
      saveOriginalState() {
        const t = this.binding, e = this.buffer, i = this.valueSize, n = i * this._origIndex;
        t.getValue(e, n);
        for (let t = i; t !== r; ++t) e[t] = e[n + t % i];
        this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0;
      }
      restoreOriginalState() {
        const t = 3 * this.valueSize;
        this.binding.setValue(this.buffer, t);
      }
      _setAdditiveIdentityNumeric() {
        const t = this._addIndex * this.valueSize, e = t + this.valueSize;
        for (let i = t; i < e; i++) this.buffer[i] = 0;
      }
      _setAdditiveIdentityQuaternion() {
        this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1;
      }
      _setAdditiveIdentityOther() {
        const t = this._origIndex * this.valueSize, e = this._addIndex * this.valueSize;
        for (let i = 0; i < this.valueSize; i++) this.buffer[e + i] = this.buffer[t + i];
      }
      _select(t, e, i, n, r) {
        if (n >= 0.5) for (let n = 0; n !== r; ++n) t[e + n] = t[i + n];
      }
      _slerp(t, e, i, n) {
        Quaternion.slerpFlat(t, e, t, e, t, i, n);
      }
      _slerpAdditive(t, e, i, n, r) {
        const o = this._workIndex * r;
        Quaternion.multiplyQuaternionsFlat(t, o, t, e, t, i), Quaternion.slerpFlat(t, e, t, e, t, o, n);
      }
      _lerp(t, e, i, n, r) {
        const o = 1 - n;
        for (let s = 0; s !== r; ++s) {
          const r = e + s;
          t[r] = t[r] * o + t[i + s] * n;
        }
      }
      _lerpAdditive(t, e, i, n, r) {
        for (let o = 0; o !== r; ++o) {
          const r = e + o;
          t[r] = t[r] + t[i + o] * n;
        }
      }
    }
    const us = "\\[\\]\\.:\\/", ms = new RegExp("[\\[\\]\\.:\\/]", "g"), ps = "[^\\[\\]\\.:\\/]", ds = "[^" + us.replace("\\.", "") + "]", fs = /((?:WC+[\/:])*)/.source.replace("WC", ps), _s = /(WCOD+)?/.source.replace("WCOD", ds), ys = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", ps), gs = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", ps), xs = new RegExp("^" + fs + _s + ys + gs + "$"), vs = ["material", "materials", "bones"];
    class PropertyBinding {
      constructor(t, e, i) {
        this.path = e, this.parsedPath = i || PropertyBinding.parseTrackName(e), this.node = PropertyBinding.findNode(t, this.parsedPath.nodeName) || t, this.rootNode = t, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
      }
      static create(t, e, i) {
        return t && t.isAnimationObjectGroup ? new PropertyBinding.Composite(t, e, i) : new PropertyBinding(t, e, i);
      }
      static sanitizeNodeName(t) {
        return t.replace(/\s/g, "_").replace(ms, "");
      }
      static parseTrackName(t) {
        const e = xs.exec(t);
        if (!e) throw new Error("PropertyBinding: Cannot parse trackName: " + t);
        const i = {nodeName: e[2], objectName: e[3], objectIndex: e[4], propertyName: e[5], propertyIndex: e[6]}, n = i.nodeName && i.nodeName.lastIndexOf(".");
        if (void 0 !== n && -1 !== n) {
          const t = i.nodeName.substring(n + 1);
          -1 !== vs.indexOf(t) && (i.nodeName = i.nodeName.substring(0, n), i.objectName = t);
        }
        if (null === i.propertyName || 0 === i.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
        return i;
      }
      static findNode(t, e) {
        if (!e || "" === e || "." === e || -1 === e || e === t.name || e === t.uuid) return t;
        if (t.skeleton) {
          const i = t.skeleton.getBoneByName(e);
          if (void 0 !== i) return i;
        }
        if (t.children) {
          const i = function (t) {
            for (let n = 0; n < t.length; n++) {
              const r = t[n];
              if (r.name === e || r.uuid === e) return r;
              const o = i(r.children);
              if (o) return o;
            }
            return null;
          }, n = i(t.children);
          if (n) return n;
        }
        return null;
      }
      _getValue_unavailable() {}
      _setValue_unavailable() {}
      _getValue_direct(t, e) {
        t[e] = this.targetObject[this.propertyName];
      }
      _getValue_array(t, e) {
        const i = this.resolvedProperty;
        for (let n = 0, r = i.length; n !== r; ++n) t[e++] = i[n];
      }
      _getValue_arrayElement(t, e) {
        t[e] = this.resolvedProperty[this.propertyIndex];
      }
      _getValue_toArray(t, e) {
        this.resolvedProperty.toArray(t, e);
      }
      _setValue_direct(t, e) {
        this.targetObject[this.propertyName] = t[e];
      }
      _setValue_direct_setNeedsUpdate(t, e) {
        this.targetObject[this.propertyName] = t[e], this.targetObject.needsUpdate = true;
      }
      _setValue_direct_setMatrixWorldNeedsUpdate(t, e) {
        this.targetObject[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = true;
      }
      _setValue_array(t, e) {
        const i = this.resolvedProperty;
        for (let n = 0, r = i.length; n !== r; ++n) i[n] = t[e++];
      }
      _setValue_array_setNeedsUpdate(t, e) {
        const i = this.resolvedProperty;
        for (let n = 0, r = i.length; n !== r; ++n) i[n] = t[e++];
        this.targetObject.needsUpdate = true;
      }
      _setValue_array_setMatrixWorldNeedsUpdate(t, e) {
        const i = this.resolvedProperty;
        for (let n = 0, r = i.length; n !== r; ++n) i[n] = t[e++];
        this.targetObject.matrixWorldNeedsUpdate = true;
      }
      _setValue_arrayElement(t, e) {
        this.resolvedProperty[this.propertyIndex] = t[e];
      }
      _setValue_arrayElement_setNeedsUpdate(t, e) {
        this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = true;
      }
      _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, e) {
        this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = true;
      }
      _setValue_fromArray(t, e) {
        this.resolvedProperty.fromArray(t, e);
      }
      _setValue_fromArray_setNeedsUpdate(t, e) {
        this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = true;
      }
      _setValue_fromArray_setMatrixWorldNeedsUpdate(t, e) {
        this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = true;
      }
      _getValue_unbound(t, e) {
        this.bind(), this.getValue(t, e);
      }
      _setValue_unbound(t, e) {
        this.bind(), this.setValue(t, e);
      }
      bind() {
        let t = this.node;
        const e = this.parsedPath, i = e.objectName, n = e.propertyName;
        let r = e.propertyIndex;
        if (t || (t = PropertyBinding.findNode(this.rootNode, e.nodeName) || this.rootNode, this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !t) return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
        if (i) {
          let n = e.objectIndex;
          switch (i) {
            case "materials":
              if (!t.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
              if (!t.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
              t = t.material.materials;
              break;
            case "bones":
              if (!t.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
              t = t.skeleton.bones;
              for (let e = 0; e < t.length; e++) if (t[e].name === n) {
                n = e;
                break;
              }
              break;
            default:
              if (void 0 === t[i]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
              t = t[i];
          }
          if (void 0 !== n) {
            if (void 0 === t[n]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
            t = t[n];
          }
        }
        const o = t[n];
        if (void 0 === o) {
          const i = e.nodeName;
          return void console.error("THREE.PropertyBinding: Trying to update property for track: " + i + "." + n + " but it wasn't found.", t);
        }
        let s = this.Versioning.None;
        this.targetObject = t, void 0 !== t.needsUpdate ? s = this.Versioning.NeedsUpdate : void 0 !== t.matrixWorldNeedsUpdate && (s = this.Versioning.MatrixWorldNeedsUpdate);
        let a = this.BindingType.Direct;
        if (void 0 !== r) {
          if ("morphTargetInfluences" === n) {
            if (!t.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
            if (!t.geometry.isBufferGeometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
            if (!t.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
            void 0 !== t.morphTargetDictionary[r] && (r = t.morphTargetDictionary[r]);
          }
          a = this.BindingType.ArrayElement, this.resolvedProperty = o, this.propertyIndex = r;
        } else void 0 !== o.fromArray && void 0 !== o.toArray ? (a = this.BindingType.HasFromToArray, this.resolvedProperty = o) : Array.isArray(o) ? (a = this.BindingType.EntireArray, this.resolvedProperty = o) : this.propertyName = n;
        this.getValue = this.GetterByBindingType[a], this.setValue = this.SetterByBindingTypeAndVersioning[a][s];
      }
      unbind() {
        this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
      }
    }
    PropertyBinding.Composite = class Composite {
      constructor(t, e, i) {
        const n = i || PropertyBinding.parseTrackName(e);
        this._targetGroup = t, this._bindings = t.subscribe_(e, n);
      }
      getValue(t, e) {
        this.bind();
        const i = this._targetGroup.nCachedObjects_, n = this._bindings[i];
        void 0 !== n && n.getValue(t, e);
      }
      setValue(t, e) {
        const i = this._bindings;
        for (let n = this._targetGroup.nCachedObjects_, r = i.length; n !== r; ++n) i[n].setValue(t, e);
      }
      bind() {
        const t = this._bindings;
        for (let e = this._targetGroup.nCachedObjects_, i = t.length; e !== i; ++e) t[e].bind();
      }
      unbind() {
        const t = this._bindings;
        for (let e = this._targetGroup.nCachedObjects_, i = t.length; e !== i; ++e) t[e].unbind();
      }
    }, PropertyBinding.prototype.BindingType = {Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3}, PropertyBinding.prototype.Versioning = {None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2}, PropertyBinding.prototype.GetterByBindingType = [PropertyBinding.prototype._getValue_direct, PropertyBinding.prototype._getValue_array, PropertyBinding.prototype._getValue_arrayElement, PropertyBinding.prototype._getValue_toArray], PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [[PropertyBinding.prototype._setValue_direct, PropertyBinding.prototype._setValue_direct_setNeedsUpdate, PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [PropertyBinding.prototype._setValue_array, PropertyBinding.prototype._setValue_array_setNeedsUpdate, PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate], [PropertyBinding.prototype._setValue_arrayElement, PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate, PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [PropertyBinding.prototype._setValue_fromArray, PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate, PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];
    class AnimationAction {
      constructor(t, e, i = null, n = e.blendMode) {
        this._mixer = t, this._clip = e, this._localRoot = i, this.blendMode = n;
        const r = e.tracks, o = r.length, s = new Array(o), a = {endingStart: R, endingEnd: R};
        for (let t = 0; t !== o; ++t) {
          const e = r[t].createInterpolant(null);
          s[t] = e, e.settings = a;
        }
        this._interpolantSettings = a, this._interpolants = s, this._propertyBindings = new Array(o), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = 2201, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = Infinity, this.paused = false, this.enabled = true, this.clampWhenFinished = false, this.zeroSlopeAtStart = true, this.zeroSlopeAtEnd = true;
      }
      play() {
        return this._mixer._activateAction(this), this;
      }
      stop() {
        return this._mixer._deactivateAction(this), this.reset();
      }
      reset() {
        return this.paused = false, this.enabled = true, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping();
      }
      isRunning() {
        return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this);
      }
      isScheduled() {
        return this._mixer._isActiveAction(this);
      }
      startAt(t) {
        return this._startTime = t, this;
      }
      setLoop(t, e) {
        return this.loop = t, this.repetitions = e, this;
      }
      setEffectiveWeight(t) {
        return this.weight = t, this._effectiveWeight = this.enabled ? t : 0, this.stopFading();
      }
      getEffectiveWeight() {
        return this._effectiveWeight;
      }
      fadeIn(t) {
        return this._scheduleFading(t, 0, 1);
      }
      fadeOut(t) {
        return this._scheduleFading(t, 1, 0);
      }
      crossFadeFrom(t, e, i) {
        if (t.fadeOut(e), this.fadeIn(e), i) {
          const i = this._clip.duration, n = t._clip.duration, r = n / i, o = i / n;
          t.warp(1, r, e), this.warp(o, 1, e);
        }
        return this;
      }
      crossFadeTo(t, e, i) {
        return t.crossFadeFrom(this, e, i);
      }
      stopFading() {
        const t = this._weightInterpolant;
        return null !== t && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this;
      }
      setEffectiveTimeScale(t) {
        return this.timeScale = t, this._effectiveTimeScale = this.paused ? 0 : t, this.stopWarping();
      }
      getEffectiveTimeScale() {
        return this._effectiveTimeScale;
      }
      setDuration(t) {
        return this.timeScale = this._clip.duration / t, this.stopWarping();
      }
      syncWith(t) {
        return this.time = t.time, this.timeScale = t.timeScale, this.stopWarping();
      }
      halt(t) {
        return this.warp(this._effectiveTimeScale, 0, t);
      }
      warp(t, e, i) {
        const n = this._mixer, r = n.time, o = this.timeScale;
        let s = this._timeScaleInterpolant;
        null === s && (s = n._lendControlInterpolant(), this._timeScaleInterpolant = s);
        const a = s.parameterPositions, l = s.sampleValues;
        return a[0] = r, a[1] = r + i, l[0] = t / o, l[1] = e / o, this;
      }
      stopWarping() {
        const t = this._timeScaleInterpolant;
        return null !== t && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this;
      }
      getMixer() {
        return this._mixer;
      }
      getClip() {
        return this._clip;
      }
      getRoot() {
        return this._localRoot || this._mixer._root;
      }
      _update(t, e, i, n) {
        if (!this.enabled) return void this._updateWeight(t);
        const r = this._startTime;
        if (null !== r) {
          const n = (t - r) * i;
          if (n < 0 || 0 === i) return;
          this._startTime = null, e = i * n;
        }
        e *= this._updateTimeScale(t);
        const o = this._updateTime(e), s = this._updateWeight(t);
        if (s > 0) {
          const t = this._interpolants, e = this._propertyBindings;
          switch (this.blendMode) {
            case 2501:
              for (let i = 0, n = t.length; i !== n; ++i) t[i].evaluate(o), e[i].accumulateAdditive(s);
              break;
            case F:
            default:
              for (let i = 0, r = t.length; i !== r; ++i) t[i].evaluate(o), e[i].accumulate(n, s);
          }
        }
      }
      _updateWeight(t) {
        let e = 0;
        if (this.enabled) {
          e = this.weight;
          const i = this._weightInterpolant;
          if (null !== i) {
            const n = i.evaluate(t)[0];
            e *= n, t > i.parameterPositions[1] && (this.stopFading(), 0 === n && (this.enabled = false));
          }
        }
        return this._effectiveWeight = e, e;
      }
      _updateTimeScale(t) {
        let e = 0;
        if (!this.paused) {
          e = this.timeScale;
          const i = this._timeScaleInterpolant;
          if (null !== i) {
            e *= i.evaluate(t)[0], t > i.parameterPositions[1] && (this.stopWarping(), 0 === e ? this.paused = true : this.timeScale = e);
          }
        }
        return this._effectiveTimeScale = e, e;
      }
      _updateTime(t) {
        const e = this._clip.duration, i = this.loop;
        let n = this.time + t, r = this._loopCount;
        const o = 2202 === i;
        if (0 === t) return -1 === r ? n : o && 1 == (1 & r) ? e - n : n;
        if (2200 === i) {
          -1 === r && (this._loopCount = 0, this._setEndings(true, true, false));
          t: {
            if (n >= e) n = e; else {
              if (!(n < 0)) {
                this.time = n;
                break t;
              }
              n = 0;
            }
            this.clampWhenFinished ? this.paused = true : this.enabled = false, this.time = n, this._mixer.dispatchEvent({type: "finished", action: this, direction: t < 0 ? -1 : 1});
          }
        } else {
          if (-1 === r && (t >= 0 ? (r = 0, this._setEndings(true, 0 === this.repetitions, o)) : this._setEndings(0 === this.repetitions, true, o)), n >= e || n < 0) {
            const i = Math.floor(n / e);
            n -= e * i, r += Math.abs(i);
            const s = this.repetitions - r;
            if (s <= 0) this.clampWhenFinished ? this.paused = true : this.enabled = false, n = t > 0 ? e : 0, this.time = n, this._mixer.dispatchEvent({type: "finished", action: this, direction: t > 0 ? 1 : -1}); else {
              if (1 === s) {
                const e = t < 0;
                this._setEndings(e, !e, o);
              } else this._setEndings(false, false, o);
              this._loopCount = r, this.time = n, this._mixer.dispatchEvent({type: "loop", action: this, loopDelta: i});
            }
          } else this.time = n;
          if (o && 1 == (1 & r)) return e - n;
        }
        return n;
      }
      _setEndings(t, e, i) {
        const n = this._interpolantSettings;
        i ? (n.endingStart = P, n.endingEnd = P) : (n.endingStart = t ? this.zeroSlopeAtStart ? P : R : I, n.endingEnd = e ? this.zeroSlopeAtEnd ? P : R : I);
      }
      _scheduleFading(t, e, i) {
        const n = this._mixer, r = n.time;
        let o = this._weightInterpolant;
        null === o && (o = n._lendControlInterpolant(), this._weightInterpolant = o);
        const s = o.parameterPositions, a = o.sampleValues;
        return s[0] = r, a[0] = e, s[1] = r + t, a[1] = i, this;
      }
    }
    (class AnimationMixer extends EventDispatcher {
      constructor(t) {
        super(), this._root = t, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1;
      }
      _bindAction(t, e) {
        const i = t._localRoot || this._root, n = t._clip.tracks, r = n.length, o = t._propertyBindings, s = t._interpolants, a = i.uuid, l = this._bindingsByRootAndName;
        let c = l[a];
        void 0 === c && (c = {}, l[a] = c);
        for (let t = 0; t !== r; ++t) {
          const r = n[t], l = r.name;
          let h = c[l];
          if (void 0 !== h) o[t] = h; else {
            if (h = o[t], void 0 !== h) {
              null === h._cacheIndex && (++h.referenceCount, this._addInactiveBinding(h, a, l));
              continue;
            }
            const n = e && e._propertyBindings[t].binding.parsedPath;
            h = new PropertyMixer(PropertyBinding.create(i, l, n), r.ValueTypeName, r.getValueSize()), ++h.referenceCount, this._addInactiveBinding(h, a, l), o[t] = h;
          }
          s[t].resultBuffer = h.buffer;
        }
      }
      _activateAction(t) {
        if (!this._isActiveAction(t)) {
          if (null === t._cacheIndex) {
            const e = (t._localRoot || this._root).uuid, i = t._clip.uuid, n = this._actionsByClip[i];
            this._bindAction(t, n && n.knownActions[0]), this._addInactiveAction(t, i, e);
          }
          const e = t._propertyBindings;
          for (let t = 0, i = e.length; t !== i; ++t) {
            const i = e[t];
            0 == i.useCount++ && (this._lendBinding(i), i.saveOriginalState());
          }
          this._lendAction(t);
        }
      }
      _deactivateAction(t) {
        if (this._isActiveAction(t)) {
          const e = t._propertyBindings;
          for (let t = 0, i = e.length; t !== i; ++t) {
            const i = e[t];
            0 == --i.useCount && (i.restoreOriginalState(), this._takeBackBinding(i));
          }
          this._takeBackAction(t);
        }
      }
      _initMemoryManager() {
        this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
        const t = this;
        this.stats = {actions: {get total() {
          return t._actions.length;
        }, get inUse() {
          return t._nActiveActions;
        }}, bindings: {get total() {
          return t._bindings.length;
        }, get inUse() {
          return t._nActiveBindings;
        }}, controlInterpolants: {get total() {
          return t._controlInterpolants.length;
        }, get inUse() {
          return t._nActiveControlInterpolants;
        }}};
      }
      _isActiveAction(t) {
        const e = t._cacheIndex;
        return null !== e && e < this._nActiveActions;
      }
      _addInactiveAction(t, e, i) {
        const n = this._actions, r = this._actionsByClip;
        let o = r[e];
        if (void 0 === o) o = {knownActions: [t], actionByRoot: {}}, t._byClipCacheIndex = 0, r[e] = o; else {
          const e = o.knownActions;
          t._byClipCacheIndex = e.length, e.push(t);
        }
        t._cacheIndex = n.length, n.push(t), o.actionByRoot[i] = t;
      }
      _removeInactiveAction(t) {
        const e = this._actions, i = e[e.length - 1], n = t._cacheIndex;
        i._cacheIndex = n, e[n] = i, e.pop(), t._cacheIndex = null;
        const r = t._clip.uuid, o = this._actionsByClip, s = o[r], a = s.knownActions, l = a[a.length - 1], c = t._byClipCacheIndex;
        l._byClipCacheIndex = c, a[c] = l, a.pop(), t._byClipCacheIndex = null;
        delete s.actionByRoot[(t._localRoot || this._root).uuid], 0 === a.length && delete o[r], this._removeInactiveBindingsForAction(t);
      }
      _removeInactiveBindingsForAction(t) {
        const e = t._propertyBindings;
        for (let t = 0, i = e.length; t !== i; ++t) {
          const i = e[t];
          0 == --i.referenceCount && this._removeInactiveBinding(i);
        }
      }
      _lendAction(t) {
        const e = this._actions, i = t._cacheIndex, n = this._nActiveActions++, r = e[n];
        t._cacheIndex = n, e[n] = t, r._cacheIndex = i, e[i] = r;
      }
      _takeBackAction(t) {
        const e = this._actions, i = t._cacheIndex, n = --this._nActiveActions, r = e[n];
        t._cacheIndex = n, e[n] = t, r._cacheIndex = i, e[i] = r;
      }
      _addInactiveBinding(t, e, i) {
        const n = this._bindingsByRootAndName, r = this._bindings;
        let o = n[e];
        void 0 === o && (o = {}, n[e] = o), o[i] = t, t._cacheIndex = r.length, r.push(t);
      }
      _removeInactiveBinding(t) {
        const e = this._bindings, i = t.binding, n = i.rootNode.uuid, r = i.path, o = this._bindingsByRootAndName, s = o[n], a = e[e.length - 1], l = t._cacheIndex;
        a._cacheIndex = l, e[l] = a, e.pop(), delete s[r], 0 === Object.keys(s).length && delete o[n];
      }
      _lendBinding(t) {
        const e = this._bindings, i = t._cacheIndex, n = this._nActiveBindings++, r = e[n];
        t._cacheIndex = n, e[n] = t, r._cacheIndex = i, e[i] = r;
      }
      _takeBackBinding(t) {
        const e = this._bindings, i = t._cacheIndex, n = --this._nActiveBindings, r = e[n];
        t._cacheIndex = n, e[n] = t, r._cacheIndex = i, e[i] = r;
      }
      _lendControlInterpolant() {
        const t = this._controlInterpolants, e = this._nActiveControlInterpolants++;
        let i = t[e];
        return void 0 === i && (i = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), i.__cacheIndex = e, t[e] = i), i;
      }
      _takeBackControlInterpolant(t) {
        const e = this._controlInterpolants, i = t.__cacheIndex, n = --this._nActiveControlInterpolants, r = e[n];
        t.__cacheIndex = n, e[n] = t, r.__cacheIndex = i, e[i] = r;
      }
      clipAction(t, e, i) {
        const n = e || this._root, r = n.uuid;
        let o = "string" == typeof t ? AnimationClip.findByName(n, t) : t;
        const s = null !== o ? o.uuid : t, a = this._actionsByClip[s];
        let l = null;
        if (void 0 === i && (i = null !== o ? o.blendMode : F), void 0 !== a) {
          const t = a.actionByRoot[r];
          if (void 0 !== t && t.blendMode === i) return t;
          l = a.knownActions[0], null === o && (o = l._clip);
        }
        if (null === o) return null;
        const c = new AnimationAction(this, o, e, i);
        return this._bindAction(c, l), this._addInactiveAction(c, s, r), c;
      }
      existingAction(t, e) {
        const i = e || this._root, n = i.uuid, r = "string" == typeof t ? AnimationClip.findByName(i, t) : t, o = r ? r.uuid : t, s = this._actionsByClip[o];
        return void 0 !== s && s.actionByRoot[n] || null;
      }
      stopAllAction() {
        const t = this._actions;
        for (let e = this._nActiveActions - 1; e >= 0; --e) t[e].stop();
        return this;
      }
      update(t) {
        t *= this.timeScale;
        const e = this._actions, i = this._nActiveActions, n = this.time += t, r = Math.sign(t), o = this._accuIndex ^= 1;
        for (let s = 0; s !== i; ++s) {
          e[s]._update(n, t, r, o);
        }
        const s = this._bindings, a = this._nActiveBindings;
        for (let t = 0; t !== a; ++t) s[t].apply(o);
        return this;
      }
      setTime(t) {
        this.time = 0;
        for (let t = 0; t < this._actions.length; t++) this._actions[t].time = 0;
        return this.update(t);
      }
      getRoot() {
        return this._root;
      }
      uncacheClip(t) {
        const e = this._actions, i = t.uuid, n = this._actionsByClip, r = n[i];
        if (void 0 !== r) {
          const t = r.knownActions;
          for (let i = 0, n = t.length; i !== n; ++i) {
            const n = t[i];
            this._deactivateAction(n);
            const r = n._cacheIndex, o = e[e.length - 1];
            n._cacheIndex = null, n._byClipCacheIndex = null, o._cacheIndex = r, e[r] = o, e.pop(), this._removeInactiveBindingsForAction(n);
          }
          delete n[i];
        }
      }
      uncacheRoot(t) {
        const e = t.uuid, i = this._actionsByClip;
        for (const t in i) {
          const n = i[t].actionByRoot[e];
          void 0 !== n && (this._deactivateAction(n), this._removeInactiveAction(n));
        }
        const n = this._bindingsByRootAndName[e];
        if (void 0 !== n) for (const t in n) {
          const e = n[t];
          e.restoreOriginalState(), this._removeInactiveBinding(e);
        }
      }
      uncacheAction(t, e) {
        const i = this.existingAction(t, e);
        null !== i && (this._deactivateAction(i), this._removeInactiveAction(i));
      }
    }.prototype._controlInterpolantsResultBuffer = new Float32Array(1));
    class Uniform {
      constructor(t) {
        "string" == typeof t && (console.warn("THREE.Uniform: Type parameter is no longer needed."), t = arguments[1]), this.value = t;
      }
      clone() {
        return new Uniform(void 0 === this.value.clone ? this.value : this.value.clone());
      }
    }
    (class InstancedInterleavedBuffer extends InterleavedBuffer {
      constructor(t, e, i = 1) {
        super(t, e), this.meshPerAttribute = i;
      }
      copy(t) {
        return super.copy(t), this.meshPerAttribute = t.meshPerAttribute, this;
      }
      clone(t) {
        const e = super.clone(t);
        return e.meshPerAttribute = this.meshPerAttribute, e;
      }
      toJSON(t) {
        const e = super.toJSON(t);
        return e.isInstancedInterleavedBuffer = true, e.meshPerAttribute = this.meshPerAttribute, e;
      }
    }.prototype.isInstancedInterleavedBuffer = true);
    const bs = new Vector2;
    class Box2 {
      constructor(t = new Vector2(Infinity, Infinity), e = new Vector2(-Infinity, -Infinity)) {
        this.min = t, this.max = e;
      }
      set(t, e) {
        return this.min.copy(t), this.max.copy(e), this;
      }
      setFromPoints(t) {
        this.makeEmpty();
        for (let e = 0, i = t.length; e < i; e++) this.expandByPoint(t[e]);
        return this;
      }
      setFromCenterAndSize(t, e) {
        const i = bs.copy(e).multiplyScalar(0.5);
        return this.min.copy(t).sub(i), this.max.copy(t).add(i), this;
      }
      clone() {
        return (new this.constructor).copy(this);
      }
      copy(t) {
        return this.min.copy(t.min), this.max.copy(t.max), this;
      }
      makeEmpty() {
        return this.min.x = this.min.y = Infinity, this.max.x = this.max.y = -Infinity, this;
      }
      isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y;
      }
      getCenter(t) {
        return this.isEmpty() ? t.set(0, 0) : t.addVectors(this.min, this.max).multiplyScalar(0.5);
      }
      getSize(t) {
        return this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min);
      }
      expandByPoint(t) {
        return this.min.min(t), this.max.max(t), this;
      }
      expandByVector(t) {
        return this.min.sub(t), this.max.add(t), this;
      }
      expandByScalar(t) {
        return this.min.addScalar(-t), this.max.addScalar(t), this;
      }
      containsPoint(t) {
        return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y);
      }
      containsBox(t) {
        return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y;
      }
      getParameter(t, e) {
        return e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y));
      }
      intersectsBox(t) {
        return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y);
      }
      clampPoint(t, e) {
        return e.copy(t).clamp(this.min, this.max);
      }
      distanceToPoint(t) {
        return bs.copy(t).clamp(this.min, this.max).sub(t).length();
      }
      intersect(t) {
        return this.min.max(t.min), this.max.min(t.max), this;
      }
      union(t) {
        return this.min.min(t.min), this.max.max(t.max), this;
      }
      translate(t) {
        return this.min.add(t), this.max.add(t), this;
      }
      equals(t) {
        return t.min.equals(this.min) && t.max.equals(this.max);
      }
    }
    Box2.prototype.isBox2 = true;
    (class ImmediateRenderObject extends Object3D {
      constructor(t) {
        super(), this.material = t, this.render = function () {}, this.hasPositions = false, this.hasNormals = false, this.hasColors = false, this.hasUvs = false, this.positionArray = null, this.normalArray = null, this.colorArray = null, this.uvArray = null, this.count = 0;
      }
    }.prototype.isImmediateRenderObject = true);
    const ws = new three_module_Vector3, Ss = new Matrix4, Ms = new Matrix4;
    function Cs(t) {
      const e = [];
      t && t.isBone && e.push(t);
      for (let i = 0; i < t.children.length; i++) e.push.apply(e, Cs(t.children[i]));
      return e;
    }
    const As = new Float32Array(1);
    new Int32Array(As.buffer);
    Curve.create = function (t, e) {
      return console.log("THREE.Curve.create() has been deprecated"), t.prototype = Object.create(Curve.prototype), t.prototype.constructor = t, t.prototype.getPoint = e, t;
    }, Path.prototype.fromPoints = function (t) {
      return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(t);
    }, class GridHelper extends LineSegments {
      constructor(t = 10, e = 10, i = 4473924, n = 8947848) {
        i = new three_module_Color(i), n = new three_module_Color(n);
        const r = e / 2, o = t / e, s = t / 2, a = [], l = [];
        for (let t = 0, c = 0, h = -s; t <= e; t++, h += o) {
          a.push(-s, 0, h, s, 0, h), a.push(h, 0, -s, h, 0, s);
          const e = t === r ? i : n;
          e.toArray(l, c), c += 3, e.toArray(l, c), c += 3, e.toArray(l, c), c += 3, e.toArray(l, c), c += 3;
        }
        const c = new BufferGeometry;
        c.setAttribute("position", new Float32BufferAttribute(a, 3)), c.setAttribute("color", new Float32BufferAttribute(l, 3));
        super(c, new LineBasicMaterial({vertexColors: true, toneMapped: false})), this.type = "GridHelper";
      }
    }.prototype.setColors = function () {
      console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.");
    }, class SkeletonHelper extends LineSegments {
      constructor(t) {
        const e = Cs(t), i = new BufferGeometry, n = [], r = [], o = new three_module_Color(0, 0, 1), s = new three_module_Color(0, 1, 0);
        for (let t = 0; t < e.length; t++) {
          const i = e[t];
          i.parent && i.parent.isBone && (n.push(0, 0, 0), n.push(0, 0, 0), r.push(o.r, o.g, o.b), r.push(s.r, s.g, s.b));
        }
        i.setAttribute("position", new Float32BufferAttribute(n, 3)), i.setAttribute("color", new Float32BufferAttribute(r, 3));
        super(i, new LineBasicMaterial({vertexColors: true, depthTest: false, depthWrite: false, toneMapped: false, transparent: true})), this.type = "SkeletonHelper", this.isSkeletonHelper = true, this.root = t, this.bones = e, this.matrix = t.matrixWorld, this.matrixAutoUpdate = false;
      }
      updateMatrixWorld(t) {
        const e = this.bones, i = this.geometry, n = i.getAttribute("position");
        Ms.copy(this.root.matrixWorld).invert();
        for (let t = 0, i = 0; t < e.length; t++) {
          const r = e[t];
          r.parent && r.parent.isBone && (Ss.multiplyMatrices(Ms, r.matrixWorld), ws.setFromMatrixPosition(Ss), n.setXYZ(i, ws.x, ws.y, ws.z), Ss.multiplyMatrices(Ms, r.parent.matrixWorld), ws.setFromMatrixPosition(Ss), n.setXYZ(i + 1, ws.x, ws.y, ws.z), i += 2);
        }
        i.getAttribute("position").needsUpdate = true, super.updateMatrixWorld(t);
      }
    }.prototype.update = function () {
      console.error("THREE.SkeletonHelper: update() no longer needs to be called.");
    }, Loader.prototype.extractUrlBase = function (t) {
      return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), LoaderUtils.extractUrlBase(t);
    }, Loader.Handlers = {add: function () {
      console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.");
    }, get: function () {
      console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.");
    }}, Box2.prototype.center = function (t) {
      return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(t);
    }, Box2.prototype.empty = function () {
      return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty();
    }, Box2.prototype.isIntersectionBox = function (t) {
      return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t);
    }, Box2.prototype.size = function (t) {
      return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(t);
    }, Box3.prototype.center = function (t) {
      return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(t);
    }, Box3.prototype.empty = function () {
      return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty();
    }, Box3.prototype.isIntersectionBox = function (t) {
      return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t);
    }, Box3.prototype.isIntersectionSphere = function (t) {
      return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t);
    }, Box3.prototype.size = function (t) {
      return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(t);
    }, Sphere.prototype.empty = function () {
      return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."), this.isEmpty();
    }, Frustum.prototype.setFromMatrix = function (t) {
      return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."), this.setFromProjectionMatrix(t);
    }, Matrix3.prototype.flattenToArrayOffset = function (t, e) {
      return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e);
    }, Matrix3.prototype.multiplyVector3 = function (t) {
      return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), t.applyMatrix3(this);
    }, Matrix3.prototype.multiplyVector3Array = function () {
      console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.");
    }, Matrix3.prototype.applyToBufferAttribute = function (t) {
      return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."), t.applyMatrix3(this);
    }, Matrix3.prototype.applyToVector3Array = function () {
      console.error("THREE.Matrix3: .applyToVector3Array() has been removed.");
    }, Matrix3.prototype.getInverse = function (t) {
      return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(t).invert();
    }, Matrix4.prototype.extractPosition = function (t) {
      return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(t);
    }, Matrix4.prototype.flattenToArrayOffset = function (t, e) {
      return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e);
    }, Matrix4.prototype.getPosition = function () {
      return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), (new three_module_Vector3).setFromMatrixColumn(this, 3);
    }, Matrix4.prototype.setRotationFromQuaternion = function (t) {
      return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(t);
    }, Matrix4.prototype.multiplyToArray = function () {
      console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
    }, Matrix4.prototype.multiplyVector3 = function (t) {
      return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this);
    }, Matrix4.prototype.multiplyVector4 = function (t) {
      return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this);
    }, Matrix4.prototype.multiplyVector3Array = function () {
      console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.");
    }, Matrix4.prototype.rotateAxis = function (t) {
      console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), t.transformDirection(this);
    }, Matrix4.prototype.crossVector = function (t) {
      return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this);
    }, Matrix4.prototype.translate = function () {
      console.error("THREE.Matrix4: .translate() has been removed.");
    }, Matrix4.prototype.rotateX = function () {
      console.error("THREE.Matrix4: .rotateX() has been removed.");
    }, Matrix4.prototype.rotateY = function () {
      console.error("THREE.Matrix4: .rotateY() has been removed.");
    }, Matrix4.prototype.rotateZ = function () {
      console.error("THREE.Matrix4: .rotateZ() has been removed.");
    }, Matrix4.prototype.rotateByAxis = function () {
      console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
    }, Matrix4.prototype.applyToBufferAttribute = function (t) {
      return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."), t.applyMatrix4(this);
    }, Matrix4.prototype.applyToVector3Array = function () {
      console.error("THREE.Matrix4: .applyToVector3Array() has been removed.");
    }, Matrix4.prototype.makeFrustum = function (t, e, i, n, r, o) {
      return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(t, e, n, i, r, o);
    }, Matrix4.prototype.getInverse = function (t) {
      return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(t).invert();
    }, Plane.prototype.isIntersectionLine = function (t) {
      return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(t);
    }, Quaternion.prototype.multiplyVector3 = function (t) {
      return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), t.applyQuaternion(this);
    }, Quaternion.prototype.inverse = function () {
      return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."), this.invert();
    }, Ray.prototype.isIntersectionBox = function (t) {
      return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t);
    }, Ray.prototype.isIntersectionPlane = function (t) {
      return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(t);
    }, Ray.prototype.isIntersectionSphere = function (t) {
      return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t);
    }, Triangle.prototype.area = function () {
      return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea();
    }, Triangle.prototype.barycoordFromPoint = function (t, e) {
      return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(t, e);
    }, Triangle.prototype.midpoint = function (t) {
      return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(t);
    }, Triangle.prototypenormal = function (t) {
      return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(t);
    }, Triangle.prototype.plane = function (t) {
      return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(t);
    }, Triangle.barycoordFromPoint = function (t, e, i, n, r) {
      return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), Triangle.getBarycoord(t, e, i, n, r);
    }, Triangle.normal = function (t, e, i, n) {
      return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), Triangle.getNormal(t, e, i, n);
    }, Shape.prototype.extractAllPoints = function (t) {
      return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(t);
    }, Shape.prototype.extrude = function (t) {
      return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new ExtrudeGeometry(this, t);
    }, Shape.prototype.makeGeometry = function (t) {
      return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new ShapeGeometry(this, t);
    }, Vector2.prototype.fromAttribute = function (t, e, i) {
      return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, i);
    }, Vector2.prototype.distanceToManhattan = function (t) {
      return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t);
    }, Vector2.prototype.lengthManhattan = function () {
      return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
    }, three_module_Vector3.prototype.setEulerFromRotationMatrix = function () {
      console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.");
    }, three_module_Vector3.prototype.setEulerFromQuaternion = function () {
      console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.");
    }, three_module_Vector3.prototype.getPositionFromMatrix = function (t) {
      return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(t);
    }, three_module_Vector3.prototype.getScaleFromMatrix = function (t) {
      return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(t);
    }, three_module_Vector3.prototype.getColumnFromMatrix = function (t, e) {
      return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(e, t);
    }, three_module_Vector3.prototype.applyProjection = function (t) {
      return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(t);
    }, three_module_Vector3.prototype.fromAttribute = function (t, e, i) {
      return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, i);
    }, three_module_Vector3.prototype.distanceToManhattan = function (t) {
      return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t);
    }, three_module_Vector3.prototype.lengthManhattan = function () {
      return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
    }, Vector4.prototype.fromAttribute = function (t, e, i) {
      return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, i);
    }, Vector4.prototype.lengthManhattan = function () {
      return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
    }, Object3D.prototype.getChildByName = function (t) {
      return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(t);
    }, Object3D.prototype.renderDepth = function () {
      console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.");
    }, Object3D.prototype.translate = function (t, e) {
      return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(e, t);
    }, Object3D.prototype.getWorldRotation = function () {
      console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.");
    }, Object3D.prototype.applyMatrix = function (t) {
      return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t);
    }, Object.defineProperties(Object3D.prototype, {eulerOrder: {get: function () {
      return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order;
    }, set: function (t) {
      console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = t;
    }}, useQuaternion: {get: function () {
      console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
    }, set: function () {
      console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
    }}}), Mesh.prototype.setDrawMode = function () {
      console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
    }, Object.defineProperties(Mesh.prototype, {drawMode: {get: function () {
      return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."), 0;
    }, set: function () {
      console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
    }}}), SkinnedMesh.prototype.initBones = function () {
      console.error("THREE.SkinnedMesh: initBones() has been removed.");
    }, PerspectiveCamera.prototype.setLens = function (t, e) {
      console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== e && (this.filmGauge = e), this.setFocalLength(t);
    }, Object.defineProperties(Light.prototype, {onlyShadow: {set: function () {
      console.warn("THREE.Light: .onlyShadow has been removed.");
    }}, shadowCameraFov: {set: function (t) {
      console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = t;
    }}, shadowCameraLeft: {set: function (t) {
      console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = t;
    }}, shadowCameraRight: {set: function (t) {
      console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = t;
    }}, shadowCameraTop: {set: function (t) {
      console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = t;
    }}, shadowCameraBottom: {set: function (t) {
      console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = t;
    }}, shadowCameraNear: {set: function (t) {
      console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = t;
    }}, shadowCameraFar: {set: function (t) {
      console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = t;
    }}, shadowCameraVisible: {set: function () {
      console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.");
    }}, shadowBias: {set: function (t) {
      console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = t;
    }}, shadowDarkness: {set: function () {
      console.warn("THREE.Light: .shadowDarkness has been removed.");
    }}, shadowMapWidth: {set: function (t) {
      console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = t;
    }}, shadowMapHeight: {set: function (t) {
      console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = t;
    }}}), Object.defineProperties(BufferAttribute.prototype, {length: {get: function () {
      return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length;
    }}, dynamic: {get: function () {
      return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.usage === H;
    }, set: function () {
      console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.setUsage(H);
    }}}), BufferAttribute.prototype.setDynamic = function (t) {
      return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(true === t ? H : k), this;
    }, BufferAttribute.prototype.copyIndicesArray = function () {
      console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.");
    }, BufferAttribute.prototype.setArray = function () {
      console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
    }, BufferGeometry.prototype.addIndex = function (t) {
      console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(t);
    }, BufferGeometry.prototype.addAttribute = function (t, e) {
      return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."), e && e.isBufferAttribute || e && e.isInterleavedBufferAttribute ? "index" === t ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(e), this) : this.setAttribute(t, e) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.setAttribute(t, new BufferAttribute(arguments[1], arguments[2])));
    }, BufferGeometry.prototype.addDrawCall = function (t, e, i) {
      void 0 !== i && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(t, e);
    }, BufferGeometry.prototype.clearDrawCalls = function () {
      console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups();
    }, BufferGeometry.prototype.computeOffsets = function () {
      console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
    }, BufferGeometry.prototype.removeAttribute = function (t) {
      return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."), this.deleteAttribute(t);
    }, BufferGeometry.prototype.applyMatrix = function (t) {
      return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t);
    }, Object.defineProperties(BufferGeometry.prototype, {drawcalls: {get: function () {
      return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups;
    }}, offsets: {get: function () {
      return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups;
    }}}), InterleavedBuffer.prototype.setDynamic = function (t) {
      return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(true === t ? H : k), this;
    }, InterleavedBuffer.prototype.setArray = function () {
      console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
    }, ExtrudeGeometry.prototype.getArrays = function () {
      console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.");
    }, ExtrudeGeometry.prototype.addShapeList = function () {
      console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.");
    }, ExtrudeGeometry.prototype.addShape = function () {
      console.error("THREE.ExtrudeGeometry: .addShape() has been removed.");
    }, Scene.prototype.dispose = function () {
      console.error("THREE.Scene: .dispose() has been removed.");
    }, Uniform.prototype.onUpdate = function () {
      return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this;
    }, Object.defineProperties(Material.prototype, {wrapAround: {get: function () {
      console.warn("THREE.Material: .wrapAround has been removed.");
    }, set: function () {
      console.warn("THREE.Material: .wrapAround has been removed.");
    }}, overdraw: {get: function () {
      console.warn("THREE.Material: .overdraw has been removed.");
    }, set: function () {
      console.warn("THREE.Material: .overdraw has been removed.");
    }}, wrapRGB: {get: function () {
      return console.warn("THREE.Material: .wrapRGB has been removed."), new three_module_Color;
    }}, shading: {get: function () {
      console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
    }, set: function (t) {
      console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === t;
    }}, stencilMask: {get: function () {
      return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask;
    }, set: function (t) {
      console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask = t;
    }}, vertexTangents: {get: function () {
      console.warn("THREE." + this.type + ": .vertexTangents has been removed.");
    }, set: function () {
      console.warn("THREE." + this.type + ": .vertexTangents has been removed.");
    }}}), Object.defineProperties(ShaderMaterial.prototype, {derivatives: {get: function () {
      return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives;
    }, set: function (t) {
      console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = t;
    }}}), Er.prototype.clearTarget = function (t, e, i, n) {
      console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(t), this.clear(e, i, n);
    }, Er.prototype.animate = function (t) {
      console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(t);
    }, Er.prototype.getCurrentRenderTarget = function () {
      return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget();
    }, Er.prototype.getMaxAnisotropy = function () {
      return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy();
    }, Er.prototype.getPrecision = function () {
      return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision;
    }, Er.prototype.resetGLState = function () {
      return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset();
    }, Er.prototype.supportsFloatTextures = function () {
      return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float");
    }, Er.prototype.supportsHalfFloatTextures = function () {
      return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float");
    }, Er.prototype.supportsStandardDerivatives = function () {
      return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives");
    }, Er.prototype.supportsCompressedTextureS3TC = function () {
      return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc");
    }, Er.prototype.supportsCompressedTexturePVRTC = function () {
      return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc");
    }, Er.prototype.supportsBlendMinMax = function () {
      return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax");
    }, Er.prototype.supportsVertexTextures = function () {
      return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures;
    }, Er.prototype.supportsInstancedArrays = function () {
      return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays");
    }, Er.prototype.enableScissorTest = function (t) {
      console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(t);
    }, Er.prototype.initMaterial = function () {
      console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
    }, Er.prototype.addPrePlugin = function () {
      console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
    }, Er.prototype.addPostPlugin = function () {
      console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
    }, Er.prototype.updateShadowMap = function () {
      console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
    }, Er.prototype.setFaceCulling = function () {
      console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.");
    }, Er.prototype.allocTextureUnit = function () {
      console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.");
    }, Er.prototype.setTexture = function () {
      console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
    }, Er.prototype.setTexture2D = function () {
      console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.");
    }, Er.prototype.setTextureCube = function () {
      console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.");
    }, Er.prototype.getActiveMipMapLevel = function () {
      return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."), this.getActiveMipmapLevel();
    }, Object.defineProperties(Er.prototype, {shadowMapEnabled: {get: function () {
      return this.shadowMap.enabled;
    }, set: function (t) {
      console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = t;
    }}, shadowMapType: {get: function () {
      return this.shadowMap.type;
    }, set: function (t) {
      console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = t;
    }}, shadowMapCullFace: {get: function () {
      console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
    }, set: function () {
      console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
    }}, context: {get: function () {
      return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."), this.getContext();
    }}, vr: {get: function () {
      return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"), this.xr;
    }}, gammaInput: {get: function () {
      return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."), false;
    }, set: function () {
      console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
    }}, gammaOutput: {get: function () {
      return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), false;
    }, set: function (t) {
      console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), this.outputEncoding = true === t ? N : G;
    }}, toneMappingWhitePoint: {get: function () {
      return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."), 1;
    }, set: function () {
      console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.");
    }}}), Object.defineProperties(wr.prototype, {cullFace: {get: function () {
      console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
    }, set: function () {
      console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
    }}, renderReverseSided: {get: function () {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
    }, set: function () {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
    }}, renderSingleSided: {get: function () {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
    }, set: function () {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
    }}}), Object.defineProperties(WebGLRenderTarget.prototype, {wrapS: {get: function () {
      return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS;
    }, set: function (t) {
      console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = t;
    }}, wrapT: {get: function () {
      return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT;
    }, set: function (t) {
      console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = t;
    }}, magFilter: {get: function () {
      return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter;
    }, set: function (t) {
      console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = t;
    }}, minFilter: {get: function () {
      return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter;
    }, set: function (t) {
      console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = t;
    }}, anisotropy: {get: function () {
      return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy;
    }, set: function (t) {
      console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = t;
    }}, offset: {get: function () {
      return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset;
    }, set: function (t) {
      console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = t;
    }}, repeat: {get: function () {
      return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat;
    }, set: function (t) {
      console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = t;
    }}, format: {get: function () {
      return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format;
    }, set: function (t) {
      console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = t;
    }}, type: {get: function () {
      return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type;
    }, set: function (t) {
      console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = t;
    }}, generateMipmaps: {get: function () {
      return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps;
    }, set: function (t) {
      console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = t;
    }}}), Audio.prototype.load = function (t) {
      console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
      const e = this;
      return (new AudioLoader).load(t, function (t) {
        e.setBuffer(t);
      }), this;
    }, CubeCamera.prototype.updateCubeMap = function (t, e) {
      return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(t, e);
    }, CubeCamera.prototype.clear = function (t, e, i, n) {
      return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."), this.renderTarget.clear(t, e, i, n);
    }, ImageUtils.crossOrigin = void 0, ImageUtils.loadTexture = function (t, e, i, n) {
      console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
      const r = new TextureLoader;
      r.setCrossOrigin(this.crossOrigin);
      const o = r.load(t, i, void 0, n);
      return e && (o.mapping = e), o;
    }, ImageUtils.loadTextureCube = function (t, e, i, n) {
      console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
      const r = new CubeTextureLoader;
      r.setCrossOrigin(this.crossOrigin);
      const o = r.load(t, i, void 0, n);
      return e && (o.mapping = e), o;
    }, ImageUtils.loadCompressedTexture = function () {
      console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.");
    }, ImageUtils.loadCompressedTextureCube = function () {
      console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.");
    };
    "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {detail: {revision: "132"}})), "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = "132");
    class Color {
      constructor(t = 255, e = 255, i = 255) {
        this.setScalarRGB(t, e, i);
      }
      setScalarR(t) {
        return this._r = Math.round(t) || 0, this;
      }
      setScalarG(t) {
        return this._g = Math.round(t) || 0, this;
      }
      setScalarB(t) {
        return this._b = Math.round(t) || 0, this;
      }
      set r (t) {
        this.setScalarR(t);
      }
      set g (t) {
        this.setScalarG(t);
      }
      set b (t) {
        this.setScalarB(t);
      }
      get r() {
        return this._r;
      }
      get g() {
        return this._g;
      }
      get b() {
        return this._b;
      }
      setScalarRGB(t, e, i) {
        return this.setScalarR(t).setScalarG(e).setScalarB(i);
      }
      setScalar(t) {
        return this.setScalarR(t >> 16 & 255).setScalarG(t >> 8 & 255).setScalarB(255 & t);
      }
      getScalar() {
        return parseInt(`0x${Color.partOfRgbToHex(this.r)}${Color.partOfRgbToHex(this.g)}${Color.partOfRgbToHex(this.b)}}`, 16);
      }
      static partOfRgbToHex(t) {
        let e = Number(t).toString(16);
        return e.length < 2 && (e = "0" + e), e;
      }
      setHex(t) {
        t = t.replace("#", "");
        const e = parseInt(t, 16);
        return this.setScalarRGB(e >> 16 & 255, e >> 8 & 255, 255 & e);
      }
      getHex() {
        return `#${Color.partOfRgbToHex(this.r)}${Color.partOfRgbToHex(this.g)}${Color.partOfRgbToHex(this.b)}`;
      }
      setArray(t) {
        return this.setScalarRGB(t[0], t[1], t[2]);
      }
      addScalarR(t) {
        return this.setScalarR(this.r + t);
      }
      addScalarG(t) {
        return this.setScalarG(this.g + t);
      }
      addScalarB(t) {
        return this.setScalarB(this.b + t);
      }
      addScalar(t) {
        return this.addScalarR(t).addScalarG(t).addScalarB(t);
      }
      addR(t) {
        return this.addScalarR(t.r);
      }
      addG(t) {
        return this.addScalarG(t.g);
      }
      addB(t) {
        return this.addScalarB(t.b);
      }
      add(t) {
        return this.addR(t).addG(t).addB(t);
      }
      subtractScalarR(t) {
        return this.setScalarR(this.r - t);
      }
      subtractScalarG(t) {
        return this.setScalarG(this.g - t);
      }
      subtractScalarB(t) {
        return this.setScalarB(this.b - t);
      }
      subtractScalar(t) {
        return this.subtractScalarR(t).subtractScalarG(t).subtractScalarB(t);
      }
      subtractR(t) {
        return this.subtractScalarR(t.r);
      }
      subtractG(t) {
        return this.subtractScalarG(t.g);
      }
      subtractB(t) {
        return this.subtractScalarB(t.b);
      }
      subtract(t) {
        return this.subtractR(t).subtractG(t).subtractB(t);
      }
      multiplyScalarR(t) {
        return this.setScalarR(this.r * t);
      }
      multiplyScalarG(t) {
        return this.setScalarG(this.g * t);
      }
      multiplyScalarB(t) {
        return this.setScalarB(this.b * t);
      }
      multiplyScalar(t) {
        return this.multiplyScalarR(t).multiplyScalarG(t).multiplyScalarB(t);
      }
      multiplyR(t) {
        return this.multiplyScalarR(t.r);
      }
      multiplyG(t) {
        return this.multiplyScalarG(t.g);
      }
      multiplyB(t) {
        return this.multiplyScalarB(t.b);
      }
      multiply(t) {
        return this.multiplyR(t).multiplyG(t).multiplyB(t);
      }
      divideScalarR(t) {
        return this.setScalarR(this.r / t);
      }
      divideScalarG(t) {
        return this.setScalarG(this.g / t);
      }
      divideScalarB(t) {
        return this.setScalarB(this.b / t);
      }
      divideScalar(t) {
        return this.divideScalarR(t).divideScalarG(t).divideScalarB(t);
      }
      divideR(t) {
        return this.divideScalarR(t.r);
      }
      divideG(t) {
        return this.divideScalarG(t.g);
      }
      divideB(t) {
        return this.divideScalarB(t.b);
      }
      divide(t) {
        return this.divideR(t).divideG(t).divideB(t);
      }
      copy(t) {
        return this.setScalarRGB(t.r, t.g, t.b);
      }
      clone() {
        return new Color(this.r, this.g, this.b);
      }
      isEqualScalar(t) {
        return this.r === t && this.g === t && this.b === t;
      }
      isEqualTo(t) {
        return this.r === t.r && this.g === t.g && this.b === t.b;
      }
      toGrayScale() {
        const t = 0.58 * this.r + 0.17 * this.g + 0.8 * this.b;
        return this.setScalarR(t).setScalarG(t).setScalarB(t);
      }
      toThreeColor() {
        return new three_module_Color(this.r / 255, this.g / 255, this.b / 255);
      }
      static fromThreeColor(t) {
        return new Color(t.r, t.g, t.b).multiplyScalar(255);
      }
      static fromScalar(t) {
        return (new Color).setScalar(t);
      }
      static fromHex(t) {
        return (new Color).setHex(t);
      }
      static fromArray(t) {
        return (new Color).setArray(t);
      }
    }
    Color.WHITE = Color.fromScalar(16777215), Color.GRAY = Color.fromScalar(11184810), Color.RED = Color.fromScalar(16711680), Color.GREEN = Color.fromScalar(65280), Color.YELLOW = Color.fromScalar(16777045), Color.BLUE = Color.fromScalar(255), Color.AQUA = Color.fromScalar(5636095), Color.BLACK = Color.fromScalar(0);
    class ValueUtils {
      static smoothValue(t, e = 0, i = 12, n = 0.01, r = 0.001) {
        const o = (t - e) / i, s = 1 === i || Math.abs(o) <= n ? t : e + o;
        return Math.abs(s) < r ? 0 : s;
      }
      static smoothAngle(t, e = 0, i = 12, n = 0.001) {
        let r = ValueUtils.absAngle(t), o = ValueUtils.absAngle(e);
        return o - r > Math.PI && (r += 2 * Math.PI, o > 2 * Math.PI && (o -= 2 * Math.PI, r = t)), r - o > Math.PI && (r = -(2 * Math.PI - r), o < 0 && (o = 2 * Math.PI, r = t)), ValueUtils.smoothValue(r, o, i, n);
      }
      static isEqual(t, e, i = 0.01) {
        let n = Math.abs(t - e);
        return console.log("diff", t, e, n), n <= i;
      }
      static mergeOptions(t = {}, e = {}) {
        for (const i in e) t[i] = e[i];
      }
      static isUpper(t) {
        return t === t.toUpperCase();
      }
      static getAvg(t) {
        let e = 0;
        for (let i = 0; i < t.length; i++) e += parseInt(t[i], 10);
        return e / t.length;
      }
      static getMax(t) {
        return Math.max.apply(null, t);
      }
      static getMin(t) {
        return Math.min.apply(null, t);
      }
      static objectUnFreeze(t) {
        let e;
        if (t instanceof Array) {
          e = [];
          const i = t => {
            e.push(t);
          };
          t.forEach(i);
        } else if (t instanceof String) e = String(t).toString(); else if ("object" == typeof t) {
          e = {};
          for (const i in t) e[i] = t[i];
        }
        return e;
      }
      static hashString(t) {
        let e, i = 0;
        if (0 === t.length) return i;
        for (let n = 0; n < t.length; n++) e = t.charCodeAt(n), i = (i << 5) - i + e, i |= 0;
        return i;
      }
      static isNumberChanged(t, e, i = ValueUtils.FACTOR) {
        return Math.abs(t - e) > i;
      }
      static isVector2Changed(t, e, i = ValueUtils.FACTOR) {
        return ValueUtils.isNumberChanged(t.x, e.x, i) || ValueUtils.isNumberChanged(t.y, e.y, i);
      }
      static isPoint2Changed(t, e, i = ValueUtils.FACTOR) {
        return ValueUtils.isNumberChanged(t.x, e.x, i) || ValueUtils.isNumberChanged(t.y, e.y, i);
      }
      static isVector3Changed(t, e, i = ValueUtils.FACTOR) {
        return ValueUtils.isNumberChanged(t.x, e.x, i) || ValueUtils.isNumberChanged(t.y, e.y, i) || ValueUtils.isNumberChanged(t.z, e.z, i);
      }
      static isThreeVector3AndVector3Changed(t, e, i = ValueUtils.FACTOR) {
        return ValueUtils.isNumberChanged(t.x, e.x, i) || ValueUtils.isNumberChanged(t.y, e.y, i) || ValueUtils.isNumberChanged(t.z, e.z, i);
      }
      static isVector4Changed(t, e, i = ValueUtils.FACTOR) {
        return ValueUtils.isNumberChanged(t.x, e.x, i) || ValueUtils.isNumberChanged(t.y, e.y, i) || ValueUtils.isNumberChanged(t.z, e.z, i) || ValueUtils.isNumberChanged(t.w, e.w, i);
      }
      static isEulerChanged(t, e, i = ValueUtils.FACTOR) {
        return ValueUtils.isNumberChanged(t.x, e.x, i) || ValueUtils.isNumberChanged(t.y, e.y, i) || ValueUtils.isNumberChanged(t.z, e.z, i);
      }
      static isThreeEulerAndVector3Changed(t, e, i = ValueUtils.FACTOR) {
        return ValueUtils.isNumberChanged(t.x, e.x, i) || ValueUtils.isNumberChanged(t.y, e.y, i) || ValueUtils.isNumberChanged(t.z, e.z, i);
      }
      static firstNonNull(...t) {
        for (const e in t) {
          const i = t[e];
          if (!this.isUndefinedOrNull(i)) return i;
        }
        return null;
      }
      static firstNonNullOr(t, ...e) {
        for (const t in e) {
          const i = e[t];
          if (!this.isUndefinedOrNull(i)) return i;
        }
        return t;
      }
      static limit(t, e, i) {
        return t = Math.max(e, t), Math.min(i, t);
      }
      static countObjectsKeys(...t) {
        let e = 0;
        for (const i in t) e += Object.keys(t[i]).length;
        return e;
      }
      static copyToClipboard(t) {
        let e, i;
        document.body.createTextRange ? (e = document.body.createTextRange(), e.moveToElementText(t), e.select()) : window.getSelection && (i = window.getSelection(), e = document.createRange(), e.selectNodeContents(t), i.removeAllRanges(), i.addRange(e)), document.execCommand("Copy");
      }
      static fallbackCopyTextToClipboard(t) {
        const e = document.createElement("textarea");
        e.value = t, document.body.appendChild(e), e.focus(), e.select();
        try {
          const t = document.execCommand("copy") ? "successful" : "unsuccessful";
          console.log("Fallback: Copying text command was " + t);
        } catch (t) {
          console.error("Fallback: Oops, unable to copy", t);
        }
        document.body.removeChild(e);
      }
      static copyTextToClipboard(t) {
        navigator.clipboard ? navigator.clipboard.writeText(t).then(() => console.log("Async: Copying to clipboard was successful!")).catch(t => console.error("Async: Could not copy text: ", t)) : ValueUtils.fallbackCopyTextToClipboard(t);
      }
      static cosAngle(t, e) {
        const i = t.length() * e.length();
        return 0 === i ? 0 : t.dot(e) / i;
      }
      static sinAngle(t, e) {
        return 1 - ValueUtils.cosAngle(t, e);
      }
      static toFixed(t, e) {
        return parseFloat(t.toFixed(e));
      }
      static getUpdatedDiff(t, e, i = {}) {
        try {
          for (const n in e) if (false !== e.hasOwnProperty(n)) if (null !== e[n]) {
            if ("Array" === e[n].constructor.name) {
              i[n] = e[n];
              continue;
            }
            if ("Object" === e[n].constructor.name) {
              i[n] = {}, void 0 !== t[n] && null !== t[n] || "Object" === e[n].constructor.name && (t[n] = {});
              const r = ValueUtils.getUpdatedDiff(t[n], e[n], i[n]);
              r && false === ValueUtils.objectIsEmpty(r) && (i[n] = r), 0 === Object.keys(i[n]).length && delete i[n];
            } else null !== t && e[n] !== t[n] && (i[n] = e[n]);
          } else null !== t && e[n] !== t[n] && (i[n] = e[n]);
          return i;
        } catch (n) {
          console.error(n, {oldObject: t, newObject: e, updatedDiff: i});
        }
      }
      static fastMerge(t, e) {
        for (const i in e) false !== e.hasOwnProperty(i) && (null !== e[i] ? "Array" !== e[i].constructor.name && "Object" === e[i].constructor.name ? (void 0 !== t[i] && null !== t[i] || (t[i] = {}), ValueUtils.fastMerge(t[i], e[i])) : t[i] = e[i] : delete t[i]);
      }
      static objectIsEmpty(t) {
        for (const e in t) if (t.hasOwnProperty(e)) return false;
        return true;
      }
      static humanToThreeJsAngle(t) {
        return ValueUtils.absAngle(t - Math.PI / 2);
      }
      static threeJsToHumanAngle(t) {
        return ValueUtils.absAngle(t + Math.PI / 2);
      }
      static absAngle(t) {
        const e = ValueUtils.normalizeAngle(t);
        return e < 0 ? 2 * Math.PI + e : e;
      }
      static absAngleVector3(t) {
        const e = t.clone();
        return e.x = ValueUtils.absAngle(t.x), e.y = ValueUtils.absAngle(t.y), e.z = ValueUtils.absAngle(t.z), e;
      }
      static normalizeAngle(t) {
        const e = 2 * Math.PI;
        return t < e || t > e ? t % e : t;
      }
      static absAngleDeg(t) {
        const e = ValueUtils.normalizeAngleDeg(t);
        return e < 0 ? 360 + e : e;
      }
      static normalizeAngleDeg(t) {
        return t % 360;
      }
      static getHumanityNumber(t) {
        const e = {num: t, suffix: "", text: t.toString()};
        return t >= 1e15 ? (e.num = Math.floor(t / 1e15 * 10) / 10, e.suffix = "Q") : t >= 1e12 ? (e.num = Math.floor(t / 1e12 * 10) / 10, e.suffix = "T") : t >= 1e9 ? (e.num = Math.floor(t / 1e9 * 10) / 10, e.suffix = "B") : t >= 1e6 ? (e.num = Math.floor(t / 1e6 * 10) / 10, e.suffix = "M") : t >= 1e3 && (e.num = Math.floor(t / 1e3 * 10) / 10, e.suffix = "K"), e.text = `${e.num}${e.suffix}`, e;
      }
      static getRawNumberFromHumanity(t) {
        return (t = t.toLowerCase()).endsWith("q") ? 1e15 * parseFloat(t) : t.endsWith("t") ? 1e12 * parseFloat(t) : t.endsWith("b") ? 1e9 * parseFloat(t) : t.endsWith("m") ? 1e6 * parseFloat(t) : t.endsWith("k") ? 1e3 * parseFloat(t) : parseFloat(t);
      }
      static formatMoney(t, e = 2, i = ".", n = ",") {
        const r = t < 0 ? "-" : "", o = String(parseInt(t = Math.abs(Number(t) || 0).toFixed(e), 10)), s = o.length > 3 ? o.length % 3 : 0;
        return r + (s ? o.substr(0, s) + n : "") + o.substr(s).replace(/(\d{3})(?=\d)/g, "$1" + n) + (e ? i + Math.abs(t - o).toFixed(e).slice(2) : "");
      }
      static declOfNum(t, e) {
        return e[t % 10 == 1 && t % 100 != 11 ? 0 : t % 10 >= 2 && t % 10 <= 4 && (t % 100 < 10 || t % 100 >= 20) ? 1 : 2];
      }
      static getCamelCaseForCss(t) {
        const e = t.split("_"), i = e[e.length - 1];
        return i.charAt(0).toLowerCase() + i.slice(1);
      }
      static getValidClassName(t) {
        const e = t.split("_");
        return e[e.length - 1];
      }
      static radianToDegrees(t) {
        return 180 * t / Math.PI;
      }
      static degreesToRadian(t) {
        return t * Math.PI / 180;
      }
      static isUndefinedOrNull(t) {
        return null == t;
      }
      static isNotUndefinedAndNotNull(t) {
        return false === ValueUtils.isUndefinedOrNull(t);
      }
      static isNumber(t) {
        return "number" == typeof t && false === isNaN(t) && isFinite(t);
      }
      static isBoolean(t) {
        return "boolean" == typeof t;
      }
      static isString(t) {
        return "string" == typeof t;
      }
      static objectToBase64(t) {
        return btoa(unescape(encodeURIComponent(JSON.stringify(t))));
      }
      static uniqueValues(t) {
        const e = {}, i = [];
        for (const n of t) e[n] || i.push(e[n] = n);
        return i;
      }
    }
    ValueUtils.FACTOR = 0.01, ValueUtils.OBJECTS = {Object: true, Array: true};
    class Box2dUtils {
      static toBox2DValue(t) {
        return t / Box2dUtils.POSITION_SCALE;
      }
      static fromBox2DValue(t) {
        return t * Box2dUtils.POSITION_SCALE;
      }
      static getThreeRotationFromBox2d(t) {
        return ValueUtils.absAngle(t - Math.PI / 2);
      }
      static getBox2dRotationFromThree(t) {
        return ValueUtils.absAngle(t + Math.PI / 2);
      }
    }
    Box2dUtils.POSITION_SCALE = 64;
    class Listener {
      constructor(t, e) {
        this._uuid = Randomize.getUuid(), this._enabled = true, this._priority = Listener.DEFAULT_PRIORITY, this._executedTimes = 0, this._alive = true, this._event = t, this._func = e;
      }
      execute(t) {
        false !== this._alive && (this._func(t), this._limit && ++this._executedTimes >= this._limit && (this._alive = false));
      }
      isAlive() {
        return this._alive;
      }
      setPriority(t) {
        return this._priority = t, this._event.setNeedSort(true), this;
      }
      getPriority() {
        return this._priority;
      }
      setLimit(t) {
        return this._limit = t, this;
      }
      getLimit() {
        return this._limit;
      }
      getUuid() {
        return this._uuid;
      }
      getFunc() {
        return this._func;
      }
      getEvent() {
        return this._event;
      }
      enable() {
        this.isDisabled() && (this.getEvent().addListener(this), this._enabled = true);
      }
      disable() {
        this.isEnabled() && (this.getEvent().off(this), this._enabled = false);
      }
      isEnabled() {
        return this._enabled;
      }
      isDisabled() {
        return false === this._enabled;
      }
      isListener() {
        return true;
      }
      destroy() {
        this.getEvent().off(this), this._event = null, this._func = null;
      }
    }
    Listener.DEFAULT_PRIORITY = 0;
    class Event {
      constructor(t) {
        this._enabled = true, this._listeners = {}, this._data = {}, this._paused = false, this._stopped = false, this._needSort = false, this._name = t;
      }
      on(t) {
        return this.addListener(new Listener(this, t));
      }
      addListener(t) {
        return this._listeners[t.getUuid()] = t, t.getPriority() !== Listener.DEFAULT_PRIORITY && this.setNeedSort(true), t;
      }
      once(t) {
        return this.on(t).setLimit(1);
      }
      off(t) {
        this.hasListener(t) && delete this._listeners[t.getUuid()];
      }
      offFunc(t) {
        const e = Object.values(this._listeners).find(e => e.getFunc() === t);
        e && this.off(e);
      }
      execute(t = {}) {
        this._data = t, this._needSort && this.sortListeners(), this.executeListeners();
      }
      executeListeners() {
        for (const t in this._listeners) {
          if (this._currentListener = this._listeners[t], this.isPaused() || this.isStopped()) return void (this._stopped = false);
          if (this._pausedOnListener) this._currentListener === this._pausedOnListener && (this._pausedOnListener = null); else {
            if (this.isDisabled()) return;
            false !== this._currentListener.isAlive() ? this._currentListener.execute(this._data) : this.off(this._currentListener);
          }
        }
      }
      enable() {
        this._enabled = true;
      }
      disable() {
        this._enabled = false;
      }
      isEnabled() {
        return this._enabled;
      }
      isDisabled() {
        return false === this.isEnabled();
      }
      pause() {
        this.isPaused() || (this._paused = true, this._pausedOnListener = this._currentListener);
      }
      isPaused() {
        return this._paused;
      }
      resume() {
        false !== this.isPaused() && (this._paused = false, this.executeListeners());
      }
      stop() {
        this._stopped = true;
      }
      isStopped() {
        return this._stopped;
      }
      setNeedSort(t) {
        this._needSort = t;
      }
      sortListeners() {
        this.setNeedSort(false);
        const t = {};
        Object.keys(this._listeners).sort((t, e) => this._listeners[e].getPriority() - this._listeners[t].getPriority()).forEach(e => t[e] = this._listeners[e]), this._listeners = t;
      }
      hasListener(t) {
        return this._listeners.hasOwnProperty(t.getUuid());
      }
      getListenersCount() {
        return Object.keys(this._listeners).length;
      }
      getName() {
        return this._name;
      }
      destroy() {
        this._data = {}, this._listeners = {};
      }
    }
    class Events {
      constructor() {
        this._events = {};
      }
      emit(t, e = {}) {
        this.getEvent(t).execute(e);
      }
      on(t, e) {
        return this.getEvent(t).on(e);
      }
      off(t, e) {
        return this.getEvent(t).offFunc(e);
      }
      once(t, e) {
        return this.getEvent(t).once(e);
      }
      getEvent(t) {
        return this.hasnt(t) && (this._events[t] = new Event(t)), this._events[t];
      }
      hasnt(t) {
        return false === this._events.hasOwnProperty(t);
      }
      destroy() {
        for (const t in this._events) this._events[t].destroy();
        this._events = {};
      }
    }
    var Ts, Es, Ls, Ds = i(63);
    class AbstractVector2 {
      constructor(t = 0, e = 0) {
        this._x = 0, this._y = 0, this.x = t, this.y = e;
      }
      enableEvents() {
        this.events = new Events;
      }
      setScalarX(t) {
        let e = false;
        return this._x !== t && (e = true), this._x = t || 0, e && this.events && this.events.emit("change", {axis: "x"}), this;
      }
      setScalarY(t) {
        let e = false;
        return this._y !== t && (e = true), this._y = t || 0, e && this.events && this.events.emit("change", {axis: "y"}), this;
      }
      setScalar(t) {
        return this.setScalarX(t).setScalarY(t);
      }
      set x (t) {
        this.setScalarX(t);
      }
      set y (t) {
        this.setScalarY(t);
      }
      setX(t) {
        return this.setScalarX(t.x);
      }
      setY(t) {
        return this.setScalarY(t.y);
      }
      setXY(t) {
        return this.setScalarX(t.x).setScalarY(t.y);
      }
      setScalarXY(t, e) {
        return this.setScalarX(t).setScalarY(e);
      }
      set(t) {
        return this.setX(t).setY(t);
      }
      copy(t) {
        return this.set(t);
      }
      get x() {
        return this._x;
      }
      get y() {
        return this._y;
      }
      addScalarX(t) {
        return this.setScalarX(this.x + t);
      }
      addScalarY(t) {
        return this.setScalarY(this.y + t);
      }
      addScalar(t) {
        return this.addScalarX(t).addScalarY(t);
      }
      addX(t) {
        return this.addScalarX(t.x);
      }
      addY(t) {
        return this.addScalarY(t.y);
      }
      add(t) {
        return this.addX(t).addY(t);
      }
      smoothlyAddScalarX(t, e, i = 0.01) {
        return this.setScalarX(ValueUtils.smoothValue(t, this.x, e, i));
      }
      smoothlyAddScalarY(t, e, i = 0.01) {
        return this.setScalarY(ValueUtils.smoothValue(t, this.y, e, i));
      }
      smoothlyAddScalar(t, e, i = 0.01) {
        return this.smoothlyAddScalarX(t, e, i).smoothlyAddScalarY(t, e, i);
      }
      smoothlyAddX(t, e, i = 0.01) {
        return this.smoothlyAddScalarX(t.x, e, i);
      }
      smoothlyAddY(t, e, i = 0.01) {
        return this.smoothlyAddScalarY(t.y, e, i);
      }
      smoothlyAdd(t, e = 12) {
        return this.smoothlyAddX(t, e).smoothlyAddY(t, e);
      }
      subtractScalarX(t) {
        return this.setScalarX(this.x - t);
      }
      subtractScalarY(t) {
        return this.setScalarY(this.y - t);
      }
      subtractScalar(t) {
        return this.subtractScalarX(t).subtractScalarY(t);
      }
      subtractX(t) {
        return this.subtractScalarX(t.x);
      }
      subtractY(t) {
        return this.subtractScalarY(t.y);
      }
      subtract(t) {
        return this.subtractX(t).subtractY(t);
      }
      multiplyScalarX(t) {
        return this.setScalarX(this.x * t);
      }
      multiplyScalarY(t) {
        return this.setScalarY(this.y * t);
      }
      multiplyScalar(t) {
        return this.multiplyScalarX(t).multiplyScalarY(t);
      }
      multiplyX(t) {
        return this.multiplyScalarX(t.x);
      }
      multiplyY(t) {
        return this.multiplyScalarY(t.y);
      }
      multiply(t) {
        return this.multiplyX(t).multiplyY(t);
      }
      divideScalarX(t) {
        return this.setScalarX(this.x / t);
      }
      divideScalarY(t) {
        return this.setScalarY(this.y / t);
      }
      divideScalar(t) {
        return this.divideScalarX(t).divideScalarY(t);
      }
      divideX(t) {
        return this.divideScalarX(t.x);
      }
      divideY(t) {
        return this.divideScalarY(t.y);
      }
      divide(t) {
        return this.divideX(t).divideY(t);
      }
      invertX() {
        return this.multiplyScalarX(-1);
      }
      invertY() {
        return this.multiplyScalarY(-1);
      }
      invert() {
        return this.invertX().invertY();
      }
      normalize() {
        const t = this.length();
        return 0 !== t && this.divide(Vector2_Vector2.fromScalar(t)), this;
      }
      length() {
        return Math.sqrt(this.lengthSq());
      }
      lengthSq() {
        return this.x * this.x + this.y * this.y;
      }
      ceilX() {
        return this.setScalarX(Math.ceil(this.x));
      }
      ceilY() {
        return this.setScalarY(Math.ceil(this.y));
      }
      ceil() {
        return this.ceilX().ceilY();
      }
      floorX() {
        return this.setScalarX(Math.floor(this.x));
      }
      floorY() {
        return this.setScalarY(Math.floor(this.y));
      }
      floor() {
        return this.floorX().floorY();
      }
      roundX() {
        return this.setScalarX(Math.round(this.x));
      }
      roundY() {
        return this.setScalarY(Math.round(this.y));
      }
      round() {
        return this.roundX().roundY();
      }
      toFixedScalarX(t = 8) {
        return this.setScalarX(parseFloat(this.x.toFixed(t)));
      }
      toFixedScalarY(t = 8) {
        return this.setScalarY(parseFloat(this.y.toFixed(t)));
      }
      toFixedScalar(t = 8) {
        return this.toFixedScalarX(t).toFixedScalarY(t);
      }
      toFixedX(t) {
        return this.toFixedScalarX(t.x);
      }
      toFixedY(t) {
        return this.toFixedScalarY(t.y);
      }
      toFixed(t) {
        return this.toFixedX(t).toFixedY(t);
      }
      minX(t) {
        return this.setScalarX(Math.max(this.x, t));
      }
      minY(t) {
        return this.setScalarY(Math.max(this.y, t));
      }
      min(t) {
        return this.minX(t).minY(t);
      }
      getMin() {
        return Math.min(this.x, this.y);
      }
      maxX(t) {
        return this.setScalarX(Math.min(this.x, t));
      }
      maxY(t) {
        return this.setScalarY(Math.min(this.y, t));
      }
      max(t) {
        return this.maxX(t).maxY(t);
      }
      getMax() {
        return Math.max(this.x, this.y);
      }
      maxLimit(t) {
        return this.length() > t ? this.normalize().multiplyScalar(t) : this;
      }
      dot(t) {
        return this.x * t.x + this.y * t.y;
      }
      isEqualScalar(t) {
        return this.x === t && this.y === t;
      }
      isZero() {
        return this.isEqualScalar(0);
      }
      isEqualTo(t) {
        return this.x === t.x && this.y === t.y;
      }
      applyFromObject(t) {
        return false === ValueUtils.isUndefinedOrNull(t.x) && this.setScalarX(t.x), false === ValueUtils.isUndefinedOrNull(t.y) && this.setScalarY(t.y), false === ValueUtils.isUndefinedOrNull(t._x) && this.setScalarX(t._x), false === ValueUtils.isUndefinedOrNull(t._y) && this.setScalarY(t._y), this;
      }
      toString() {
        return `x: ${this.x}, y: ${this.y}`;
      }
      toArray() {
        return [this.x, this.y];
      }
      toObject() {
        return {x: this.x, y: this.y};
      }
      toBox2dVec() {
        return new Ds.Common.Math.b2Vec2(Box2dUtils.toBox2DValue(this.x), Box2dUtils.toBox2DValue(this.y));
      }
      toThreeVector3(t = 0) {
        return new three_module_Vector3(this.x, this.y, t);
      }
      toThreeVector2() {
        return new Vector2(this.x, this.y);
      }
    }
    class Vector3 extends AbstractVector2 {
      constructor(t = 0, e = 0, i = 0) {
        super(t, e), this._z = 0, this.z = i;
      }
      setScalarZ(t) {
        let e = false;
        return this._z !== t && (e = true), this._z = t || 0, e && this.events && this.events.emit("change", {axis: "z"}), this;
      }
      setScalar(t) {
        return this.setScalarXYZ(t, t, t);
      }
      set x (t) {
        this.setScalarX(t);
      }
      set y (t) {
        this.setScalarY(t);
      }
      set z (t) {
        this.setScalarZ(t);
      }
      setScalarXYZ(t, e, i) {
        return this.setScalarX(t).setScalarY(e).setScalarZ(i);
      }
      set(t) {
        return this.setX(t).setY(t).setZ(t);
      }
      copy(t) {
        return this.set(t);
      }
      setZ(t) {
        return this.setScalarZ(t.z);
      }
      get x() {
        return super.x;
      }
      get y() {
        return super.y;
      }
      get z() {
        return this._z;
      }
      addScalarZ(t) {
        return this.setScalarZ(this.z + t);
      }
      addScalar(t) {
        return this.addScalarX(t).addScalarY(t).addScalarZ(t);
      }
      addZ(t) {
        return this.addScalarZ(t.z);
      }
      add(t) {
        return this.addX(t).addY(t).addZ(t);
      }
      smoothlyAddScalarZ(t, e, i = 0.01) {
        return this.setScalarZ(ValueUtils.smoothValue(t, this.z, e, i));
      }
      smoothlyAddScalar(t, e) {
        return this.smoothlyAddScalarX(t, e).smoothlyAddScalarY(t, e).smoothlyAddScalarZ(t, e);
      }
      smoothlyAddZ(t, e, i = 0.01) {
        return this.smoothlyAddScalarZ(t.z, e, i);
      }
      smoothlyAdd(t, e = 12, i = 0.01) {
        return this.smoothlyAddX(t, e, i).smoothlyAddY(t, e, i).smoothlyAddZ(t, e, i);
      }
      subtractScalarZ(t) {
        return this.setScalarZ(this.z - t);
      }
      subtractScalar(t) {
        return this.subtractScalarX(t).subtractScalarY(t).subtractScalarZ(t);
      }
      subtractZ(t) {
        return this.subtractScalarZ(t.z);
      }
      subtract(t) {
        return this.subtractX(t).subtractY(t).subtractZ(t);
      }
      multiplyScalarZ(t) {
        return this.setScalarZ(this.z * t);
      }
      multiplyScalar(t) {
        return this.multiplyScalarX(t).multiplyScalarY(t).multiplyScalarZ(t);
      }
      multiplyZ(t) {
        return this.multiplyScalarZ(t.z);
      }
      multiply(t) {
        return this.multiplyX(t).multiplyY(t).multiplyZ(t);
      }
      divideScalarZ(t) {
        return this.setScalarZ(this.z / t);
      }
      divideScalar(t) {
        return this.divideScalarX(t).divideScalarY(t).divideScalarZ(t);
      }
      divideZ(t) {
        return this.divideScalarZ(t.z);
      }
      divide(t) {
        return this.divideX(t).divideY(t).divideZ(t);
      }
      to(t) {
        return t.clone().subtract(this);
      }
      invertZ() {
        return this.multiplyScalarZ(-1);
      }
      invert() {
        return this.invertX().invertY().invertZ();
      }
      lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z;
      }
      length() {
        return Math.sqrt(this.lengthSq());
      }
      normalize() {
        let t = this.length();
        return 0 !== t && this.divide(new Vector3(t, t, t)), this;
      }
      ceilZ() {
        return this.setScalarZ(Math.ceil(this.z));
      }
      ceil() {
        return this.ceilX().ceilY().ceilZ();
      }
      floorZ() {
        return this.setScalarZ(Math.floor(this.z));
      }
      floor() {
        return this.floorX().floorY().floorZ();
      }
      roundZ() {
        return this.setScalarZ(Math.round(this.z));
      }
      round() {
        return this.roundX().roundY().roundZ();
      }
      toFixedScalarZ(t = 8) {
        return this.setScalarZ(parseFloat(this.z.toFixed(t)));
      }
      toFixedScalar(t = 8) {
        return this.toFixedScalarX(t).toFixedScalarY(t).toFixedScalarZ(t);
      }
      toFixedZ(t) {
        return this.toFixedScalarZ(t.z);
      }
      toFixed(t) {
        return this.toFixedX(t).toFixedY(t).toFixedZ(t);
      }
      minZ(t) {
        return this.setScalarZ(Math.max(this.z, t));
      }
      min(t) {
        return this.minX(t).minY(t).minZ(t);
      }
      getMin() {
        return Math.min(this.x, this.y, this.z);
      }
      maxZ(t) {
        return this.setScalarZ(Math.min(this.z, t));
      }
      max(t) {
        return this.maxX(t).maxY(t).maxZ(t);
      }
      getMax() {
        return Math.max(this.x, this.y, this.z);
      }
      clone() {
        return new Vector3(this.x, this.y, this.z);
      }
      dot(t) {
        return this.x * t.x + this.y * t.y + this.z * t.z;
      }
      isEqualScalar(t) {
        return this.x === t && this.y === t && this.z === t;
      }
      isZero() {
        return this.isEqualScalar(0);
      }
      isEqualTo(t) {
        return this.x === t.x && this.y === t.y && this.z === t.z;
      }
      applyFromObject(t) {
        return super.applyFromObject(t), false === ValueUtils.isUndefinedOrNull(t.z) && this.setScalarZ(t.z), false === ValueUtils.isUndefinedOrNull(t._z) && this.setScalarZ(t._z), this;
      }
      static random(t = 0, e = 1) {
        return new Vector3(Math.floor(Randomize.getRandomFloat(t, e)), Math.floor(Randomize.getRandomFloat(t, e)), Math.floor(Randomize.getRandomFloat(t, e)));
      }
      randomSubVector() {
        return this.clone().normalize().multiplyScalar(Randomize.getRandomFloat(0, this.length()));
      }
      toString() {
        return `x: ${this.x}, y: ${this.y}, z: ${this.z}`;
      }
      toArray() {
        return [this.x, this.y, this.z];
      }
      toObject() {
        return {x: this.x, y: this.y, z: this.z};
      }
      toThreeEuler() {
        return new Euler(this.x, this.y, this.z);
      }
      toThreeQuaternion() {
        return (new Quaternion).setFromEuler(this.toThreeEuler());
      }
      toThreeVector3() {
        return new three_module_Vector3(this.x, this.y, this.z);
      }
      toVector2() {
        return new Vector2_Vector2(this.x, this.y);
      }
      static fromThreeVector3(t) {
        return new Vector3(t.x, t.y, t.z);
      }
      static fromVector2(t) {
        return new Vector3(t.x, t.y);
      }
      static fromThreeVector2(t) {
        return new Vector3(t.x, t.y);
      }
      static fromThreeEuler(t) {
        return new Vector3(t.x, t.y, t.z);
      }
      static fromThreeQuaternion(t) {
        return Vector3.fromThreeEuler((new Euler).setFromQuaternion(t));
      }
      static fromArray(t) {
        return new Vector3(t[0] || 0, t[1] || 0, t[2] || 0);
      }
      static fromObject(t) {
        return void 0 === t ? new Vector3 : ValueUtils.isUndefinedOrNull(t.x) && ValueUtils.isUndefinedOrNull(t.y) && ValueUtils.isUndefinedOrNull(t.z) ? new Vector3(t._x, t._y, t._z) : new Vector3(t.x, t.y, t.z);
      }
      static fromScalar(t) {
        return new Vector3(t, t, t);
      }
    }
    class Vector2_Vector2 extends AbstractVector2 {
      set x (t) {
        this.setScalarX(t);
      }
      set y (t) {
        this.setScalarY(t);
      }
      get x() {
        return super.x;
      }
      get y() {
        return super.y;
      }
      clone() {
        return new Vector2_Vector2(this.x, this.y);
      }
      horizontalAngle() {
        return Math.atan2(this.y, this.x);
      }
      horizontalAngleDeg() {
        return ValueUtils.radianToDegrees(this.horizontalAngle());
      }
      verticalAngle() {
        return Math.atan2(this.x, this.y);
      }
      verticalAngleDeg() {
        return ValueUtils.radianToDegrees(this.verticalAngle());
      }
      angle() {
        return this.horizontalAngle();
      }
      angleDeg() {
        return this.horizontalAngleDeg();
      }
      direction() {
        return this.horizontalAngle();
      }
      rotate(t) {
        const e = Math.cos(t), i = Math.sin(t), n = this.x * e - this.y * i, r = this.x * i + this.y * e;
        return this.setScalarX(n).setScalarY(r);
      }
      rotateDeg(t) {
        return this.rotate(ValueUtils.degreesToRadian(t));
      }
      rotateTo(t) {
        return this.rotate(t - this.angle());
      }
      rotateToDeg(t) {
        return this.rotateTo(ValueUtils.degreesToRadian(t));
      }
      rotateBy(t) {
        return this.rotate(this.angle() + t);
      }
      rotateByDeg(t) {
        return this.rotateBy(ValueUtils.degreesToRadian(t));
      }
      distanceX(t) {
        return this.x - t.y;
      }
      distanceY(t) {
        return this.y - t.y;
      }
      distance(t) {
        return Math.sqrt(this.distanceSq(t));
      }
      distanceSq(t) {
        const e = this.distanceX(t), i = this.distanceY(t);
        return e * e + i * i;
      }
      static to2dProjection(t, e) {
        const i = document.documentElement.clientWidth / 2, n = document.documentElement.clientHeight / 2, r = new three_module_Vector3;
        return r.setFromMatrixPosition(t.matrixWorld).project(e), r.x = r.x * i + i, r.y = -r.y * n + n, new Vector2_Vector2(r.x, r.y);
      }
      to(t) {
        return this.copy(t.clone().subtract(this));
      }
      static random(t = 0, e = 1) {
        return new Vector2_Vector2(Math.floor(Randomize.getRandomFloat(t, e)), Math.floor(Randomize.getRandomFloat(t, e)));
      }
      randomSubVector() {
        return this.clone().normalize().multiplyScalar(Randomize.getRandomFloat(0, this.length()));
      }
      isNumber() {
        return ValueUtils.isNumber(this.x) && ValueUtils.isNumber(this.y);
      }
      toVector3(t = 0) {
        return new Vector3(this.x, this.y, t);
      }
      static fromBox2dVec(t) {
        return new Vector2_Vector2(Box2dUtils.fromBox2DValue(t.x), Box2dUtils.fromBox2DValue(t.y));
      }
      static fromThreeVector3(t) {
        return new Vector2_Vector2(t.x, t.y);
      }
      static fromVector3(t) {
        return new Vector2_Vector2(t.x, t.y);
      }
      static fromThreeVector2(t) {
        return new Vector2_Vector2(t.x, t.y);
      }
      static fromThreeEuler(t) {
        return new Vector2_Vector2(t.x, t.y);
      }
      static fromArray(t) {
        return new Vector2_Vector2(t[0], t[1]);
      }
      static fromObject(t) {
        return void 0 === t ? new Vector2_Vector2 : ValueUtils.isUndefinedOrNull(t.x) && ValueUtils.isUndefinedOrNull(t.y) ? new Vector2_Vector2(t._x, t._y) : new Vector2_Vector2(t.x, t.y);
      }
      static fromScalar(t) {
        return new Vector2_Vector2(t, t);
      }
    }
    Vector2_Vector2.ZERO = new Vector2_Vector2(0, 0), Vector2_Vector2.UP = new Vector2_Vector2(0, 1), Vector2_Vector2.DOWN = new Vector2_Vector2(0, -1), Vector2_Vector2.LEFT = new Vector2_Vector2(-1, 0), Vector2_Vector2.RIGHT = new Vector2_Vector2(1, 0), Vector2_Vector2.UP_RIGHT = new Vector2_Vector2(1, 1), Vector2_Vector2.UP_LEFT = new Vector2_Vector2(-1, 1), Vector2_Vector2.DOWN_RIGHT = new Vector2_Vector2(1, -1), Vector2_Vector2.DOWN_LEFT = new Vector2_Vector2(-1, -1), Vector2_Vector2.IDENTITY = new Vector2_Vector2(1, 1);
    class Randomize {
      static getRandomColor(t = 0, e = 0, i = 0, n = 255, r = 255, o = 255) {
        return new Color(Randomize.getRandomInt(t, n), Randomize.getRandomInt(e, r), Randomize.getRandomInt(i, o));
      }
      static getRandomColorScalar(t = 0, e = 0, i = 0, n = 255, r = 255, o = 255) {
        let s = 0;
        return s |= (255 & Randomize.getRandomInt(t, n)) << 0, s |= (255 & Randomize.getRandomInt(e, r)) << 8, s |= (255 & Randomize.getRandomInt(i, o)) << 16, s;
      }
      static getRandomInt(t = 0, e = 1) {
        return e++, Math.floor(Randomize.getRandomFloat(t, e));
      }
      static getRandomFloat(t = 0, e = 1) {
        return e--, Math.random() * (e - t + 1) + t;
      }
      static getRandomVector2(t = Vector2_Vector2.fromScalar(-1), e = Vector2_Vector2.fromScalar(1)) {
        return new Vector2_Vector2(Randomize.getRandomFloat(t.x, e.x), Randomize.getRandomFloat(t.y, e.y));
      }
      static getRandomVector2Scalar(t = 0, e = 1) {
        return Vector2_Vector2.fromObject({x: Randomize.getRandomFloat(t, e), y: Randomize.getRandomFloat(t, e)});
      }
      static getRandomVector3(t = Vector3.fromScalar(-1), e = Vector3.fromScalar(1)) {
        return new Vector3(Randomize.getRandomFloat(t.x, e.x), Randomize.getRandomFloat(t.y, e.y), Randomize.getRandomFloat(t.z, e.z));
      }
      static getRandomVector3Scalar(t = 0, e = 1) {
        return new Vector3(Randomize.getRandomFloat(t, e), Randomize.getRandomFloat(t, e), Randomize.getRandomFloat(t, e));
      }
      static getRandomFromArray(t) {
        return t[Randomize.getRandomInt(0, t.length - 1)];
      }
      static getRandomFromObject(t) {
        let e = Object.keys(t);
        return t[e[Randomize.getRandomInt(0, e.length - 1)]];
      }
      static getUuid() {
        return Math.random().toString(36).substr(2, 9);
      }
      static getRandomAngle() {
        return Randomize.getRandomFloat(0, 2 * Math.PI);
      }
      static getPositionAround(t, e) {
        let i = t.clone();
        return i.x = Randomize.getRandomInt(i.x - e, i.x + e), i.y = Randomize.getRandomInt(i.y - e, i.y + e), i;
      }
      static shuffleArray(t) {
        let e, i, n = t.length;
        for (; 0 !== n;) i = Math.floor(Math.random() * n), n -= 1, e = t[n], t[n] = t[i], t[i] = e;
        return t;
      }
    }
    class Rect {
      constructor(t, e, i, n) {
        this.left = 0, this.top = 0, this.right = 0, this.bottom = 0, this.left = t || 0, this.top = e || 0, this.right = i || 0, this.bottom = n || 0;
      }
      isVecInRect(t) {
        return this.isInRect(t.x, t.y);
      }
      isInRect(t, e) {
        return this.left <= t && t <= this.right && this.bottom <= e && e <= this.top;
      }
      randomBoundPointTo(t) {
        const e = Randomize.getRandomInt(0, 3), i = this.randomBoundPointOnSide(e);
        return t.x = i.x, t.y = i.y, e;
      }
      randomBoundPointOnSide(t) {
        const e = new Vector2_Vector2;
        switch (t) {
          case 0:
            e.y = this.top, e.x = Randomize.getRandomFloat(this.left, this.right);
            break;
          case 1:
            e.y = this.bottom, e.x = Randomize.getRandomFloat(this.left, this.right);
            break;
          case 2:
            e.x = this.right, e.y = Randomize.getRandomFloat(this.bottom, this.top);
            break;
          case 3:
            e.x = this.left, e.y = Randomize.getRandomFloat(this.bottom, this.top);
        }
        return e;
      }
      randomPointWithExcludeRect(t) {
        const e = new Vector2_Vector2, i = t.randomBoundPointTo(e), n = this.randomBoundPointOnSide(i);
        return n.subtract(e), n.randomSubVector(), n.add(e), this.limitVector(n), n;
      }
      limitVector(t, e = 0) {
        return t.y = Math.min(this.top - e, t.y), t.x = Math.max(this.left + e, t.x), t.x = Math.min(this.right - e, t.x), t.y = Math.max(this.bottom + e, t.y), t;
      }
      expand(t) {
        return this.top += t, this.left -= t, this.right += t, this.bottom -= t, this;
      }
      translate(t) {
        return this.top += t.y, this.left += t.x, this.right += t.x, this.bottom += t.y, this;
      }
      getSize() {
        return new Vector2_Vector2(this.right - this.left, this.top - this.bottom);
      }
      getRadius() {
        return this.getSize().divideScalar(2);
      }
      clone() {
        return new Rect(this.left, this.top, this.right, this.bottom);
      }
      copy(t) {
        return this.copyValues(t.left, t.top, t.right, t.bottom);
      }
      copySize(t) {
        return this.copyWidthHeight(t.x, t.y);
      }
      copyWidthHeight(t, e) {
        return this.copyValues(-t / 2, e / 2, t / 2, -e / 2);
      }
      copyValues(t, e, i, n) {
        return this.left = t, this.top = e, this.right = i, this.bottom = n, this;
      }
      isEqual(t) {
        return this.left === t.left && this.right === t.right && this.top === t.top && this.bottom === t.bottom;
      }
      toBox2dAabb() {
        return Rect.toBox2dAabb(this);
      }
      static toBox2dAabb(t) {
        const e = new Ds.Collision.b2AABB;
        return e.lowerBound.Set(Box2dUtils.toBox2DValue(t.left), Box2dUtils.toBox2DValue(t.bottom)), e.upperBound.Set(Box2dUtils.toBox2DValue(t.right), Box2dUtils.toBox2DValue(t.top)), e;
      }
      static fromObject(t) {
        const e = new Rect;
        return e.left = t.left, e.top = t.top, e.right = t.right, e.bottom = t.bottom, e;
      }
      static fromThreeBox3(t) {
        const e = new Rect;
        return e.left = t.min.x, e.top = t.max.y, e.right = t.max.x, e.bottom = t.min.y, e;
      }
      static fromWidthHeight(t, e) {
        return new Rect(-t / 2, e / 2, t / 2, -e / 2);
      }
      static fromSize(t) {
        return Rect.fromRadius(t / 2);
      }
      static fromRadius(t) {
        return new Rect(-t, t, t, -t);
      }
      static fromPoint(t, e) {
        return new Rect(t.x - e, t.y + e, t.x + e, t.y - e);
      }
      static fromVector2(t, e) {
        return new Rect(t.x - e, t.y + e, t.x + e, t.y - e);
      }
    }
    class Box2dDebugDataSender extends Ds.Dynamics.b2DebugDraw {
      DrawSegment(t, e, i) {
        this.worldForWorker.addPacket({responseType: "Box2dDebugDataSender_DrawSegment", responseData: {vert1: t, vert2: e, color: i}});
      }
      DrawPolygon(t, e, i) {
        this.worldForWorker.addPacket({responseType: "Box2dDebugDataSender_DrawPolygon", responseData: {vertices: t, vertexCount: e, color: i}});
      }
      DrawSolidPolygon(t, e, i) {
        this.worldForWorker.addPacket({responseType: "Box2dDebugDataSender_DrawSolidPolygon", responseData: {vertices: t, vertexCount: e, color: i}});
      }
      DrawCircle(t, e, i) {
        this.worldForWorker.addPacket({responseType: "Box2dDebugDataSender_DrawCircle", responseData: {center: t, radius: e, color: i}});
      }
      DrawSolidCircle(t, e, i, n) {
        this.worldForWorker.addPacket({responseType: "Box2dDebugDataSender_DrawSolidCircle", responseData: {center: t, radius: e, axis: i, color: n}});
      }
      DrawTransform(t) {
        this.worldForWorker.addPacket({responseType: "Box2dDebugDataSender_DrawTransform", responseData: {transform: t}});
      }
    }
    !function (t) {
      t[t.STATIC = 0] = "STATIC", t[t.KINEMATIC = 1] = "KINEMATIC", t[t.DYNAMIC = 2] = "DYNAMIC";
    }(Ts || (Ts = {})), function (t) {
      t.DEFAULT = "DEFAULT", t.MODEL = "MODEL";
    }(Es || (Es = {}));
    class Box2dRayCastOutput {
      constructor(t, e) {
        this.normal = t, this.fraction = e;
      }
    }
    !function (t) {
      t.BOX = "BOX", t.CIRCLE = "CIRCLE", t.POLYGON = "POLYGON";
    }(Ls || (Ls = {}));
    class EntityFlags {}
    EntityFlags.FLAG_DISABLE_PHYSICS = 1, EntityFlags.FLAG_DISABLE_TICKING = 2, EntityFlags.FLAG_SERVER_ONLY = 4, EntityFlags.FLAG_AUTO_CLEANABLE = 8, EntityFlags.FLAG_CROSS_WORLD_BORDER = 16, EntityFlags.FLAG_TICK_DAEMON = 32, EntityFlags.FLAG_ALWAYS_DISPLAYED = 64, EntityFlags.FLAG_FORCE_CHUNK = 128, EntityFlags.FLAG_TICK_REQUESTED = 256, EntityFlags.FLAG_COLLISION_NOTIFICATION = 512;
    class Box2dAbstractFixtureDef extends Ds.Dynamics.b2FixtureDef {
      constructor(t, e, i, n = 1) {
        super(), this.density = 1 | n, this.friction = t, this.restitution = e, this.isSensor = i;
      }
    }
    class Box2dBoxFixtureDef extends Box2dAbstractFixtureDef {
      constructor(t, e, i, n, r, o, s = 1) {
        super(n, r, o, s), this.shape = new Ds.Collision.Shapes.b2PolygonShape, this.shape.SetAsOrientedBox(Box2dUtils.toBox2DValue(t.x), Box2dUtils.toBox2DValue(t.y), e.toBox2dVec(), i);
      }
    }
    class Box2dCircleFixtureDef extends Box2dAbstractFixtureDef {
      constructor(t, e, i, n, r, o = 1) {
        super(i, n, r, o), this.shape = new Ds.Collision.Shapes.b2CircleShape(Box2dUtils.toBox2DValue(e)), this.shape.m_p = Vector2_Vector2.fromObject(t).toBox2dVec();
      }
    }
    class Box2dFixtures {
      constructor(t) {
        this._fixtures = {}, this.body = t;
      }
      set(t) {
        for (const e in t.volumes) {
          const i = t.volumes[e];
          if (!i.serverOnly) switch (i.type) {
            case Ls.CIRCLE:
              ValueUtils.isNumber(i.radius) && ValueUtils.isNumber(i.friction) && ValueUtils.isNumber(i.restitution) && ValueUtils.isBoolean(i.sensor) && (this._fixtures[e] = this.body.CreateFixture(new Box2dCircleFixtureDef(Vector2_Vector2.ZERO.clone(), i.radius, i.friction, i.restitution, i.sensor)));
              break;
            case Ls.BOX:
              const t = Vector2_Vector2.fromObject(i.size), n = Vector2_Vector2.fromObject(i.center);
              t.isNumber() && n.isNumber() && ValueUtils.isNumber(i.friction) && ValueUtils.isNumber(i.restitution) && ValueUtils.isBoolean(i.sensor) && (this._fixtures[e] = this.body.CreateFixture(new Box2dBoxFixtureDef(t, n, i.angle, i.friction, i.restitution, i.sensor)));
          }
        }
      }
      reSetFixture(t) {
        const e = new Ds.Collision.Shapes.b2MassData;
        this.body.GetMassData(e);
        for (const t in this._fixtures) this.body.DestroyFixture(this._fixtures[t]);
        this.set(t), this.body.SetMassData(e);
      }
      forEach(t) {
        let e = this.body.GetFixtureList();
        for (; e;) t(e), e = e.m_next;
      }
      preparePoints(t) {
        const e = new Vector2_Vector2(0, 0);
        for (const i in t) switch (i) {
          case Ls.CIRCLE:
            for (const n in t[i]) e.x = Math.max(e.x, Math.abs(t[i][n].aX + t[i][n].xRadius)), e.y = Math.max(e.y, Math.abs(t[i][n].aY + t[i][n].yRadius));
            break;
          case Ls.POLYGON:
            for (const n in t[i]) for (const r in t[i][n]) e.x = Math.max(e.x, Math.abs(t[i][n][r].x)), e.y = Math.max(e.y, Math.abs(t[i][n][r].y));
        }
        const i = e.clone().divideScalar(2);
        for (const e in t) switch (e) {
          case Ls.CIRCLE:
            for (const n in t[e]) t[e][n].aX = t[e][n].aX - i.x, t[e][n].aY = -1 * t[e][n].aY + i.y;
            break;
          case Ls.POLYGON:
            for (const n in t[e]) for (const r in t[e][n]) t[e][n][r].x = t[e][n][r].x - i.x, t[e][n][r].y = -1 * t[e][n][r].y + i.y;
        }
      }
    }
    class EntityBox2d {
      constructor(t, e) {
        this._speedMultiplier = EntityBox2d.DEFAULT_SPEED_MULTIPLIER, this.mass = 0, this.canUnActive = true, this.activeDistance = 200, this._transformsVersion = 1, this.box2dData = e, this.box2dBody = t, this.shapeType = e.shape, this.activeDistance = e.activeDistance, this.canUnActive = e.canUnActive, this.fixture = new Box2dFixtures(this.box2dBody), this.fixture.set(e), this.box2dBody.SetFixedRotation(true), this.speedMultiplier = e.multiplier, this.setMass(e.mass), this.setAngle(e.angle), this.setPosition(Vector2_Vector2.fromObject(e.position)), this.setVelocity(Vector2_Vector2.fromObject(e.velocity));
      }
      cropSmallVector(t) {
        return t.length() < EntityBox2d.SLEEPING_FACTOR ? Vector2_Vector2.ZERO.clone() : t;
      }
      cropSmallNumber(t) {
        return Math.abs(t) < EntityBox2d.SLEEPING_FACTOR ? 0 : t;
      }
      reSetFixture(t) {
        this.fixture.reSetFixture(t), this.updateMassData();
      }
      getMass() {
        const t = new Ds.Collision.Shapes.b2MassData;
        return this.box2dBody.GetMassData(t), t.mass;
      }
      setMass(t) {
        false !== ValueUtils.isNumber(t) && false !== ValueUtils.isNumberChanged(t, this.mass) && (t <= 0 || (this.mass = t, this.updateMassData()));
      }
      updateMassData() {
        this.box2dBody.ResetMassData();
        const t = new Ds.Collision.Shapes.b2MassData;
        this.box2dBody.GetMassData(t);
        const e = this.mass / t.mass;
        t.mass *= e, t.I *= e, this.box2dBody.SetMassData(t);
      }
      isAwake() {
        return this.box2dBody.IsAwake();
      }
      setAwake(t) {
        ValueUtils.isBoolean(t) && this.box2dBody.SetAwake(t);
      }
      setSensor(t) {
        ValueUtils.isBoolean(t) && this.fixture.forEach(e => e.SetSensor(t));
      }
      isSensorAll() {
        let t = 0, e = 0;
        return this.fixture.forEach(i => {
          e++, i.IsSensor() && t++;
        }), t === e;
      }
      setRestitution(t) {
        ValueUtils.isNumber(t) && this.fixture.forEach(e => e.SetRestitution(t));
      }
      setFriction(t) {
        ValueUtils.isNumber(t) && this.fixture.forEach(e => e.SetFriction(t));
      }
      setDensity(t) {
        ValueUtils.isNumber(t) && this.fixture.forEach(e => e.SetDensity(t));
      }
      setBodyType(t) {
        let e = 0;
        switch (t) {
          case Ts.STATIC:
            e = 0;
            break;
          case Ts.KINEMATIC:
            e = 1;
            break;
          case Ts.DYNAMIC:
            e = 2;
        }
        this.box2dBody.SetType(e);
      }
      setAngle(t) {
        ValueUtils.isNumber(t) && (this.box2dBody.SetAwake(true), this.box2dBody.SetAngle(ValueUtils.absAngle(t)));
      }
      getAngle() {
        return this.box2dBody.GetAngle();
      }
      setAngularVelocity(t) {
        if (ValueUtils.isNumber(t)) return this.box2dBody.SetAngularVelocity(this.cropSmallNumber(t));
      }
      getAngularVelocity() {
        return this.box2dBody.GetAngularVelocity();
      }
      getPosition() {
        return Vector2_Vector2.fromBox2dVec(this.box2dBody.GetPosition());
      }
      setPosition(t) {
        false !== t.isNumber() && ValueUtils.isVector2Changed(this.getPosition(), t, EntityBox2d.SLEEPING_FACTOR) && (this.setAwake(true), this.box2dBody.SetPosition(t.toBox2dVec()));
      }
      setActive(t) {
        ValueUtils.isBoolean(t) && this.box2dBody.SetActive(t);
      }
      isActive() {
        return this.box2dBody.IsActive();
      }
      setAllowContact(t) {
        if (ValueUtils.isBoolean(t)) {
          const e = this.box2dBody.GetUserData();
          e && (e.allowContact = t);
        }
      }
      addPosition(t) {
        t.isNumber() && ValueUtils.isVector2Changed(this.getPosition(), t, EntityBox2d.SLEEPING_FACTOR) && (this.setAwake(true), this.box2dBody.SetPosition(this.getPosition().add(t).toBox2dVec()));
      }
      applyForceToCenter(t) {
        t.isNumber() && (t = this.cropSmallVector(t), this.box2dBody.ApplyForce(t.toBox2dVec(), Vector2_Vector2.fromObject(this.box2dBody.m_sweep.c)));
      }
      setVelocity(t) {
        false !== t.isNumber() && ValueUtils.isVector2Changed(this.getVelocity(), t) && this.setVelocityForce(t);
      }
      setVelocityForce(t) {
        if (false === t.isNumber()) return;
        const e = t.clone().multiplyScalar(this._speedMultiplier).toBox2dVec();
        this.box2dBody.SetAwake(true), this.box2dBody.SetLinearVelocity(e);
      }
      getVelocity() {
        const t = Vector2_Vector2.fromBox2dVec(this.box2dBody.GetLinearVelocity());
        return this._speedMultiplier > 0 && t.divideScalar(this._speedMultiplier), t;
      }
      getImpulse() {
        return this.getVelocity().multiplyScalar(this.getMass());
      }
      addVelocity(t) {
        if (false === t.isNumber()) return;
        const e = (t = this.cropSmallVector(t)).clone().multiplyScalar(this.getMass()).multiplyScalar(this.speedMultiplier);
        this.applyForceToCenter(e);
      }
      setSleepingAllowed(t) {
        this.box2dBody.SetSleepingAllowed(t);
      }
      get speedMultiplier() {
        return this._speedMultiplier / EntityBox2d.DEFAULT_SPEED_MULTIPLIER;
      }
      set speedMultiplier (t) {
        if (false === ValueUtils.isNumber(t)) return;
        const e = this.getVelocity();
        this._speedMultiplier = t * EntityBox2d.DEFAULT_SPEED_MULTIPLIER, this.setVelocityForce(e);
      }
      rayCastFixtures(t, e, i) {
        const n = [], r = Vector2_Vector2.fromObject(t).toBox2dVec(), o = Vector2_Vector2.fromObject(e).toBox2dVec();
        if (r.isNumber() && o.isNumber()) {
          const t = new Ds.Collision.b2RayCastInput(r, o, i);
          this.fixture.forEach(e => {
            const i = new Ds.Collision.b2RayCastOutput;
            e.RayCast(i, t) && n.push(new Box2dRayCastOutput(i.normal, i.fraction));
          });
        }
        return n;
      }
      testPoint(t) {
        let e = false;
        const i = Vector2_Vector2.fromObject(t).toBox2dVec();
        return i.isNumber() && this.fixture.forEach(t => {
          t.TestPoint(i) && (e = true);
        }), e;
      }
      getTransformsVersion() {
        return this._transformsVersion;
      }
      setTransformsVersion(t) {
        this._transformsVersion = t;
      }
    }
    EntityBox2d.DEFAULT_SPEED_MULTIPLIER = 150, EntityBox2d.SLEEPING_FACTOR = 0.01;
    class EntityBox2dJoint {
      constructor(t, e, i) {
        this.jointDef = this.createJointDef(t), this.jointDef.localAnchorA.Set(Box2dUtils.toBox2DValue(t.localAnchorA.x), Box2dUtils.toBox2DValue(t.localAnchorA.y)), this.jointDef.localAnchorB.Set(Box2dUtils.toBox2DValue(t.localAnchorB.x), Box2dUtils.toBox2DValue(t.localAnchorB.y)), this.setBodies(e, i);
      }
      setBodies(t, e) {
        this.setBodyA(t), this.setBodyB(e);
      }
      setBodyA(t) {
        t && (this._bodyA = t, this.jointDef.bodyA = this._bodyA);
      }
      setBodyB(t) {
        t && (this._bodyB = t, this.jointDef.bodyB = this._bodyB);
      }
    }
    class EntityBox2dJointDistance extends EntityBox2dJoint {
      createJointDef(t) {
        const e = new Ds.Dynamics.Joints.b2DistanceJointDef;
        return e.frequencyHz = t.frequencyHz, e.dampingRatio = t.dampingRatio, e.length = Box2dUtils.toBox2DValue(t.length), e;
      }
    }
    class EntityBox2dJointRevolute extends EntityBox2dJoint {
      createJointDef(t) {
        const e = new Ds.Dynamics.Joints.b2RevoluteJointDef;
        return e.collideConnected = t.collideConnected, e.referenceAngle = t.referenceAngle, e.enableLimit = t.enableLimit, e.lowerAngle = t.lowerAngle, e.upperAngle = t.upperAngle, e.enableMotor = t.enableMotor, e.maxMotorTorque = t.maxMotorTorque, e.motorSpeed = t.motorSpeed, e;
      }
    }
    class Box2dWorld {
      constructor(t, e) {
        this.bodyTypes = {DYNAMIC: Ds.Dynamics.b2Body.b2_dynamicBody, KINEMATIC: Ds.Dynamics.b2Body.b2_kinematicBody, STATIC: Ds.Dynamics.b2Body.b2_staticBody}, this.debugDataSender = new Box2dDebugDataSender;
        const i = new Ds.Common.Math.b2Vec2(0, 0);
        this.box2dWorldObj = new Ds.Dynamics.b2World(i, true), this.worldForWorker = t, this.box2dWorldObj.SetContactListener(new e(this.worldForWorker));
      }
      step(t, e = 1, i = 1) {
        this.box2dWorldObj.Step(t, e, i), this.box2dWorldObj.ClearForces();
      }
      createEntity(t, e) {
        const i = this.createBox2dDef(t), n = this.box2dWorldObj.CreateBody(i);
        n.SetUserData(t.userData), n.SetFixedRotation(t.fixedRotation), n.SetBullet(t.bullet), n.SetLinearDamping(t.linearDamping), n.SetAngularDamping(t.angularDamping), n.SetAngularVelocity(t.angularVelocity);
        return new EntityBox2d(n, t);
      }
      destroyEntity(t) {
        this.box2dWorldObj.DestroyBody(t.box2dBody);
      }
      createBox2dDef(t) {
        const e = new Ds.Dynamics.b2BodyDef;
        e.type = this.getBodyType(t.type);
        const i = Vector2_Vector2.fromObject(t.position).toBox2dVec();
        return e.position.Set(i.x, i.y), e;
      }
      getBodyType(t) {
        return this.bodyTypes[Ts[t]];
      }
      createJoint(t, e, i) {
        let n;
        switch (t.type) {
          case "DISTANCE":
            n = new EntityBox2dJointDistance(t, e, i);
            break;
          case "REVOLUTE":
            n = new EntityBox2dJointRevolute(t, e, i);
        }
        return n.joint = this.box2dWorldObj.CreateJoint(n.jointDef), n;
      }
      destroyJoint(t) {
        this.box2dWorldObj.DestroyJoint(t);
      }
      selectEntities(t) {
        const e = [];
        return this.box2dWorldObj.QueryAABB(t => {
          const i = t.GetBody().GetUserData();
          return i && i.uuid && false === e.includes(i.uuid) && e.push(i.uuid), true;
        }, Rect.toBox2dAabb(t)), e;
      }
    }
    class WorldForWorker {
      constructor(t, e, i) {
        this.entities = {}, this.cachedEntityTransforms = {}, this.updateEntitiesOnce = {}, this._forceUpdateEntities = {}, this.joints = {}, this._joinTimeouts = {}, this.tickTimeOld = 0, this.entitiesData = [], this.packets = [], this._activePhysicsCenter = Vector2_Vector2.ZERO.clone(), this._timeouts = {}, this.commandsMap = {tick: () => this.tick(), startTicking: () => this.startTicking(), stopTicking: () => this.stopTicking(), createEntity: t => this.createEntity(t.entityUuid, t.entityData), setEntityMultiplier: t => this.setEntityMultiplier(t.entityUuid, t.entityData), setEntityMass: t => this.setEntityMass(t.entityUuid, t.entityData), setEntityVelocity: t => this.setEntityVelocity(t.entityUuid, t.entityData), setEntityAngularVelocity: t => this.setEntityAngularVelocity(t.entityUuid, t.entityData), addEntityVelocity: t => this.addEntityVelocity(t.entityUuid, t.entityData), setEntityVelocitySmoothly: t => this.setEntityVelocitySmoothly(t.entityUuid, t.entityData), reCreateEntityFixture: t => this.reCreateEntityFixture(t.entityUuid, t.entityData), setEntityAngle: t => this.setEntityAngle(t.entityUuid, t.entityData), setEntityBodyType: t => this.setEntityBodyType(t.entityUuid, t.entityData), setEntitySensor: t => this.setEntitySensor(t.entityUuid, t.entityData), setEntityRestitution: t => this.setEntityRestitution(t.entityUuid, t.entityData), setEntityFriction: t => this.setEntityFriction(t.entityUuid, t.entityData), setEntityDensity: t => this.setEntityDensity(t.entityUuid, t.entityData), addEntityPosition: t => this.addEntityPosition(t.entityUuid, t.entityData), setEntityPosition: t => this.setEntityPosition(t.entityUuid, t.entityData), setActive: t => this.setActive(t.entityUuid, t.entityData), setEntityAllowContact: t => this.setEntityAllowContact(t.entityUuid, t.entityData), sendUpdateRequest: t => this.sendUpdateRequest(t.entityUuid), updateActivePhysicsCenter: t => this.updateActivePhysicsCenter(t.entityData), destroyEntity: t => this.destroyEntity(t.entityUuid), destroyAllEntities: t => this.destroyAllEntities(), createJoint: t => this.createJoint(t.entityUuid, t.entityData), destroyJoint: t => this.destroyJoint(t.entityUuid), destroyAllJoints: t => this.destroyAllJoints(), rayCast: t => this.rayCast(t.uuid, t.point1, t.point2, t.maxFraction), testPoint: t => this.testPoint(t.uuid, t.data), selectEntities: t => this.selectEntities(t.uuid, t.rect)}, this.worker = t, this._tps = e, this.box2dWorld = new Box2dWorld(this, i), this.tick();
      }
      runCommand(t, e) {
        this.commandsMap.hasOwnProperty(t) && this.commandsMap[t](e);
      }
      createEntity(t, e) {
        this.entities[t] = this.box2dWorld.createEntity(e), this.sendUpdateRequest(t);
      }
      destroyEntity(t) {
        this.entities.hasOwnProperty(t) && (this.box2dWorld.destroyEntity(this.entities[t]), delete this.entities[t], delete this.updateEntitiesOnce[t], delete this.cachedEntityTransforms[t], delete this._forceUpdateEntities[t]);
      }
      destroyAllEntities() {
        for (const t in this.entities) this.destroyEntity(t);
      }
      setEntityMultiplier(t, e) {
        this.entities.hasOwnProperty(t) && (this.entities[t].speedMultiplier = e, this.sendUpdateRequest(t));
      }
      setEntityMass(t, e) {
        this.entities.hasOwnProperty(t) && (this.entities[t].setMass(e), this.sendUpdateRequest(t));
      }
      setEntityVelocity(t, e) {
        this.entities.hasOwnProperty(t) && (this.entities[t].setTransformsVersion(e.version), this.entities[t].setVelocity(Vector2_Vector2.fromObject(e.velocity)), this.sendUpdateRequest(t));
      }
      setEntityAngularVelocity(t, e) {
        this.entities.hasOwnProperty(t) && (this.entities[t].setAngularVelocity(e), this.sendUpdateRequest(t));
      }
      addEntityVelocity(t, e) {
        this.entities.hasOwnProperty(t) && (this.entities[t].addVelocity(Vector2_Vector2.fromObject(e)), this.sendUpdateRequest(t));
      }
      setEntityVelocitySmoothly(t, e) {
        this.entities.hasOwnProperty(t) && this.sendUpdateRequest(t);
      }
      reCreateEntityFixture(t, e) {
        this.entities.hasOwnProperty(t) && (this.entities[t].reSetFixture(e), this.sendUpdateRequest(t));
      }
      setEntityAngle(t, e) {
        this.entities.hasOwnProperty(t) && (this.entities[t].setTransformsVersion(e.version), this.entities[t].setAngle(e.angle), this.sendUpdateRequest(t));
      }
      setEntityBodyType(t, e) {
        this.entities.hasOwnProperty(t) && (this.entities[t].setBodyType(e), this.sendUpdateRequest(t));
      }
      setEntitySensor(t, e) {
        this.entities.hasOwnProperty(t) && (this.entities[t].setSensor(e), this.sendUpdateRequest(t));
      }
      setEntityRestitution(t, e) {
        this.entities.hasOwnProperty(t) && (this.entities[t].setRestitution(e), this.sendUpdateRequest(t));
      }
      setEntityFriction(t, e) {
        this.entities.hasOwnProperty(t) && (this.entities[t].setFriction(e), this.sendUpdateRequest(t));
      }
      setEntityDensity(t, e) {
        this.entities.hasOwnProperty(t) && (this.entities[t].setDensity(e), this.sendUpdateRequest(t));
      }
      addEntityPosition(t, e) {
        this.entities.hasOwnProperty(t) && (this.entities[t].addPosition(Vector2_Vector2.fromObject(e)), this.sendUpdateRequest(t));
      }
      setEntityPosition(t, e) {
        this.entities.hasOwnProperty(t) && (this.entities[t].setTransformsVersion(e.version), this.entities[t].setPosition(Vector2_Vector2.fromObject(e.position)), this.sendUpdateRequest(t, e.force));
      }
      setActive(t, e) {
        this.entities.hasOwnProperty(t) && (this.entities[t].setActive(e), this.sendUpdateRequest(t));
      }
      setEntityAllowContact(t, e) {
        this.entities.hasOwnProperty(t) && this.entities[t].setAllowContact(e);
      }
      sendUpdateRequest(t, e = false) {
        false !== this.entities.hasOwnProperty(t) && (this.updateEntitiesOnce[t] = this.entities[t], e && (this._forceUpdateEntities[t] = true));
      }
      updateActivePhysicsCenter(t) {
        this._activePhysicsCenter.copy(Vector2_Vector2.fromObject(t));
      }
      createJoint(t, e) {
        if (this.joints[t]) return;
        let i, n;
        if (this.entities[e.uuidA] && (i = this.entities[e.uuidA].box2dBody), this.entities[e.uuidB] && (n = this.entities[e.uuidB].box2dBody), !i || !n || i === n) return this.clearJointTimeout(t), void (this._joinTimeouts[t] = setTimeout(() => this.createJoint(t, e), 1e3));
        this.joints[t] = this.box2dWorld.createJoint(e, i, n), this.addPacket({responseType: "jointAttached", responseData: e});
      }
      destroyJoint(t) {
        this.clearJointTimeout(t), this.joints[t] && (this.box2dWorld.destroyJoint(this.joints[t].joint), delete this.joints[t]);
      }
      destroyAllJoints() {
        for (const t in this.joints) this.clearJointTimeout(t), this.box2dWorld.destroyJoint(this.joints[t].joint);
        this.joints = {};
      }
      clearJointTimeout(t) {
        this._joinTimeouts[t] && clearTimeout(this._joinTimeouts[t]);
      }
      rayCast(t, e, i, n) {
        const r = [];
        for (const t in this.entities) {
          const o = this.entities[t].rayCastFixtures(e, i, n);
          o.length && r.push({uuid: parseInt(t, 10), intersects: o});
        }
        this.addPacket({responseType: "rayCast", responseData: {uuid: t, entities: r}});
      }
      testPoint(t, e) {
        const i = [];
        for (const t in this.entities) if (this.entities[t].testPoint(e.point) && (i.push(t), e.first)) break;
        this.addPacket({responseType: "testPoint", responseData: {uuid: t, entities: i}});
      }
      selectEntities(t, e) {
        const i = this.box2dWorld.selectEntities(e);
        this.addPacket({responseType: "selectEntities", responseData: {uuid: t, entities: i}});
      }
      startTicking() {
        this.tickingInterval || (this.tickingInterval = setInterval(() => this.tick(), 1e3 / this._tps));
      }
      stopTicking() {
        this.tickingInterval && (clearInterval(this.tickingInterval), this.tickingInterval = null);
      }
      tick() {
        const t = performance.now(), e = t - this.tickTimeOld;
        this.tickTimeOld = t, this.tickTimeouts();
        for (let t = 0; t < 1; t++) this.box2dWorld.step(e / 1 / 1e3, 1, 1);
        this.updateEntities(), this.sendPackets();
      }
      updateEntities() {
        this.entitiesData = [];
        for (const t in this.updateEntitiesOnce) {
          const e = this.updateEntitiesOnce[t], i = {transforms: {rotation: e.getAngle(), position: e.getPosition().toObject(), velocity: e.getVelocity().toObject(), angularVelocity: e.getAngularVelocity(), speedMultiplier: e.speedMultiplier}, transformsVersion: e.getTransformsVersion(), force: this._forceUpdateEntities.hasOwnProperty(t), isAwake: e.isAwake(), isActive: e.isActive(), isSensorAll: e.isSensorAll()};
          let n = true;
          if (this.cachedEntityTransforms.hasOwnProperty(t)) {
            const e = ValueUtils.getUpdatedDiff(this.cachedEntityTransforms[t], i);
            0 === Object.keys(e).length && (n = false);
          }
          this.cachedEntityTransforms[t] = i, n && this.entitiesData.push({entityUuid: t, entityData: i}), delete this.updateEntitiesOnce[t], delete this._forceUpdateEntities[t], this.updateActiveEntityStatus(t);
        }
        return this.entitiesData.length && this.addPacket({responseType: "updateEntities", responseData: {entitiesData: this.entitiesData, entityCount: Object.keys(this.entities).length, jointCount: Object.keys(this.joints).length}}), this;
      }
      updateActiveEntityStatus(t) {
        if (false === this.entities.hasOwnProperty(t)) return;
        const e = this.entities[t], i = this.getDistanceToActivePhysicsCenter(e.getPosition());
        i < e.activeDistance ? (e.setAwake(true), this.updateEntitiesOnce[t] = e) : e.canUnActive ? e.isAwake() ? (e.setAwake(false), this.updateEntitiesOnce[t] = e) : this.setTimeoutTicks(() => this.updateActiveEntityStatus(t), i / 5e3 * 1e4 / (1e3 / this._tps)) : false === e.canUnActive && (e.setAwake(true), this.updateEntitiesOnce[t] = e);
      }
      inActivePhysicsZone(t, e = 200) {
        return this.getDistanceToActivePhysicsCenter(t) < e;
      }
      getDistanceToActivePhysicsCenter(t) {
        return t.clone().subtract(this._activePhysicsCenter).length();
      }
      addPacket(t) {
        this.packets.push(t);
      }
      sendPackets() {
        0 !== this.packets.length && (this.worker.postMessage({type: "packets", packets: this.packets}), this.packets = []);
      }
      tickTimeouts() {
        for (const t in this._timeouts) ++this._timeouts[t].currentTicksCount >= this._timeouts[t].ticksCount && (this._timeouts[t].callback(), delete this._timeouts[t]);
      }
      setTimeoutTicks(t, e) {
        const i = Randomize.getUuid();
        return this._timeouts[i] = {callback: t, ticksCount: e, currentTicksCount: 0}, i;
      }
    }
    class GlobalContactListener extends class DefaultGlobalContactListener {
      constructor(t) {
        this._worldForWorker = t, this.worldManifold = new Ds.Collision.b2WorldManifold, this.contactPoint = new Vector2_Vector2;
      }
      canContact(t) {
        return true;
      }
      isShooterPlayer(t, e) {
        return t.serverProperties && e.serverProperties && t.serverProperties.uuid === e.serverProperties.ownerUuid;
      }
      isPlayer(t) {
        return this.entityIs(t, "ENTITY_PLAYER");
      }
      entityIs(t, e) {
        return t.serverProperties && t.serverProperties.clientSettings.entityType === e;
      }
      hasEntityIn(t, e) {
        return e.serverProperties && t.hasOwnProperty(e.serverProperties.clientSettings.entityType);
      }
      updateContactPoint(t, e, i) {}
      BeginContact(t) {
        this.canContact(t) ? this.processContact(t, true) : t.SetEnabled(false);
      }
      EndContact(t) {
        this.processContact(t, false);
      }
      PreSolve(t, e) {
        t.SetEnabled(this.canContact(t));
      }
      processContact(t, e) {
        if (false === t.IsEnabled()) return;
        const i = t.GetFixtureA().GetBody().GetUserData(), n = t.GetFixtureB().GetBody().GetUserData();
        t.GetFixtureA().IsSensor() && false === i.allowContactIfSensor || t.GetFixtureB().IsSensor() && false === n.allowContactIfSensor || this._worldForWorker.addPacket({responseType: "processContact", responseData: {uuidA: i.uuid, uuidB: n.uuid, begin: e}});
      }
      PostSolve(t, e) {}
    } {
      constructor() {
        super(...arguments), this._bullets = {ENTITY_ARROW: null, ENTITY_EGG: null, ENTITY_ENDER_EYE: null, ENTITY_ENDER_PEARL: null, ENTITY_FIRE_BALL: null, ENTITY_WITHER_HEAD: null, ENTITY_POTION_BOTTLE: null, ENTITY_EXP_BOTTLE: null, ENTITY_SNOW_BALL: null}, this._bulletsCollideWithPlayer = {};
      }
      canContact(t) {
        const e = t.GetFixtureA().GetBody().GetUserData(), i = t.GetFixtureB().GetBody().GetUserData();
        if (false === e.allowContact || false === i.allowContact) return false;
        let n = true;
        return this.isBullet(e) ? n = this.onCollideWithBullet(e, i) : this.isBullet(i) && (n = this.onCollideWithBullet(i, e)), n;
      }
      onCollideWithBullet(t, e) {
        let i = true;
        return this.isBullet(e) || this.isShooterPlayer(e, t) ? i = false : this.isPlayer(e) && (i = this._bulletsCollideWithPlayer.hasOwnProperty(t.serverProperties.clientSettings.entityType)), i;
      }
      isBullet(t) {
        return this.hasEntityIn(this._bullets, t);
      }
    }
    const Vs = self;
    let Bs;
    Vs.onmessage = t => {
      const e = t.data;
      if (0 !== e.length) for (const t in e) {
        const i = e[t];
        "initialize" === i.name ? Bs = new WorldForWorker(Vs, i.data.tps, GlobalContactListener) : Bs && Bs.runCommand(i.name, i.data);
      }
    };
  })();
})();
